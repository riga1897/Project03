~/workspace$ pytest --cov=src --cov-report=term-missing
============================== test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1999 items                                                            

tests/test_abstract.py ........                                           [  0%]
tests/test_abstract_db_manager.py ....                                    [  0%]
tests/test_abstract_filter_complete.py .........                          [  1%]
tests/test_api_complete.py ...................                            [  2%]
tests/test_api_config.py ....                                             [  2%]
tests/test_api_data_filter.py ......                                      [  2%]
tests/test_api_fixes.py .......                                           [  2%]
tests/test_api_infrastructure_final.py F...FF..FF.FFF......F.F            [  4%]
tests/test_api_modules.py ............................                    [  5%]
tests/test_api_modules_consolidated.py ....                               [  5%]
tests/test_api_modules_coverage.py ..F...F............                    [  6%]
tests/test_app_config.py .........                                        [  7%]
tests/test_base_api.py ...............                                    [  7%]
tests/test_base_formatter.py ..........                                   [  8%]
tests/test_base_formatter_complete.py ..............................      [  9%]
tests/test_base_parser.py ......                                          [ 10%]
tests/test_cache.py ......................                                [ 11%]
tests/test_cached_api.py ....                                             [ 11%]
tests/test_cached_api_complete.py ................                        [ 12%]
tests/test_components_fixed.py ...                                        [ 12%]
tests/test_comprehensive_coverage_boost.py .............................. [ 13%]
.........                                                                 [ 14%]
tests/test_comprehensive_coverage_final.py ss...s.....sF.......F..        [ 15%]
tests/test_comprehensive_fixed.py .....                                   [ 15%]
tests/test_comprehensive_missing_coverage.py F.....FFFF.EEE.............. [ 17%]
.                                                                         [ 17%]
tests/test_config_consolidated.py .....                                   [ 17%]
tests/test_config_missing_coverage.py .....sssss.............ss...        [ 18%]
tests/test_config_modules_consolidated.py ......                          [ 19%]
tests/test_config_modules_coverage.py ...................FFF..........    [ 20%]
tests/test_console_interface.py ......                                    [ 20%]
tests/test_console_interface_coverage.py ..................               [ 21%]
tests/test_core_functionality_consolidated.py .....                       [ 22%]
tests/test_core_infrastructure_final.py ..F.......FF....F..FF..F..        [ 23%]
tests/test_core_modules_comprehensive.py ........                         [ 23%]
tests/test_critical_missing_coverage.py ......F.......................    [ 25%]
tests/test_data_normalizers_comprehensive.py ............................ [ 26%]
                                                                          [ 26%]
tests/test_database_connection.py ........                                [ 27%]
tests/test_db_config.py .....                                             [ 27%]
tests/test_db_manager.py .................                                [ 28%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                        [ 29%]
tests/test_decorators.py .......                                          [ 29%]
tests/test_description_parser.py ..........                               [ 29%]
tests/test_env_loader.py ................                                 [ 30%]
tests/test_filter_utils.py ......                                         [ 30%]
tests/test_final_coverage_fixes.py .FF...................                 [ 32%]
tests/test_formatters_coverage.py ...........................             [ 33%]
tests/test_get_api_complete.py ....................                       [ 34%]
tests/test_hh_api_complete.py .................                           [ 35%]
tests/test_hh_api_config.py .....                                         [ 35%]
tests/test_hh_parser.py ........                                          [ 35%]
tests/test_integration.py .............                                   [ 36%]
tests/test_interfaces.py .ss                                              [ 36%]
tests/test_interfaces_coverage.py ..F..F...s........                      [ 37%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F...... [ 39%]
FF                                                                        [ 39%]
tests/test_main_application_interface.py ...                              [ 39%]
tests/test_main_application_interface_complete.py ....................... [ 40%]
....................                                                      [ 41%]
tests/test_main_consolidated.py .........                                 [ 41%]
tests/test_menu_manager.py ..........                                     [ 42%]
tests/test_missing_components.py .........                                [ 42%]
tests/test_missing_coverage_components.py .FF......FFFFF.....F            [ 43%]
tests/test_missing_coverage_extended.py ............F.FFF...........F.... [ 45%]
................FFF...                                                    [ 46%]
tests/test_models_coverage.py ...........................                 [ 47%]
tests/test_models_fixed.py ...                                            [ 48%]
tests/test_paginator.py ......                                            [ 48%]
tests/test_parsers_complete.py ............                               [ 49%]
tests/test_parsers_coverage.py .............................              [ 50%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                  [ 51%]
tests/test_real_components_coverage.py ........EEFE......F.               [ 52%]
tests/test_repository_fixed.py ..                                         [ 52%]
tests/test_salary_fixed.py ...........                                    [ 53%]
tests/test_salary_utils.py ......................                         [ 54%]
tests/test_search_utils.py ............................                   [ 55%]
tests/test_search_utils_complete.py ..................................... [ 57%]
.........                                                                 [ 57%]
tests/test_services_consolidated.py ....                                  [ 58%]
tests/test_services_coverage.py ............................              [ 59%]
tests/test_services_storage_consolidated.py ..........                    [ 59%]
tests/test_simple_db_adapter.py .........                                 [ 60%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                          [ 61%]
tests/test_sj_api.py ..............                                       [ 61%]
tests/test_sj_api_complete.py .............F....                          [ 62%]
tests/test_sj_api_config.py .....                                         [ 62%]
tests/test_sj_parser.py ........                                          [ 63%]
tests/test_sj_parser_complete.py ..............                           [ 64%]
tests/test_source_manager.py .................                            [ 64%]
tests/test_source_selector.py .................                           [ 65%]
tests/test_storage_abstractions.py ........                               [ 66%]
tests/test_storage_abstractions_coverage.py ........                      [ 66%]
tests/test_storage_complete.py .............                              [ 67%]
tests/test_storage_components_complete.py ......F....FF...............F   [ 68%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF     [ 70%]
tests/test_storage_components_fixes.py ....F....F...............          [ 71%]
tests/test_storage_factory.py ........                                    [ 71%]
tests/test_storage_modules_consolidated.py ....                           [ 71%]
tests/test_target_companies.py .....                                      [ 72%]
tests/test_typed_data_processor.py ................                       [ 72%]
tests/test_ui_components_complete.py .................................... [ 74%]
..                                                                        [ 74%]
tests/test_ui_components_extended.py ..................                   [ 75%]
tests/test_ui_components_missing_tests.py ..........FEEE...........FEEE   [ 77%]
tests/test_ui_config.py .......................                           [ 78%]
tests/test_ui_helpers_comprehensive.py .................................. [ 80%]
.....                                                                     [ 80%]
tests/test_ui_helpers_extended.py ....................................... [ 82%]
.                                                                         [ 82%]
tests/test_ui_modules_consolidated.py .....                               [ 82%]
tests/test_ui_navigation.py ......................                        [ 83%]
tests/test_ui_navigation_complete.py ..s..                                [ 83%]
tests/test_ui_navigation_comprehensive.py ......                          [ 84%]
tests/test_ui_navigation_extended.py .......F...........................  [ 85%]
tests/test_unified_api.py ................F...F.                          [ 87%]
tests/test_unified_api_complete.py ......F......................          [ 88%]
tests/test_unified_api_fixed.py ...                                       [ 88%]
tests/test_user_interface.py ...............                              [ 89%]
tests/test_user_interface_consolidated.py F.F                             [ 89%]
tests/test_user_interface_coverage.py ssssssFEEEEE                        [ 90%]
tests/test_user_interface_fixed.py ...                                    [ 90%]
tests/test_utils_consolidated.py .....                                    [ 90%]
tests/test_utils_coverage.py ......s..s...ssssssss                        [ 91%]
tests/test_utils_ui_consolidated.py ......                                [ 91%]
tests/test_vacancy_abstractions.py .................                      [ 92%]
tests/test_vacancy_display_handler.py ...................                 [ 93%]
tests/test_vacancy_formatter.py ........                                  [ 94%]
tests/test_vacancy_models_complete.py ....                                [ 94%]
tests/test_vacancy_models_consolidated.py ....                            [ 94%]
tests/test_vacancy_operations.py ......                                   [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................  [ 96%]
tests/test_vacancy_operations_coordinator_complete.py ................... [ 97%]
...                                                                       [ 97%]
tests/test_vacancy_processing_coordinator.py .............                [ 97%]
tests/test_vacancy_repository.py .........                                [ 98%]
tests/test_vacancy_stats.py ............                                  [ 98%]
tests/test_vacancy_stats_fixed.py .........                               [ 99%]
tests/test_vacancy_validator.py ............                              [100%]

==================================== ERRORS =====================================
______ ERROR at setup of TestSimpleDBAdapterCoverage.test_query_execution _______

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f684d28d890>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
___ ERROR at setup of TestSimpleDBAdapterCoverage.test_connection_management ____

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f684d28ded0>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
____ ERROR at setup of TestSimpleDBAdapterCoverage.test_transaction_handling ____

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f684d28e550>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
_____ ERROR at setup of TestFileCacheRealMethods.test_cache_key_generation ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f684ce7e590>
temp_cache_dir = '/tmp/tmpxlregs2k'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
______ ERROR at setup of TestFileCacheRealMethods.test_save_and_load_cycle ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f684ce7ec10>
temp_cache_dir = '/tmp/tmp5_j5ls5j'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
____ ERROR at setup of TestFileCacheRealMethods.test_invalid_cache_handling _____

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f684ce7f590>
temp_cache_dir = '/tmp/tmpfck0qq6e'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_application_lifecycle _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f684cb18a10>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_main_application_flow _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f684cb18d90>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_configuration_management _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f684cb192d0>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_with_different_datasets __

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f684cb26f10>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_navigation_comprehensive _

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f684cb27550>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_______ ERROR at setup of TestPaginatorFixed.test_paginator_configuration _______

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f684cb27c90>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_startup_sequence _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca60ad0>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_menu_display_functionality _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca61110>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_user_interaction_handling _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca61790>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_error_handling_in_interface _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca61dd0>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_lifecycle _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca62410>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
=================================== FAILURES ====================================
____________ TestHeadHunterAPICore.test_hh_api_get_vacancies_success ____________

self = <MagicMock name='get' id='140085938695120'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7f684d47c790>
mock_get = <MagicMock name='get' id='140085938695120'>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f684c9d3ad0>

    @patch('requests.get')
    def test_hh_api_get_vacancies_success(self, mock_get, hh_api):
        """Тест успешного получения вакансий от HH API"""
        if not HH_API_AVAILABLE:
            return
    
        # Мокируем успешный ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Tech Corp"},
                    "salary": {"from": 100000, "to": 150000, "currency": "RUR"}
                }
            ],
            "found": 1,
            "pages": 1,
            "page": 0
        }
        mock_get.return_value = mock_response
    
        result = hh_api.get_vacancies("python")
    
        assert isinstance(result, list)
>       mock_get.assert_called()
E       AssertionError: Expected 'get' to have been called.

tests/test_api_infrastructure_final.py:91: AssertionError
----------------------------- Captured stderr call ------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 604.41page/s, vacancies=931]
_________________ TestHeadHunterAPICore.test_hh_api_pagination __________________

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7f684d47dfd0>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f6847600d90>

    def test_hh_api_pagination(self, hh_api):
        """Тест пагинации"""
        if not HH_API_AVAILABLE:
            return
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "items": [],
                "found": 100,
                "pages": 5,
                "page": 0
            }
            mock_get.return_value = mock_response
    
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("python", page=2)
>               assert isinstance(result, dict)
E               AssertionError: assert False
E                +  where False = isinstance([{'accept_incomplete_resumes': False, 'accept_temporary': False, 'address': {'building': '3к2Б', 'city': 'Санкт-Петерб...тро Спортивная', 'city': 'Санкт-Петербург', 'description': None, 'id': '5687491', ...}, 'adv_context': None, ...}, ...], dict)

tests/test_api_infrastructure_final.py:149: AssertionError
_______________ TestSuperJobAPICore.test_sj_api_with_auth_header ________________

self = <tests.test_api_infrastructure_final.TestSuperJobAPICore object at 0x7f684d47e7d0>
mock_get = <MagicMock name='get' id='140085858256976'>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f6847d1c450>

    @patch('requests.get')
    def test_sj_api_with_auth_header(self, mock_get, sj_api):
        """Тест SJ API с заголовком авторизации"""
        if not SJ_API_AVAILABLE:
            return
    
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 456,
                    "profession": "Python Developer",
                    "link": "https://superjob.ru/vacancy/456",
                    "firm_name": "SJ Corp",
                    "payment_from": 80000,
                    "payment_to": 120000,
                    "currency": "rub"
                }
            ],
            "total": 1
        }
        mock_get.return_value = mock_response
    
        result = sj_api.get_vacancies("python")
        assert isinstance(result, list)
    
        # Проверяем что использовался правильный заголовок
>       call_kwargs = mock_get.call_args[1]
                      ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/test_api_infrastructure_final.py:189: TypeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:163 SuperJob API ключ не настроен или используется тестовый ключ
________________ TestUnifiedAPICore.test_unified_api_aggregation ________________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7f684d47db10>
mock_sj = <MagicMock name='get_vacancies' id='140085855873936'>
mock_hh = <MagicMock name='get_vacancies' id='140085855872912'>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6847ad5ed0>

    @patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies')
    @patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies')
    def test_unified_api_aggregation(self, mock_sj, mock_hh, unified_api):
        """Тест агрегации данных от разных источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Мокируем ответы от разных API
        mock_hh.return_value = [{"id": "hh1", "source": "hh"}]
        mock_sj.return_value = [{"id": "sj1", "source": "sj"}]
    
>       result = unified_api.get_vacancies("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:238: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICore.test_unified_api_error_resilience ______________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7f684d47f7d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6847ad52d0>

    def test_unified_api_error_resilience(self, unified_api):
        """Тест устойчивости к ошибкам отдельных API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', side_effect=Exception("HH Error")), \
             patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies', return_value=[{"id": "sj1"}]):
    
>           result = unified_api.get_vacancies("python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:249: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestCachedAPICore.test_cached_api_cache_hit __________________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7f684d488090>
mock_save = <MagicMock name='save_response' id='140085942209424'>
mock_load = <MagicMock name='load_response' id='140085941362192'>
cached_api = <Mock spec='CachedAPI' id='140085953173968'>

    @patch('src.utils.cache.FileCache.load_response')
    @patch('src.utils.cache.FileCache.save_response')
    def test_cached_api_cache_hit(self, mock_save, mock_load, cached_api):
        """Тест попадания в кэш"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем попадание в кэш
        cached_data = {
            "items": [{"id": "cached1", "title": "Cached Job"}],
            "timestamp": datetime.now().timestamp()
        }
        mock_load.return_value = cached_data
    
        if hasattr(cached_api, 'get_vacancies'):
            result = cached_api.get_vacancies("python")
>           assert isinstance(result, list)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140085937975632'>, list)

tests/test_api_infrastructure_final.py:289: AssertionError
_________________ TestCachedAPICore.test_cached_api_cache_miss __________________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7f684d4883d0>
mock_api = <MagicMock name='get_vacancies' id='140085941814992'>
mock_save = <MagicMock name='save_response' id='140085938034512'>
mock_load = <MagicMock name='load_response' id='140085945274896'>
cached_api = <Mock spec='CachedAPI' id='140085953126352'>

    @patch('src.utils.cache.FileCache.load_response')
    @patch('src.utils.cache.FileCache.save_response')
    @patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies')
    def test_cached_api_cache_miss(self, mock_api, mock_save, mock_load, cached_api):
        """Тест промаха кэша"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем промах кэша
        mock_load.return_value = None
        mock_api.return_value = [{"id": "new1", "title": "New Job"}]
    
        if hasattr(cached_api, 'get_vacancies'):
            result = cached_api.get_vacancies("python")
>           assert isinstance(result, list)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140085949889488'>, list)

tests/test_api_infrastructure_final.py:307: AssertionError
______________ TestCachedAPICore.test_cached_api_cache_expiration _______________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7f684d488910>
cached_api = <Mock spec='CachedAPI' id='140085942121552'>

    def test_cached_api_cache_expiration(self, cached_api):
        """Тест истечения срока действия кэша"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем устаревшие данные кэша
        old_timestamp = (datetime.now() - timedelta(hours=25)).timestamp()
        expired_data = {
            "items": [{"id": "old1"}],
            "timestamp": old_timestamp
        }
    
        with patch('src.utils.cache.FileCache.load_response', return_value=expired_data), \
             patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', return_value=[]):
    
            if hasattr(cached_api, 'get_vacancies'):
                result = cached_api.get_vacancies("python")
>               assert isinstance(result, list)
E               AssertionError: assert False
E                +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140085856503568'>, list)

tests/test_api_infrastructure_final.py:329: AssertionError
_______________ TestAPIPerformanceCore.test_api_request_batching ________________

self = <tests.test_api_infrastructure_final.TestAPIPerformanceCore object at 0x7f684d48ba50>

    def test_api_request_batching(self):
        """Тест батчинга запросов"""
        if UNIFIED_API_AVAILABLE:
            unified_api = UnifiedAPI()
    
            # Мокируем множественные запросы
            with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', return_value=[]) as mock_hh:
                queries = ["python", "java", "javascript"]
    
                if hasattr(unified_api, 'get_vacancies_batch'):
                    results = unified_api.get_vacancies_batch(queries)
                    assert isinstance(results, dict)
                else:
                    # Если батчинг не поддерживается, тестируем последовательные запросы
                    for query in queries:
>                       result = unified_api.get_vacancies(query)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E                       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:439: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestAPIIntegrationCore.test_full_api_pipeline _________________

self = <tests.test_api_infrastructure_final.TestAPIIntegrationCore object at 0x7f684d4908d0>
mock_get = <MagicMock name='get' id='140085857014352'>

    @patch('requests.get')
    def test_full_api_pipeline(self, mock_get):
        """Тест полного пайплайна API"""
        if not (HH_API_AVAILABLE and UNIFIED_API_AVAILABLE):
            return
    
        # Мокируем весь пайплайн
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "test123",
                    "name": "Full Stack Developer",
                    "alternate_url": "https://hh.ru/vacancy/test123",
                    "employer": {"name": "Integration Corp"},
                    "salary": {"from": 120000, "to": 180000, "currency": "RUR"},
                    "snippet": {
                        "requirement": "Python, Django",
                        "responsibility": "Development"
                    },
                    "area": {"name": "Moscow"},
                    "published_at": "2025-01-20T10:30:00+0300"
                }
            ],
            "found": 1
        }
        mock_get.return_value = mock_response
    
        unified_api = UnifiedAPI()
>       vacancies = unified_api.get_vacancies("python")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:507: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________ TestUnifiedAPICoverage.test_search_with_filters ________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f684d4cd550>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6847fa2710>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
        with patch.object(unified_api.hh_api, 'get_vacancies') as mock_hh, \
             patch.object(unified_api.sj_api, 'get_vacancies') as mock_sj:
    
            mock_hh.return_value = []
            mock_sj.return_value = []
    
>           result = unified_api.search_with_filters(search_params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'search_with_filters'

tests/test_api_modules_coverage.py:89: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____________ TestUnifiedAPICoverage.test_error_handling_api_failures ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f684d4cea10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f684736e790>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:162: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestStorageModules.test_postgres_saver_functionality ______________

self = <tests.test_comprehensive_coverage_final.TestStorageModules object at 0x7f684d25a6d0>

    def test_postgres_saver_functionality(self):
        """Тест функциональности PostgreSQL сохранения"""
        if 'postgres_saver' not in MODULES_TO_TEST:
            pytest.skip("PostgresSaver not available")
    
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085856922832'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________ TestIntegrationCoverage.test_full_pipeline_coverage ______________

self = <tests.test_comprehensive_coverage_final.TestIntegrationCoverage object at 0x7f684d260510>

    def test_full_pipeline_coverage(self):
        """Тест полного пайплайна обработки данных"""
        # Создаем тестовые данные
        test_vacancy_data = {
            "id": "123456789",
            "name": "Senior Python Developer",
            "employer": {"name": "TechCorp"},
            "salary": {"from": 150000, "to": 200000, "currency": "RUR"},
            "area": {"name": "Москва"},
            "experience": {"name": "От 3 до 6 лет"},
            "description": "We are looking for a senior Python developer..."
        }
    
        # Тестируем цепочку: API -> Parser -> Model -> Storage
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка моков
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [test_vacancy_data]}
            mock_get.return_value = mock_response
    
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085851830160'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success ______

self = <Mock name='mock.execute' id='140085857424592'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7f684d288f90>
mock_connect = <MagicMock name='connect' id='140085857882064'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847c02510>
mock_connection = (<Mock name='connect()' id='140085857107728'>, <Mock id='140085857107856'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
_________ TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f684d28b690>
mock_connect = <MagicMock name='connect' id='140085938404560'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f684736d8d0>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f6847cd4940>

    @patch('psycopg2.connect')
    def test_save_vacancies_single_vacancy(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения одной вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
            # Используем реальный объект Vacancy
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f684736d8d0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6847cd4940>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestPostgresSaverCoverage.test_delete_vacancy_by_id_success __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f684d28bc50>
mock_connect = <MagicMock name='connect' id='140085853480784'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c93910>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id_success(self, mock_connect, postgres_saver):
        """Тест успешного удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.rowcount = 1
    
            if hasattr(postgres_saver, 'delete_vacancy_by_id'):
>               result = postgres_saver.delete_vacancy_by_id('test123')
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c93910>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_______ TestPostgresSaverCoverage.test_error_handling_in_save_operations ________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847376c10>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6847350d50>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
>           cursor = connection.cursor()
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'cursor'

src/storage/postgres_saver.py:352: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f684d28c350>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847376c10>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f6847350d50>

    def test_error_handling_in_save_operations(self, postgres_saver, mock_vacancy):
        """Тест обработки ошибок при сохранении"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch.object(postgres_saver, '_get_connection', return_value=None):
            # Тест с недоступным подключением
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847376c10>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6847350d50>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
                if new_count > 5:
                    update_messages.append(f"... и еще {new_count - 5} новых вакансий")
                if updated_count > 5:
                    update_messages.append(f"... и еще {updated_count - 5} обновленных вакансий")
    
            connection.commit()
    
            total_input = len(vacancies)
    
            logger.info("Batch операция через временные таблицы:")
            logger.info(f"  Входящих вакансий: {total_input}")
            logger.info(f"  Добавлено в БД: {new_count}")
            logger.info(f"  Обновлено в БД: {updated_count}")
    
            # Дополнительная проверка количества записей в БД
            cursor.execute("SELECT COUNT(*) FROM vacancies")
            total_in_db = cursor.fetchone()[0]
            logger.info(f"  Итого записей в БД после операции: {total_in_db}")
    
            # Показываем сводку результатов
            logger.info(
                f"Результат: сохранено {new_count + updated_count} из {total_input} вакансий (новых: {new_count}, обновлено: {updated_count})"
            )
    
        except PsycopgError as e:
            logger.error(f"Ошибка при batch операции через временные таблицы: {e}")
            if not connection.closed:
                try:
                    connection.rollback()
                except Exception:
                    pass
            raise
        finally:
            if "cursor" in locals():
                cursor.close()
>           connection.close()
            ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'close'

src/storage/postgres_saver.py:638: AttributeError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f684d28c990>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68476e1e10>

    def test_batch_operations(self, postgres_saver):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        # Создаем набор тестовых вакансий
        test_vacancies = []
        for i in range(5):
            vacancy_data = {
                'vacancy_id': f'test{i}',
                'title': f'Job {i}',
                'url': f'https://test{i}.com',
                'description': f'Description {i}',
                'employer': {'name': f'Company {i}', 'employer_id': f'comp{i}'},
                'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
                'source': 'test'
            }
            test_vacancies.append(vacancy_data)
    
        # Мокаем соединение для пакетной операции
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            mock_conn.return_value = Mock()
>           result = postgres_saver.save_vacancies(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f68476e1e10>
vacancies = [{'description': 'Description 0', 'employer': {'employer_id': 'comp0', 'name': 'Company 0'}, 'salary': {'currency': 'R...d': 'comp4', 'name': 'Company 4'}, 'salary': {'currency': 'RUR', 'from': 100000, 'to': 150000}, 'source': 'test', ...}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________________ TestSJAPIConfigCoverage.test_get_api_key ____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f684d2e8890>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
___________________ TestSJAPIConfigCoverage.test_get_base_url ___________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f684d2e6610>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_______________ TestSJAPIConfigCoverage.test_get_request_headers ________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f684d0f0890>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
_______________ TestVacancyModelsCore.test_employer_functionality _______________

self = <tests.test_core_infrastructure_final.TestVacancyModelsCore object at 0x7f684d149250>

    def test_employer_functionality(self):
        """Тест функциональности Employer"""
        if not VACANCY_MODELS_AVAILABLE:
            return
    
        employer = Employer(name="Tech Corp", employer_id="emp123")
        assert employer.name == "Tech Corp"
>       assert employer.employer_id == "emp123"
               ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'Employer' object has no attribute 'employer_id'

tests/test_core_infrastructure_final.py:105: AttributeError
_______ TestPostgresSaverCoreFixed.test_postgres_saver_with_real_vacancy ________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7f684d158bd0>
mock_connect = <MagicMock name='connect' id='140085853479696'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f684763e450>
real_vacancy_object = <src.vacancies.models.Vacancy object at 0x7f6847caa410>

    @patch('psycopg2.connect')
    def test_postgres_saver_with_real_vacancy(self, mock_connect, postgres_saver, real_vacancy_object):
        """Тест сохранения реального объекта вакансии"""
        if not POSTGRES_SAVER_AVAILABLE or not VACANCY_MODELS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Тестируем с реальным объектом Vacancy
>           result = postgres_saver.save_vacancies([real_vacancy_object])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f684763e450>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6847caa410>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________ TestPostgresSaverCoreFixed.test_postgres_type_validation_fix __________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7f684d159190>
mock_connect = <MagicMock name='connect' id='140085851163536'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847b01d10>

    @patch('psycopg2.connect')
    def test_postgres_type_validation_fix(self, mock_connect, postgres_saver):
        """Тест исправления валидации типов"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 0
        mock_connect.return_value = mock_conn
    
        # Тест с невалидными данными (словари вместо объектов Vacancy)
        invalid_data = [
            {"id": "1", "title": "Job 1", "company_name": "Company 1"},
            {"id": "2", "title": "Job 2", "company_name": "Company 2"}
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать невалидные типы
>           result = postgres_saver.save_vacancies(invalid_data)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847b01d10>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestUtilsCoreFunctionality.test_menu_manager_functionality ___________

self = <tests.test_core_infrastructure_final.TestUtilsCoreFunctionality object at 0x7f684d15b510>

    def test_menu_manager_functionality(self):
        """Тест функциональности менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            menu_manager = MenuManager()
    
            if hasattr(menu_manager, 'display_menu'):
                with patch('builtins.print'):
                    menu_items = ['Option 1', 'Option 2', 'Exit']
>                   menu_manager.display_menu(menu_items)
E                   TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_core_infrastructure_final.py:428: TypeError
__________ TestCacheCoreFunctionality.test_file_cache_core_operations ___________

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7f684d15b690>

    def test_file_cache_core_operations(self):
        """Тест основных операций файлового кэша"""
        try:
            from src.utils.cache import FileCache
    
            with tempfile.TemporaryDirectory() as temp_dir:
                cache = FileCache(cache_dir=temp_dir)
    
                test_data = {"test": "data", "items": [1, 2, 3]}
                test_params = {"query": "python", "page": 1}
    
                # Тест сохранения
                cache.save_response("test_source", test_params, test_data)
    
                # Тест загрузки
                loaded_data = cache.load_response("test_source", test_params)
    
                # Тест валидации
>               is_valid = cache.is_valid_response(test_data)
                           ^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'FileCache' object has no attribute 'is_valid_response'

tests/test_core_infrastructure_final.py:498: AttributeError
_____________ TestCacheCoreFunctionality.test_cache_error_handling ______________

self = PosixPath('/invalid/path'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           FileNotFoundError: [Errno 2] No such file or directory: '/invalid/path'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7f684d15a7d0>

    def test_cache_error_handling(self):
        """Тест обработки ошибок кэша"""
        try:
            from src.utils.cache import FileCache
    
            # Тест с недоступной директорией
>           cache = FileCache(cache_dir="/invalid/path")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/cache.py:17: in __init__
    self._ensure_dir_exists()
src/utils/cache.py:21: in _ensure_dir_exists
    self.cache_dir.mkdir(parents=True, exist_ok=True)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1120: in mkdir
    self.parent.mkdir(parents=True, exist_ok=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PosixPath('/invalid'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           OSError: [Errno 30] Read-only file system: '/invalid'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: OSError
___________ TestEdgeCasesCoreFinal.test_none_and_empty_data_handling ____________

self = <tests.test_core_infrastructure_final.TestEdgeCasesCoreFinal object at 0x7f684d15c790>

    def test_none_and_empty_data_handling(self):
        """Тест обработки None и пустых данных"""
        test_modules = [
            ('src.utils.data_normalizers', 'normalize_area_data'),
            ('src.utils.file_handlers', 'FileHandler'),
            ('src.utils.cache', 'FileCache')
        ]
    
        for module_name, class_or_func_name in test_modules:
            try:
                module = __import__(module_name, fromlist=[class_or_func_name])
>               target = getattr(module, class_or_func_name)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: module 'src.utils.file_handlers' has no attribute 'FileHandler'

tests/test_core_infrastructure_final.py:577: AttributeError
__________ TestPostgresSaverCriticalCoverage.test_transaction_rollback __________

self = <tests.test_critical_missing_coverage.TestPostgresSaverCriticalCoverage object at 0x7f684d17a6d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c02190>
mock_connection = (<Mock id='140085857577040'>, <Mock id='140085857569424'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_cursor.execute.side_effect = Exception("Database error")
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            if hasattr(postgres_saver, 'save_vacancies'):
                test_vacancy = {'id': 'error_test', 'title': 'Error Job'}
>               result = postgres_saver.save_vacancies([test_vacancy])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_critical_missing_coverage.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c02190>
vacancies = [{'id': 'error_test', 'title': 'Error Job'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______________ TestDBManagerCoverage.test_create_database_schema _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e0e90>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6845281410>
mock_connection = (<Mock id='140085851551696'>, <Mock name='mock.cursor()' id='140085859134608'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
_________________ TestDBManagerCoverage.test_save_company_data __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e2e90>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847385990>
mock_connection = (<Mock id='140085858602448'>, <Mock name='mock.cursor()' id='140085858604688'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
_____________ TestDBManagerCoverage.test_save_vacancy_comprehensive _____________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e3290>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847372b50>
mock_connection = (<Mock id='140085848118224'>, <Mock name='mock.cursor()' id='140085848118544'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
________________ TestDBManagerCoverage.test_bulk_save_operations ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e36d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847681090>
mock_connection = (<Mock id='140085813586128'>, <Mock name='mock.cursor()' id='140085859138448'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
__________________ TestDBManagerCoverage.test_query_operations __________________

self = <Mock name='mock.cursor().execute' id='140085858367120'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e3b10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847385e50>
mock_connection = (<Mock id='140085848124624'>, <Mock name='mock.cursor()' id='140085848124368'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085858677520'>, исправляем...
________________ TestDBManagerCoverage.test_search_functionality ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684d1e3f50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847d51ed0>
mock_connection = (<Mock id='140085858477392'>, <Mock name='mock.cursor()' id='140085858476880'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
_________________ TestDBManagerCoverage.test_filter_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684cff4590>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847db4cd0>
mock_connection = (<Mock id='140085858888080'>, <Mock name='mock.cursor()' id='140085858893584'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
_______________ TestDBManagerCoverage.test_aggregation_operations _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684cff4c50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f68476889d0>
mock_connection = (<Mock id='140085851362128'>, <Mock name='mock.cursor()' id='140085851362704'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
_________________ TestDBManagerCoverage.test_update_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684cff5350>
db_manager = <src.storage.db_manager.DBManager object at 0x7f684f919010>
mock_connection = (<Mock id='140085949558160'>, <Mock name='mock.cursor()' id='140085949552336'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
_________________ TestDBManagerCoverage.test_delete_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684cff5a50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847b006d0>
mock_connection = (<Mock id='140085856046352'>, <Mock name='mock.cursor()' id='140085856058640'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
_______________ TestDBManagerCoverage.test_transaction_management _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f684cff6150>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847603e90>
mock_connection = (<Mock id='140085850811408'>, <Mock name='mock.cursor()' id='140085850813456'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
__________ TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ___________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f684d05b950>
mock_connect = <MagicMock name='connect' id='140085858796432'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473dc650>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f684760a820>

    @patch('psycopg2.connect')
    def test_save_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения реальных объектов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473dc650>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f684760a820>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________ TestPostgresSaverFinalFixes.test_vacancy_type_validation ____________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f684d05bf90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473dc990>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473dc990>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______ TestMainApplicationInterfaceCoverage.test_concrete_implementation _______

self = <tests.test_interfaces_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684d0ea110>

    def test_concrete_implementation(self):
        """Тест конкретной реализации интерфейса"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        # Создаем конкретную реализацию
        class ConcreteInterface(MainApplicationInterface):
            def run_application(self):
                return "Running"
    
>       interface = ConcreteInterface()
                    ^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_interfaces_coverage.py:87: TypeError
_____ TestVacancyDisplayHandlerCoverage.test_display_handler_methods_exist ______

self = <tests.test_interfaces_coverage.TestVacancyDisplayHandlerCoverage object at 0x7f684d0eb1d0>

    def test_display_handler_methods_exist(self):
        """Тест существования методов обработчика"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        mock_storage = Mock()
        try:
            handler = VacancyDisplayHandler(mock_storage)
        except TypeError:
            handler = VacancyDisplayHandler()
    
        # Проверяем наличие ожидаемых методов
        expected_methods = ['display_vacancies', 'display_vacancy_details', 'show_vacancies']
    
        existing_methods = [method for method in expected_methods if hasattr(handler, method)]
>       assert len(existing_methods) > 0, "Handler should have at least one display method"
E       AssertionError: Handler should have at least one display method
E       assert 0 > 0
E        +  where 0 = len([])

tests/test_interfaces_coverage.py:144: AssertionError
___________ TestDBManagerFixed.test_get_companies_and_vacancies_count ___________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf18790>
mock_connect = <MagicMock name='connect' id='140085573667024'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6836daba10>
mock_connection = (<Mock name='connect()' id='140085573631056'>, <Mock id='140085573631504'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
___________________ TestDBManagerFixed.test_get_all_vacancies ___________________

self = <Mock name='mock.execute' id='140085571996816'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf18d50>
mock_connect = <MagicMock name='connect' id='140085573723664'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f684cf04990>
mock_connection = (<Mock name='connect()' id='140085573730064'>, <Mock id='140085573723408'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085573964432'>, исправляем...
____________________ TestDBManagerFixed.test_get_avg_salary _____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf19310>
mock_connect = <MagicMock name='connect' id='140085573717072'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6836dc3fd0>
mock_connection = (<Mock name='connect()' id='140085573715024'>, <Mock id='140085573722576'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085571995280'>, исправляем...
___________ TestDBManagerFixed.test_get_vacancies_with_higher_salary ____________

self = <Mock name='mock.execute' id='140085847784784'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf19910>
mock_connect = <MagicMock name='connect' id='140085572174992'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6836c49390>
mock_connection = (<Mock name='connect()' id='140085572174352'>, <Mock id='140085572174096'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085572016016'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085856599376'>, исправляем...
______________ TestDBManagerFixed.test_get_vacancies_with_keyword _______________

self = <Mock name='mock.execute' id='140085859002384'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf19a90>
mock_connect = <MagicMock name='connect' id='140085858979856'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847dcf850>
mock_connection = (<Mock name='connect()' id='140085858987856'>, <Mock id='140085858986384'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085858606864'>, исправляем...
__________________ TestDBManagerFixed.test_get_database_stats ___________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f684cf19e10>
mock_connect = <MagicMock name='connect' id='140085856924944'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847bd75d0>
mock_connection = (<Mock name='connect()' id='140085856919632'>, <Mock id='140085856917520'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085851580432'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_____ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects ______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f684cf1a510>
mock_connect = <MagicMock name='connect' id='140085857147792'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847652c50>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f6847de6a90>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847652c50>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6847de6a90>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______________ TestPostgresSaverFixed.test_delete_vacancy_by_id ________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f684cf1b090>
mock_connect = <MagicMock name='connect' id='140085851150736'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c51150>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c51150>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count ________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f684cf1bfd0>
mock_connect = <MagicMock name='connect' id='140085857351248'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6844e87ed0>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
________________ TestSimpleDBAdapterFixed.test_get_all_vacancies ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f684cf205d0>
mock_connect = <MagicMock name='connect' id='140085856086416'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847b0ac90>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
___________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword ____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f684cf20bd0>
mock_connect = <MagicMock name='connect' id='140085858470992'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847d52450>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
______________ TestSimpleDBAdapterFixed.test_init_database_schema _______________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f684cf21310>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6844e87e10>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6844e857d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6844e87e10> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestAPIModulesFixed.test_hh_api_methods_coverage ________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f684cf28590>
mock_get = <MagicMock name='get' id='140085851746896'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
____________ TestAPIModulesFixed.test_cached_api_basic_functionality ____________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f684cf29290>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
___________________ TestEdgeCasesFixed.test_db_empty_results ____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f684cf298d0>
mock_connect = <MagicMock name='connect' id='140085847965136'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085857021072'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140085860898576'>, исправляем...
_______________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _______________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f684cf28d90>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
___________ TestAPIModulesIntegration.test_sj_api_basic_functionality ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7f684cf92510>

    def test_sj_api_basic_functionality(self):
        """Тест базовой функциональности SuperJob API"""
        if not SJ_API_AVAILABLE:
            pytest.skip("SuperJobAPI not available")
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"objects": [], "total": 0}
            mock_get.return_value = mock_response
    
            sj_api = SuperJobAPI()
            assert sj_api is not None
    
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:86: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________ TestAPIModulesIntegration.test_unified_api_filter_methods ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7f684cf92850>

    def test_unified_api_filter_methods(self):
        """Тест методов фильтрации UnifiedAPI"""
        if not UNIFIED_API_AVAILABLE:
            pytest.skip("UnifiedAPI not available")
    
        api = UnifiedAPI()
        assert api is not None
    
        # Тест пустого списка
        if hasattr(api, '_filter_by_target_companies'):
            result = api._filter_by_target_companies([])
            assert result == []
    
        # Тест с данными
        test_vacancies = [
            {"employer": {"id": "123"}, "title": "Test Job"}
        ]
    
>       with patch.object(api, '_get_target_company_ids', return_value=[]):

tests/test_missing_coverage_components.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f684cf65010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7f68448c4310> does not have the attribute '_get_target_company_ids'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________ TestDBManagerCoverage.test_get_companies_and_vacancies_count __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f684cfa57d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f68479a1c50>

    def test_get_companies_and_vacancies_count(self, db_manager):
        """Тест получения количества компаний и вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = [("Company A", 10), ("Company B", 5)]
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085854613456'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_________________ TestDBManagerCoverage.test_get_all_vacancies __________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f684cfa5e10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847b72bd0>

    def test_get_all_vacancies(self, db_manager):
        """Тест получения всех вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085856506768'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___________________ TestDBManagerCoverage.test_get_avg_salary ___________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f684cfa6450>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847322190>

    def test_get_avg_salary(self, db_manager):
        """Тест получения средней зарплаты"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (125000,)
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085847794192'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestDBManagerCoverage.test_get_vacancies_with_higher_salary __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f684cfa6ad0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f684731e110>

    def test_get_vacancies_with_higher_salary(self, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085856923920'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____________ TestDBManagerCoverage.test_get_vacancies_with_keyword _____________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f684cfa7110>
db_manager = <src.storage.db_manager.DBManager object at 0x7f68476e7b10>

    def test_get_vacancies_with_keyword(self, db_manager):
        """Тест получения вакансий по ключевому слову"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085851740368'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestIntegrationScenarios.test_api_and_database_integration ___________

self = <tests.test_missing_coverage_components.TestIntegrationScenarios object at 0x7f684cf93910>

    def test_api_and_database_integration(self):
        """Тест интеграции API и базы данных"""
        if not (UNIFIED_API_AVAILABLE and DB_MANAGER_AVAILABLE):
            pytest.skip("Required modules not available")
    
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            # Настройка DB
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140085860906640'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________________ TestPaginatorCoverage.test_get_page ______________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f684cfdaa50>
paginator = <Mock id='140085857981968'>

    def test_get_page(self, paginator):
        """Тест получения страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'get_page'):
            page_data = paginator.get_page(0)
>           assert isinstance(page_data, list) or page_data is None
E           AssertionError: assert (False or <Mock name='mock.get_page()' id='140085857986256'> is None)
E            +  where False = isinstance(<Mock name='mock.get_page()' id='140085857986256'>, list)

tests/test_missing_coverage_extended.py:339: AssertionError
___________________ TestPaginatorCoverage.test_previous_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f684cfdb710>
paginator = <Mock id='140085803377488'>

    def test_previous_page(self, paginator):
        """Тест перехода к предыдущей странице"""
        if not PAGINATOR_AVAILABLE:
            return
    
        # Сначала переходим на следующую страницу
        if hasattr(paginator, 'next_page'):
            paginator.next_page()
    
        if hasattr(paginator, 'previous_page'):
            initial_page = getattr(paginator, 'current_page', 2)
            result = paginator.previous_page()
            if result:
                new_page = getattr(paginator, 'current_page', 1)
>               assert new_page == initial_page - 1
E               assert 0 == (0 - 1)

tests/test_missing_coverage_extended.py:367: AssertionError
___________________ TestPaginatorCoverage.test_has_next_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f684cfdbd50>
paginator = <Mock id='140085851135184'>

    def test_has_next_page(self, paginator):
        """Тест проверки наличия следующей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_next_page'):
            result = paginator.has_next_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_next_page()' id='140085851141520'>, bool)

tests/test_missing_coverage_extended.py:376: AssertionError
_________________ TestPaginatorCoverage.test_has_previous_page __________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f684cfe03d0>
paginator = <Mock id='140085851291920'>

    def test_has_previous_page(self, paginator):
        """Тест проверки наличия предыдущей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_previous_page'):
            result = paginator.has_previous_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_previous_page()' id='140085851292432'>, bool)

tests/test_missing_coverage_extended.py:385: AssertionError
________________ TestVacancyFormatterCoverage.test_format_salary ________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7f684cfe3890>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7f684747e450>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:555: TypeError
_________ TestUIInterfacesCoverage.test_vacancy_display_handler_display _________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f684cdf6910>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:836: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_search_handler_search __________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f684cdf6f50>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ____

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f684cdf7550>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:859: TypeError
__________ TestPostgresSaverCoverage.test_database_connection_methods ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce5f050>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847d9ea10>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
______________ TestPostgresSaverCoverage.test_create_tables_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce5f410>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847df1110>
mock_connection = (<Mock id='140085859138576'>, <Mock name='mock.cursor()' id='140085859135184'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
______________ TestPostgresSaverCoverage.test_save_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce5f810>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473e3d90>
mock_connection = (<Mock id='140085848576464'>, <Mock name='mock.cursor()' id='140085848587856'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
____________ TestPostgresSaverCoverage.test_save_multiple_vacancies _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce5fe10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847674b90>
mock_connection = (<Mock id='140085851282512'>, <Mock name='mock.cursor()' id='140085851282896'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140085854718288'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140085854718288'> = <Mock name='mock.cursor()' id='140085851282896'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
______________ TestPostgresSaverCoverage.test_get_vacancies_method ______________

self = <Mock name='mock.cursor().execute' id='140085573326416'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6c4d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847fcce50>
mock_connection = (<Mock id='140085861077072'>, <Mock name='mock.cursor()' id='140085861076688'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
__________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6cb50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473b1d90>
mock_connection = (<Mock id='140085848379664'>, <Mock name='mock.cursor()' id='140085848380496'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
_____________ TestPostgresSaverCoverage.test_filter_by_salary_range _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6d1d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847cb1850>
mock_connection = (<Mock id='140085857815824'>, <Mock name='mock.cursor()' id='140085857826832'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
______________ TestPostgresSaverCoverage.test_get_companies_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6d850>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6844e56250>
mock_connection = (<Mock id='140085809208016'>, <Mock name='mock.cursor()' id='140085809211536'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_____________ TestPostgresSaverCoverage.test_delete_vacancy_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6de90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473257d0>
mock_connection = (<Mock id='140085847805904'>, <Mock name='mock.cursor()' id='140085847814352'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f68473257d0>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
_________________ TestPostgresSaverCoverage.test_clear_all_data _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6e550>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847ddb9d0>
mock_connection = (<Mock id='140085859035600'>, <Mock name='mock.cursor()' id='140085859037584'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_____________ TestPostgresSaverCoverage.test_get_statistics_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6ec50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847bc18d0>
mock_connection = (<Mock id='140085856843856'>, <Mock name='mock.cursor()' id='140085856838160'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
_________________ TestPostgresSaverCoverage.test_export_to_json _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6f350>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6836dd52d0>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
________________ TestPostgresSaverCoverage.test_import_from_json ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce6f9d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847c8d750>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
______________ TestPostgresSaverCoverage.test_transaction_rollback ______________

self = <Mock name='mock.rollback' id='140085851309328'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce74710>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f684ce5fed0>
mock_connection = (<Mock id='140085944232784'>, <Mock name='mock.cursor()' id='140085848576976'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f684ce74d90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847bb10d0>
mock_connection = (<Mock id='140085856777936'>, <Mock name='mock.cursor()' id='140085856772624'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6847bb10d0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
________________ TestFileCacheRealMethods.test_cache_expiration _________________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f684ce7f250>
temp_cache_dir = '/tmp/tmpa1imwwuy'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш с очень коротким TTL
>       cache = FileCache(cache_dir=temp_cache_dir, ttl_seconds=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:273: TypeError
________ TestIntegrationWithRealClasses.test_cache_with_api_integration _________

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7f684ce81690>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:424: KeyError
___________ TestSimpleDBAdapterCoverage.test_connect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd5ab10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847654290>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
__________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd5ae90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f684cfdb990>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd5b4d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847bd0a10>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6836dfc3d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847bd0a10> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd5bb10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847cc4dd0>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847cc4c50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847cc4dd0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd64190>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847236590>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847234790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847236590> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd647d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847d0fb10>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847dd5d90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847d0fb10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd64e10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847dcd350>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847dcdfd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847dcd350> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd65450>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847ba1190>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847ba26d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6847ba1190> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd65a50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68377c6550>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f68377c4f50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68377c6550> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd66090>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68448c7010>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f68448c5150>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68448c7010> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_error_handling_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f684cd666d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f684ce6c550>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f684ce6ed10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f684ce6c550> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSuperJobAPIComplete.test_deduplicate_vacancies _______________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f684cd9a910>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f6836d01c90>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6836d44090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestPostgresSaver.test_save_vacancies_batch __________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f684cc24b50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6836c66310>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6847a3cfd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f6836c66310> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_insert_vacancy ____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f684cc25750>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68473a4e90>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f68473a5410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f68473a4e90> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_get_vacancies _____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f684cc25b10>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6836da89d0>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f6836dab850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6836da89d0> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestStorageIntegration.test_repository_with_validator_integration _______

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f684cc37c10>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock id='140085858679184'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestVacancyStorageServiceCoverage.test_storage_service_initialization _____

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f684cc40e10>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
__________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ___________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f684cc41190>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6847948110>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
__________ TestVacancyStorageServiceCoverage.test_search_functionality __________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f684cc42110>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6836d03ed0>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
___________ TestVacancyStorageServiceCoverage.test_delete_operations ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f684cc42750>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6847d7f890>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f684cc43650>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f6847d9de50>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_______ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field ________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f684cc43c90>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f684794b550>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
___________ TestDeduplicationServiceCoverage.test_identify_duplicates ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f684cc50350>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f6847d7d6d0>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
___________ TestFilteringServiceCoverage.test_filter_by_salary_range ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f684cc51250>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6847c61110>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_keyword ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f684cc51890>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6847db2910>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_company ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f684cc51f10>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6836dd7d90>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
______________ TestFilteringServiceCoverage.test_complex_filtering ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f684cc40ed0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f684c9e3a90>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
_______________ TestVacancyRepositoryCoverage.test_create_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f684cc52510>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f684c9dabd0>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_____________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f684cc52890>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f68479ff0d0>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
_______________ TestVacancyRepositoryCoverage.test_update_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f684cc52c50>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6847d7df90>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6847d7df90>
vacancy = <Mock id='140085858655632'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140085846826576'>: 'Mock' object does not support the context manager protocol
_____________ TestVacancyRepositoryCoverage.test_get_all_vacancies ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f684cc536d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6847d702d0>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6847d702d0>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
______________ TestVacancyRepositoryCoverage.test_count_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f684cc53d10>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6847a66b10>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f684cc5d2d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f6847db6750>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_required_fields ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f684cc5d950>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f68479fe3d0>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
_____________ TestVacancyValidatorCoverage.test_validate_data_types _____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f684cc5df90>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f6836dd7d90>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________________ TestDBManagerFixed.test_database_operations __________________

self = <tests.test_storage_components_fixes.TestDBManagerFixed object at 0x7f684cc6dbd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6847db1210>
mock_db_connection = (<Mock id='140085861169360'>, <Mock id='140085861163088'>)

    def test_database_operations(self, db_manager, mock_db_connection):
        """Тест операций с базой данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_db_connection
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            # Тестируем различные операции
            operations = ['create_tables', 'drop_tables', 'clear_data']
    
            for operation in operations:
                if hasattr(db_manager, operation):
>                   result = getattr(db_manager, operation)()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f6847db1210>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:147: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.db_manager:db_manager.py:277 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
_________________ TestPostgresSaverFixed.test_delete_operations _________________

self = <tests.test_storage_components_fixes.TestPostgresSaverFixed object at 0x7f684cc6fc10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6836cad5d0>
mock_connection = (<Mock id='140085858804368'>, <Mock id='140085858796048'>)

    def test_delete_operations(self, postgres_saver, mock_connection):
        """Тест операций удаления"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            delete_methods = ['delete_vacancy_by_id', 'delete_all_vacancies', 'clear_companies']
    
            for method_name in delete_methods:
                if hasattr(postgres_saver, method_name):
                    if method_name == 'delete_vacancy_by_id':
>                       result = getattr(postgres_saver, method_name)('test_id')
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6836cad5d0>
vacancy_id = 'test_id'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
___ TestMainApplicationInterfaceFixed.test_main_app_interface_initialization ____

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f684cb18690>

    def test_main_app_interface_initialization(self):
        """Тест инициализации главного интерфейса приложения"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return
    
>       mai = MainApplicationInterface()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:303: TypeError
_______________ TestPaginatorFixed.test_paginator_initialization ________________

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f684cb268d0>

    def test_paginator_initialization(self):
        """Тест инициализации пагинатора"""
        if not PAGINATOR_AVAILABLE:
            return
    
>       pag = Paginator(page_size=10)
              ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:678: TypeError
_________ TestUINavigationExtended.test_paginate_display_custom_actions _________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f684c9f3c10>
mock_print = <MagicMock name='print' id='140085855044560'>
mock_input = <MagicMock name='input' id='140085809381584'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='140085855056784'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
________________ TestUnifiedAPI.test_filter_by_target_companies _________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f684ca0bf10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6847f72250>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
_________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources __________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f684ca21a50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6836d0ff50>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
____________ TestUnifiedAPIComplete.test_filter_by_target_companies _____________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7f684ca2f290>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6847f34c10>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestUserInterfaceConsolidated.test_main_interface_complete ___________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f684ca59a90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f684ca58a90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestUserInterfaceConsolidated.test_interface_components_integration ______

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f684ca4e550>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
_ TestMainApplicationInterfaceCoverage.test_main_application_interface_initialization _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7f684ca60490>

    def test_main_application_interface_initialization(self):
        """Тест инициализации MainApplicationInterface"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
>       interface = MainApplicationInterface()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:148: TypeError
================================ tests coverage =================================
_______________ coverage: platform linux, python 3.11.13-final-0 ________________

Name                                                     Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------------
src/__init__.py                                              0      0   100%
src/api_modules/__init__.py                                  0      0   100%
src/api_modules/base_api.py                                 23      0   100%
src/api_modules/cached_api.py                              168     47    72%   114-115, 144-147, 157, 159, 166-168, 183, 186-187, 203, 215-238, 247, 267-269, 289, 298-299, 308-310, 335-336, 340-342
src/api_modules/get_api.py                                  53     19    64%   46-54, 64, 73-74, 102-103, 116-118, 124, 126-132, 134, 136
src/api_modules/hh_api.py                                  142     25    82%   77-85, 169, 178-180, 219-221, 233, 256, 276, 289, 293-295, 329-331
src/api_modules/sj_api.py                                  128     28    78%   99-106, 206-210, 222, 263-264, 277-279, 291-292, 296-308
src/api_modules/unified_api.py                             270     77    71%   124, 133, 154-155, 175-176, 212-213, 221-240, 245, 291-293, 304-306, 316-322, 390-391, 401-418, 422-432, 436-458
src/config/__init__.py                                       0      0   100%
src/config/api_config.py                                    13      0   100%
src/config/app_config.py                                    17      0   100%
src/config/db_config.py                                     61     25    59%   24, 44-48, 85-88, 96-99, 104, 133-136, 156-172
src/config/hh_api_config.py                                 21      2    90%   31, 37
src/config/sj_api_config.py                                 49     17    65%   59, 62, 68-75, 79-87
src/config/target_companies.py                              61     24    61%   124-130, 135-138, 143-146, 151, 156-162, 167, 185, 190
src/config/ui_config.py                                     27      0   100%
src/interfaces/__init__.py                                   0      0   100%
src/interfaces/main_application_interface.py               121     88    27%   76, 89-98, 109-136, 140-152, 156-161, 166-180, 184-214, 224-225, 230, 234-236
src/storage/__init__.py                                      6      0   100%
src/storage/abstract.py                                     14      0   100%
src/storage/abstract_db_manager.py                          21      6    71%   16, 26, 36, 46, 59, 69
src/storage/components/__init__.py                           0      0   100%
src/storage/components/database_connection.py               53     11    79%   14-16, 19-20, 77-78, 88-89, 97-98
src/storage/components/vacancy_repository.py               113     61    46%   50-51, 119-134, 146-150, 174-178, 190-209, 221-291
src/storage/components/vacancy_validator.py                 65     22    66%   62, 65, 73-74, 78-79, 92, 99, 110, 115, 120, 138-152
src/storage/db_manager.py                                  348    188    46%   17-24, 63, 83-139, 223-228, 246-247, 262-272, 282-338, 348-361, 376-405, 419-451, 519-522, 525-528, 533-535, 574-576, 593-594, 646-651, 665, 715-718, 723-728, 818-820, 832, 844-845, 857-859, 871-877, 892-1022
src/storage/interfaces/typed_data_processor.py              46     25    46%   32, 45, 64, 78, 94, 100, 106-117, 124, 130-133, 139-148
src/storage/postgres_saver.py                              790    495    37%   10-13, 72-74, 109-111, 124-125, 133-140, 145-146, 148-151, 176-183, 188-194, 199-200, 202-205, 263-265, 280-281, 295-305, 310-317, 322-323, 325-328, 338, 342-343, 374-380, 399-400, 404-409, 417-419, 442-445, 452, 455-458, 473, 480, 487, 594-598, 604-606, 628-634, 655, 662-664, 678, 690-692, 705, 721-779, 783-895, 918-958, 961, 974-992, 1002-1007, 1010-1016, 1024-1048, 1067-1098, 1107-1109, 1125-1180, 1184-1196, 1218-1237, 1240, 1245-1247, 1264-1303, 1323-1574, 1626-1627, 1633-1635
src/storage/services/__init__.py                             4      0   100%
src/storage/services/abstract_filter_service.py             30      7    77%   34, 44, 64, 88, 101, 114, 127
src/storage/services/abstract_storage_service.py            25      6    76%   34, 47, 60, 73, 83, 93
src/storage/services/company_id_filter_service.py           94     62    34%   49, 62, 68-76, 85-135, 141-202, 206-214, 223
src/storage/services/deduplication_service.py               64     43    33%   15-16, 20-21, 43, 56-129, 133-142, 146-154, 183, 192
src/storage/services/filtering_service.py                  105     66    37%   15-16, 20-21, 25-26, 48, 76-88, 95-132, 143-155, 159-170, 189-199, 228, 237
src/storage/services/sql_deduplication_service.py           64     49    23%   44-64, 68-111, 116-148, 152-160, 173-182
src/storage/services/sql_filter_service.py                  89     63    29%   47, 59-78, 82-146, 152-191, 195-202, 207-209, 218-247
src/storage/services/vacancy_processing_coordinator.py      44      0   100%
src/storage/services/vacancy_storage_service.py            334    239    28%   15-16, 20-21, 25-26, 31-32, 37-38, 42-43, 47-48, 52-53, 57-58, 93-94, 119-146, 150-170, 176-194, 211-215, 226-238, 244-320, 334, 338-339, 360-362, 366-395, 417-469, 499, 511-535, 539-590, 594-601, 606, 610, 614, 618
src/storage/simple_db_adapter.py                           142     86    39%   21, 25, 29, 42-43, 64-71, 78-80, 94-101, 112-115, 117, 121, 125-165, 169-202, 206-210, 219
src/storage/storage_factory.py                              13      0   100%
src/ui_interfaces/__init__.py                                0      0   100%
src/ui_interfaces/console_interface.py                     394    306    22%   23-25, 69, 82, 84, 86, 88, 90, 92, 94, 97, 100, 102-110, 116-127, 157, 161, 165, 169, 173-224, 228-301, 305, 309, 319-355, 359, 370-371, 382-385, 395-544, 548-579, 584-604
src/ui_interfaces/source_selector.py                        44     14    68%   39-40, 42-43, 45-46, 48-49, 64, 74-79
src/ui_interfaces/vacancy_display_handler.py                72     58    19%   32-70, 74-107, 111-141
src/ui_interfaces/vacancy_operations_coordinator.py        194    105    46%   68-79, 100, 102, 104, 108, 116-122, 126-165, 169-192, 196-198, 211, 248-273, 302-322
src/ui_interfaces/vacancy_search_handler.py                152    126    17%   39-76, 90-114, 124, 135-170, 180-197, 209-232, 248-262, 272-308
src/user_interface.py                                       55     47    15%   26-94, 98
src/utils/__init__.py                                        0      0   100%
src/utils/abstract_filter.py                                26     14    46%   30, 47, 61, 75, 88-102
src/utils/api_data_filter.py                               154     88    43%   9-10, 25, 55-56, 71-83, 97, 105-106, 122, 130-131, 148-160, 173-185, 191-196, 206, 212, 215, 217, 223-241, 245, 256, 269, 275-284, 288-307
src/utils/base_formatter.py                                 38     11    71%   14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64
src/utils/cache.py                                         135     40    70%   61-62, 78, 98-100, 115-117, 124-126, 130-139, 165, 169-170, 174-176, 205-210, 221-224, 227, 236-238, 244
src/utils/data_normalizers.py                               75     13    83%   77-80, 107, 113-121, 154-162
src/utils/db_manager_demo.py                               236    218     8%   32, 38-64, 73-81, 85-103, 107-155, 159-211, 215-224, 228-272, 276-315, 319-370, 377-382, 386
src/utils/decorators.py                                     73     53    27%   24-52, 56-57, 61, 77-91, 97-106, 112-121
src/utils/description_parser.py                             70     32    54%   42, 78, 88-90, 96-101, 116-135, 141-177
src/utils/env_loader.py                                     59     34    42%   32-33, 41-76, 104-111
src/utils/file_handlers.py                                  38     25    34%   36-48, 57-76
src/utils/menu_manager.py                                   49      4    92%   38, 56, 77, 93
src/utils/paginator.py                                      28      7    75%   51-52, 57-61
src/utils/salary.py                                        113     15    87%   35-36, 55-61, 71-72, 78, 94, 181, 207
src/utils/search_utils.py                                  156      6    96%   204, 215, 219, 223, 227, 282
src/utils/source_manager.py                                 60     37    38%   77-80, 92-95, 108-119, 131-134, 146, 158-161, 173-176, 188-191, 198-200
src/utils/ui_helpers.py                                    161      4    98%   135, 225-226, 325
src/utils/ui_navigation.py                                  99      0   100%
src/utils/vacancy_formatter.py                             167     53    68%   122, 129, 148, 154, 170-171, 176, 182, 188-201, 206, 218, 225, 229-231, 235-241, 246, 259-262, 273-304
src/utils/vacancy_operations.py                            165     99    40%   43, 64, 75-87, 111, 122-134, 159, 170-182, 220-244, 248-261, 264-265, 268-269, 290-310, 320-339, 346-370
src/utils/vacancy_stats.py                                  86     53    38%   57-60, 83-91, 95-100, 110-158, 163-165
src/vacancies/__init__.py                                    0      0   100%
src/vacancies/abstract.py                                   10      0   100%
src/vacancies/abstract_models.py                            99     28    72%   18, 23, 28, 33, 38, 44, 53, 58, 63, 69, 75, 84, 89, 94, 100, 106, 115, 120, 125, 130, 135, 140, 146, 155, 160, 165, 171, 177
src/vacancies/models.py                                    390    139    64%   40, 44, 64, 77, 81, 89, 91, 93, 99, 102, 106, 122, 126, 131-133, 141, 144, 149, 153, 169, 173, 178-180, 188, 191, 196, 200, 299, 317, 329-332, 344, 348, 352, 358, 370, 374, 378, 384, 404-438, 443-451, 458, 476, 483, 495-499, 502-510, 514-521, 554-564, 568, 598, 600-605, 612, 614, 616, 618, 649-651, 670, 686, 701-706, 720, 725-727, 731-733, 737-739, 743-745, 749
src/vacancies/parsers/__init__.py                           55     11    80%   16, 21, 26, 31, 36, 88, 97, 106, 111, 116, 121
src/vacancies/parsers/base_parser.py                         9      2    78%   19, 32
src/vacancies/parsers/hh_parser.py                          55     10    82%   21, 32-33, 55-57, 96-98, 119
src/vacancies/parsers/sj_parser.py                          57     28    51%   24-43, 57-65, 107, 121-122, 145-147
--------------------------------------------------------------------------------------
TOTAL                                                     7192   3461    52%
============================ short test summary info ============================
FAILED tests/test_api_infrastructure_final.py::TestHeadHunterAPICore::test_hh_api_get_vacancies_success - AssertionError: Expected 'get' to have been called.
FAILED tests/test_api_infrastructure_final.py::TestHeadHunterAPICore::test_hh_api_pagination - AssertionError: assert False
FAILED tests/test_api_infrastructure_final.py::TestSuperJobAPICore::test_sj_api_with_auth_header - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_api_infrastructure_final.py::TestUnifiedAPICore::test_unified_api_aggregation - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_infrastructure_final.py::TestUnifiedAPICore::test_unified_api_error_resilience - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_infrastructure_final.py::TestCachedAPICore::test_cached_api_cache_hit - AssertionError: assert False
FAILED tests/test_api_infrastructure_final.py::TestCachedAPICore::test_cached_api_cache_miss - AssertionError: assert False
FAILED tests/test_api_infrastructure_final.py::TestCachedAPICore::test_cached_api_cache_expiration - AssertionError: assert False
FAILED tests/test_api_infrastructure_final.py::TestAPIPerformanceCore::test_api_request_batching - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_infrastructure_final.py::TestAPIIntegrationCore::test_full_api_pipeline - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_search_with_filters - AttributeError: 'UnifiedAPI' object has no attribute 'search_with_filters'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_error_handling_api_failures - AttributeError: 'method' object has no attribute 'side_effect'
FAILED tests/test_comprehensive_coverage_final.py::TestStorageModules::test_postgres_saver_functionality - AttributeError: __enter__
FAILED tests/test_comprehensive_coverage_final.py::TestIntegrationCoverage::test_full_pipeline_coverage - AttributeError: __enter__
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count_success - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_save_vacancies_single_vacancy - TypeError: 'Mock' object is not iterable
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_by_id_success - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_error_handling_in_save_operations - AttributeError: 'NoneType' object has no attribute 'close'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: 'Mock' object is not iterable
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_base_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_request_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_core_infrastructure_final.py::TestVacancyModelsCore::test_employer_functionality - AttributeError: 'Employer' object has no attribute 'employer_id'
FAILED tests/test_core_infrastructure_final.py::TestPostgresSaverCoreFixed::test_postgres_saver_with_real_vacancy - TypeError: 'Mock' object is not iterable
FAILED tests/test_core_infrastructure_final.py::TestPostgresSaverCoreFixed::test_postgres_type_validation_fix - TypeError: 'Mock' object is not iterable
FAILED tests/test_core_infrastructure_final.py::TestUtilsCoreFunctionality::test_menu_manager_functionality - TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were...
FAILED tests/test_core_infrastructure_final.py::TestCacheCoreFunctionality::test_file_cache_core_operations - AttributeError: 'FileCache' object has no attribute 'is_valid_response'
FAILED tests/test_core_infrastructure_final.py::TestCacheCoreFunctionality::test_cache_error_handling - OSError: [Errno 30] Read-only file system: '/invalid'
FAILED tests/test_core_infrastructure_final.py::TestEdgeCasesCoreFinal::test_none_and_empty_data_handling - AttributeError: module 'src.utils.file_handlers' has no attribute 'FileHandler'
FAILED tests/test_critical_missing_coverage.py::TestPostgresSaverCriticalCoverage::test_transaction_rollback - TypeError: 'Mock' object is not iterable
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_create_database_schema - AttributeError: 'DBManager' object has no attribute 'create_database_schema'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_company_data - AttributeError: 'DBManager' object has no attribute 'save_company'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_vacancy_comprehensive - AttributeError: 'DBManager' object has no attribute 'save_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_bulk_save_operations - AttributeError: 'DBManager' object has no attribute 'save_companies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_query_operations - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_search_functionality - AttributeError: 'DBManager' object has no attribute 'search_by_keyword'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_filter_operations - AttributeError: 'DBManager' object has no attribute 'filter_by_experience'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_aggregation_operations - AttributeError: 'DBManager' object has no attribute 'count_vacancies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_update_operations - AttributeError: 'DBManager' object has no attribute 'update_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_delete_operations - AttributeError: 'DBManager' object has no attribute 'delete_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_transaction_management - AttributeError: 'DBManager' object has no attribute 'begin_transaction'
FAILED tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_save_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_vacancy_type_validation - TypeError: 'Mock' object is not iterable
FAILED tests/test_interfaces_coverage.py::TestMainApplicationInterfaceCoverage::test_concrete_implementation - TypeError: MainApplicationInterface.__init__() missing 3 required positional...
FAILED tests/test_interfaces_coverage.py::TestVacancyDisplayHandlerCoverage::test_display_handler_methods_exist - AssertionError: Handler should have at least one display method
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_wit...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods ...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestAPIModulesIntegration::test_sj_api_basic_functionality - assert False
FAILED tests/test_missing_coverage_components.py::TestAPIModulesIntegration::test_unified_api_filter_methods - AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7f68448c...
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_all_vacancies - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_avg_salary - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_vacancies_with_higher_salary - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_vacancies_with_keyword - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestIntegrationScenarios::test_api_and_database_integration - AttributeError: __enter__
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_get_page - AssertionError: assert (False or <Mock name='mock.get_page()' id='1400858579...
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_previous_page - assert 0 == (0 - 1)
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_next_page - AssertionError: assert False
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_previous_page - AssertionError: assert False
FAILED tests/test_missing_coverage_extended.py::TestVacancyFormatterCoverage::test_format_salary - TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_display_handler_display - TypeError: VacancyDisplayHandler.__init__() missing 1 required positional ar...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_search_handler_search - TypeError: VacancySearchHandler.__init__() missing 2 required positional arg...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_operations_coordinator_coordinate - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positi...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_ra...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_cache_expiration - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seco...
FAILED tests/test_real_components_coverage.py::TestIntegrationWithRealClasses::test_cache_with_api_integration - KeyError: 'found'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f6836...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstr...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'sav...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'sea...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'cle...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_dupli...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_duplica...
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_company'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multiple_f...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_require...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_data_ty...
FAILED tests/test_storage_components_fixes.py::TestDBManagerFixed::test_database_operations - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_fixes.py::TestPostgresSaverFixed::test_delete_operations - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_main_app_interface_initialization - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
FAILED tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_paginator_initialization - TypeError: Paginator() takes no arguments
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'Targe...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/te...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional...
FAILED tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_main_application_interface_initialization - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_query_execution - TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were...
ERROR tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_connection_management - TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were...
ERROR tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_transaction_handling - TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were...
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_cache_key_generation - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seco...
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_save_and_load_cycle - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seco...
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_invalid_cache_handling - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seco...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_application_lifecycle - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_main_application_flow - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_configuration_management - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_pagination_with_different_datasets - TypeError: Paginator() takes no arguments
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_pagination_navigation_comprehensive - TypeError: Paginator() takes no arguments
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_paginator_configuration - TypeError: Paginator() takes no arguments
ERROR tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_application_startup_sequence - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_menu_display_functionality - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_user_interaction_handling - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_error_handling_in_interface - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
ERROR tests/test_user_interface_coverage.py::TestMainApplicationInterfaceCoverage::test_application_lifecycle - TypeError: Can't instantiate abstract class MainApplicationInterface with ab...
=========== 140 failed, 1811 passed, 31 skipped, 17 errors in 38.71s ============
~/workspace$ 