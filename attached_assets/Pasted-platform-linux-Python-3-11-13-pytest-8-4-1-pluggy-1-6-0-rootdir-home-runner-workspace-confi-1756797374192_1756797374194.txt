platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 535 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  2%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  4%]
tests/test_app_config.py .....                                                           [  5%]
tests/test_base_api.py ......                                                            [  6%]
tests/test_base_formatter.py ..........                                                  [  8%]
tests/test_base_parser.py ......                                                         [  9%]
tests/test_cache.py .......                                                              [ 10%]
tests/test_cache_manager.py .....F.......                                                [ 13%]
tests/test_cached_api.py ...........                                                     [ 15%]
tests/test_console_interface.py ......                                                   [ 16%]
tests/test_db_config.py .....                                                            [ 17%]
tests/test_db_manager.py .................                                               [ 20%]
tests/test_decorators.py .......                                                         [ 21%]
tests/test_env_loader.py ............                                                    [ 24%]
tests/test_file_handlers.py ............                                                 [ 26%]
tests/test_get_api.py ......                                                             [ 27%]
tests/test_hh_api.py .......                                                             [ 28%]
tests/test_hh_api_config.py .....                                                        [ 29%]
tests/test_hh_parser.py ........                                                         [ 31%]
tests/test_menu_manager.py ..........                                                    [ 33%]
tests/test_menu_system.py .................F..                                           [ 36%]
tests/test_paginator.py ......                                                           [ 37%]
tests/test_postgres_saver.py .......                                                     [ 39%]
tests/test_salary_utils.py ......................                                        [ 43%]
tests/test_search_utils.py ............................                                  [ 48%]
tests/test_sj_api.py ..............                                                      [ 51%]
tests/test_sj_api_config.py .....                                                        [ 52%]
tests/test_sj_parser.py ........                                                         [ 53%]
tests/test_source_manager.py .................                                           [ 56%]
tests/test_source_selector.py ..................                                         [ 60%]
tests/test_storage_factory.py ........                                                   [ 61%]
tests/test_target_companies.py .....                                                     [ 62%]
tests/test_ui_config.py .....                                                            [ 63%]
tests/test_ui_helpers.py ...........                                                     [ 65%]
tests/test_unified_api.py .................                                              [ 68%]
tests/test_user_interface.py ...F.....F...F........                                      [ 72%]
tests/test_vacancy_display_handler.py ..............                                     [ 75%]
tests/test_vacancy_formatter.py ........                                                 [ 77%]
tests/test_vacancy_models.py .................................................           [ 86%]
tests/test_vacancy_operations.py ......                                                  [ 87%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 92%]
tests/test_vacancy_search_handler.py .FFE.EFFEFFFF.FFF....EF                             [ 96%]
tests/test_vacancy_stats.py EEEF.E.F...EEFFFFF                                           [100%]

============================================ ERRORS ============================================
_____________ ERROR at setup of TestVacancySearchHandler.test_save_search_results ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75e710>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b35fe20>
salary_data = <src.utils.salary.Salary object at 0x7faa4b35fdc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____________ ERROR at setup of TestVacancySearchHandler.test_storage_integration ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75f350>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b35f640>
salary_data = <src.utils.salary.Salary object at 0x7faa4b35f940>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancySearchHandler.test_search_statistics _______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75d090>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b090a00>
salary_data = <src.utils.salary.Salary object at 0x7faa4b090ac0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ ERROR at setup of TestVacancySearchHandler.test_search_handler_type_safety __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b7580d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b08de40>
salary_data = <src.utils.salary.Salary object at 0x7faa4b08dcc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_company_distribution _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4bb7a190>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b08f8e0>
salary_data = <src.utils.salary.Salary object at 0x7faa4b08e5c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_source_distribution __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4bb7a210>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b0db340>
salary_data = <src.utils.salary.Salary object at 0x7faa4b0db520>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ ERROR at setup of TestVacancyStats.test_salary_percentiles __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4bb7ac10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b0dbd60>
salary_data = <src.utils.salary.Salary object at 0x7faa4b0dbdc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
________________ ERROR at setup of TestVacancyStats.test_display_company_stats _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4bb7bf90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b08cfa0>
salary_data = <src.utils.salary.Salary object at 0x7faa4b08cf40>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_type_safety _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4b749550>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b08dc00>
salary_data = <src.utils.salary.Salary object at 0x7faa4b08cb80>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_performance _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7faa4b749c10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b0bb520>
salary_data = <src.utils.salary.Salary object at 0x7faa4b0b9180>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
__________________________ TestCacheManager.test_cache_ttl_expiration __________________________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7faa4d3f9c10>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7faa4bbe2e90>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени
>       with patch('src.utils.cache.datetime') as mock_datetime:

tests/test_cache_manager.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4bbe3110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/cache.py'> does not have the attribute 'datetime'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________________ TestMenuManager.test_submenu_navigation ____________________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7faa4c349550>
mock_print = <MagicMock name='print' id='140369383136208'>
mock_input = <MagicMock name='input' id='140369391825232'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7faa4b381310>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140369391825232'>, args = ('\nВыберите пункт меню: ',)
kwargs = {}, effect = <list_iterator object at 0x7faa4c334b80>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
__________________________ TestUserInterface.test_vacancy_model_basic __________________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7faa4bf6de90>

    def test_vacancy_model_basic(self):
        """Тест базовой модели вакансии"""
        try:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            # Правильное создание объекта Salary согласно реальному API
            salary_data = {'from': 100000, 'to': 150000, 'currency': 'RUR'}
            salary = Salary(salary_data)
    
>           vacancy = Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh",
                employer={"name": "Test Company"},
                salary=salary,
                description="Test job"
            )

tests/test_user_interface.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7faa4b33d660>
salary_data = <src.utils.salary.Salary object at 0x7faa4b3525c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________________ TestUserInterface.test_logging_configuration _________________________

self = <MagicMock name='logging.getLogger' id='140369383372304'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'getLogger' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7faa4bf78250>
mock_logging = <MagicMock name='logging' id='140369383371792'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что модуль загружен
            assert hasattr(src.user_interface, 'main')
    
            # Логирование может быть настроено при импорте или в main
            # Проверяем хотя бы то, что getLogger был вызван
>           mock_logging.getLogger.assert_called()
E           AssertionError: Expected 'getLogger' to have been called.

tests/test_user_interface.py:237: AssertionError
_____________________ TestUserInterface.test_interface_workflow_simulation _____________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7faa4bf79d50>
mock_print = <MagicMock name='print' id='140369383409232'>
consolidated_mocks = {'app_config': <Mock id='140369383091152'>, 'db_config': <Mock name='mock.get_db_config()' id='140369383090576'>, 'db_manager': <Mock id='140369391813648'>, 'logger': <Mock id='140369391813008'>, ...}

    @patch('builtins.print')
    def test_interface_workflow_simulation(self, mock_print, consolidated_mocks):
        """Тест симуляции рабочего процесса интерфейса"""
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            ui = UserInterface(
                storage=consolidated_mocks['storage'],
                db_manager=consolidated_mocks['db_manager']
            )
    
            # Мокируем все пользовательские взаимодействия
            with patch('builtins.input', return_value="0"), \
>                patch('src.utils.ui_helpers.get_user_input', return_value="0") if SRC_AVAILABLE else patch('builtins.input', return_value="0"):
                                                                                   ^^^^^^^^^^^^^
E                NameError: name 'SRC_AVAILABLE' is not defined

tests/test_user_interface.py:306: NameError
_____________________ TestVacancySearchHandler.test_search_vacancies_basic _____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75ed90>
mock_print = <MagicMock name='print' id='140369380259792'>
mock_input = <MagicMock name='input' id='140369391698320'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b0c3050>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
        if SRC_AVAILABLE:
            # Мокируем интерактивные элементы для реального класса
>           with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python"), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15):

tests/test_vacancy_search_handler.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b0c3550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestVacancySearchHandler.test_search_vacancies_workflow ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75ddd0>
mock_print = <MagicMock name='print' id='140369383091024'>
mock_input = <MagicMock name='input' id='140369382698384'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b376e50>
consolidated_mocks = {'input': <Mock id='140369383092944'>, 'print': <Mock id='140369383088080'>, 'source_selector': <Mock id='140369383092112'>, 'storage': <Mock id='140369383093520'>, ...}

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_workflow(self, mock_print, mock_input, search_handler, consolidated_mocks):
        """Тест рабочего процесса поиска вакансий"""
        # Настройка моков для полного рабочего процесса
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b315250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_with_mocked_input ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75c1d0>
mock_print = <MagicMock name='print' id='140369381085712'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b18cd90>
consolidated_mocks = {'input': <Mock id='140369381083920'>, 'print': <Mock id='140369381085008'>, 'source_selector': <Mock id='140369381084048'>, 'storage': <Mock id='140369381084176'>, ...}

    @patch('builtins.print')
    def test_search_with_mocked_input(self, mock_print, search_handler, consolidated_mocks):
        """Тест поиска с замокированным вводом"""
        # Полностью мокируем все input операции
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b18d110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_results_structure ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75c710>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4bbc8b90>
consolidated_mocks = {'input': <Mock id='140369391822800'>, 'print': <Mock id='140369391827792'>, 'source_selector': <Mock id='140369391819088'>, 'storage': <Mock id='140369391814096'>, ...}

    def test_search_results_structure(self, search_handler, consolidated_mocks):
        """Тест структуры результатов поиска"""
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4bbc96d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario0] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75b390>
mock_print = <MagicMock name='print' id='140369383372560'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b3b87d0>
test_scenario = {'name': 'python_search', 'query': 'Python', 'source': 'hh.ru'}
consolidated_mocks = {'input': <Mock id='140369383371472'>, 'print': <Mock id='140369383373776'>, 'source_selector': <Mock id='140369383361552'>, 'storage': <Mock id='140369383364240'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b371650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario1] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75a2d0>
mock_print = <MagicMock name='print' id='140369383056400'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b36ded0>
test_scenario = {'name': 'java_search', 'query': 'Java', 'source': 'superjob.ru'}
consolidated_mocks = {'input': <Mock id='140369383049616'>, 'print': <Mock id='140369383059472'>, 'source_selector': <Mock id='140369383060240'>, 'storage': <Mock id='140369383050512'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b36e310>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario2] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b759810>
mock_print = <MagicMock name='print' id='140369382882768'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4bb5bd50>
test_scenario = {'name': 'empty_search', 'query': '', 'source': 'all'}
consolidated_mocks = {'input': <Mock id='140369391364304'>, 'print': <Mock id='140369391356816'>, 'source_selector': <Mock id='140369456058128'>, 'storage': <Mock id='140369456057936'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b343550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_concurrent_searches _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b759f10>
mock_print = <MagicMock name='print' id='140369382639184'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b309a10>
consolidated_mocks = {'input': <Mock id='140369382642256'>, 'print': <Mock id='140369382638544'>, 'source_selector': <Mock id='140369382638864'>, 'storage': <Mock id='140369423222608'>, ...}

    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, search_handler, consolidated_mocks):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_vacancy_search_handler.py:400: in <listcomp>
    results = [future.result() for future in concurrent.futures.as_completed(futures)]
               ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/thread.py:58: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_vacancy_search_handler.py:394: in search_task
    with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b316fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_performance_metrics _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75b0d0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b18a2d0>
consolidated_mocks = {'input': <Mock id='140369381067600'>, 'print': <Mock id='140369381074192'>, 'source_selector': <Mock id='140369391400080'>, 'storage': <Mock id='140369391389136'>, ...}

    def test_performance_metrics(self, search_handler, consolidated_mocks):
        """Тест метрик производительности"""
        import time
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b1893d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_integration_workflow ______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b759910>
mock_print = <MagicMock name='print' id='140369383145232'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b381710>
consolidated_mocks = {'input': <Mock id='140369383140112'>, 'print': <Mock id='140369383142992'>, 'source_selector': <Mock id='140369383136208'>, 'storage': <Mock id='140369383142416'>, ...}

    @patch('builtins.print')
    def test_integration_workflow(self, mock_print, search_handler, consolidated_mocks):
        """Тест интеграционного рабочего процесса"""
        search_handler.storage = consolidated_mocks['storage']
        consolidated_mocks['storage'].add_vacancy.return_value = True
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b330550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancySearchHandler.test_memory_usage __________________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7faa4b75bc50>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7faa4b323ad0>
consolidated_mocks = {'input': <Mock id='140369382751696'>, 'print': <Mock id='140369382748880'>, 'source_selector': <Mock id='140369382746960'>, 'storage': <Mock id='140369382744656'>, ...}

    def test_memory_usage(self, search_handler, consolidated_mocks):
        """Тест использования памяти"""
        import gc
    
        # Выполняем поиск и проверяем, что память освобождается
        initial_objects = len(gc.get_objects())
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7faa4b321410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runne