collected 535 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  2%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  4%]
tests/test_app_config.py .....                                                           [  5%]
tests/test_base_api.py ......                                                            [  6%]
tests/test_base_formatter.py ..........                                                  [  8%]
tests/test_base_parser.py ......                                                         [  9%]
tests/test_cache.py .......                                                              [ 10%]
tests/test_cache_manager.py .....F.......                                                [ 13%]
tests/test_cached_api.py ...........                                                     [ 15%]
tests/test_console_interface.py ......                                                   [ 16%]
tests/test_db_config.py .....                                                            [ 17%]
tests/test_db_manager.py .................                                               [ 20%]
tests/test_decorators.py .......                                                         [ 21%]
tests/test_env_loader.py ............                                                    [ 24%]
tests/test_file_handlers.py ............                                                 [ 26%]
tests/test_get_api.py ......                                                             [ 27%]
tests/test_hh_api.py .......                                                             [ 28%]
tests/test_hh_api_config.py .....                                                        [ 29%]
tests/test_hh_parser.py ........                                                         [ 31%]
tests/test_menu_manager.py ..........                                                    [ 33%]
tests/test_menu_system.py .................F..                                           [ 36%]
tests/test_paginator.py ......                                                           [ 37%]
tests/test_postgres_saver.py .......                                                     [ 39%]
tests/test_salary_utils.py ......................                                        [ 43%]
tests/test_search_utils.py ............................                                  [ 48%]
tests/test_sj_api.py ..............                                                      [ 51%]
tests/test_sj_api_config.py .....                                                        [ 52%]
tests/test_sj_parser.py ........                                                         [ 53%]
tests/test_source_manager.py .................                                           [ 56%]
tests/test_source_selector.py ..................                                         [ 60%]
tests/test_storage_factory.py ........                                                   [ 61%]
tests/test_target_companies.py .....                                                     [ 62%]
tests/test_ui_config.py .....                                                            [ 63%]
tests/test_ui_helpers.py ...........                                                     [ 65%]
tests/test_unified_api.py .................                                              [ 68%]
tests/test_user_interface.py ...F.....F...F........                                      [ 72%]
tests/test_vacancy_display_handler.py ..............                                     [ 75%]
tests/test_vacancy_formatter.py ........                                                 [ 77%]
tests/test_vacancy_models.py .................................................           [ 86%]
tests/test_vacancy_operations.py ......                                                  [ 87%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 92%]
tests/test_vacancy_search_handler.py .FFE.EFFEFFFF.FFF....EF                             [ 96%]
tests/test_vacancy_stats.py EEEF.E.F...EEFFFFF                                           [100%]

============================================ ERRORS ============================================
_____________ ERROR at setup of TestVacancySearchHandler.test_save_search_results ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7763350>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf7363e20>
salary_data = <src.utils.salary.Salary object at 0x7fecf7363dc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____________ ERROR at setup of TestVacancySearchHandler.test_storage_integration ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7763bd0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf7363640>
salary_data = <src.utils.salary.Salary object at 0x7fecf7363940>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancySearchHandler.test_search_statistics _______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7761a90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf7008a00>
salary_data = <src.utils.salary.Salary object at 0x7fecf7008ac0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ ERROR at setup of TestVacancySearchHandler.test_search_handler_type_safety __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7763f10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf70a1e40>
salary_data = <src.utils.salary.Salary object at 0x7fecf70a1cc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_company_distribution _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf774bfd0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf70a38e0>
salary_data = <src.utils.salary.Salary object at 0x7fecf70a25c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_source_distribution __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf774bd50>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf703b340>
salary_data = <src.utils.salary.Salary object at 0x7fecf703b520>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ ERROR at setup of TestVacancyStats.test_salary_percentiles __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7748d90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf703bd60>
salary_data = <src.utils.salary.Salary object at 0x7fecf703bdc0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
________________ ERROR at setup of TestVacancyStats.test_display_company_stats _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf77499d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf70a0fa0>
salary_data = <src.utils.salary.Salary object at 0x7fecf70a0f40>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_type_safety _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7741510>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf70a1c00>
salary_data = <src.utils.salary.Salary object at 0x7fecf70a0b80>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_performance _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7741a50>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf7083520>
salary_data = <src.utils.salary.Salary object at 0x7fecf7081180>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
__________________________ TestCacheManager.test_cache_ttl_expiration __________________________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7fecf93f9b50>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7fecf77b6c90>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени
>       with patch('src.utils.cache.datetime') as mock_datetime:

tests/test_cache_manager.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf77b6e90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/cache.py'> does not have the attribute 'datetime'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________________ TestMenuManager.test_submenu_navigation ____________________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7fecf8349290>
mock_print = <MagicMock name='print' id='140655736658768'>
mock_input = <MagicMock name='input' id='140655745478928'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7fecf7381290>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140655745478928'>, args = ('\nВыберите пункт меню: ',)
kwargs = {}, effect = <list_iterator object at 0x7fecf8330c40>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
__________________________ TestUserInterface.test_vacancy_model_basic __________________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecf7f71a10>

    def test_vacancy_model_basic(self):
        """Тест базовой модели вакансии"""
        try:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            # Правильное создание объекта Salary согласно реальному API
            salary_data = {'from': 100000, 'to': 150000, 'currency': 'RUR'}
            salary = Salary(salary_data)
    
>           vacancy = Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh",
                employer={"name": "Test Company"},
                salary=salary,
                description="Test job"
            )

tests/test_user_interface.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7fecf733d660>
salary_data = <src.utils.salary.Salary object at 0x7fecf73525c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________________ TestUserInterface.test_logging_configuration _________________________

self = <MagicMock name='logging.getLogger' id='140655736947280'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'getLogger' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecf7f73d90>
mock_logging = <MagicMock name='logging' id='140655736554832'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что модуль загружен
            assert hasattr(src.user_interface, 'main')
    
            # Логирование может быть настроено при импорте или в main
            # Проверяем хотя бы то, что getLogger был вызван
>           mock_logging.getLogger.assert_called()
E           AssertionError: Expected 'getLogger' to have been called.

tests/test_user_interface.py:237: AssertionError
_____________________ TestUserInterface.test_interface_workflow_simulation _____________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecf7f798d0>
mock_print = <MagicMock name='print' id='140655736291600'>
consolidated_mocks = {'app_config': <Mock id='140655740926288'>, 'db_config': <Mock name='mock.get_db_config()' id='140655736297872'>, 'db_manager': <Mock id='140655740923344'>, 'logger': <Mock id='140655736955792'>, ...}

    @patch('builtins.print')
    def test_interface_workflow_simulation(self, mock_print, consolidated_mocks):
        """Тест симуляции рабочего процесса интерфейса"""
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            ui = UserInterface(
                storage=consolidated_mocks['storage'],
                db_manager=consolidated_mocks['db_manager']
            )
    
            # Мокируем все пользовательские взаимодействия
            with patch('builtins.input', return_value="0"), \
>                patch('src.utils.ui_helpers.get_user_input', return_value="0") if SRC_AVAILABLE else patch('builtins.input', return_value="0"):
                                                                                   ^^^^^^^^^^^^^
E                NameError: name 'SRC_AVAILABLE' is not defined

tests/test_user_interface.py:306: NameError
_____________________ TestVacancySearchHandler.test_search_vacancies_basic _____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf776c7d0>
mock_print = <MagicMock name='print' id='140655736318480'>
mock_input = <MagicMock name='input' id='140655736309200'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf732df10>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
        if SRC_AVAILABLE:
            # Мокируем интерактивные элементы для реального класса
>           with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python"), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15):

tests/test_vacancy_search_handler.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7343990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestVacancySearchHandler.test_search_vacancies_workflow ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf776cb10>
mock_print = <MagicMock name='print' id='140655744735120'>
mock_input = <MagicMock name='input' id='140655745307024'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7b34f10>
consolidated_mocks = {'input': <Mock id='140655744740880'>, 'print': <Mock id='140655744738192'>, 'source_selector': <Mock id='140655744738512'>, 'storage': <Mock id='140655744732240'>, ...}

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_workflow(self, mock_print, mock_input, search_handler, consolidated_mocks):
        """Тест рабочего процесса поиска вакансий"""
        # Настройка моков для полного рабочего процесса
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7340cd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_with_mocked_input ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7762a50>
mock_print = <MagicMock name='print' id='140655734689360'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf71a0a50>
consolidated_mocks = {'input': <Mock id='140655734689040'>, 'print': <Mock id='140655734688848'>, 'source_selector': <Mock id='140655734689168'>, 'storage': <Mock id='140655734689104'>, ...}

    @patch('builtins.print')
    def test_search_with_mocked_input(self, mock_print, search_handler, consolidated_mocks):
        """Тест поиска с замокированным вводом"""
        # Полностью мокируем все input операции
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf71a1010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_results_structure ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf77629d0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7708b90>
consolidated_mocks = {'input': <Mock id='140655740368400'>, 'print': <Mock id='140655740359760'>, 'source_selector': <Mock id='140655740364240'>, 'storage': <Mock id='140655740355728'>, ...}

    def test_search_results_structure(self, search_handler, consolidated_mocks):
        """Тест структуры результатов поиска"""
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf770a690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario0] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7760210>
mock_print = <MagicMock name='print' id='140655736947408'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf73cbd90>
test_scenario = {'name': 'python_search', 'query': 'Python', 'source': 'hh.ru'}
consolidated_mocks = {'input': <Mock id='140655736961808'>, 'print': <Mock id='140655736951248'>, 'source_selector': <Mock id='140655736952656'>, 'storage': <Mock id='140655736951120'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7749f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario1] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7760a10>
mock_print = <MagicMock name='print' id='140655736293776'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf732bb50>
test_scenario = {'name': 'java_search', 'query': 'Java', 'source': 'superjob.ru'}
consolidated_mocks = {'input': <Mock id='140655736306320'>, 'print': <Mock id='140655736291664'>, 'source_selector': <Mock id='140655736305360'>, 'storage': <Mock id='140655736295376'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf736af50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario2] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf77607d0>
mock_print = <MagicMock name='print' id='140655736400080'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7343c90>
test_scenario = {'name': 'empty_search', 'query': '', 'source': 'all'}
consolidated_mocks = {'input': <Mock id='140655736402576'>, 'print': <Mock id='140655736396752'>, 'source_selector': <Mock id='140655736403920'>, 'storage': <Mock id='140655736390352'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7342450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_concurrent_searches _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf77601d0>
mock_print = <MagicMock name='print' id='140655736150992'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7373290>
consolidated_mocks = {'input': <Mock id='140655740730384'>, 'print': <Mock id='140655740723024'>, 'source_selector': <Mock id='140655740723600'>, 'storage': <Mock id='140655740715792'>, ...}

    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, search_handler, consolidated_mocks):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_vacancy_search_handler.py:400: in <listcomp>
    results = [future.result() for future in concurrent.futures.as_completed(futures)]
               ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/thread.py:58: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_vacancy_search_handler.py:394: in search_task
    with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf770b990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_performance_metrics _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf775b850>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7bac090>
consolidated_mocks = {'input': <Mock id='140655745368400'>, 'print': <Mock id='140655745383952'>, 'source_selector': <Mock id='140655745384080'>, 'storage': <Mock id='140655736582352'>, ...}

    def test_performance_metrics(self, search_handler, consolidated_mocks):
        """Тест метрик производительности"""
        import time
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7bad810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_integration_workflow ______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf7759c90>
mock_print = <MagicMock name='print' id='140655740598800'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf7743e90>
consolidated_mocks = {'input': <Mock id='140655740588176'>, 'print': <Mock id='140655740595792'>, 'source_selector': <Mock id='140655740586704'>, 'storage': <Mock id='140655740591120'>, ...}

    @patch('builtins.print')
    def test_integration_workflow(self, mock_print, search_handler, consolidated_mocks):
        """Тест интеграционного рабочего процесса"""
        search_handler.storage = consolidated_mocks['storage']
        consolidated_mocks['storage'].add_vacancy.return_value = True
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf718bc50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancySearchHandler.test_memory_usage __________________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf775a790>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf77aa010>
consolidated_mocks = {'input': <Mock id='140655741014544'>, 'print': <Mock id='140655741015312'>, 'source_selector': <Mock id='140655741019088'>, 'storage': <Mock id='140655741015376'>, ...}

    def test_memory_usage(self, search_handler, consolidated_mocks):
        """Тест использования памяти"""
        import gc
    
        # Выполняем поиск и проверяем, что память освобождается
        initial_objects = len(gc.get_objects())
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf77aa510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestVacancySearchHandler.test_search_handler_workflow_complete ________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecf775bd90>
mock_print = <MagicMock name='print' id='140655734441104'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7fecf71649d0>
consolidated_mocks = {'input': <Mock id='140655734442896'>, 'print': <Mock id='140655734442640'>, 'source_selector': <Mock id='140655734442832'>, 'storage': <Mock id='140655734443728'>, ...}

    @patch('builtins.print')
    def test_search_handler_workflow_complete(self, mock_print, search_handler, consolidated_mocks):
        """Тест полного рабочего процесса обработчика"""
        # Настройка консолидированных моков для полного workflow
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
        consolidated_mocks['storage'].add_vacancy.return_value = True
        consolidated_mocks['unified_api'].get_vacancies.return_value = []
    
        # Мокируем все пользовательские взаимодействия
        mock_inputs = {
            'get_user_input': "Python",
            'get_positive_integer': 15,
            'input': "1"
        }
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=mock_inputs['get_user_input']) if SRC_AVAILABLE else patch('builtins.input', return_value=mock_inputs['input']), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=mock_inputs['get_positive_integer']) if SRC_AVAILABLE else patch('builtins.input', return_value=str(mock_inputs['get_positive_integer'])):

tests/test_vacancy_search_handler.py:565: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fecf7166010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancyStats.test_empty_vacancies_list __________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7748610>

    def test_empty_vacancies_list(self):
        """Тест с пустым списком вакансий"""
        empty_list = []
    
>       distribution = VacancyStats.get_company_distribution(empty_list)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:611: AttributeError
______________________ TestVacancyStats.test_company_statistics_detailed _______________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf774a310>

    def test_company_statistics_detailed(self):
        """Тест детальной статистики по компаниям"""
        vacancies = [
            Vacancy(
                title="Job 1",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 2",
                url="https://test.com/2",
                vacancy_id="2",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 3",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "Company B", "id": "456"}
            )
        ]
    
>       stats = VacancyStats.get_company_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:685: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

vacancies = [<src.vacancies.models.Vacancy object at 0x7fecf6e694a0>, <src.vacancies.models.Vacancy object at 0x7fecf6e6b520>, <src.vacancies.models.Vacancy object at 0x7fecf6e686d0>]

    def get_company_statistics(vacancies: List[Vacancy]) -> Dict[str, Any]:
        """
        Получение статистики по компаниям
    
        Args:
            vacancies: Список вакансий
    
        Returns:
            Словарь со статистикой по компаниям
        """
>       company_stats = VacancyStats.get_company_distribution(vacancies)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:411: AttributeError
________________________ TestVacancyStats.test_vacancy_stats_edge_cases ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7741a90>

    def test_vacancy_stats_edge_cases(self):
        """Тест граничных случаев статистики"""
        # Тест с вакансиями без всех данных
        minimal_vacancies = [
            Vacancy(
                title="",
                url="",
                vacancy_id="1",
                source=""
            )
        ]
    
        # Все методы должны корректно обрабатывать минимальные данные
        stats_methods = [
>           VacancyStats.get_company_distribution,
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            VacancyStats.get_source_distribution,
            VacancyStats.calculate_salary_percentiles,
            VacancyStats.analyze_salaries,
            VacancyStats.get_company_statistics,
            VacancyStats.analyze_experience_requirements,
            VacancyStats.get_location_statistics
        ]
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:833: AttributeError
_____________________ TestVacancyStats.test_parametrized_vacancy_counts[0] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf77439d0>
vacancy_count = 0

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:866: AttributeError
_____________________ TestVacancyStats.test_parametrized_vacancy_counts[1] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7743610>
vacancy_count = 1

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:866: AttributeError
____________________ TestVacancyStats.test_parametrized_vacancy_counts[10] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf774ae10>
vacancy_count = 10

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:866: AttributeError
____________________ TestVacancyStats.test_parametrized_vacancy_counts[100] ____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7fecf7748c10>
vacancy_count = 100

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:866: AttributeError
=================================== short test summary info ====================================
FAILED tests/test_cache_manager.py::TestCacheManager::test_cache_ttl_expiration - AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/c...
FAILED tests/test_menu_system.py::TestMenuManager::test_submenu_navigation - StopIteration
FAILED tests/test_user_interface.py::TestUserInterface::test_vacancy_model_basic - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_user_interface.py::TestUserInterface::test_logging_configuration - AssertionError: Expected 'getLogger' to have been called.
FAILED tests/test_user_interface.py::TestUserInterface::test_interface_workflow_simulation - NameError: name 'SRC_AVAILABLE' is not defined
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_basic - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_workflow - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_with_mocked_input - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_results_structure - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario0] - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario1] - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario2] - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_concurrent_searches - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_performance_metrics - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_integration_workflow - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_memory_usage - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_handler_workflow_complete - AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/works...
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_empty_vacancies_list - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_company_statistics_detailed - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_vacancy_stats_edge_cases - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_parametrized_vacancy_counts[0] - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_parametrized_vacancy_counts[1] - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_parametrized_vacancy_counts[10] - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_parametrized_vacancy_counts[100] - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_save_search_results - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_storage_integration - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_statistics - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_handler_type_safety - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_company_distribution - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_source_distribution - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_salary_percentiles - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_display_company_stats - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_vacancy_stats_type_safety - AttributeError: 'Salary' object has no attribute 'get'
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_vacancy_stats_performance - AttributeError: 'Salary' object has no attribute 'get'
========================== 24 failed, 501 passed, 10 errors in 4.25s ===========================