~/workspace$ pytest
=========================== test session starts ============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 273 items                                                        

tests/test_abstract.py ........                                      [  2%]
tests/test_abstract_db_manager.py ....                               [  4%]
tests/test_api_config.py FFFF                                        [  5%]
tests/test_app_config.py FFF.F                                       [  7%]
tests/test_base_api.py FFFF                                          [  9%]
tests/test_base_parser.py F.FFFF                                     [ 11%]
tests/test_cache.py .....F.                                          [ 13%]
tests/test_cached_api.py FFFFF                                       [ 15%]
tests/test_db_manager.py .F.FFFFFFF                                  [ 19%]
tests/test_decorators.py .......                                     [ 21%]
tests/test_env_loader.py .FFFFFF.F                                   [ 25%]
tests/test_file_handlers.py ............                             [ 29%]
tests/test_get_api.py ......                                         [ 31%]
tests/test_hh_api.py F.FFFFF                                         [ 34%]
tests/test_hh_api_config.py FFFF.                                    [ 36%]
tests/test_hh_parser.py .F..FFF.                                     [ 39%]
tests/test_menu_manager.py FFFF.FFFFF                                [ 42%]
tests/test_paginator.py FFFFFF                                       [ 45%]
tests/test_postgres_saver.py ..F...F                                 [ 47%]
tests/test_salary_utils.py FFFFFF.......FFFF...                      [ 54%]
tests/test_search_utils.py ......FFFF.                               [ 58%]
tests/test_sj_api.py FF.FFFF                                         [ 61%]
tests/test_sj_api_config.py FF.F.                                    [ 63%]
tests/test_sj_parser.py ........                                     [ 66%]
tests/test_storage_factory.py .F...F                                 [ 68%]
tests/test_target_companies.py FF.F.                                 [ 70%]
tests/test_ui_config.py FF...                                        [ 72%]
tests/test_ui_helpers.py .........F.                                 [ 76%]
tests/test_unified_api.py ...F.F                                  [ 78%]
tests/test_user_interface.py .FF..F..                             [ 81%]
tests/test_vacancy_display_handler.py .FFFFFF                     [ 83%]
tests/test_vacancy_formatter.py ..F..F.                           [ 86%]
tests/test_vacancy_models.py ......F.FFFFFFFF                     [ 92%]
tests/test_vacancy_operations_coordinator.py FF.FFFF.             [ 95%]
tests/test_vacancy_search_handler.py FFFFFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestAPIConfig.test_api_config_initialization ______________

self = <workspace.tests.test_api_config.TestAPIConfig object at 0x7f28faf6e510>

    def test_api_config_initialization(self):
        """Тест инициализации APIConfig"""
        config = APIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.api_config.APIConfig object at 0x7f28fb5664d0>, 'BASE_URL')

tests/test_api_config.py:12: AssertionError
________________ TestAPIConfig.test_api_config_defaults _________________

self = <workspace.tests.test_api_config.TestAPIConfig object at 0x7f28faf6eb10>

    def test_api_config_defaults(self):
        """Тест значений по умолчанию"""
        config = APIConfig()
>       assert config.TIMEOUT > 0
               ^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'TIMEOUT'

tests/test_api_config.py:19: AttributeError
________________ TestAPIConfig.test_api_config_from_env _________________

self = <workspace.tests.test_api_config.TestAPIConfig object at 0x7f28faf6f090>

    @patch.dict(os.environ, {'API_TIMEOUT': '30'})
    def test_api_config_from_env(self):
        """Тест загрузки конфигурации из переменных окружения"""
        config = APIConfig()
        # Проверяем, что конфигурация может загружаться из окружения
>       assert isinstance(config.TIMEOUT, (int, float))
                          ^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'TIMEOUT'

tests/test_api_config.py:27: AttributeError
_______________ TestAPIConfig.test_api_config_validation ________________

self = <workspace.tests.test_api_config.TestAPIConfig object at 0x7f28faf6f6d0>

    def test_api_config_validation(self):
        """Тест валидации конфигурации"""
        config = APIConfig()
>       assert config.TIMEOUT > 0
               ^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'TIMEOUT'

tests/test_api_config.py:32: AttributeError
_____________ TestAppConfig.test_app_config_initialization ______________

self = <workspace.tests.test_app_config.TestAppConfig object at 0x7f28faf78d10>

    def test_app_config_initialization(self):
        """Тест инициализации AppConfig"""
        config = AppConfig()
>       assert hasattr(config, 'DEBUG')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.app_config.AppConfig object at 0x7f28f9bbce10>, 'DEBUG')

tests/test_app_config.py:11: AssertionError
_______________ TestAppConfig.test_app_config_debug_mode ________________

self = <workspace.tests.test_app_config.TestAppConfig object at 0x7f28faf79310>

    def test_app_config_debug_mode(self):
        """Тест режима отладки"""
        config = AppConfig()
>       assert isinstance(config.DEBUG, bool)
                          ^^^^^^^^^^^^
E       AttributeError: 'AppConfig' object has no attribute 'DEBUG'

tests/test_app_config.py:17: AttributeError
________________ TestAppConfig.test_app_config_log_level ________________

self = <workspace.tests.test_app_config.TestAppConfig object at 0x7f28faf79910>

    def test_app_config_log_level(self):
        """Тест уровня логирования"""
        config = AppConfig()
>       assert config.LOG_LEVEL in ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'AppConfig' object has no attribute 'LOG_LEVEL'

tests/test_app_config.py:22: AttributeError
______________ TestAppConfig.test_app_config_env_override _______________

self = <workspace.tests.test_app_config.TestAppConfig object at 0x7f28faf7a4d0>

    @patch.dict('os.environ', {'DEBUG': 'True'})
    def test_app_config_env_override(self):
        """Тест переопределения из переменных окружения"""
        config = AppConfig()
        # Проверяем, что конфигурация корректно работает
>       assert isinstance(config.DEBUG, bool)
                          ^^^^^^^^^^^^
E       AttributeError: 'AppConfig' object has no attribute 'DEBUG'

tests/test_app_config.py:35: AttributeError
_______________ TestBaseAPI.test_base_api_initialization ________________

self = <workspace.tests.test_base_api.TestBaseAPI object at 0x7f28faf67e10>

    def test_base_api_initialization(self):
        """Тест инициализации BaseAPI"""
        # Создаем мок для requests.Session
        mock_session = MagicMock()
>       api = BaseAPI()
              ^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseAPI with abstract methods get_vacancies, get_vacancy_details

tests/test_base_api.py:34: TypeError
______________ TestBaseAPI.test_base_api_abstract_methods _______________

self = <workspace.tests.test_base_api.TestBaseAPI object at 0x7f28faf64910>

    def test_base_api_abstract_methods(self):
        """Тест абстрактных методов BaseAPI"""
>       api = BaseAPI()
              ^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseAPI with abstract methods get_vacancies, get_vacancy_details

tests/test_base_api.py:42: TypeError
______________ TestBaseAPI.test_base_api_request_handling _______________

self = <workspace.tests.test_base_api.TestBaseAPI object at 0x7f28faf6fb10>
mock_get = <MagicMock name='get' id='139813973455632'>

    @patch('requests.Session.get')
    def test_base_api_request_handling(self, mock_get):
        """Тест обработки запросов"""
        # Настраиваем мок
        mock_response = Mock()
        mock_response.json.return_value = {"test": "data"}
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = BaseAPI()
              ^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseAPI with abstract methods get_vacancies, get_vacancy_details

tests/test_base_api.py:60: TypeError
___________________ TestBaseAPI.test_base_api_headers ___________________

self = <workspace.tests.test_base_api.TestBaseAPI object at 0x7f28faf6f390>

    def test_base_api_headers(self):
        """Тест заголовков запроса"""
>       api = BaseAPI()
              ^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseAPI with abstract methods get_vacancies, get_vacancy_details

tests/test_base_api.py:70: TypeError
____________ TestBaseParser.test_base_parser_initialization _____________

self = <workspace.tests.test_base_parser.TestBaseParser object at 0x7f28faf7a150>

    def test_base_parser_initialization(self):
        """Тест инициализации базового парсера"""
>       parser = ConcreteParser()
                 ^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteParser with abstract method parse_vacancies

tests/test_base_parser.py:20: TypeError
___________ TestBaseParser.test_concrete_parser_parse_vacancy ___________

self = <workspace.tests.test_base_parser.TestBaseParser object at 0x7f28faf7b250>

    def test_concrete_parser_parse_vacancy(self):
        """Тест парсинга одной вакансии"""
>       parser = ConcreteParser()
                 ^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteParser with abstract method parse_vacancies

tests/test_base_parser.py:30: TypeError
_______ TestBaseParser.test_concrete_parser_parse_vacancies_list ________

self = <workspace.tests.test_base_parser.TestBaseParser object at 0x7f28faf84390>

    def test_concrete_parser_parse_vacancies_list(self):
        """Тест парсинга списка вакансий"""
>       parser = ConcreteParser()
                 ^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteParser with abstract method parse_vacancies

tests/test_base_parser.py:38: TypeError
_________________ TestBaseParser.test_parser_empty_data _________________

self = <workspace.tests.test_base_parser.TestBaseParser object at 0x7f28faf84850>

    def test_parser_empty_data(self):
        """Тест парсинга пустых данных"""
>       parser = ConcreteParser()
                 ^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteParser with abstract method parse_vacancies

tests/test_base_parser.py:52: TypeError
________________ TestBaseParser.test_parser_invalid_data ________________

self = <workspace.tests.test_base_parser.TestBaseParser object at 0x7f28faf85f50>

    def test_parser_invalid_data(self):
        """Тест парсинга невалидных данных"""
>       parser = ConcreteParser()
                 ^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteParser with abstract method parse_vacancies

tests/test_base_parser.py:58: TypeError
_______________ TestCacheManager.test_generate_cache_key ________________

args = (<workspace.tests.test_cache.TestCacheManager object at 0x7f28faf965d0>,)
keywargs = {}
newargs = (<workspace.tests.test_cache.TestCacheManager object at 0x7f28faf965d0>, <MagicMock name='rmtree' id='139813969672208'>)
newkeywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
        with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):
>           return func(*newargs, **newkeywargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: TestCacheManager.test_generate_cache_key() takes 1 positional argument but 2 were given

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1378: TypeError
_____________ TestCachedAPI.test_cached_api_initialization ______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f28fab0b6d0>

    def test_cached_api_initialization(self):
        """Тест инициализации CachedAPI"""
>       api = CachedAPI()
              ^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_cached_api.py:18: TypeError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f28fab0ba50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f28faf94e10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.cached_api' from '/home/runner/workspace/tests/../src/api_modules/cached_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f28fab087d0>

    def test_cached_api_abstract_methods(self):
        """Тест абстрактных методов CachedAPI"""
>       api = CachedAPI()
              ^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_cached_api.py:33: TypeError
_________________ TestCachedAPI.test_cache_integration __________________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f28fafa2850>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f28fab0b050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/cache.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestCachedAPI.test_cached_api_inheritance _______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f28fafa01d0>

    def test_cached_api_inheritance(self):
        """Тест наследования от BaseAPI"""
>       from src.api_modules.base_api import BaseAPI
E       ImportError: cannot import name 'BaseAPI' from 'src.api_modules.base_api' (/home/runner/workspace/tests/../src/api_modules/base_api.py)

tests/test_cached_api.py:52: ImportError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafa05d0>
mock_connect = <MagicMock name='connect' id='139813968853840'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:34: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object does not support the context manager protocol
___________________ TestDBManager.test_create_tables ____________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafa2710>
mock_connect = <MagicMock name='connect' id='139813968839440'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
>       db_manager.create_tables()

tests/test_db_manager.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f28faf647d0>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:68: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
_________ TestDBManager.test_get_companies_and_vacancies_count __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28faf78890>
mock_connect = <MagicMock name='connect' id='139813964985552'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect):
        """Тест получения количества компаний и вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("Test Company", 5),
            ("Another Company", 3)
        ]
    
        db_manager = DBManager()
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       AssertionError: assert 12 == 2
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:80: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:288 Нет подключения к базе данных
_________________ TestDBManager.test_get_all_vacancies __________________

self = <Mock name='connect().cursor().execute' id='139813969150032'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28faf79210>
mock_connect = <MagicMock name='connect' id='139813986065744'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test Company", 100000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:100: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafcf490>
mock_connect = <MagicMock name='connect' id='139813960426320'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchone.return_value = (125000.0,)
    
        db_manager = DBManager()
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert None == 125000.0

tests/test_db_manager.py:116: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <Mock name='connect().cursor().execute' id='139813956995280'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafcf610>
mock_connect = <MagicMock name='connect' id='139813969455248'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:136: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
_____________ TestDBManager.test_get_vacancies_with_keyword _____________

self = <Mock name='connect().cursor().execute' id='139813969061072'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafcdf10>
mock_connect = <MagicMock name='connect' id='139813969066192'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect):
        """Тест получения вакансий по ключевому слову"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test Company", 100000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_vacancies_with_keyword("Python")
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:155: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f28fafcda50>
mock_connect = <MagicMock name='connect' id='139813964611472'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
>       db_manager.populate_companies_table()

tests/test_db_manager.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f28f9b8ed50>

    def populate_companies_table(self):
        """Заполняет таблицу companies целевыми компаниями"""
        try:
            # Используем контекстный менеджер для безопасной работы с подключением
>           with self._get_connection() as connection:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:203: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:252 Ошибка при заполнении таблицы companies: 'Mock' object does not support the context manager protocol
_______________ TestEnvLoader.test_load_env_file_success ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28faf86d90>
mock_exists = <MagicMock name='exists' id='139813968846096'>
mock_file = <MagicMock name='open' id='139813968848848'>

    @patch('builtins.open', new_callable=mock_open, read_data='KEY1=value1\nKEY2=value2\n# Comment\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_success(self, mock_exists, mock_file):
        """Тест успешной загрузки .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:24: AttributeError
______________ TestEnvLoader.test_load_env_file_not_found _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28faf86b90>
mock_exists = <MagicMock name='exists' id='139813969450768'>

    @patch('os.path.exists', return_value=False)
    def test_load_env_file_not_found(self, mock_exists):
        """Тест загрузки несуществующего .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:33: AttributeError
______________ TestEnvLoader.test_load_env_file_read_error ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28fafb0410>
mock_exists = <MagicMock name='exists' id='139813951379664'>
mock_file = <MagicMock name='open' id='139813951387216'>

    @patch('builtins.open', side_effect=OSError("Read error"))
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_read_error(self, mock_exists, mock_file):
        """Тест ошибки чтения .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:42: AttributeError
________________ TestEnvLoader.test_parse_env_line_valid ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28fafb08d0>

    def test_parse_env_line_valid(self):
        """Тест парсинга валидной строки .env"""
        loader = EnvLoader()
    
>       key, value = loader.parse_line("KEY=value")
                     ^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_line'

tests/test_env_loader.py:50: AttributeError
_______________ TestEnvLoader.test_parse_env_line_invalid _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28fafb0c50>

    def test_parse_env_line_invalid(self):
        """Тест парсинга невалидной строки .env"""
        loader = EnvLoader()
    
        # Комментарий
>       result = loader.parse_line("# This is a comment")
                 ^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_line'

tests/test_env_loader.py:63: AttributeError
______________ TestEnvLoader.test_set_environment_variable ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28fafb1550>

    @patch.dict(os.environ, {}, clear=True)
    def test_set_environment_variable(self):
        """Тест установки переменной окружения"""
        loader = EnvLoader()
>       loader.set_env_var("TEST_KEY", "test_value")
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'set_env_var'

tests/test_env_loader.py:78: AttributeError
_______________ TestEnvLoader.test_load_env_file_function _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f28fafb2010>
mock_exists = <MagicMock name='exists' id='139813951426448'>
mock_file = <MagicMock name='open' id='139813960460368'>

    @patch('builtins.open', new_callable=mock_open, read_data='API_KEY=secret123\nDEBUG=true\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_function(self, mock_exists, mock_file):
        """Тест функции load_env_file"""
        with patch.dict(os.environ, {}, clear=True):
>           result = load_env_file(".env")
                     ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
_____________ TestHeadHunterAPI.test_hh_api_initialization ______________

self = <workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa39f690>

    def test_hh_api_initialization(self):
        """Тест инициализации HeadHunterAPI"""
        api = HeadHunterAPI()
>       assert hasattr(api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.hh_api.HeadHunterAPI object at 0x7f28f93962d0>, 'base_url')

tests/test_hh_api.py:17: AssertionError
_____________ TestHeadHunterAPI.test_get_vacancies_success ______________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa3a8450>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests.Session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
___________ TestHeadHunterAPI.test_get_vacancy_by_id_success ____________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa3a8b10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests.Session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestHeadHunterAPI.test_get_vacancies_network_error ___________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa38e8d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests.Session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______________ TestHeadHunterAPI.test_build_search_params _______________

self = <workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa3a8dd0>

    def test_build_search_params(self):
        """Тест построения параметров поиска"""
        api = HeadHunterAPI()
    
        # Проверяем базовые параметры
>       params = api._build_search_params("Python", page=0)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute '_build_search_params'

tests/test_hh_api.py:89: AttributeError
___________ TestHeadHunterAPI.test_process_vacancies_response ___________

self = <workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f28fa3a9110>

    def test_process_vacancies_response(self):
        """Тест обработки ответа с вакансиями"""
        api = HeadHunterAPI()
    
        test_response = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "employer": {"name": "Test Company"}
                }
            ]
        }
    
>       result = api._process_vacancies_response(test_response)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute '_process_vacancies_response'

tests/test_hh_api.py:109: AttributeError
_____________ TestHHAPIConfig.test_hh_config_initialization _____________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f28fa3aa090>

    def test_hh_config_initialization(self):
        """Тест инициализации HH API конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'BASE_URL')

tests/test_hh_api_config.py:11: AssertionError
__________________ TestHHAPIConfig.test_hh_config_urls __________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f28fa3aa850>

    def test_hh_config_urls(self):
        """Тест URL конфигурации"""
        config = HHAPIConfig()
>       assert config.BASE_URL.startswith('https://api.hh.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'BASE_URL'

tests/test_hh_api_config.py:18: AttributeError
_______________ TestHHAPIConfig.test_hh_config_parameters _______________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f28fa3aae50>

    def test_hh_config_parameters(self):
        """Тест параметров конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'DEFAULT_PER_PAGE')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'DEFAULT_PER_PAGE')

tests/test_hh_api_config.py:25: AssertionError
________________ TestHHAPIConfig.test_hh_config_timeout _________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f28fa3ab490>

    def test_hh_config_timeout(self):
        """Тест настроек таймаута"""
        config = HHAPIConfig()
>       assert hasattr(config, 'TIMEOUT')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'TIMEOUT')

tests/test_hh_api_config.py:33: AssertionError
__________________ TestHHParser.test_parse_hh_vacancy ___________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f28fa3b5f50>

    def test_parse_hh_vacancy(self):
        """Тест парсинга вакансии HH"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['id'] == '123456'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:31: KeyError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f28fa3b73d0>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {'items': [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies_list(data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_vacancies_list'

tests/test_hh_parser.py:55: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f28fa3b7a90>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {'id': '123', 'name': 'Test Job'}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result['id'] == '123'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:63: KeyError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f28fa3c8190>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['company'] == 'Test Company'
               ^^^^^^^^^^^^^^^^^
E       KeyError: 'company'

tests/test_hh_parser.py:70: KeyError
___________ TestMenuManager.test_menu_manager_initialization ____________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3c9e50>

    def test_menu_manager_initialization(self):
        """Тест инициализации MenuManager"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:21: TypeError
___________________ TestMenuManager.test_display_menu ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3ca1d0>
mock_print = <MagicMock name='print' id='139813951436624'>

    @patch('builtins.print')
    def test_display_menu(self, mock_print):
        """Тест отображения меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:32: TypeError
_______________ TestMenuManager.test_get_menu_item_valid ________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3ca510>

    def test_get_menu_item_valid(self):
        """Тест получения валидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:45: TypeError
______________ TestMenuManager.test_get_menu_item_invalid _______________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3ca990>

    def test_get_menu_item_invalid(self):
        """Тест получения невалидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:56: TypeError
_________________ TestMenuManager.test_menu_validation __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3cb590>

    def test_menu_validation(self):
        """Тест валидации пунктов меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:70: TypeError
_________________ TestMenuManager.test_get_user_choice __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3cbb50>
mock_input = <MagicMock name='input' id='139813968710032'>

    @patch('builtins.input', return_value='1')
    def test_get_user_choice(self, mock_input):
        """Тест получения выбора пользователя"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:82: TypeError
__________________ TestMenuManager.test_add_menu_item ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3d4190>

    def test_add_menu_item(self):
        """Тест добавления пункта меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:92: TypeError
_________________ TestMenuManager.test_remove_menu_item _________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3d4790>

    def test_remove_menu_item(self):
        """Тест удаления пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:107: TypeError
___________ TestMenuManager.test_remove_nonexistent_menu_item ___________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f28fa3d4d50>

    def test_remove_nonexistent_menu_item(self):
        """Тест удаления несуществующего пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:120: TypeError
______________ TestPaginator.test_paginator_initialization ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3d70d0>

    def test_paginator_initialization(self):
        """Тест инициализации Paginator"""
        items = ["item1", "item2", "item3"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:56: TypeError
_________________ TestPaginator.test_paginator_get_page _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3d7750>

    def test_paginator_get_page(self):
        """Тест получения страницы"""
        items = ["item1", "item2", "item3", "item4", "item5"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:66: TypeError
_______________ TestPaginator.test_paginator_invalid_page _______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3ca3d0>

    def test_paginator_invalid_page(self):
        """Тест получения невалидной страницы"""
        items = ["item1", "item2"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:80: TypeError
_______________ TestPaginator.test_paginator_empty_items ________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3d6c90>

    def test_paginator_empty_items(self):
        """Тест пагинатора с пустым списком"""
>       paginator = Paginator([], items_per_page=5)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:91: TypeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3d7cd0>
mock_print = <MagicMock name='print' id='139813951617296'>
mock_input = <MagicMock name='input' id='139813969597264'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:106: TypeError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f28fa3dc090>
mock_print = <MagicMock name='print' id='139813968928272'>
mock_input = <MagicMock name='input' id='139813965114704'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter, items_per_page=5)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:120: TypeError
__________________ TestPostgresSaver.test_save_vacancy __________________

self = <workspace.tests.test_postgres_saver.TestPostgresSaver object at 0x7f28f9f08d10>
mock_connect = <MagicMock name='connect' id='139813969078800'>

    @patch('src.storage.postgres_saver.psycopg2.connect')
    def test_save_vacancy(self, mock_connect):
        """Тест сохранения вакансии"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_postgres_saver.py:156: TypeError
____________ TestPostgresSaver.test_save_multiple_vacancies _____________

self = <workspace.tests.test_postgres_saver.TestPostgresSaver object at 0x7f28f9f0a550>
mock_connect = <MagicMock name='connect' id='139813968708816'>

    @patch('src.storage.postgres_saver.psycopg2.connect')
    def test_save_multiple_vacancies(self, mock_connect):
        """Тест сохранения нескольких вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        vacancies = [
>           Vacancy(id="123", title="Python Developer", company="Test Company", url="https://test1.com", source="hh.ru"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Vacancy(id="124", title="Java Developer", company="Test Company", url="https://test2.com", source="hh.ru")
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_postgres_saver.py:237: TypeError
_____________ TestSalaryUtils.test_parse_salary_range_valid _____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4c390>

    def test_parse_salary_range_valid(self):
        """Тест парсинга валидного диапазона зарплаты"""
>       result = parse_salary_range("100000 - 150000")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f9f62290>
state = <re._parser.State object at 0x7f28f9f61b50>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4c6d0>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
>       assert parse_salary_range("invalid") is None
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f8dc5410>
state = <re._parser.State object at 0x7f28f8dc5cd0>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
_________ TestSalaryUtils.test_parse_salary_range_reverse_order _________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4c310>

    def test_parse_salary_range_reverse_order(self):
        """Тест парсинга диапазона в обратном порядке"""
>       result = parse_salary_range("150000 - 100000")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f8e82c90>
state = <re._parser.State object at 0x7f28f8e81a50>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
_____________ TestSalaryUtils.test_format_salary_with_range _____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4cad0>

    def test_format_salary_with_range(self):
        """Тест форматирования зарплаты с диапазоном"""
        # Mock VacancySalary for testing format_salary
        class MockVacancySalary:
            def __init__(self, from_amount, to_amount, currency):
                self.from_amount = from_amount
                self.to_amount = to_amount
                self.currency = currency
    
        salary = MockVacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        result = format_salary(salary.from_amount, salary.to_amount, salary.currency)
    
>       assert "100000" in result
E       AssertionError: assert '100000' in '100 000 - 150 000 RUR'

tests/test_salary_utils.py:107: AssertionError
_____________ TestSalaryUtils.test_format_salary_from_only ______________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4cdd0>

    def test_format_salary_from_only(self):
        """Тест форматирования зарплаты только с минимальным значением"""
        class MockVacancySalary:
            def __init__(self, from_amount, currency):
                self.from_amount = from_amount
                self.currency = currency
    
        salary = MockVacancySalary(from_amount=100000, currency="RUR")
        result = format_salary(salary.from_amount, None, salary.currency)
    
>       assert "от 100000" in result
E       AssertionError: assert 'от 100000' in 'от 100 000 RUR'

tests/test_salary_utils.py:121: AssertionError
______________ TestSalaryUtils.test_format_salary_to_only _______________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b4dad0>

    def test_format_salary_to_only(self):
        """Тест форматирования зарплаты только с максимальным значением"""
        class MockVacancySalary:
            def __init__(self, to_amount, currency):
                self.to_amount = to_amount
                self.currency = currency
    
        salary = MockVacancySalary(to_amount=150000, currency="RUR")
        result = format_salary(None, salary.to_amount, salary.currency)
    
>       assert "до 150000" in result
E       AssertionError: assert 'до 150000' in 'до 150 000 RUR'

tests/test_salary_utils.py:134: AssertionError
__________ TestSalaryUtils.test_normalize_salary_string_range ___________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b55690>

    def test_normalize_salary_string_range(self):
        """Тест нормализации зарплаты из строки с диапазоном"""
>       from_amount, to_amount, currency = normalize_salary("100000 - 150000")
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:56: in normalize_salary
    from_amount, to_amount = parse_salary_range(salary_data)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f8d661d0>
state = <re._parser.State object at 0x7f28f8d67fd0>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
________ TestSalaryUtils.test_normalize_salary_string_from_only _________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b55dd0>

    def test_normalize_salary_string_from_only(self):
        """Тест нормализации зарплаты из строки только с минимальным значением"""
>       from_amount, to_amount, currency = normalize_salary("от 100000")
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:56: in normalize_salary
    from_amount, to_amount = parse_salary_range(salary_data)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f970f050>
state = <re._parser.State object at 0x7f28f970df50>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
_________ TestSalaryUtils.test_normalize_salary_string_to_only __________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b56490>

    def test_normalize_salary_string_to_only(self):
        """Тест нормализации зарплаты из строки только с максимальным значением"""
>       from_amount, to_amount, currency = normalize_salary("до 150000")
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:56: in normalize_salary
    from_amount, to_amount = parse_salary_range(salary_data)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f9f0bb50>
state = <re._parser.State object at 0x7f28f9f097d0>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
_________ TestSalaryUtils.test_normalize_salary_string_invalid __________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f28f9b57a50>

    def test_normalize_salary_string_invalid(self):
        """Тест нормализации невалидной зарплаты из строки"""
>       from_amount, to_amount, currency = normalize_salary("invalid salary")
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_salary_utils.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests/test_salary_utils.py:56: in normalize_salary
    from_amount, to_amount = parse_salary_range(salary_data)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_salary_utils.py:16: in parse_salary_range
    clean_str = re.sub(r'[^\d\s-от до]', '', salary_str.lower())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:185: in sub
    return _compile(pattern, flags).sub(repl, string, count)
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/__init__.py:294: in _compile
    p = _compiler.compile(pattern, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_compiler.py:745: in compile
    p = _parser.parse(p, flags)
        ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:989: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:464: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <re._parser.Tokenizer object at 0x7f28f8d64d90>
state = <re._parser.State object at 0x7f28f8d66050>, verbose = 0
nested = 1, first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
>                           raise source.error(msg, len(this) + 1 + len(that))
E                           re.error: bad character range \s-о at position 4

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/re/_parser.py:616: error
___________ TestAdvancedSearch.test_search_with_and_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f28f9b39b50>

    def test_search_with_and_operator(self):
        """Тест поиска с оператором AND"""
        vacancies = [
            Vacancy("123", "Python Django Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Python Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "Django Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_and(vacancies, ["python", "django"])
    
        # Должна найтись только первая вакансия
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_search_utils.py:76: AssertionError
____________ TestAdvancedSearch.test_search_with_or_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f28f9b39110>

    def test_search_with_or_operator(self):
        """Тест поиска с оператором OR"""
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "C++ Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["python", "java"])
    
        # Должны найтись первые две вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:91: AssertionError
____________ TestAdvancedSearch.test_search_case_insensitive ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f28f9b3a490>

    def test_search_case_insensitive(self):
        """Тест поиска без учета регистра"""
        vacancies = [
            Vacancy("123", "PYTHON Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "python developer", "https://test2.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["Python"])
    
        # Должны найтись обе вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:104: AssertionError
_____________ TestAdvancedSearch.test_search_in_description _____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f28f9b3a890>

    def test_search_in_description(self):
        """Тест поиска в описании вакансии"""
        vacancies = [
>           Vacancy("123", "Developer", "https://test.com", "hh.ru",
                   description="Work with Python and Django"),
            Vacancy("124", "Developer", "https://test2.com", "hh.ru",
                   description="Work with Java")
        ]
E       TypeError: Vacancy.__init__() got multiple values for argument 'description'

tests/test_search_utils.py:109: TypeError
______________ TestSuperJobAPI.test_sj_api_initialization _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f14cd0>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJobAPI"""
        api = SuperJobAPI()
>       assert hasattr(api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f28f8c0e810>, 'base_url')

tests/test_sj_api.py:17: AssertionError
_______________ TestSuperJobAPI.test_sj_api_with_api_key ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f14d10>

    def test_sj_api_with_api_key(self):
        """Тест инициализации с API ключом"""
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:22: TypeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

args = (<workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f15a10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.sj_api.requests.Session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.sj_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestSuperJobAPI.test_get_vacancy_by_id_success _____________

args = (<workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f16310>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.sj_api.requests.Session'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.sj_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
________________ TestSuperJobAPI.test_api_key_validation ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f17350>

    def test_api_key_validation(self):
        """Тест валидации API ключа"""
        api = SuperJobAPI()
    
        # Проверяем обработку отсутствующего API ключа
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f28f8c3b2d0>, 'api_key')

tests/test_sj_api.py:82: AssertionError
_____________ TestSuperJobAPI.test_api_key_from_environment _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f28f9f16390>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'env_test_key'})
    def test_api_key_from_environment(self):
        """Тест получения API ключа из переменной окружения"""
        api = SuperJobAPI()
        # API должен использовать ключ из окружения
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f28f8c3a510>, 'api_key')

tests/test_sj_api.py:89: AssertionError
_____________ TestSJAPIConfig.test_sj_config_initialization _____________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f28f9f166d0>

    def test_sj_config_initialization(self):
        """Тест инициализации SuperJob API конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'BASE_URL')

tests/test_sj_api_config.py:11: AssertionError
__________________ TestSJAPIConfig.test_sj_config_urls __________________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f28f9f17ed0>

    def test_sj_config_urls(self):
        """Тест URL конфигурации"""
        config = SJAPIConfig()
>       assert config.BASE_URL.startswith('https://api.superjob.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'BASE_URL'

tests/test_sj_api_config.py:17: AttributeError
_______________ TestSJAPIConfig.test_sj_config_parameters _______________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f28f9f17310>

    def test_sj_config_parameters(self):
        """Тест параметров конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'DEFAULT_COUNT')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'DEFAULT_COUNT')

tests/test_sj_api_config.py:31: AssertionError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f28f9f16790>

    def test_create_postgres_storage(self):
        """Тест создания PostgreSQL хранилища"""
        factory = StorageFactory()
>       storage = factory.create_storage('postgres', {})
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: StorageFactory.create_storage() takes from 0 to 1 positional arguments but 2 were given

tests/test_storage_factory.py:61: TypeError
__________ TestStorageFactory.test_create_storage_with_config ___________

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f28f9b25f50>

    def test_create_storage_with_config(self):
        """Тест создания хранилища с конфигурацией"""
        factory = StorageFactory()
        config = {'host': 'localhost', 'port': 5432}
>       storage = factory.create_storage('postgres', config)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: StorageFactory.create_storage() takes from 0 to 1 positional arguments but 2 were given

tests/test_storage_factory.py:87: TypeError
_______ TestTargetCompanies.test_target_companies_initialization ________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f28f9b24510>

    def test_target_companies_initialization(self):
        """Тест инициализации списка целевых компаний"""
        companies = TargetCompanies()
>       assert hasattr(companies, 'companies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.target_companies.TargetCompanies object at 0x7f28f8c38510>, 'companies')

tests/test_target_companies.py:44: AssertionError
________ TestTargetCompanies.test_get_target_companies_function _________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f28f9b27cd0>

    def test_get_target_companies_function(self):
        """Тест функции получения целевых компаний"""
        companies = get_target_companies()
>       assert isinstance(companies, (list, dict))
E       AssertionError: assert False
E        +  where False = isinstance(<src.config.target_companies.TargetCompanies object at 0x7f28f8c3b4d0>, (<class 'list'>, <class 'dict'>))

tests/test_target_companies.py:50: AssertionError
_____________ TestTargetCompanies.test_companies_not_empty ______________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f28f9b0ee90>

    def test_companies_not_empty(self):
        """Тест что список компаний не пустой"""
        companies = get_target_companies()
>       assert len(companies) > 0
               ^^^^^^^^^^^^^^
E       TypeError: object of type 'TargetCompanies' has no len()

tests/test_target_companies.py:67: TypeError
______________ TestUIConfig.test_ui_config_initialization _______________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f28f9b0ce90>

    def test_ui_config_initialization(self):
        """Тест инициализации UI конфигурации"""
        config = UIConfig()
>       assert hasattr(config, 'PAGINATION_SIZE')
E       AssertionError: assert False
E        +  where False = hasattr(UIConfig(items_per_page=5, max_display_items=20), 'PAGINATION_SIZE')

tests/test_ui_config.py:10: AssertionError
________________ TestUIConfig.test_ui_config_pagination _________________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f28f9b0d5d0>

    def test_ui_config_pagination(self):
        """Тест настроек пагинации"""
        config = UIConfig()
>       assert config.PAGINATION_SIZE > 0
               ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIConfig' object has no attribute 'PAGINATION_SIZE'

tests/test_ui_config.py:16: AttributeError
________________ TestUIHelpers.test_display_vacancy_info ________________

self = <workspace.tests.test_ui_helpers.TestUIHelpers object at 0x7f28f9fcaf90>
mock_print = <MagicMock name='print' id='139813948897168'>

    @patch('builtins.print')
    def test_display_vacancy_info(self, mock_print):
        """Тест отображения информации о вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'area'

tests/test_ui_helpers.py:169: TypeError
_______________ TestUnifiedAPI.test_get_available_sources _______________

self = <workspace.tests.test_unified_api.TestUnifiedAPI object at 0x7f28f9b025d0>

    def test_get_available_sources(self):
        """Тест получения доступных источников"""
        api = UnifiedAPI()
        sources = api.get_available_sources()
    
>       assert isinstance(sources, set)
E       AssertionError: assert False
E        +  where False = isinstance(['hh', 'sj'], set)

tests/test_unified_api.py:59: AssertionError
____________________ TestUnifiedAPI.test_clear_cache ____________________

self = <workspace.tests.test_unified_api.TestUnifiedAPI object at 0x7f28f9b01550>

    def test_clear_cache(self):
        """Тест очистки кэша"""
        with patch('src.api_modules.unified_api.HeadHunterAPI') as mock_hh, \
             patch('src.api_modules.unified_api.SuperJobAPI') as mock_sj:
    
            mock_hh_instance = Mock()
            mock_sj_instance = Mock()
            mock_hh.return_value = mock_hh_instance
            mock_sj.return_value = mock_sj_instance
    
            api = UnifiedAPI()
>           api.clear_cache()
E           TypeError: UnifiedAPI.clear_cache() missing 1 required positional argument: 'sources'

tests/test_unified_api.py:87: TypeError
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <MagicMock name='_handle_choice' id='139813950346448'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_handle_choice' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f28f9b03b10>
mock_stdout = <_io.StringIO object at 0x7f28fb4d7a30>
mock_input = <MagicMock name='input' id='139813950353488'>

    @patch('builtins.input', return_value='0')
    @patch('sys.stdout', new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
        with patch.object(ui, '_display_menu'):
            with patch.object(ui, '_handle_choice') as mock_handle:
                mock_handle.return_value = False
                ui.run()
>               mock_handle.assert_called()
E               AssertionError: Expected '_handle_choice' to have been called.

tests/test_user_interface.py:63: AssertionError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <MagicMock name='_search_vacancies' id='139813948846096'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_search_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f28f9b03a50>
mock_input = <MagicMock name='input' id='139813948839824'>

    @patch('builtins.input', return_value='1')
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
        with patch.object(ui, '_search_vacancies') as mock_search:
            result = ui._handle_choice('1')
            if hasattr(ui, '_search_vacancies'):
>               mock_search.assert_called()
E               AssertionError: Expected '_search_vacancies' to have been called.

tests/test_user_interface.py:72: AssertionError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f28f9fe0050>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        with patch('builtins.input', side_effect=KeyboardInterrupt):
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

tests/test_user_interface.py:92: Failed
______ TestVacancyDisplayHandler.test_display_vacancies_empty_list ______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f83910>
mock_print = <MagicMock name='print' id='139813950992720'>

    @patch('builtins.print')
    def test_display_vacancies_empty_list(self, mock_print):
        """Тест отображения пустого списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       handler.display_vacancies([])
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:84: AttributeError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f82f10>
mock_print = <MagicMock name='print' id='139813950217936'>

    @patch('builtins.print')
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru")
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:100: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f83410>
mock_paginate = <MagicMock name='quick_paginate' id='139813956704592'>

    @patch('src.ui_interfaces.vacancy_display_handler.quick_paginate')
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:115: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f800d0>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:131: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f80050>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124",
            title="Junior Developer",
            url="https://test.com/vacancy/124",
            source="hh.ru",
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:153: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f28f9f80910>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(
            id="125",
            title="Intern",
            url="https://test.com/vacancy/125",
            source="hh.ru",
            salary=salary
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:174: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f28f9f82610>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f28f970b4c0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f28f9b03510>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость"
        )

tests/test_vacancy_formatter.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f28f8f8f700>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____ TestVacancyEmployer.test_vacancy_employer_str_representation ______

self = <workspace.tests.test_vacancy_models.TestVacancyEmployer object at 0x7f28f9bfd690>

    def test_vacancy_employer_str_representation(self):
        """Тест строкового представления VacancyEmployer"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       assert str(employer) == "Test Company"
E       AssertionError: assert 'VacancyEmplo...rusted=False)' == 'Test Company'
E         
E         - Test Company
E         + VacancyEmployer(id='1', name='Test Company', url=None, trusted=False)

tests/test_vacancy_models.py:86: AssertionError
________________ TestVacancy.test_vacancy_initialization ________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bfe310>

    def test_vacancy_initialization(self):
        """Тест инициализации Vacancy"""
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:100: TypeError
_________________ TestVacancy.test_vacancy_with_salary __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf3ed0>

    def test_vacancy_with_salary(self):
        """Тест вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            salary=str(salary) # Assuming salary is converted to string for the placeholder Vacancy
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:116: TypeError
________________ TestVacancy.test_vacancy_with_employer _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf3a90>

    def test_vacancy_with_employer(self):
        """Тест вакансии с работодателем"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:128: TypeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf04d0>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:143: TypeError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf0a50>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"]
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:196: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf0dd0>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"]
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:214: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf1d90>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:231: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f28f9bf1bd0>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary)
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_models.py:252: TypeError
___ TestVacancyOperationsCoordinator.test_coordinator_initialization ____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f28f9be0490>

    def test_coordinator_initialization(self):
        """Тест инициализации VacancyOperationsCoordinator"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
>       assert coordinator.api == mock_api
               ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyOperationsCoordinator' object has no attribute 'api'

tests/test_vacancy_operations_coordinator.py:21: AttributeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f28f9be0f10>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='139813968846800'>

    @patch('src.ui_interfaces.vacancy_search_handler.VacancySearchHandler')
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7f28fb7831d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f28f9be2210>
mock_print = <MagicMock name='print' id='139813951584080'>
mock_input = <MagicMock name='input' id='139813951575504'>

    @patch('builtins.input', return_value='5')
    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, mock_input):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
>       from src.vacancies.models import Vacancy, VacancySalary
E       ImportError: cannot import name 'VacancySalary' from 'src.vacancies.models' (/home/runner/workspace/tests/../src/vacancies/models.py)

tests/test_vacancy_operations_coordinator.py:62: ImportError
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f28f9be2150>
mock_print = <MagicMock name='print' id='139813951574032'>
mock_input = <MagicMock name='input' id='139813956355792'>

    @patch('builtins.input', return_value='Python')
    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, mock_input):
        """Тест поиска сохраненных вакансий по ключевому слову"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:86: NameError
_____ TestVacancyOperationsCoordinator.test_handle_delete_vacancies _____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f28f9be2450>
mock_input = <MagicMock name='input' id='139813965172304'>

    @patch('builtins.input', return_value='Python')
    def test_handle_delete_vacancies(self, mock_input):
        """Тест удаления вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:103: NameError
______ TestVacancyOperationsCoordinator.test_handle_cache_cleanup _______

self = <Mock name='mock.clear_cache' id='139813968767120'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear_cache' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOp