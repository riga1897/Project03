platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 297 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py ....                                     [  5%]
tests/test_app_config.py .....                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 13%]
tests/test_cached_api.py FFFFF                                    [ 15%]
tests/test_db_manager.py FF...F.F                                 [ 17%]
tests/test_decorators.py .......                                  [ 20%]
tests/test_env_loader.py ............                             [ 24%]
tests/test_file_handlers.py ............                          [ 28%]
tests/test_get_api.py ......                                      [ 30%]
tests/test_hh_api.py .......                                      [ 32%]
tests/test_hh_api_config.py .....                                 [ 34%]
tests/test_hh_parser.py ....FFFF                                  [ 37%]
tests/test_menu_manager.py ..........                             [ 40%]
tests/test_paginator.py ....FF                                    [ 42%]
tests/test_postgres_saver.py .......                              [ 44%]
tests/test_salary_utils.py .F..................                   [ 51%]
tests/test_search_utils.py ..................                     [ 57%]
tests/test_sj_api.py .F...FFF.                                    [ 60%]
tests/test_sj_api_config.py .....                                 [ 62%]
tests/test_sj_parser.py ........                                  [ 64%]
tests/test_storage_factory.py ........                            [ 67%]
tests/test_target_companies.py .....                              [ 69%]
tests/test_ui_config.py .....                                     [ 71%]
tests/test_ui_helpers.py ...........                              [ 74%]
tests/test_unified_api.py .................                       [ 80%]
tests/test_user_interface.py ........                             [ 83%]
tests/test_vacancy_display_handler.py ..FFFFF                     [ 85%]
tests/test_vacancy_formatter.py ..F..F.                           [ 87%]
tests/test_vacancy_models.py .......F...F                         [ 91%]
tests/test_vacancy_operations_coordinator.py ...........          [ 95%]
tests/test_vacancy_search_handler.py ......                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestCachedAPI.test_cached_api_initialization ______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fafbbd3ec90>
mock_file_cache = <MagicMock name='FileCache' id='140392726447184'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_initialization(self, mock_file_cache):
        """Тест инициализации CachedAPI"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPIImplementation with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:40: TypeError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fafbbd4b3d0>
mock_file_cache = <MagicMock name='FileCache' id='140392726273936'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_with_cache_manager(self, mock_file_cache):
        """Тест CachedAPI с кэш менеджером"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPIImplementation with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:49: TypeError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fafbbd4b750>
mock_file_cache = <MagicMock name='FileCache' id='140392726460944'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_abstract_methods(self, mock_file_cache):
        """Тест абстрактных методов CachedAPI"""
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPIImplementation with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:55: TypeError
_________________ TestCachedAPI.test_cache_integration __________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fafbbd4bb10>
mock_file_cache = <MagicMock name='FileCache' id='140392726599184'>

    @patch("src.utils.cache.FileCache")
    def test_cache_integration(self, mock_file_cache):
        """Тест интеграции с кэшем"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None
        mock_cache_instance.set.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPIImplementation with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:72: TypeError
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fafbbd4bf10>
mock_file_cache = <MagicMock name='FileCache' id='140392726661904'>

    @patch("src.utils.cache.FileCache")
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPIImplementation with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:84: TypeError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fafbbd5a950>
mock_connect = <MagicMock name='connect' id='140392726762704'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем метод проверки соединения
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            result = db_manager.check_connection()
>           assert result is True
E           assert False is True

tests/test_db_manager.py:91: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
___________________ TestDBManager.test_create_tables ____________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fafbbd5b010>
mock_connect = <MagicMock name='connect' id='140392726820112'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        # Мокаем метод обеспечения существования таблиц
        with patch.object(db_manager, "_ensure_tables_exist", return_value=True):
            with patch.object(db_manager, "_get_connection", return_value=mock_connection):
>               db_manager.create_tables()

tests/test_db_manager.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fafba9ca710>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Создаем упрощенную таблицу компаний для целевых компаний
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS companies (
                            id SERIAL PRIMARY KEY,
                            name VARCHAR(255) NOT NULL UNIQUE,
                            hh_id VARCHAR(50),
                            sj_id VARCHAR(50)
                        );
                    """
                    )
                    logger.info("✓ Таблица companies создана/проверена")
    
                    # Создаем полную таблицу вакансий сразу с правильными типами
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS vacancies (
                            id SERIAL PRIMARY KEY,
                            vacancy_id VARCHAR(255) UNIQUE NOT NULL,
                            title TEXT NOT NULL,
                            url TEXT,
                            salary_from INTEGER,
                            salary_to INTEGER,
                            salary_currency VARCHAR(10),
                            description TEXT,
                            requirements TEXT,
                            responsibilities TEXT,
                            experience VARCHAR(100),
                            employment VARCHAR(100),
                            schedule VARCHAR(100),
                            area TEXT,
                            source VARCHAR(50),
                            published_at TIMESTAMP,
                            company_id INTEGER,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    """
                    )
    
                    # Проверяем и исправляем тип company_id если нужно
                    cursor.execute(
                        """
                        SELECT data_type
                        FROM information_schema.columns
                        WHERE table_name = 'vacancies' AND column_name = 'company_id'
                    """
                    )
    
                    result = cursor.fetchone()
>                   if result and result[0] not in ("integer", "bigint"):
                                  ^^^^^^^^^
E                   TypeError: 'Mock' object is not subscriptable

src/storage/db_manager.py:123: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fafbbd60a90>
mock_connect = <MagicMock name='connect' id='140392726596240'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor_instance = mock_cursor.__enter__.return_value
        mock_cursor_instance.fetchall.return_value = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
    
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем соединение
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            result = db_manager.get_vacancies_with_higher_salary()
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:182: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object is not subscriptable
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fafbbd61790>
mock_connect = <MagicMock name='connect' id='140392726453584'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем функцию получения целевых компаний
        test_companies = [{"id": "1", "name": "Test Company 1"}, {"id": "2", "name": "Test Company 2"}]
    
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            # Мокаем функцию получения целевых компаний
>           with patch("src.config.target_companies.get_target_companies_data", return_value=test_companies):

tests/test_db_manager.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fafbadedbd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.target_companies' from '/home/runner/workspace/tests/../src/config/target_companies.py'> does not have the attribute 'get_target_companies_data'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fafbb1cc1d0>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {"items": [self.sample_hh_vacancy]}
    
        # Мокаем Vacancy.to_dict для избежания ошибок реального класса
        with patch("src.vacancies.parsers.hh_parser.Vacancy") as mock_vacancy:
            mock_vacancy_instance = Mock()
            mock_vacancy_instance.to_dict.return_value = {
                "vacancy_id": "123456",
                "title": "Python Developer",
                "url": "https://hh.ru/vacancy/123456"
            }
            mock_vacancy.from_dict.return_value = mock_vacancy_instance
    
            result = self.parser.parse_vacancies(data["items"])
    
            assert len(result) == 1
>           assert result[0]["vacancy_id"] == "123456"
E           AssertionError: assert <MagicMock name='Vacancy.to_dict().__getitem__()' id='140392722669392'> == '123456'

tests/test_hh_parser.py:173: AssertionError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fafbb1cc890>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {"id": "123", "name": "Test Job"}
    
        # Мокаем Vacancy.from_dict
        with patch("src.vacancies.parsers.hh_parser.Vacancy") as mock_vacancy:
            mock_vacancy_instance = Mock()
            mock_vacancy_instance.vacancy_id = "123"
            mock_vacancy_instance.title = "Test Job"
            mock_vacancy.from_dict.return_value = mock_vacancy_instance
    
            result = self.parser.parse_vacancy(minimal_data)
>           assert result.vacancy_id == "123"
                   ^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'vacancy_id'

tests/test_hh_parser.py:188: AttributeError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fafbb1ccf50>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        # Мокаем Vacancy.from_dict
        with patch("src.vacancies.parsers.hh_parser.Vacancy") as mock_vacancy:
            mock_vacancy_instance = Mock()
            mock_vacancy_instance.employer = {"name": "Test Company", "id": "1"}
            mock_vacancy.from_dict.return_value = mock_vacancy_instance
    
            result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>           assert result.employer["name"] == "Test Company"
                   ^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'employer'

tests/test_hh_parser.py:200: AttributeError
_______________ TestHHParser.test_parse_hh_location_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fafbb1cd610>

    def test_parse_hh_location_data(self):
        """Тест парсинга данных о местоположении"""
        # Мокаем Vacancy.from_dict
        with patch("src.vacancies.parsers.hh_parser.Vacancy") as mock_vacancy:
            mock_vacancy_instance = Mock()
            mock_vacancy_instance.area = {"name": "Москва"}
            mock_vacancy.from_dict.return_value = mock_vacancy_instance
    
            result = self.parser.parse_vacancy(self.sample_hh_vacancy)
            assert "area" in result
>           assert result["area"]["name"] == "Москва"
                   ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: string indices must be integers, not 'str'

tests/test_hh_parser.py:213: TypeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fafbb1e9b90>
mock_print = <MagicMock name='print' id='140392722230544'>
mock_input = <MagicMock name='input' id='140392722232848'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Тестируем функцию quick_paginate напрямую
>       from src.utils.paginator import quick_paginate
E       ImportError: cannot import name 'quick_paginate' from 'src.utils.paginator' (/home/runner/workspace/tests/../src/utils/paginator.py)

tests/test_paginator.py:110: ImportError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fafbb1ea210>
mock_print = <MagicMock name='print' id='140392726769488'>
mock_input = <MagicMock name='input' id='140392722618000'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Тестируем функцию quick_paginate напрямую
>       from src.utils.paginator import quick_paginate
E       ImportError: cannot import name 'quick_paginate' from 'src.utils.paginator' (/home/runner/workspace/tests/../src/utils/paginator.py)

tests/test_paginator.py:129: ImportError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7fafbad08a50>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
        result = parse_salary_range("invalid")
        assert result == (None, None)
        result_empty = parse_salary_range("")
        assert result_empty == (None, None)
        # Одиночное число возвращается как диапазон от этого числа до этого же числа
        result_single = parse_salary_range("100000")
        assert result_single == (100000, 100000)
>       assert parse_salary_range("abc - def") is None
E       AssertionError: assert (None, None) is None
E        +  where (None, None) = parse_salary_range('abc - def')

tests/test_salary_utils.py:96: AssertionError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fafbad3de90>
mock_paginator = <MagicMock name='Paginator' id='140392722625872'>
mock_api_config = <MagicMock name='APIConfig' id='140392712531792'>
mock_cache = <MagicMock name='FileCache' id='140392722507792'>
mock_connector = <MagicMock name='APIConnector' id='140392722509840'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_vacancies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения вакансий"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        # Настраиваем мок коннектора
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
    
        test_response = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "link": "https://superjob.ru/vacancy/123"
                }
            ]
        }
        mock_connector_instance.get.return_value = test_response
    
        # Мокируем paginator для избежания ошибок
        mock_paginator_instance = Mock()
        mock_paginator_instance.count = 1
        mock_paginator.return_value = mock_paginator_instance
    
        api = SuperJobAPI()
    
        # Мокируем методы API для изоляции теста
>       with patch.object(api, '_get_cached_data', return_value=test_response["objects"]):

tests/test_sj_api.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fafba5d23d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7fafba5d3250> does not have the attribute '_get_cached_data'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSuperJobAPI.test_format_search_params _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fafbad3f610>
mock_paginator = <MagicMock name='Paginator' id='140392722065232'>
mock_api_config = <MagicMock name='APIConfig' id='140392722415952'>
mock_cache = <MagicMock name='FileCache' id='140392722419088'>
mock_connector = <MagicMock name='APIConnector' id='140392722559248'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_format_search_params(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест форматирования параметров поиска"""
        api = SuperJobAPI()
    
        # Тестируем через публичный метод или создаем мок
        test_params = {
            "keyword": "Python",
            "count": 50,
            "page": 1
        }
    
        # Мокируем приватный метод
>       with patch.object(api, '_format_search_params', return_value=test_params) as mock_format:

tests/test_sj_api.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fafba921a50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7fafba53cc90> does not have the attribute '_format_search_params'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSuperJobAPI.test_get_companies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fafbad3fc50>
mock_paginator = <MagicMock name='Paginator' id='140392722363920'>
mock_api_config = <MagicMock name='APIConfig' id='140392722363344'>
mock_cache = <MagicMock name='FileCache' id='140392722351952'>
mock_connector = <MagicMock name='APIConnector' id='140392722846096'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_companies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения компаний"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
    
        test_response = {
            "objects": [
                {
                    "id": 1,
                    "title": "Яндекс",
                    "link": "https://superjob.ru/company/1"
                }
            ]
        }
        mock_connector_instance.get.return_value = test_response
    
        api = SuperJobAPI()
    
        # Мокируем метод get_companies
>       with patch.object(api, 'get_companies', return_value=test_response["objects"]) as mock_get_companies:

tests/test_sj_api.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fafba5ff8d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7fafba5fedd0> does not have the attribute 'get_companies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestSuperJobAPI.test_clear_cache ____________________

self = <Mock name='FileCache().clear' id='140392722058768'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fafbad402d0>
mock_paginator = <MagicMock name='Paginator' id='140392722649168'>
mock_api_config = <MagicMock name='APIConfig' id='140392722646672'>
mock_cache = <MagicMock name='FileCache' id='140392722657232'>
mock_connector = <MagicMock name='APIConnector' id='140392722077264'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_clear_cache(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache.return_value = mock_cache_instance
    
        api = SuperJobAPI()
        api.clear_cache("sj")
    
>       mock_cache_instance.clear.assert_called_once()
E       AssertionError: Expected 'clear' to have been called once. Called 0 times.

tests/test_sj_api.py:191: AssertionError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fafbadc5850>
mock_print = <MagicMock name='print' id='140392722364560'>

    @patch("builtins.print")
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:146: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fafbadc5c10>
mock_paginate = <MagicMock name='quick_paginate' id='140392722019728'>

    @patch("src.ui_interfaces.vacancy_display_handler.quick_paginate")
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:161: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fafbadc6190>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:177: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fafbadc6790>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124", title="Junior Developer", url="https://test.com/vacancy/124", source="hh.ru", employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:199: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fafbadc6d90>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(id="125", title="Intern", url="https://test.com/vacancy/125", source="hh.ru", salary=salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:216: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fafbadd9c10>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary_dict = {
            "from": 100000,
            "to": 150000,
            "currency": "RUR"
        }
    
        vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary_dict,  # Передаем словарь вместо объекта
        )
    
        formatter = VacancyFormatter()
        result = formatter.format_vacancy_info(vacancy)
    
        assert "Python Developer" in result
        assert "123" in result
>       assert "100000" in result or "150000" in result
E       AssertionError: assert ('100000' in 'ID: 123\nНазвание: Python Developer\nЗарплата: от 100 000 до 150 000 руб. в месяц\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123' or '150000' in 'ID: 123\nНазвание: Python Developer\nЗарплата: от 100 000 до 150 000 руб. в месяц\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123')

tests/test_vacancy_formatter.py:150: AssertionError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fafbaddae50>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary_dict = {
            "from": 100000,
            "to": 150000,
            "currency": "RUR"
        }
        employer_dict = {"name": "Test Company", "id": "1"}
    
        vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary_dict,
            employer=employer_dict,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость",
        )
    
        formatter = VacancyFormatter()
        result = formatter.format_vacancy_info(vacancy)
    
        assert "Python Developer" in result
        assert "Test Company" in result
>       assert "100000" in result or "150000" in result
E       AssertionError: assert ('100000' in 'ID: 123\nНазвание: Python Developer\nКомпания: Test Company\nЗарплата: от 100 000 до 150 000 руб. в месяц\nОпыт: От 1 года до 3 лет\nЗанятость: Полная занятость\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123' or '150000' in 'ID: 123\nНазвание: Python Developer\nКомпания: Test Company\nЗарплата: от 100 000 до 150 000 руб. в месяц\nОпыт: От 1 года до 3 лет\nЗанятость: Полная занятость\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123')

tests/test_vacancy_formatter.py:208: AssertionError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fafbadeacd0>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
        vacancy = Vacancy(
            vacancy_id="123", title="Python Developer", url="https://test.com/vacancy/123", source="hh.ru"
        )
        # Устанавливаем работодателя после создания
        vacancy.employer = {"name": "Test Company"}
        str_repr = str(vacancy)
        assert "Python Developer" in str_repr
        assert "123" in str_repr
        assert "Test Company" in str_repr
>       assert "hh.ru" in str_repr
E       AssertionError: assert 'hh.ru' in '[HH.RU] Должность: Python Developer\nКомпания: Test Company\nЗарплата: Зарплата не указана\nТребования: Не указаны\nСсылка: https://test.com/vacancy/123'

tests/test_vacancy_models.py:157: AssertionError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fafbadec590>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
        )
    
>       result = vacancy.to_dict()
                 ^^^^^^^^^^^^^^^^^

tests/test_vacancy_models.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.vacancies.models.Vacancy object at 0x7fafb9cbdcc0>

    def to_dict(self) -> Dict[str, Any]:
        """Преобразование вакансии в словарь"""
        result = {
            "vacancy_id": self.vacancy_id,
            "title": self.title,
            "url": self.url,
            "source": self.source,
            "area": self.area,
            "experience": self.experience,
            "employment": self.employment,
            "description": self.description,
            "published_at": self.published_at,
        }
    
        if self.salary:
            result["salary"] = {
>               "from_amount": self.salary.from_amount,
                               ^^^^^^^^^^^^^^^^^^^^^^^
                "to_amount": self.salary.to_amount,
                "currency": self.salary.currency,
            }
E           AttributeError: 'Salary' object has no attribute 'from_amount'

src/vacancies/models.py:364: AttributeError
======================== short test summary info ========================
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_initialization - TypeError: Can't instantiate abstract class CachedAPIImplementation ...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_with_cache_manager - TypeError: Can't instantiate abstract class CachedAPIImplementation ...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_abstract_methods - TypeError: Can't instantiate abstract class CachedAPIImplementation ...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cache_integration - TypeError: Can't instantiate abstract class CachedAPIImplementation ...
FAILED tests/test_cached_api.py::TestCachedAPI::test_clear_cache_method - TypeError: Can't instantiate abstract class CachedAPIImplementation ...
FAILED tests/test_db_manager.py::TestDBManager::test_check_connection_success - assert False is True
FAILED tests/test_db_manager.py::TestDBManager::test_create_tables - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary - assert 0 == 1
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - AttributeError: <module 'src.config.target_companies' from '/home/ru...
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancies_list - AssertionError: assert <MagicMock name='Vacancy.to_dict().__getitem_...
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancy_minimal_data - AttributeError: 'dict' object has no attribute 'vacancy_id'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_employer_data - AttributeError: 'dict' object has no attribute 'employer'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_location_data - TypeError: string indices must be integers, not 'str'
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_quit - ImportError: cannot import name 'quick_paginate' from 'src.utils.pag...
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_navigation - ImportError: cannot import name 'quick_paginate' from 'src.utils.pag...
FAILED tests/test_salary_utils.py::TestSalaryUtils::test_parse_salary_range_invalid - AssertionError: assert (None, None) is None
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancies_success - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7faf...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_format_search_params - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7faf...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_companies_success - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7faf...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_clear_cache - AssertionError: Expected 'clear' to have been called once. Called 0 ...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_data - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_pagination - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_employer - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_salary - AssertionError: assert ('100000' in 'ID: 123\nНазвание: Python Devel...
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_full - AssertionError: assert ('100000' in 'ID: 123\nНазвание: Python Devel...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_str_representation - AssertionError: assert 'hh.ru' in '[HH.RU] Должность: Python Develop...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_to_dict - AttributeError: 'Salary' object has no attribute 'from_amount'
==================== 29 failed, 268 passed in 1.49s =====================
~/workspace$ 