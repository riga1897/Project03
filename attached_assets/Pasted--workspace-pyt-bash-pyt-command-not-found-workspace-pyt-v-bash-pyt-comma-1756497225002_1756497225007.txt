~/workspace$ pytуые -м
bash: pytуые: command not found
~/workspace$ pytуые -v
bash: pytуые: command not found
~/workspace$ pytest -v
============================ test session starts ============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 487 items                                                         

tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_hh_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_sj_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_keywords PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_location PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_experience PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_employment_type PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_company PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_complex_filter_chain PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_empty_filter_results PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_with_empty_data PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_invalid_data_structure PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_api_initialization PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_valid PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_invalid PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_page PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies PASSED [  3%]
tests/test_api_modules.py::TestSuperJobAPI::test_api_initialization PASSED [  3%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_valid PASSED [  3%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_invalid PASSED [  3%]
tests/test_api_modules.py::TestUnifiedAPI::test_get_available_sources PASSED [  4%]
tests/test_api_modules.py::TestUnifiedAPI::test_validate_sources PASSED [  4%]
tests/test_api_modules.py::TestUnifiedAPI::test_get_vacancies_from_sources PASSED [  4%]
tests/test_api_modules.py::TestUnifiedAPI::test_get_vacancies_from_source PASSED [  4%]
tests/test_api_modules.py::TestUnifiedAPI::test_clear_cache PASSED    [  4%]
tests/test_api_modules.py::TestBaseJobAPI::test_abstract_class PASSED [  5%]
tests/test_api_modules.py::TestBaseJobAPI::test_clear_cache_method PASSED [  5%]
tests/test_api_modules.py::TestAPIIntegration::test_end_to_end_workflow PASSED [  5%]
tests/test_api_modules.py::TestAPIIntegration::test_error_handling PASSED [  5%]
tests/test_base_api.py::TestBaseJobAPI::test_abstract_methods PASSED  [  5%]
tests/test_base_api.py::TestBaseJobAPI::test_concrete_implementation PASSED [  6%]
tests/test_base_api.py::TestBaseJobAPI::test_get_vacancies_implementation PASSED [  6%]
tests/test_base_api.py::TestBaseJobAPI::test_validate_vacancy_implementation PASSED [  6%]
tests/test_base_api.py::TestBaseJobAPI::test_clear_cache_method_exists PASSED [  6%]
tests/test_base_api.py::TestBaseJobAPI::test_clear_cache_creates_directory_if_not_exists PASSED [  6%]
tests/test_base_api.py::TestBaseJobAPI::test_clear_cache_error_handling PASSED [  7%]
tests/test_base_api.py::TestBaseJobAPI::test_inheritance_structure PASSED [  7%]
tests/test_base_api.py::TestBaseJobAPI::test_abstract_method_enforcement PASSED [  7%]
tests/test_base_api.py::TestBaseJobAPI::test_method_signatures PASSED [  7%]
tests/test_base_api.py::TestBaseJobAPIIntegration::test_multiple_implementations PASSED [  8%]
tests/test_base_api.py::TestBaseJobAPIIntegration::test_polymorphic_usage PASSED [  8%]
tests/test_base_api.py::TestBaseJobAPIIntegration::test_cache_operations_multiple_sources PASSED [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_base_formatter_is_abstract PASSED [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_concrete_formatter_implementation PASSED [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy_info PASSED [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy_info_no_number PASSED [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary PASSED [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency PASSED [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text PASSED [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_date PASSED [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_experience PASSED [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_employment_type PASSED [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_schedule PASSED [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name PASSED [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_tags PASSED [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_number PASSED [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_all_abstract_methods_implemented PASSED [ 11%]
tests/test_cache.py::TestFileCache::test_cache_initialization PASSED  [ 11%]
tests/test_cache.py::TestFileCache::test_generate_params_hash PASSED  [ 11%]
tests/test_cache.py::TestFileCache::test_generate_params_hash_different_params PASSED [ 12%]
tests/test_cache.py::TestFileCache::test_save_response PASSED         [ 12%]
tests/test_cache.py::TestFileCache::test_load_response_success PASSED [ 12%]
tests/test_cache.py::TestFileCache::test_load_response_nonexistent PASSED [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_source PASSED    [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_all PASSED       [ 13%]
tests/test_cache.py::TestFileCache::test_cache_with_complex_params PASSED [ 13%]
tests/test_cache.py::TestFileCache::test_cache_file_corrupted PASSED  [ 13%]
tests/test_cache.py::TestFileCache::test_is_valid_response PASSED     [ 13%]
tests/test_cache.py::TestFileCache::test_validate_cached_structure PASSED [ 13%]
tests/test_cached_api.py::TestCachedAPI::test_initialization PASSED   [ 14%]
tests/test_cached_api.py::TestCachedAPI::test_connect_to_api_with_cache PASSED [ 14%]
tests/test_cached_api.py::TestCachedAPI::test_connect_to_api_from_file_cache PASSED [ 14%]
tests/test_cached_api.py::TestCachedAPI::test_clear_cache PASSED      [ 14%]
tests/test_cached_api.py::TestCachedAPI::test_get_cache_status PASSED [ 14%]
tests/test_cached_api.py::TestCachedAPI::test_is_complete_response_valid PASSED [ 15%]
tests/test_cached_api.py::TestCachedAPI::test_is_complete_response_invalid PASSED [ 15%]
tests/test_cached_api.py::TestCachedAPI::test_validate_response_structure_valid PASSED [ 15%]
tests/test_cached_api.py::TestCachedAPI::test_validate_response_structure_invalid PASSED [ 15%]
tests/test_cached_api.py::TestCachedAPI::test_memory_cache_integration PASSED [ 16%]
tests/test_cached_api.py::TestCachedAPI::test_inherited_abstract_methods PASSED [ 16%]
tests/test_cached_api.py::TestCachedAPI::test_error_handling_in_cache_operations PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_default_initialization PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_get_storage_type PASSED     [ 16%]
tests/test_config.py::TestAppConfig::test_set_storage_type_valid PASSED [ 17%]
tests/test_config.py::TestAppConfig::test_set_storage_type_invalid PASSED [ 17%]
tests/test_config.py::TestAppConfig::test_get_db_config PASSED        [ 17%]
tests/test_config.py::TestAppConfig::test_db_config_from_env PASSED   [ 17%]
tests/test_config.py::TestDatabaseConfig::test_initialization_with_env PASSED [ 17%]
tests/test_config.py::TestDatabaseConfig::test_get_connection_params PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_get_dsn PASSED         [ 18%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_success PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_failure PASSED [ 18%]
tests/test_config.py::TestHHAPIConfig::test_get_headers PASSED        [ 18%]
tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url PASSED  [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_employers_url PASSED  [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_areas_url PASSED      [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_request_params PASSED [ 19%]
tests/test_config.py::TestSJAPIConfig::test_initialization PASSED     [ 19%]
tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key PASSED [ 20%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key PASSED [ 20%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key PASSED [ 20%]
tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url PASSED  [ 20%]
tests/test_config.py::TestSJAPIConfig::test_set_secret_key PASSED     [ 20%]
tests/test_config.py::TestSJAPIConfig::test_is_configured PASSED      [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_request_params PASSED [ 21%]
tests/test_console_interface.py::TestUserInterface::test_initialization PASSED [ 21%]
tests/test_console_interface.py::TestUserInterface::test_initialization_default_storage PASSED [ 21%]
tests/test_console_interface.py::TestUserInterface::test_show_menu PASSED [ 21%]
tests/test_console_interface.py::TestUserInterface::test_get_period_choice_default PASSED [ 22%]
tests/test_console_interface.py::TestUserInterface::test_get_period_choice_custom PASSED [ 22%]
tests/test_console_interface.py::TestUserInterface::test_get_period_choice_invalid_custom PASSED [ 22%]
tests/test_console_interface.py::TestUserInterface::test_get_period_choice_cancel PASSED [ 22%]
tests/test_console_interface.py::TestUserInterface::test_get_period_choice_keyboard_interrupt PASSED [ 22%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_all PASSED [ 23%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_single PASSED [ 23%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_quit PASSED [ 23%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_range PASSED [ 23%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_invalid_range PASSED [ 24%]
tests/test_console_interface.py::TestUserInterface::test_show_vacancies_for_deletion_pagination PASSED [ 24%]
tests/test_console_interface.py::TestUserInterface::test_display_vacancies_static_method PASSED [ 24%]
tests/test_console_interface.py::TestUserInterface::test_display_vacancies_with_pagination_static_method PASSED [ 24%]
tests/test_console_interface.py::TestUserInterface::test_run_keyboard_interrupt PASSED [ 24%]
tests/test_console_interface.py::TestUserInterface::test_run_exception_handling PASSED [ 25%]
tests/test_console_interface.py::TestUserInterface::test_run_method_exists PASSED [ 25%]
tests/test_console_interface.py::TestUserInterface::test_advanced_search_vacancies PASSED [ 25%]
tests/test_console_interface.py::TestUserInterface::test_advanced_search_vacancies_empty_query PASSED [ 25%]
tests/test_console_interface.py::TestUserInterface::test_filter_saved_vacancies_by_salary_min PASSED [ 25%]
tests/test_console_interface.py::TestUserInterface::test_filter_saved_vacancies_by_salary_invalid_input PASSED [ 26%]
tests/test_console_interface.py::TestUserInterface::test_interface_components_integration PASSED [ 26%]
tests/test_console_interface.py::TestUserInterface::test_error_handling_in_methods PASSED [ 26%]
tests/test_console_interface.py::TestUserInterface::test_menu_choices_coverage PASSED [ 26%]
tests/test_console_interface.py::TestUserInterface::test_initialization_with_mocks PASSED [ 26%]
tests/test_console_interface.py::TestUserInterface::test_storage_integration PASSED [ 27%]
tests/test_console_interface.py::TestUserInterface::test_db_manager_integration PASSED [ 27%]
tests/test_console_interface.py::TestUserInterface::test_operations_coordinator_methods PASSED [ 27%]
tests/test_console_interface.py::TestUserInterface::test_demo_db_manager PASSED [ 27%]
tests/test_console_interface.py::TestUserInterface::test_setup_superjob_api PASSED [ 27%]
tests/test_console_interface.py::TestUserInterface::test_run_normal_exit PASSED [ 28%]
tests/test_console_interface.py::TestUserInterface::test_all_public_methods_exist PASSED [ 28%]
tests/test_console_interface.py::TestUserInterface::test_all_private_methods_exist PASSED [ 28%]
tests/test_console_interface.py::TestUserInterface::test_static_methods_exist PASSED [ 28%]
tests/test_db_manager.py::TestDBManager::test_initialization PASSED   [ 28%]
tests/test_db_manager.py::TestDBManager::test_initialization_with_custom_config PASSED [ 29%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success PASSED [ 29%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [ 29%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED [ 29%]
tests/test_db_manager.py::TestDBManager::test_create_tables PASSED    [ 29%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_empty_table PASSED [ 30%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_already_populated PASSED [ 30%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_no_table PASSED [ 30%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count PASSED [ 30%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count_no_connection PASSED [ 31%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies PASSED [ 31%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies_no_tables PASSED [ 31%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED   [ 31%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED [ 31%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_tables PASSED [ 32%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary PASSED [ 32%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary_no_avg PASSED [ 32%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword PASSED [ 32%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 32%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_no_tables PASSED [ 33%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats PASSED [ 33%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats_error PASSED [ 33%]
tests/test_db_manager.py::TestDBManager::test_get_target_companies_analysis PASSED [ 33%]
tests/test_db_manager.py::TestDBManager::test_get_target_companies_analysis_no_data PASSED [ 33%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets PASSED [ 34%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets_empty_input PASSED [ 34%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets_sql_error PASSED [ 34%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_vacancy_stats PASSED [ 34%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_salary_analysis PASSED [ 34%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_empty_data PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_error PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_ensure_tables_exist_success PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_ensure_tables_exist_failure PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_error_handling_in_methods PASSED [ 36%]
tests/test_db_manager.py::TestDBManager::test_connection_error_handling PASSED [ 36%]
tests/test_db_manager.py::TestDBManager::test_sql_injection_protection PASSED [ 36%]
tests/test_db_manager.py::TestDBManager::test_unicode_handling PASSED [ 36%]
tests/test_db_manager.py::TestDBManager::test_context_manager_usage PASSED [ 36%]
tests/test_db_manager.py::TestDBManager::test_large_dataset_handling PASSED [ 37%]
tests/test_db_manager.py::TestDBManager::test_edge_cases_and_boundary_conditions PASSED [ 37%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_initialization PASSED [ 37%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_run_full_demo PASSED [ 37%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_get_db_manager_creation PASSED [ 37%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_display_database_stats PASSED [ 38%]
tests/test_decorators.py::test_basic_decorator PASSED                 [ 38%]
tests/test_decorators.py::test_timing_decorator PASSED                [ 38%]
tests/test_decorators.py::test_error_handling_decorator PASSED        [ 38%]
tests/test_decorators.py::test_validation_decorator PASSED            [ 39%]
tests/test_decorators.py::TestDecoratorBehavior::test_decorator_preserves_function_name PASSED [ 39%]
tests/test_decorators.py::TestDecoratorBehavior::test_decorator_with_arguments PASSED [ 39%]
tests/test_decorators.py::TestDecoratorBehavior::test_retry_decorator PASSED [ 39%]
tests/test_decorators.py::TestDecoratorBehavior::test_retry_decorator_fails_after_attempts PASSED [ 39%]
tests/test_decorators.py::TestDecoratorBehavior::test_cache_result_decorator PASSED [ 40%]
tests/test_decorators.py::TestDecoratorBehavior::test_cache_result_decorator_with_different_args PASSED [ 40%]
tests/test_env_loader.py::TestEnvLoader::test_get_env_var_from_os_environ PASSED [ 40%]
tests/test_env_loader.py::TestEnvLoader::test_get_env_var_with_default PASSED [ 40%]
tests/test_env_loader.py::TestEnvLoader::test_get_env_var_from_cache PASSED [ 40%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_success PASSED [ 41%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_not_exists PASSED [ 41%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_exception PASSED [ 41%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_ignore_comments PASSED [ 41%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_ignore_empty_lines PASSED [ 41%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_file_ignore_malformed_lines PASSED [ 42%]
tests/test_env_loader.py::TestEnvLoader::test_set_env_var PASSED      [ 42%]
tests/test_env_loader.py::TestEnvLoader::test_clear_cache PASSED      [ 42%]
tests/test_env_loader.py::TestEnvLoader::test_cache_priority_over_os_environ PASSED [ 42%]
tests/test_env_loader.py::TestEnvLoader::test_load_from_custom_file_path PASSED [ 42%]
tests/test_env_loader.py::TestEnvLoader::test_set_environment_variable PASSED [ 43%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable PASSED [ 43%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable_with_default PASSED [ 43%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_success PASSED [ 43%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_missing PASSED [ 43%]
tests/test_env_loader.py::TestEnvLoader::test_load_environment_variables PASSED [ 44%]
tests/test_env_loader.py::TestEnvLoader::test_reset_environment_variables PASSED [ 44%]
tests/test_env_loader.py::TestEnvLoaderIntegration::test_load_and_get_vars PASSED [ 44%]
tests/test_env_loader.py::TestEnvLoaderIntegration::test_load_multiple_times PASSED [ 44%]
tests/test_env_loader.py::TestEnvLoaderIntegration::test_env_var_override_by_cache PASSED [ 44%]
tests/test_env_loader.py::TestEnvLoaderIntegration::test_load_from_file_with_spaces_in_keys_and_values PASSED [ 45%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_json_data PASSED [ 45%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_json_data PASSED [ 45%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_nonexistent_json_file PASSED [ 45%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_empty_json_file PASSED [ 45%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_invalid_json_file PASSED [ 46%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_creates_directory PASSED [ 46%]
tests/test_file_handlers.py::TestJSONFileHandler::test_atomic_write_on_error PASSED [ 46%]
tests/test_file_handlers.py::TestJSONFileHandler::test_cache_clearing_on_write PASSED [ 46%]
tests/test_file_handlers.py::TestJSONFileHandler::test_global_json_handler_instance PASSED [ 47%]
tests/test_file_handlers.py::TestJSONFileHandler::test_caching_behavior PASSED [ 47%]
tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration FAILED [ 47%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_integration PASSED [ 47%]
tests/test_integration.py::TestAPIIntegration::test_superjob_api_integration PASSED [ 47%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow PASSED [ 48%]
tests/test_integration.py::TestCacheIntegration::test_cache_integration PASSED [ 48%]
tests/test_integration.py::TestErrorHandlingIntegration::test_api_error_handling PASSED [ 48%]
tests/test_integration.py::TestErrorHandlingIntegration::test_database_error_handling PASSED [ 48%]
tests/test_integration.py::TestFormatterIntegration::test_vacancy_formatter_integration PASSED [ 48%]
tests/test_integration.py::TestFormatterIntegration::test_brief_formatter_integration PASSED [ 49%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_filters PASSED [ 49%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_search PASSED [ 49%]
tests/test_main_functionality.py::TestMainFunctionality::test_vacancy_creation PASSED [ 49%]
tests/test_main_functionality.py::TestMainFunctionality::test_vacancy_operations PASSED [ 49%]
tests/test_main_functionality.py::TestMainFunctionality::test_vacancy_formatter PASSED [ 50%]
tests/test_main_functionality.py::TestMainFunctionality::test_user_input_simulation PASSED [ 50%]
tests/test_main_functionality.py::TestMainFunctionality::test_vacancy_comparison PASSED [ 50%]
tests/test_main_functionality.py::TestMainFunctionality::test_error_handling PASSED [ 50%]
tests/test_main_functionality.py::TestMainFunctionality::test_data_validation FAILED [ 50%]
tests/test_main_functionality.py::TestMainFunctionality::test_search_functionality PASSED [ 51%]
tests/test_main_functionality.py::TestMainFunctionality::test_storage_mocking PASSED [ 51%]
tests/test_main_functionality.py::TestMainFunctionality::test_configuration_defaults PASSED [ 51%]
tests/test_menu_manager.py::TestMenuManager::test_menu_manager_initialization PASSED [ 51%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_valid FAILED [ 51%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_invalid_then_valid FAILED [ 52%]
tests/test_menu_manager.py::TestMenuManager::test_display_menu_items FAILED [ 52%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_exit FAILED [ 52%]
tests/test_paginator.py::TestPaginator::test_paginator_initialization FAILED [ 52%]
tests/test_paginator.py::TestPaginator::test_get_current_page_data FAILED [ 52%]
tests/test_paginator.py::TestPaginator::test_next_page FAILED         [ 53%]
tests/test_paginator.py::TestPaginator::test_next_page_at_end FAILED  [ 53%]
tests/test_paginator.py::TestPaginator::test_previous_page FAILED     [ 53%]
tests/test_paginator.py::TestPaginator::test_previous_page_at_start FAILED [ 53%]
tests/test_paginator.py::TestPaginator::test_go_to_page_valid FAILED  [ 54%]
tests/test_paginator.py::TestPaginator::test_go_to_page_invalid FAILED [ 54%]
tests/test_paginator.py::TestPaginator::test_empty_data FAILED        [ 54%]
tests/test_paginator.py::TestPaginator::test_single_page_data FAILED  [ 54%]
tests/test_paginator.py::TestPaginator::test_page_info FAILED         [ 54%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_full_data PASSED [ 55%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_minimal_data PASSED [ 55%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_no_salary PASSED [ 55%]
tests/test_parsers.py::TestHHParser::test_parse_company_data FAILED   [ 55%]
tests/test_parsers.py::TestHHParser::test_parse_companies_list FAILED [ 55%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_full_data PASSED [ 56%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_minimal_data PASSED [ 56%]
tests/test_parsers.py::TestSuperJobParser::test_parse_companies_list FAILED [ 56%]
tests/test_postgres_saver.py::TestPostgresSaver::test_initialization PASSED [ 56%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_success FAILED [ 56%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_empty_list FAILED [ 57%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_database_error FAILED [ 57%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_all_vacancies FAILED [ 57%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_count FAILED [ 57%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success FAILED [ 57%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found FAILED [ 58%]
tests/test_postgres_saver.py::TestPostgresSaver::test_filter_vacancies_by_salary FAILED [ 58%]
tests/test_postgres_saver.py::TestPostgresSaver::test_search_vacancies_by_keyword FAILED [ 58%]
tests/test_salary.py::TestSalary::test_salary_initialization_with_range FAILED [ 58%]
tests/test_salary.py::TestSalary::test_salary_initialization_from_only FAILED [ 58%]
tests/test_salary.py::TestSalary::test_salary_initialization_to_only FAILED [ 59%]
tests/test_salary.py::TestSalary::test_salary_initialization_none_values FAILED [ 59%]
tests/test_salary.py::TestSalary::test_salary_from_dict_complete FAILED [ 59%]
tests/test_salary.py::TestSalary::test_salary_from_dict_partial FAILED [ 59%]
tests/test_salary.py::TestSalary::test_salary_from_dict_none FAILED   [ 59%]
tests/test_salary.py::TestSalary::test_salary_from_dict_empty FAILED  [ 60%]
tests/test_salary.py::TestSalary::test_salary_to_dict FAILED          [ 60%]
tests/test_salary.py::TestSalary::test_salary_to_dict_partial FAILED  [ 60%]
tests/test_salary.py::TestSalary::test_salary_average_with_both_values FAILED [ 60%]
tests/test_salary.py::TestSalary::test_salary_average_from_only FAILED [ 60%]
tests/test_salary.py::TestSalary::test_salary_average_to_only FAILED  [ 61%]
tests/test_salary.py::TestSalary::test_salary_average_none_values FAILED [ 61%]
tests/test_salary.py::TestSalary::test_salary_comparison_greater FAILED [ 61%]
tests/test_salary.py::TestSalary::test_salary_comparison_less FAILED  [ 61%]
tests/test_salary.py::TestSalary::test_salary_comparison_equal FAILED [ 62%]
tests/test_salary.py::TestSalary::test_salary_comparison_with_none FAILED [ 62%]
tests/test_salary.py::TestSalary::test_salary_string_representation_full FAILED [ 62%]
tests/test_salary.py::TestSalary::test_salary_string_representation_from_only FAILED [ 62%]
tests/test_salary.py::TestSalary::test_salary_string_representation_none FAILED [ 62%]
tests/test_salary.py::TestSalary::test_salary_is_specified FAILED     [ 63%]
tests/test_salary.py::TestSalary::test_salary_currency_conversion FAILED [ 63%]
tests/test_search_utils.py::TestSearchUtils::test_normalize_query FAILED [ 63%]
tests/test_search_utils.py::TestSearchUtils::test_extract_keywords PASSED [ 63%]
tests/test_search_utils.py::TestSearchUtils::test_build_search_params FAILED [ 63%]
tests/test_search_utils.py::TestSearchUtils::test_validate_search_query PASSED [ 64%]
tests/test_search_utils.py::TestSearchUtils::test_format_search_results PASSED [ 64%]
tests/test_search_utils.py::TestSearchUtils::test_search_query_filtering PASSED [ 64%]
tests/test_search_utils.py::TestSearchUtils::test_keyword_extraction_with_operators PASSED [ 64%]
tests/test_search_utils.py::TestSearchUtils::test_empty_search_handling FAILED [ 64%]
tests/test_search_utils.py::TestSearchUtils::test_special_characters_handling PASSED [ 65%]
tests/test_search_utils.py::TestSearchUtils::test_language_detection PASSED [ 65%]
tests/test_search_utils.py::TestSearchUtils::test_search_params_validation FAILED [ 65%]
tests/test_search_utils.py::TestSearchUtils::test_query_normalization_edge_cases PASSED [ 65%]
tests/test_search_utils.py::TestSearchUtils::test_advanced_search_combinations FAILED [ 65%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword PASSED [ 66%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword PASSED [ 66%]
tests/test_source_manager.py::TestSourceManager::test_source_manager_initialization PASSED [ 66%]
tests/test_source_manager.py::TestSourceManager::test_register_and_activate_source FAILED [ 66%]
tests/test_source_manager.py::TestSourceManager::test_deactivate_source FAILED [ 66%]
tests/test_source_manager.py::TestSourceManager::test_get_vacancies_from_all_sources PASSED [ 67%]
tests/test_source_manager.py::TestSourceManager::test_get_vacancies_from_source FAILED [ 67%]
tests/test_source_manager.py::TestSourceManager::test_get_source_stats FAILED [ 67%]
tests/test_source_manager.py::TestSourceManager::test_clear_active_sources FAILED [ 67%]
tests/test_source_manager.py::TestSourceManager::test_get_vacancies_with_error_handling PASSED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_source_selector_initialization FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_single FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_all FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_exit PASSED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_invalid_then_valid FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_display_sources_info PASSED [ 69%]
tests/test_source_selector.py::TestSourceSelector::test_get_available_sources FAILED [ 69%]
tests/test_source_selector.py::TestSourceSelector::test_validate_source_choice FAILED [ 69%]
tests/test_source_selector.py::TestSourceSelector::test_get_source_name_by_choice FAILED [ 69%]
tests/test_source_selector.py::TestSourceSelector::test_is_source_available FAILED [ 70%]
tests/test_source_selector.py::TestSourceSelector::test_display_source_menu FAILED [ 70%]
tests/test_storage.py::TestPostgresSaver::test_initialization FAILED  [ 70%]
tests/test_storage.py::TestPostgresSaver::test_add_vacancy FAILED     [ 70%]
tests/test_storage.py::TestPostgresSaver::test_get_vacancies FAILED   [ 70%]
tests/test_storage.py::TestPostgresSaver::test_delete_vacancy_by_id FAILED [ 71%]
tests/test_storage.py::TestPostgresSaver::test_get_vacancies_count FAILED [ 71%]
tests/test_storage.py::TestStorageFactory::test_create_postgres_storage PASSED [ 71%]
tests/test_storage.py::TestStorageFactory::test_get_default_storage PASSED [ 71%]
tests/test_storage.py::TestStorageFactory::test_invalid_storage_type PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_confirm_action_yes PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_confirm_action_no PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_confirm_action_default FAILED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_user_input PASSED   [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_user_input_empty ^C

================================= FAILURES ==================================
__________ TestStorageIntegration.test_postgres_saver_integration ___________

self = <tests.test_integration.TestStorageIntegration object at 0x7f59fcd7ee50>
mock_connect = <MagicMock name='connect' id='140024392425232'>
mock_execute_values = <MagicMock name='execute_values' id='140024392431312'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f59fa4a4050>

    @patch("psycopg2.extras.execute_values")
    @patch("psycopg2.connect")
    def test_postgres_saver_integration(self, mock_connect, mock_execute_values, sample_vacancy):
        """Тест интеграции с PostgreSQL"""
        # Настраиваем мок подключения
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_cursor.fetchall.return_value = []
    
        # Настраиваем кодировку для psycopg2
        mock_conn.encoding = "UTF8"
        mock_cursor.connection = mock_conn
    
        # Настраиваем context manager для подключения
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
    
        # Настраиваем context manager для курсора
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_conn.cursor.return_value = mock_cursor_context
    
        # Исправляем мок для field_info - возвращаем правильную структуру
        mock_responses = [
            (0,),  # для check database exists
        ]
        # Добавляем ответы для каждого поля в required_fields (около 20 полей)
        for _ in range(25):
            mock_responses.extend([
                ("column_name", "integer"),
                ("column_name", "text"),
                ("column_name", "varchar"),
                ("column_name", "timestamp"),
            ])
    
        # Добавляем правильный ответ для get_vacancies_count - число вместо строки
        mock_responses.append((42,))  # COUNT(*) возвращает число
    
        mock_cursor.fetchone.side_effect = mock_responses
        mock_connect.return_value = mock_conn
    
        # Настраиваем мок для execute_values
        mock_execute_values.return_value = None
    
        # Создаем хранилище и тестируем операции
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_integration.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f82874d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
________________ TestMainFunctionality.test_data_validation _________________

self = <tests.test_main_functionality.TestMainFunctionality object at 0x7f59fcd71e50>

    def test_data_validation(self):
        """Тест валидации данных"""
        # Тест создания вакансии с минимальными данными
        minimal_vacancy = Vacancy(
            title="Minimal Job", url="https://example.com/job", vacancy_id="min001", source="test"
        )
    
        assert minimal_vacancy.title == "Minimal Job"
>       assert minimal_vacancy.salary is None
E       assert <src.utils.salary.Salary object at 0x7f59f3f56920> is None
E        +  where <src.utils.salary.Salary object at 0x7f59f3f56920> = <src.vacancies.models.Vacancy object at 0x7f59f3f28fc0>.salary

tests/test_main_functionality.py:125: AssertionError
________________ TestMenuManager.test_get_user_choice_valid _________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f59fd178ad0>
mock_input = <MagicMock name='input' id='140024391610192'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f59f81f2a10>

    @patch("builtins.input", return_value="1")
    def test_get_user_choice_valid(self, mock_input, menu_manager):
        """Тест получения корректного выбора пользователя"""
        menu_items = ["Item 1", "Item 2", "Exit"]
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:29: AttributeError
__________ TestMenuManager.test_get_user_choice_invalid_then_valid __________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f59fd1781d0>
mock_print = <MagicMock name='print' id='140024321933904'>
mock_input = <MagicMock name='input' id='140024322118288'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f59f3f83610>

    @patch("builtins.input", side_effect=["invalid", "2"])
    @patch("builtins.print")
    def test_get_user_choice_invalid_then_valid(self, mock_print, mock_input, menu_manager):
        """Тест обработки некорректного, а затем корректного выбора"""
        menu_items = ["Item 1", "Item 2"]
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:37: AttributeError
__________________ TestMenuManager.test_display_menu_items __________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f59fd17a590>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f59f3f9e890>

    def test_display_menu_items(self, menu_manager):
        """Тест отображения элементов меню"""
        menu_items = ["Search", "View", "Exit"]
        with patch("builtins.print") as mock_print:
>           menu_manager.display_menu(menu_items)
E           TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:44: TypeError
_________________ TestMenuManager.test_get_user_choice_exit _________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f59fd1794d0>
mock_input = <MagicMock name='input' id='140024322312656'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f59f3fdc490>

    @patch("builtins.input", return_value="0")
    def test_get_user_choice_exit(self, mock_input, menu_manager):
        """Тест выбора выхода из меню"""
        menu_items = ["Item 1", "Exit"]
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:52: AttributeError
________________ TestPaginator.test_paginator_initialization ________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd179050>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_paginator_initialization(self, sample_data):
        """Тест инициализации пагинатора"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:20: TypeError
_________________ TestPaginator.test_get_current_page_data __________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd17b110>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_get_current_page_data(self, sample_data):
        """Тест получения данных текущей страницы"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:28: TypeError
_______________________ TestPaginator.test_next_page ________________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd17b550>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page(self, sample_data):
        """Тест перехода к следующей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:35: TypeError
____________________ TestPaginator.test_next_page_at_end ____________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd17a9d0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page_at_end(self, sample_data):
        """Тест перехода к следующей странице на последней странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:43: TypeError
_____________________ TestPaginator.test_previous_page ______________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd17bb10>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page(self, sample_data):
        """Тест перехода к предыдущей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:50: TypeError
_________________ TestPaginator.test_previous_page_at_start _________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd17aa90>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page_at_start(self, sample_data):
        """Тест перехода к предыдущей странице на первой странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:57: TypeError
____________________ TestPaginator.test_go_to_page_valid ____________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fcd72fd0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_valid(self, sample_data):
        """Тест перехода к корректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:63: TypeError
___________________ TestPaginator.test_go_to_page_invalid ___________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fcd6a190>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_invalid(self, sample_data):
        """Тест перехода к некорректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:69: TypeError
_______________________ TestPaginator.test_empty_data _______________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd15b0d0>

    def test_empty_data(self):
        """Тест пагинации с пустыми данными"""
>       paginator = Paginator([], page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:75: TypeError
____________________ TestPaginator.test_single_page_data ____________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd15aa50>

    def test_single_page_data(self):
        """Тест пагинации с данными на одну страницу"""
        data = [1, 2, 3]
>       paginator = Paginator(data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:83: TypeError
_______________________ TestPaginator.test_page_info ________________________

self = <tests.test_paginator.TestPaginator object at 0x7f59fd159e10>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_page_info(self, sample_data):
        """Тест получения информации о странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:89: TypeError
___________________ TestHHParser.test_parse_company_data ____________________

self = <tests.test_parsers.TestHHParser object at 0x7f59fcd53ad0>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f59f3ffcd10>

    def test_parse_company_data(self, hh_parser):
        """Тест парсинга данных компании"""
        company_data = {
            "id": "123",
            "name": "TestCompany",
            "description": "Test Description",
            "alternate_url": "https://hh.ru/employer/123",
        }
    
>       result = hh_parser.parse_company(company_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_company'

tests/test_parsers.py:81: AttributeError
__________________ TestHHParser.test_parse_companies_list ___________________

self = <tests.test_parsers.TestHHParser object at 0x7f59fcd504d0>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f59f3fafc10>

    def test_parse_companies_list(self, hh_parser):
        """Тест парсинга списка компаний"""
        companies_data = {"items": [{"id": "1", "name": "Company1"}, {"id": "2", "name": "Company2"}]}
    
>       result = hh_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_companies'

tests/test_parsers.py:91: AttributeError
_______________ TestSuperJobParser.test_parse_companies_list ________________

self = <tests.test_parsers.TestSuperJobParser object at 0x7f59fcd51d90>
sj_parser = <src.vacancies.parsers.sj_parser.SuperJobParser object at 0x7f59f3fa4690>

    def test_parse_companies_list(self, sj_parser):
        """Тест парсинга списка компаний SJ"""
        companies_data = {"objects": [{"id": 101, "title": "SJ Company1"}, {"id": 102, "title": "SJ Company2"}]}
    
>       result = sj_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobParser' object has no attribute 'parse_companies'

tests/test_parsers.py:154: AttributeError
_______________ TestPostgresSaver.test_save_vacancies_success _______________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd46e50>
mock_connect = <MagicMock name='connect' id='140024322061968'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59fcd7df10>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancies_success(self, mock_connect, postgres_saver):
        """Тест успешного сохранения вакансий"""
        # Мокаем подключение
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Создаем тестовые вакансии
        vacancies = [
>           Vacancy(
                vacancy_id="1",
                title="Python Developer",
                url="https://test.com/1",
                salary_from=100000,
                salary_to=150000,
                salary_currency="RUR",
                description="Test description",
                requirements="Python",
                responsibilities="Development",
                experience="1-3 года",
                employment="Полная занятость",
                schedule="Полный день",
                employer="TechCorp",
                area="Москва",
                source="hh.ru",
                published_at="2024-01-15T10:30:00+0300",
                company_id="123",
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'salary_from'

tests/test_postgres_saver.py:51: TypeError
_____________ TestPostgresSaver.test_save_vacancies_empty_list ______________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd47c10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3d03010>

    def test_save_vacancies_empty_list(self, postgres_saver):
        """Тест сохранения пустого списка"""
        result = postgres_saver.save_vacancies([])
>       assert result is True
E       assert 0 is True

tests/test_postgres_saver.py:84: AssertionError
___________ TestPostgresSaver.test_save_vacancies_database_error ____________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd44250>
mock_connect = <MagicMock name='connect' id='140024321897360'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3facf90>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancies_database_error(self, mock_connect, postgres_saver):
        """Тест ошибки базы данных при сохранении"""
        mock_connect.side_effect = psycopg2.Error("Database error")
        postgres_saver.db_manager._get_connection = Mock(side_effect=psycopg2.Error("Database error"))
    
        vacancies = [Mock(spec=Vacancy)]
>       result = postgres_saver.save_vacancies(vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:730: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:395: in add_vacancy_batch_optimized
    connection = self._get_connection()
                 ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='connect' id='140024321897360'>, args = ()
kwargs = {'client_encoding': 'utf8', 'database': 'neondb', 'host': 'ep-spring-art-adtv9zhn.c-2.us-east-1.aws.neon.tech', 'password': 'npg_pGNMaSd2ukl9', ...}
effect = Error('Database error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               psycopg2.Error: Database error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Error
--------------------------- Captured stderr call ----------------------------
ERROR:src.storage.postgres_saver:Ошибка подключения к БД neondb: Database error
----------------------------- Captured log call -----------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД neondb: Database error
_________________ TestPostgresSaver.test_get_all_vacancies __________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd444d0>
mock_connect = <MagicMock name='connect' id='140024322167056'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f18910>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_all_vacancies(self, mock_connect, postgres_saver):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            (
                "1",
                "Python Developer",
                "https://test.com/1",
                100000,
                150000,
                "RUR",
                "Test description",
                "Python",
                "Development",
                "1-3 года",
                "Полная занятость",
                "Полный день",
                "TechCorp",
                "Москва",
                "hh.ru",
                "2024-01-15T10:30:00+0300",
                "123",
            )
        ]
    
        postgres_saver.db_manager._get_connection = Mock(return_value=mock_connection)
    
>       result = postgres_saver.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_all_vacancies'

tests/test_postgres_saver.py:135: AttributeError
________________ TestPostgresSaver.test_get_vacancies_count _________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd44910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f7da50>

    def test_get_vacancies_count(self, postgres_saver):
        """Тест подсчета вакансий через DBManager"""
        postgres_saver.db_manager.get_companies_and_vacancies_count.return_value = [("Company1", 5), ("Company2", 3)]
    
>       result = postgres_saver.get_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f7da50>
filters = None

    def get_vacancies_count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Возвращает количество вакансий с учетом фильтров
    
        Args:
            filters: Словарь с фильтрами
    
        Returns:
            int: Количество вакансий
        """
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            query = "SELECT COUNT(*) FROM vacancies v LEFT JOIN companies c ON v.company_id = c.id"
            params = []
            where_conditions = []
    
            # Добавляем фильтры
            if filters:
                if filters.get("title"):
                    where_conditions.append("LOWER(title) LIKE LOWER(%s)")
                    params.append(f"%{filters['title']}%")
    
                if filters.get("salary_from"):
                    where_conditions.append("salary_from >= %s")
                    params.append(filters["salary_from"])
    
                if filters.get("salary_to"):
                    where_conditions.append("salary_to <= %s")
                    params.append(filters["salary_to"])
    
                if filters.get("employer"):  # Filter by company name from joined table
                    standardized_employer = self._standardize_employer_name(filters["employer"])
                    if standardized_employer:
                        where_conditions.append("LOWER(c.name) LIKE LOWER(%s)")
                        params.append(f"%{standardized_employer}%")
    
                # Filter by company name directly
                if filters.get("company_name"):
                    where_conditions.append("LOWER(company_name) LIKE LOWER(%s)")
                    params.append(f"%{filters['company_name']}%")
    
            if where_conditions:
                query += " WHERE " + " AND ".join(where_conditions)
    
            cursor.execute(query, params)
>           return cursor.fetchone()[0]
                   ^^^^^^^^^^^^^^^^^^^^
E           TypeError: 'NoneType' object is not subscriptable

src/storage/postgres_saver.py:1294: TypeError
____________ TestPostgresSaver.test_delete_vacancy_by_id_success ____________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd44b90>
mock_connect = <MagicMock name='connect' id='140024392622608'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f02910>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_success(self, mock_connect, postgres_saver):
        """Тест успешного удаления вакансии"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        mock_cursor.rowcount = 1  # Удалена 1 строка
    
        postgres_saver.db_manager._get_connection = Mock(return_value=mock_connection)
    
>       result = postgres_saver.delete_vacancy_by_id("123")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f02910>
vacancy_id = '123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1066: TypeError
___________ TestPostgresSaver.test_delete_vacancy_by_id_not_found ___________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd45a50>
mock_connect = <MagicMock name='connect' id='140024319810192'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3ffa410>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_not_found(self, mock_connect, postgres_saver):
        """Тест удаления несуществующей вакансии"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        mock_cursor.rowcount = 0  # Не удалено ни одной строки
    
        postgres_saver.db_manager._get_connection = Mock(return_value=mock_connection)
    
>       result = postgres_saver.delete_vacancy_by_id("nonexistent")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3ffa410>
vacancy_id = 'nonexistent'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1066: TypeError
_____________ TestPostgresSaver.test_filter_vacancies_by_salary _____________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd45d10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f82a2950>

    def test_filter_vacancies_by_salary(self, postgres_saver):
        """Тест фильтрации вакансий по зарплате через DBManager"""
        mock_vacancies = [Mock(spec=Vacancy, salary_from=100000), Mock(spec=Vacancy, salary_from=200000)]
    
        postgres_saver.db_manager.get_vacancies_with_higher_salary.return_value = mock_vacancies
    
>       result = postgres_saver.filter_vacancies_by_salary(150000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_vacancies_by_salary'

tests/test_postgres_saver.py:199: AttributeError
____________ TestPostgresSaver.test_search_vacancies_by_keyword _____________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f59fcd460d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f8112410>

    def test_search_vacancies_by_keyword(self, postgres_saver):
        """Тест поиска вакансий по ключевому слову через DBManager"""
        mock_vacancies = [Mock(spec=Vacancy, title="Python Developer")]
    
        postgres_saver.db_manager.get_vacancies_with_keyword.return_value = mock_vacancies
    
>       result = postgres_saver.search_vacancies_by_keyword("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver.py:210: AttributeError
_____________ TestSalary.test_salary_initialization_with_range ______________

self = <tests.test_salary.TestSalary object at 0x7f59fcd38910>

    def test_salary_initialization_with_range(self):
        """Тест инициализации зарплаты с диапазоном"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:15: TypeError
______________ TestSalary.test_salary_initialization_from_only ______________

self = <tests.test_salary.TestSalary object at 0x7f59fcd396d0>

    def test_salary_initialization_from_only(self):
        """Тест инициализации зарплаты только с минимумом"""
>       salary = Salary(80000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:22: TypeError
_______________ TestSalary.test_salary_initialization_to_only _______________

self = <tests.test_salary.TestSalary object at 0x7f59fcd39990>

    def test_salary_initialization_to_only(self):
        """Тест инициализации зарплаты только с максимумом"""
>       salary = Salary(salary_to=200000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:29: TypeError
_____________ TestSalary.test_salary_initialization_none_values _____________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3ac90>

    def test_salary_initialization_none_values(self):
        """Тест инициализации зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:36: TypeError
_________________ TestSalary.test_salary_from_dict_complete _________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3a610>

    def test_salary_from_dict_complete(self):
        """Тест создания зарплаты из полного словаря"""
        salary_dict = {"from": 100000, "to": 150000, "currency": "RUR"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:44: AttributeError
_________________ TestSalary.test_salary_from_dict_partial __________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3ad90>

    def test_salary_from_dict_partial(self):
        """Тест создания зарплаты из частичного словаря"""
        salary_dict = {"from": 80000, "currency": "USD"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:52: AttributeError
___________________ TestSalary.test_salary_from_dict_none ___________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3bf10>

    def test_salary_from_dict_none(self):
        """Тест создания зарплаты из None"""
>       salary = Salary.from_dict(None)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:59: AttributeError
__________________ TestSalary.test_salary_from_dict_empty ___________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3b710>

    def test_salary_from_dict_empty(self):
        """Тест создания зарплаты из пустого словаря"""
>       salary = Salary.from_dict({})
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:66: AttributeError
______________________ TestSalary.test_salary_to_dict _______________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd38210>

    def test_salary_to_dict(self):
        """Тест преобразования зарплаты в словарь"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:73: TypeError
__________________ TestSalary.test_salary_to_dict_partial ___________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd10090>

    def test_salary_to_dict_partial(self):
        """Тест преобразования частичной зарплаты в словарь"""
>       salary = Salary(80000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:81: TypeError
______________ TestSalary.test_salary_average_with_both_values ______________

self = <tests.test_salary.TestSalary object at 0x7f59fcd3b910>

    def test_salary_average_with_both_values(self):
        """Тест расчета средней зарплаты при наличии обоих значений"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:89: TypeError
_________________ TestSalary.test_salary_average_from_only __________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd39e10>

    def test_salary_average_from_only(self):
        """Тест расчета средней зарплаты при наличии только минимума"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:94: TypeError
__________________ TestSalary.test_salary_average_to_only ___________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd44ed0>

    def test_salary_average_to_only(self):
        """Тест расчета средней зарплаты при наличии только максимума"""
>       salary = Salary(salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:99: TypeError
________________ TestSalary.test_salary_average_none_values _________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd10110>

    def test_salary_average_none_values(self):
        """Тест расчета средней зарплаты при отсутствии значений"""
>       salary = Salary(None, None, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:104: TypeError
_________________ TestSalary.test_salary_comparison_greater _________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd10510>

    def test_salary_comparison_greater(self):
        """Тест сравнения зарплат - больше"""
>       salary1 = Salary(150000, 200000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:109: TypeError
__________________ TestSalary.test_salary_comparison_less ___________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd10e50>

    def test_salary_comparison_less(self):
        """Тест сравнения зарплат - меньше"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:115: TypeError
__________________ TestSalary.test_salary_comparison_equal __________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd102d0>

    def test_salary_comparison_equal(self):
        """Тест сравнения зарплат - равно"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:121: TypeError
________________ TestSalary.test_salary_comparison_with_none ________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd10a50>

    def test_salary_comparison_with_none(self):
        """Тест сравнения зарплат с None значениями"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:127: TypeError
_____________ TestSalary.test_salary_string_representation_full _____________

self = <tests.test_salary.TestSalary object at 0x7f59fcd126d0>

    def test_salary_string_representation_full(self):
        """Тест строкового представления полной зарплаты"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:135: TypeError
__________ TestSalary.test_salary_string_representation_from_only ___________

self = <tests.test_salary.TestSalary object at 0x7f59fcd12310>

    def test_salary_string_representation_from_only(self):
        """Тест строкового представления зарплаты только с минимумом"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:143: TypeError
_____________ TestSalary.test_salary_string_representation_none _____________

self = <tests.test_salary.TestSalary object at 0x7f59fcd12850>

    def test_salary_string_representation_none(self):
        """Тест строкового представления зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:150: TypeError
____________________ TestSalary.test_salary_is_specified ____________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd12c90>

    def test_salary_is_specified(self):
        """Тест проверки указана ли зарплата"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:156: TypeError
________________ TestSalary.test_salary_currency_conversion _________________

self = <tests.test_salary.TestSalary object at 0x7f59fcd131d0>

    def test_salary_currency_conversion(self):
        """Тест конвертации валют (если поддерживается)"""
>       salary = Salary(1000, 2000, "USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:166: TypeError
___________________ TestSearchUtils.test_normalize_query ____________________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f59fcd19c90>

    def test_normalize_query(self):
        """Тест нормализации поискового запроса"""
        # Обычный запрос
        assert SearchUtils.normalize_query("Python Developer") == "python developer"
    
        # Запрос с лишними пробелами
>       assert SearchUtils.normalize_query("  Python   Developer  ") == "python developer"
E       AssertionError: assert 'python   developer' == 'python developer'
E         
E         - python developer
E         + python   developer
E         ?       ++

tests/test_search_utils.py:299: AssertionError
_________________ TestSearchUtils.test_build_search_params __________________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f59fcd19690>

    def test_build_search_params(self):
        """Тест построения параметров поиска"""
        # Базовые параметры
        params = SearchUtils.build_search_filters(salary_from=100000, area=1)
>       assert params["salary_from"] == 100000
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/test_search_utils.py:324: TypeError
________________ TestSearchUtils.test_empty_search_handling _________________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f59fcd18d10>

    def test_empty_search_handling(self):
        """Тест обработки пустых поисковых запросов"""
        assert SearchUtils.normalize_query("") == ""
        assert SearchUtils.extract_keywords("") == []
        assert SearchUtils.match_keywords("", ["Python"]) is False
>       assert SearchUtils.build_search_filters() == {}  # Проверка для build_search_filters
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert None == {}
E        +  where None = <function SearchUtils.build_search_filters at 0x7f59fd1a58a0>()
E        +    where <function SearchUtils.build_search_filters at 0x7f59fd1a58a0> = SearchUtils.build_search_filters

tests/test_search_utils.py:396: AssertionError
_______________ TestSearchUtils.test_search_params_validation _______________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f59fcd1afd0>

    def test_search_params_validation(self):
        """Тест валидации параметров поиска"""
        # Валидные параметры
        params = SearchUtils.build_search_filters(experience="between1And3", employment="full_time")
>       assert params["experience"] == "between1And3"
               ^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/test_search_utils.py:425: TypeError
_____________ TestSearchUtils.test_advanced_search_combinations _____________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f59fcd1bad0>

    def test_advanced_search_combinations(self):
        """Тест сложных поисковых комбинаций"""
        # Комбинированный запрос
        keywords = ["python", "django"]
        vacancy_text = "We are looking for a Python Django developer with experience from 1 to 3 years."
        assert SearchUtils.match_keywords(vacancy_text, keywords, match_all=True) is True
    
        # Тест calculate_relevance
>       relevance = SearchUtils.calculate_relevance(vacancy_text, keywords)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'SearchUtils' has no attribute 'calculate_relevance'

tests/test_search_utils.py:455: AttributeError
____________ TestSourceManager.test_register_and_activate_source ____________

self = <tests.test_source_manager.TestSourceManager object at 0x7f59fcd2dbd0>

    def test_register_and_activate_source(self):
        """Тест регистрации и активации источника"""
        manager = SourceManager()
        mock_api = MockHHAPI()
        manager.register_source("hh.ru", mock_api)
        manager.activate_source("hh.ru")
        assert "hh.ru" in manager.get_all_sources()
        assert "hh.ru" in manager.get_active_sources()
>       assert manager.is_source_active("hh.ru") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceManager' object has no attribute 'is_source_active'

tests/test_source_manager.py:368: AttributeError
_________________ TestSourceManager.test_deactivate_source __________________

self = <tests.test_source_manager.TestSourceManager object at 0x7f59fcd2e350>

    def test_deactivate_source(self):
        """Тест деактивации источника"""
        manager = SourceManager()
        mock_api = MockHHAPI()
        manager.register_source("hh.ru", mock_api)
        manager.activate_source("hh.ru")
        manager.deactivate_source("hh.ru")
        assert "hh.ru" not in manager.get_active_sources()
>       assert manager.is_source_active("hh.ru") is False
               ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceManager' object has no attribute 'is_source_active'

tests/test_source_manager.py:378: AttributeError
_____________ TestSourceManager.test_get_vacancies_from_source ______________

self = <tests.test_source_manager.TestSourceManager object at 0x7f59fd1b8050>

    def test_get_vacancies_from_source(self):
        """Тест получения вакансий из конкретного источника"""
        manager = SourceManager()
        mock_hh_api = MockHHAPI()
        mock_sj_api = MockSJAPI()
    
        manager.register_source("hh.ru", mock_hh_api)
        manager.register_source("superjob.ru", mock_sj_api)
    
>       hh_vacancies = manager.get_vacancies_from_source("hh.ru", "python developer")
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceManager' object has no attribute 'get_vacancies_from_source'

tests/test_source_manager.py:409: AttributeError
__________________ TestSourceManager.test_get_source_stats __________________

self = <tests.test_source_manager.TestSourceManager object at 0x7f59fd1b8190>

    def test_get_source_stats(self):
        """Тест получения статистики по источникам"""
        manager = SourceManager()
        mock_hh_api = MockHHAPI()
        mock_sj_api = MockSJAPI()
    
        manager.register_source("hh.ru", mock_hh_api)
        manager.register_source("superjob.ru", mock_sj_api)
        manager.activate_source("hh.ru")
    
>       stats = manager.get_source_stats()
                ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceManager' object has no attribute 'get_source_stats'

tests/test_source_manager.py:435: AttributeError
________________ TestSourceManager.test_clear_active_sources ________________

self = <tests.test_source_manager.TestSourceManager object at 0x7f59fd1b87d0>

    def test_clear_active_sources(self):
        """Тест очистки списка активных источников"""
        manager = SourceManager()
        mock_api = MockHHAPI()
        manager.register_source("hh.ru", mock_api)
        manager.activate_source("hh.ru")
>       manager.clear_active_sources()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceManager' object has no attribute 'clear_active_sources'

tests/test_source_manager.py:453: AttributeError
__________ TestSourceSelector.test_source_selector_initialization ___________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1b9750>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3f15cd0>

    def test_source_selector_initialization(self, source_selector):
        """Тест инициализации SourceSelector"""
        assert source_selector is not None
>       assert hasattr(source_selector, "available_sources")
E       AssertionError: assert False
E        +  where False = hasattr(<src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3f15cd0>, 'available_sources')

tests/test_source_selector.py:23: AssertionError
___________ TestSourceSelector.test_get_user_source_choice_single ___________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1ba650>
mock_input = <MagicMock name='input' id='140024321493968'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3f15910>

    @patch("builtins.input", return_value="1")
    def test_get_user_source_choice_single(self, mock_input, source_selector):
        """Тест выбора одного источника"""
        with patch("builtins.print"):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:30: AssertionError
____________ TestSourceSelector.test_get_user_source_choice_all _____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1b9e50>
mock_input = <MagicMock name='input' id='140024392087632'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f82648d0>

    @patch("builtins.input", return_value="3")
    def test_get_user_source_choice_all(self, mock_input, source_selector):
        """Тест выбора всех источников"""
        with patch("builtins.print"):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'hh.ru', 'superjob.ru'}, list)

tests/test_source_selector.py:38: AssertionError
_____ TestSourceSelector.test_get_user_source_choice_invalid_then_valid _____

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1baa50>
mock_print = <MagicMock name='print' id='140024319501904'>
mock_input = <MagicMock name='input' id='140024390800592'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3d2e690>

    @patch("builtins.input", side_effect=["invalid", "1"])
    @patch("builtins.print")
    def test_get_user_source_choice_invalid_then_valid(self, mock_print, mock_input, source_selector):
        """Тест некорректного, затем корректного выбора"""
        sources = source_selector.get_user_source_choice()
>       assert isinstance(sources, list)
E       AssertionError: assert False
E        +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:52: AssertionError
_______________ TestSourceSelector.test_get_available_sources _______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1bba90>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3fbaf10>

    def test_get_available_sources(self, source_selector):
        """Тест получения доступных источников"""
>       sources = source_selector.get_available_sources()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_available_sources'

tests/test_source_selector.py:64: AttributeError
______________ TestSourceSelector.test_validate_source_choice _______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1bbfd0>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f827bf90>

    def test_validate_source_choice(self, source_selector):
        """Тест валидации выбора источника"""
>       assert source_selector.validate_source_choice("1") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'validate_source_choice'

tests/test_source_selector.py:71: AttributeError
_____________ TestSourceSelector.test_get_source_name_by_choice _____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1f1290>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f812f310>

    def test_get_source_name_by_choice(self, source_selector):
        """Тест получения имени источника по выбору"""
        # Предполагаем стандартную нумерацию
>       source_name = source_selector.get_source_name_by_choice("1")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_source_name_by_choice'

tests/test_source_selector.py:81: AttributeError
________________ TestSourceSelector.test_is_source_available ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1f1150>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f3f77610>

    def test_is_source_available(self, source_selector):
        """Тест проверки доступности источника"""
>       assert source_selector.is_source_available("hh.ru") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'is_source_available'

tests/test_source_selector.py:86: AttributeError
________________ TestSourceSelector.test_display_source_menu ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f59fd1f0250>
mock_print = <MagicMock name='print' id='140024392084496'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f59f8267c50>

    @patch("builtins.print")
    def test_display_source_menu(self, mock_print, source_selector):
        """Тест отображения меню источников"""
>       source_selector.display_source_menu()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'display_source_menu'

tests/test_source_selector.py:93: AttributeError
___________________ TestPostgresSaver.test_initialization ___________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f59fd1f3c90>
mock_connect = <MagicMock name='connect' id='140024319807888'>

    @patch("psycopg2.connect")
    def test_initialization(self, mock_connect):
        """Тест инициализации хранилища"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_storage.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f725d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
____________________ TestPostgresSaver.test_add_vacancy _____________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f59fd1f2810>
mock_connect = <MagicMock name='connect' id='140024391506256'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f59f3ab6ea0>

    @patch("psycopg2.connect")
    def test_add_vacancy(self, mock_connect, sample_vacancy):
        """Тест добавления вакансии"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_storage.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f270d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
___________________ TestPostgresSaver.test_get_vacancies ____________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f59fd1f2f50>
mock_connect = <MagicMock name='connect' id='140024391943952'>

    @patch("psycopg2.connect")
    def test_get_vacancies(self, mock_connect):
        """Тест получения вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.fetchall.return_value = [
            (
                "12345",
                "Python Developer",
                "Test Company",
                "https://hh.ru/vacancy/12345",
                "100000",
                "150000",
                "RUR",
                "Test description",
                "Python, Django",
                "Development",
                "От 1 года до 3 лет",
                "Полная занятость",
                "Полный день",
                "2024-01-01T00:00:00",
                "hh.ru",
            )
        ]
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_storage.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f3f2db10>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
________________ TestPostgresSaver.test_delete_vacancy_by_id ________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f59fd1b9090>
mock_connect = <MagicMock name='connect' id='140024322162768'>

    @patch("psycopg2.connect")
    def test_delete_vacancy_by_id(self, mock_connect):
        """Тест удаления вакансии по ID"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_storage.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f82e9b90>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
________________ TestPostgresSaver.test_get_vacancies_count _________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f59fd1f3450>
mock_connect = <MagicMock name='connect' id='140024393469776'>

    @patch("psycopg2.connect")
    def test_get_vacancies_count(self, mock_connect):
        """Тест получения количества вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.fetchone.return_value = (10,)
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
>       storage = PostgresSaver()
                  ^^^^^^^^^^^^^^^

tests/test_storage.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f59f83b81d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               IndexError: tuple index out of range

src/storage/postgres_saver.py:320: IndexError
_________________ TestUIHelpers.test_confirm_action_default _________________

self = <tests.test_ui_helpers.TestUIHelpers object at 0x7f59fcd03310>
mock_input = <MagicMock name='input' id='140024392748752'>

    @patch("builtins.input")
    def test_confirm_action_default(self, mock_input):
        """Тест подтверждения действия - по умолчанию"""
        mock_input.return_value = ""
>       result = confirm_action("Продолжить?", default=True)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: confirm_action() got an unexpected keyword argument 'default'

tests/test_ui_helpers.py:37: TypeError
========================== short test summary info ==========================
FAILED tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_main_functionality.py::TestMainFunctionality::test_data_validation - assert <src.utils.salary.Salary object at 0x7f59f3f56920> is None
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_valid - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_invalid_then_valid - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_menu_manager.py::TestMenuManager::test_display_menu_items - TypeError: MenuManager.display_menu() takes 1 positional argument but 2 ...
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_exit - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_paginator.py::TestPaginator::test_paginator_initialization - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_get_current_page_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_next_page - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_next_page_at_end - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_previous_page - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_previous_page_at_start - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_go_to_page_valid - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_go_to_page_invalid - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_empty_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_single_page_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_page_info - TypeError: Paginator() takes no arguments
FAILED tests/test_parsers.py::TestHHParser::test_parse_company_data - AttributeError: 'HHParser' object has no attribute 'parse_company'
FAILED tests/test_parsers.py::TestHHParser::test_parse_companies_list - AttributeError: 'HHParser' object has no attribute 'parse_companies'
FAILED tests/test_parsers.py::TestSuperJobParser::test_parse_companies_list - AttributeError: 'SuperJobParser' object has no attribute 'parse_companies'
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_success - TypeError: Vacancy.__init__() got an unexpected keyword argument 'salary...
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_empty_list - assert 0 is True
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_database_error - psycopg2.Error: Database error
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_all_vacancies - AttributeError: 'PostgresSaver' object has no attribute 'get_all_vacancies'
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_count - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_filter_vacancies_by_salary - AttributeError: 'PostgresSaver' object has no attribute 'filter_vacancie...
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancie...
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_with_range - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_to_only - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_none_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_complete - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_partial - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_none - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_empty - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_to_dict - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_to_dict_partial - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_average_with_both_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_average_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_average_to_only - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'
FAILED tests/test_salary.py::TestSalary::test_salary_average_none_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_greater - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_less - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_equal - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_with_none - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_full - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_none - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_is_specified - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_salary.py::TestSalary::test_salary_currency_conversion - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but ...
FAILED tests/test_search_utils.py::TestSearchUtils::test_normalize_query - AssertionError: assert 'python   developer' == 'python developer'
FAILED tests/test_search_utils.py::TestSearchUtils::test_build_search_params - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_search_utils.py::TestSearchUtils::test_empty_search_handling - assert None == {}
FAILED tests/test_search_utils.py::TestSearchUtils::test_search_params_validation - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_search_utils.py::TestSearchUtils::test_advanced_search_combinations - AttributeError: type object 'SearchUtils' has no attribute 'calculate_re...
FAILED tests/test_source_manager.py::TestSourceManager::test_register_and_activate_source - AttributeError: 'SourceManager' object has no attribute 'is_source_active'
FAILED tests/test_source_manager.py::TestSourceManager::test_deactivate_source - AttributeError: 'SourceManager' object has no attribute 'is_source_active'
FAILED tests/test_source_manager.py::TestSourceManager::test_get_vacancies_from_source - AttributeError: 'SourceManager' object has no attribute 'get_vacancies_f...
FAILED tests/test_source_manager.py::TestSourceManager::test_get_source_stats - AttributeError: 'SourceManager' object has no attribute 'get_source_stats'
FAILED tests/test_source_manager.py::TestSourceManager::test_clear_active_sources - AttributeError: 'SourceManager' object has no attribute 'clear_active_so...
FAILED tests/test_source_selector.py::TestSourceSelector::test_source_selector_initialization - AssertionError: assert False
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_single - AssertionError: assert False
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_all - AssertionError: assert False
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_invalid_then_valid - AssertionError: assert False
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_available_sources - AttributeError: 'SourceSelector' object has no attribute 'get_available_...
FAILED tests/test_source_selector.py::TestSourceSelector::test_validate_source_choice - AttributeError: 'SourceSelector' object has no attribute 'validate_sourc...
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_source_name_by_choice - AttributeError: 'SourceSelector' object has no attribute 'get_source_nam...
FAILED tests/test_source_selector.py::TestSourceSelector::test_is_source_available - AttributeError: 'SourceSelector' object has no attribute 'is_source_avai...
FAILED tests/test_source_selector.py::TestSourceSelector::test_display_source_menu - AttributeError: 'SourceSelector' object has no attribute 'display_source...
FAILED tests/test_storage.py::TestPostgresSaver::test_initialization - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_storage.py::TestPostgresSaver::test_add_vacancy - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_storage.py::TestPostgresSaver::test_get_vacancies - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_storage.py::TestPostgresSaver::test_delete_vacancy_by_id - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_storage.py::TestPostgresSaver::test_get_vacancies_count - IndexError: tuple index out of range
FAILED tests/test_ui_helpers.py::TestUIHelpers::test_confirm_action_default - TypeError: confirm_action() got an unexpected keyword argument 'default'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<frozen codecs>:327: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
===============