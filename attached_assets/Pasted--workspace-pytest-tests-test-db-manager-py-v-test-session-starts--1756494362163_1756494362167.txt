
~/workspace$ pytest tests/test_db_manager.py -v
============================ test session starts =============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace/tests
configfile: pytest.ini
plugins: mock-3.14.1, cov-6.2.1
collected 42 items                                                           

tests/test_db_manager.py::TestDBManager::test_initialization PASSED    [  2%]
tests/test_db_manager.py::TestDBManager::test_initialization_with_custom_config PASSED [  4%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success PASSED [  7%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [  9%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED [ 11%]
tests/test_db_manager.py::TestDBManager::test_create_tables PASSED     [ 14%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_empty_table FAILED [ 16%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_already_populated PASSED [ 19%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table_no_table PASSED [ 21%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count PASSED [ 23%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count_no_connection FAILED [ 26%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies FAILED [ 28%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies_no_tables PASSED [ 30%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED    [ 33%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED [ 35%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_tables PASSED [ 38%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary PASSED [ 40%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary_no_avg PASSED [ 42%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword PASSED [ 45%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 47%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_no_tables PASSED [ 50%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats FAILED [ 52%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats_error PASSED [ 54%]
tests/test_db_manager.py::TestDBManager::test_get_target_companies_analysis PASSED [ 57%]
tests/test_db_manager.py::TestDBManager::test_get_target_companies_analysis_no_data FAILED [ 59%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets FAILED [ 61%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets_empty_input PASSED [ 64%]
tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets_sql_error PASSED [ 66%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_vacancy_stats FAILED [ 69%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_salary_analysis FAILED [ 71%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_empty_data PASSED [ 73%]
tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_error PASSED [ 76%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED [ 78%]
tests/test_db_manager.py::TestDBManager::test_ensure_tables_exist_success PASSED [ 80%]
tests/test_db_manager.py::TestDBManager::test_ensure_tables_exist_failure PASSED [ 83%]
tests/test_db_manager.py::TestDBManager::test_error_handling_in_methods FAILED [ 85%]
tests/test_db_manager.py::TestDBManager::test_connection_error_handling FAILED [ 88%]
tests/test_db_manager.py::TestDBManager::test_sql_injection_protection PASSED [ 90%]
tests/test_db_manager.py::TestDBManager::test_unicode_handling PASSED  [ 92%]
tests/test_db_manager.py::TestDBManager::test_context_manager_usage PASSED [ 95%]
tests/test_db_manager.py::TestDBManager::test_large_dataset_handling PASSED [ 97%]
tests/test_db_manager.py::TestDBManager::test_edge_cases_and_boundary_conditions FAILED [100%]

================================== FAILURES ==================================
__________ TestDBManager.test_populate_companies_table_empty_table ___________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf27290>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843232637584'>, 'connection': <MagicMock name='connect()' id='139843232642896'>, 'cursor': <MagicMock name='connect().cursor()' id='139843271843280'>}

    def test_populate_companies_table_empty_table(self, mock_db_connection):
        """Тест заполнения пустой таблицы компаний"""
        # Настраиваем последовательность ответов:
        # 1. Таблица существует
        # 2. В таблице 0 компаний
        # 3. 15 проверок существования компаний (все возвращают None)
        # 4. Финальный подсчет показывает 15 компаний
        fetchone_responses = [
            (True,),   # Таблица существует
            (0,),      # Начальный подсчет = 0
        ]
        # Добавляем None для каждой проверки существования компании
        for _ in range(15):  # 15 целевых компаний
            fetchone_responses.append(None)
        # Финальный подсчет
        fetchone_responses.append((15,))
    
        mock_db_connection['cursor'].fetchone.side_effect = fetchone_responses
    
        db_manager = DBManager()
>       db_manager.populate_companies_table()

tests/test_db_manager.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f2fcca17a10>

    def populate_companies_table(self):
        """Заполняет таблицу companies целевыми компаниями"""
        try:
            # Используем контекстный менеджер для безопасной работы с подключением
            with self._get_connection() as connection:
                with connection.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Проверяем, существует ли таблица companies
                    cursor.execute(
                        """
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables
                            WHERE table_schema = 'public'
                            AND table_name = 'companies'
                        );
                    """
                    )
    
                    table_exists = cursor.fetchone()[0]
                    if not table_exists:
                        logger.warning("Таблица companies не существует. Таблицы должны быть созданы заранее.")
                        return
    
                    # Проверяем, есть ли уже данные в таблице
                    cursor.execute("SELECT COUNT(*) FROM companies")
                    companies_count = cursor.fetchone()[0]
    
                    if companies_count > 0:
                        logger.info(f"✓ Таблица companies уже содержит {companies_count} компаний")
                        return
    
                    # Добавляем целевые компании с их API идентификаторами
                    for company in TARGET_COMPANIES:
                        # Сначала проверяем, существует ли компания
                        cursor.execute("SELECT id FROM companies WHERE name = %s", (company.name,))
                        if not cursor.fetchone():
                            cursor.execute(
                                """
                                INSERT INTO companies (name, hh_id, sj_id)
                                VALUES (%s, %s, %s)
                            """,
                                (company.name, getattr(company, "hh_id", None), getattr(company, "sj_id", None)),
                            )
                            logger.info(f"Добавлена целевая компания: {company.name}")
    
                    # Проверяем результат
                    cursor.execute("SELECT COUNT(*) FROM companies")
>                   final_count = cursor.fetchone()[0]
                                  ^^^^^^^^^^^^^^^^^^^^
E                   TypeError: 'NoneType' object is not subscriptable

src/storage/db_manager.py:248: TypeError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка при заполнении таблицы companies: 'NoneType' object is not subscriptable
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:252 Ошибка при заполнении таблицы companies: 'NoneType' object is not subscriptable
_____ TestDBManager.test_get_companies_and_vacancies_count_no_connection _____

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf26610>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843233246544'>, 'connection': <MagicMock name='connect()' id='139843233246288'>, 'cursor': <MagicMock name='connect().cursor()' id='139843233382352'>}

    def test_get_companies_and_vacancies_count_no_connection(self, mock_db_connection):
        """Тест получения компаний без подключения к БД"""
        # Мокаем check_connection чтобы вернуть False
        with patch.object(DBManager, 'check_connection', return_value=False):
            db_manager = DBManager()
            companies = db_manager.get_companies_and_vacancies_count()
    
            # Должен вернуть список целевых компаний с нулями
>           assert len(companies) == 15  # 15 целевых компаний
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AssertionError: assert 12 == 15
E            +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:177: AssertionError
____________________ TestDBManager.test_get_all_vacancies ____________________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf30b10>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843237571408'>, 'connection': <MagicMock name='connect()' id='139843237572304'>, 'cursor': <MagicMock name='connect().cursor()' id='139843228657104'>}

    def test_get_all_vacancies(self, mock_db_connection):
        """Тест получения всех вакансий"""
        # Настраиваем _ensure_tables_exist
        with patch.object(DBManager, '_ensure_tables_exist', return_value=True):
            # Создаем мок RealDictCursor результата
            test_row_data = {
                "title": "Python Developer",
                "company_name": "СБЕР",
                "salary_info": "100000 - 150000 RUR",
                "url": "https://hh.ru/vacancy/12345",
                "vacancy_id": "12345",
                "raw_company_id": 1,
                "linked_company_id": 1
            }
    
            # Создаем mock объект который ведет себя как RealDictRow
            test_row = MagicMock()
            test_row.get = lambda key, default=None: test_row_data.get(key, default)
            test_row.keys = MagicMock(return_value=test_row_data.keys())
            test_row.values = MagicMock(return_value=test_row_data.values())
            test_row.items = MagicMock(return_value=test_row_data.items())
            test_row.__getitem__ = lambda key: test_row_data[key]
            test_row.__iter__ = MagicMock(return_value=iter(test_row_data))
    
            mock_db_connection['cursor'].fetchall.return_value = [test_row]
    
            db_manager = DBManager()
            vacancies = db_manager.get_all_vacancies()
    
>           assert len(vacancies) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_db_manager.py:209: AssertionError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка при получении всех вакансий: TestDBManager.test_get_all_vacancies.<locals>.<lambda>() takes 1 positional argument but 2 were given
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:480 Ошибка при получении всех вакансий: TestDBManager.test_get_all_vacancies.<locals>.<lambda>() takes 1 positional argument but 2 were given
___________________ TestDBManager.test_get_database_stats ____________________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf3c310>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843228900112'>, 'connection': <MagicMock name='connect()' id='139843228906128'>, 'cursor': <MagicMock name='connect().cursor()' id='139843229172496'>}

    def test_get_database_stats(self, mock_db_connection):
        """Тест получения статистики базы данных"""
        # Настраиваем различные ответы для разных запросов
        main_stats_data = {
            'total_vacancies': 100,
            'vacancies_with_salary': 75,
            'unique_employers': 25,
            'avg_salary': 125000.0,
            'latest_vacancy_date': '2024-01-15',
            'earliest_vacancy_date': '2024-01-01',
            'vacancies_last_week': 10,
            'vacancies_last_month': 50,
            'vacancies_with_description': 80,
            'vacancies_with_requirements': 70,
            'vacancies_with_area': 90,
            'vacancies_with_published_date': 85
        }
    
        company_stats_data = {'total_companies': 15}
        top_employers_data = [
            {'employer': 'СБЕР', 'vacancy_count': 20},
            {'employer': 'Яндекс', 'vacancy_count': 15}
        ]
        salary_distribution_data = [
            {'salary_range': '50k-100k', 'count': 30},
            {'salary_range': '100k-150k', 'count': 25}
        ]
    
        # Создаем мок объекты для RealDictCursor
        main_stats_row = MagicMock()
        main_stats_row.__iter__ = lambda self: iter(main_stats_data.items())
        for key, value in main_stats_data.items():
            setattr(main_stats_row, key, value)
            main_stats_row.__getitem__ = lambda k: main_stats_data[k]
    
        company_stats_row = MagicMock()
        company_stats_row.__getitem__ = lambda k: company_stats_data[k]
    
        # Настраиваем последовательность вызовов fetchone и fetchall
        mock_db_connection['cursor'].fetchone.side_effect = [
            main_stats_row,     # Основная статистика
            company_stats_row   # Статистика компаний
        ]
    
        mock_db_connection['cursor'].fetchall.side_effect = [
            top_employers_data,        # Топ работодатели
            salary_distribution_data   # Распределение зарплат
        ]
    
        db_manager = DBManager()
        stats = db_manager.get_database_stats()
    
        assert isinstance(stats, dict)
>       assert 'total_companies' in stats
E       AssertionError: assert 'total_companies' in {}

tests/test_db_manager.py:362: AssertionError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Неожиданная ошибка при получении статистики БД: TestDBManager.test_get_database_stats.<locals>.<lambda>() takes 1 positional argument but 2 were given
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:775 Неожиданная ошибка при получении статистики БД: TestDBManager.test_get_database_stats.<locals>.<lambda>() takes 1 positional argument but 2 were given
__________ TestDBManager.test_get_target_companies_analysis_no_data __________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf3d850>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843229114192'>, 'connection': <MagicMock name='connect()' id='139843229112464'>, 'cursor': <MagicMock name='connect().cursor()' id='139843229050640'>}

    def test_get_target_companies_analysis_no_data(self, mock_db_connection):
        """Тест анализа целевых компаний без данных"""
        with patch.object(DBManager, 'get_companies_and_vacancies_count', return_value=[]):
            db_manager = DBManager()
            result = db_manager.get_target_companies_analysis()
    
            # Должен вернуть все целевые компании с нулями
>           assert len(result) == 15
E           AssertionError: assert 12 == 15
E            +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:401: AssertionError
_______________ TestDBManager.test_filter_companies_by_targets _______________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf3df50>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843228664528'>, 'connection': <MagicMock name='connect()' id='139843228677328'>, 'cursor': <MagicMock name='connect().cursor()' id='139843228672528'>}

    def test_filter_companies_by_targets(self, mock_db_connection):
        """Тест фильтрации компаний по целевым"""
        api_companies = [
            {"id": "1", "name": "СБЕР"},
            {"id": "2", "name": "Random Company"},
            {"id": "3", "name": "Яндекс"}
        ]
    
        # Настраиваем ответ для SQL запроса
        mock_db_connection['cursor'].fetchall.return_value = [
            ("1", "СБЕР"),
            ("3", "Яндекс")
        ]
    
        db_manager = DBManager()
>       filtered = db_manager.filter_companies_by_targets(api_companies)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/db_manager.py:845: in filter_companies_by_targets
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cur = <MagicMock name='connect().cursor()' id='139843228672528'>
sql = 'INSERT INTO temp_api_companies (company_id, company_name) VALUES %s'
argslist = [('1', 'СБЕР'), ('2', 'Random Company'), ('3', 'Яндекс')]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <MagicMock name='connect().cursor().connection.encoding' id='139843228252048'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
_________ TestDBManager.test_analyze_api_data_with_sql_vacancy_stats _________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf3f450>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843228587600'>, 'connection': <MagicMock name='connect()' id='139843228587536'>, 'cursor': <MagicMock name='connect().cursor()' id='139843228946384'>}

    def test_analyze_api_data_with_sql_vacancy_stats(self, mock_db_connection):
        """Тест анализа API данных (статистика вакансий)"""
        api_data = [
            {
                "id": "1",
                "name": "Python Developer",
                "salary": {"from": 100000, "to": 150000, "currency": "RUR"},
                "employer": {"name": "СБЕР"},
                "area": {"name": "Москва"}
            }
        ]
    
        # Настраиваем ответы для анализа
        stats_row = MagicMock()
        stats_data = {
            'total_vacancies': 1,
            'unique_employers': 1,
            'vacancies_with_salary': 1,
            'avg_salary': 125000.0
        }
        stats_row.__iter__ = lambda self: iter(stats_data.items())
        for key, value in stats_data.items():
            setattr(stats_row, key, value)
    
        top_employers_data = [{'employer': 'СБЕР', 'vacancy_count': 1}]
    
        mock_db_connection['cursor'].fetchone.return_value = stats_row
        mock_db_connection['cursor'].fetchall.return_value = top_employers_data
    
        db_manager = DBManager()
>       result = db_manager.analyze_api_data_with_sql(api_data, "vacancy_stats")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/db_manager.py:941: in analyze_api_data_with_sql
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cur = <MagicMock name='connect().cursor()' id='139843228946384'>
sql = 'INSERT INTO temp_api_analysis (\n                            item_id, title, salary_from, salary_to, salary_currency,\n                            employer, area, experience, employment\n                        ) VALUES %s'
argslist = [('1', 'Python Developer', 100000, 150000, 'RUR', 'СБЕР', ...)]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <MagicMock name='connect().cursor().connection.encoding' id='139843224044688'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
________ TestDBManager.test_analyze_api_data_with_sql_salary_analysis ________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf3fb50>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843232697168'>, 'connection': <MagicMock name='connect()' id='139843232703568'>, 'cursor': <MagicMock name='connect().cursor()' id='139843232696528'>}

    def test_analyze_api_data_with_sql_salary_analysis(self, mock_db_connection):
        """Тест анализа API данных (анализ зарплат)"""
        api_data = [
            {
                "id": "1",
                "name": "Python Developer",
                "salary": {"from": 100000, "to": 150000, "currency": "RUR"}
            }
        ]
    
        salary_stats_row = MagicMock()
        salary_data = {
            'min_salary': 100000.0,
            'max_salary': 150000.0,
            'avg_salary': 125000.0,
            'count_with_salary': 1
        }
        for key, value in salary_data.items():
            setattr(salary_stats_row, key, value)
    
        mock_db_connection['cursor'].fetchone.return_value = salary_stats_row
    
        db_manager = DBManager()
>       result = db_manager.analyze_api_data_with_sql(api_data, "salary_analysis")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/db_manager.py:941: in analyze_api_data_with_sql
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cur = <MagicMock name='connect().cursor()' id='139843232696528'>
sql = 'INSERT INTO temp_api_analysis (\n                            item_id, title, salary_from, salary_to, salary_currency,\n                            employer, area, experience, employment\n                        ) VALUES %s'
argslist = [('1', 'Python Developer', 100000, 150000, 'RUR', '', ...)]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <MagicMock name='connect().cursor().connection.encoding' id='139843228795856'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
________________ TestDBManager.test_error_handling_in_methods ________________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf40510>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843223958928'>, 'connection': <MagicMock name='connect()' id='139843223952016'>, 'cursor': <MagicMock name='connect().cursor()' id='139843223983504'>}

    def test_error_handling_in_methods(self, mock_db_connection):
        """Тест обработки ошибок в различных методах"""
        import psycopg2
    
        # Тестируем обработку ошибок в get_companies_and_vacancies_count
        with patch.object(DBManager, 'check_connection', return_value=True):
            mock_db_connection['cursor'].execute.side_effect = psycopg2.Error("SQL Error")
    
            db_manager = DBManager()
    
            # Метод должен вернуть целевые компании с нулями при ошибке
            companies = db_manager.get_companies_and_vacancies_count()
>           assert len(companies) == 15
E           AssertionError: assert 12 == 15
E            +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:571: AssertionError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка при получении списка компаний и количества вакансий: SQL Error
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:349 Ошибка при получении списка компаний и количества вакансий: SQL Error
________________ TestDBManager.test_connection_error_handling ________________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf408d0>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843233285712'>, 'connection': <MagicMock name='connect()' id='139843273242000'>, 'cursor': <MagicMock name='connect().cursor()' id='139843233245968'>}

    def test_connection_error_handling(self, mock_db_connection):
        """Тест обработки ошибок подключения"""
        import psycopg2
        mock_db_connection['connect'].side_effect = psycopg2.Error("Connection error")
    
        db_manager = DBManager()
    
        # Тестируем различные методы при ошибке подключения
        assert db_manager.check_connection() is False
    
        # get_avg_salary должен вернуть None при ошибке подключения
>       with pytest.raises(psycopg2.Error):
E       Failed: DID NOT RAISE <class 'psycopg2.Error'>

tests/test_db_manager.py:585: Failed
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка подключения к базе данных: Connection error
ERROR:src.storage.db_manager:Ошибка подключения к БД: Connection error
ERROR:src.storage.db_manager:Ошибка подключения к базе данных: Connection error
ERROR:src.storage.db_manager:Ошибка при создании таблиц: Connection error
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:59 Ошибка подключения к базе данных: Connection error
ERROR    src.storage.db_manager:db_manager.py:806 Ошибка подключения к БД: Connection error
ERROR    src.storage.db_manager:db_manager.py:59 Ошибка подключения к базе данных: Connection error
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: Connection error
___________ TestDBManager.test_edge_cases_and_boundary_conditions ____________

self = <tests.test_db_manager.TestDBManager object at 0x7f2fcaf42450>
mock_db_connection = {'connect': <MagicMock name='connect' id='139843192892816'>, 'connection': <MagicMock name='connect()' id='139843191226896'>, 'cursor': <MagicMock name='connect().cursor()' id='139843183966160'>}

    def test_edge_cases_and_boundary_conditions(self, mock_db_connection):
        """Тест граничных условий и крайних случаев"""
        db_manager = DBManager()
    
        # Тест с None параметрами
        result = db_manager.get_vacancies_with_keyword(None)
        assert result == []
    
        # Тест с пустой строкой
        result = db_manager.get_vacancies_with_keyword("   ")
        assert result == []
    
        # Тест анализа API данных с некорректными данными
        invalid_api_data = [
            {"invalid": "data"},
            {"id": None, "name": ""},
            {}
        ]
    
>       result = db_manager.analyze_api_data_with_sql(invalid_api_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:685: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/db_manager.py:941: in analyze_api_data_with_sql
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cur = <MagicMock name='connect().cursor()' id='139843183966160'>
sql = 'INSERT INTO temp_api_analysis (\n                            item_id, title, salary_from, salary_to, salary_currency,\n                            employer, area, experience, employment\n                        ) VALUES %s'
argslist = [('', '', None, None, None, '', ...), ('None', '', None, None, None, '', ...), ('', '', None, None, None, '', ...)]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <MagicMock name='connect().cursor().connection.encoding' id='139843179031184'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
========================== short test summary info ===========================
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table_empty_table - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count_no_connection - AssertionError: assert 12 == 15
FAILED tests/test_db_manager.py::TestDBManager::test_get_all_vacancies - assert 0 == 1
FAILED tests/test_db_manager.py::TestDBManager::test_get_database_stats - AssertionError: assert 'total_companies' in {}
FAILED tests/test_db_manager.py::TestDBManager::test_get_target_companies_analysis_no_data - AssertionError: assert 12 == 15
FAILED tests/test_db_manager.py::TestDBManager::test_filter_companies_by_targets - KeyError: <MagicMock name='connect().cursor().connection.encoding' id='13...
FAILED tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_vacancy_stats - KeyError: <MagicMock name='connect().cursor().connection.encoding' id='13...
FAILED tests/test_db_manager.py::TestDBManager::test_analyze_api_data_with_sql_salary_analysis - KeyError: <MagicMock name='connect().cursor().connection.encoding' id='13...
FAILED tests/test_db_manager.py::TestDBManager::test_error_handling_in_methods - AssertionError: assert 12 == 15
FAILED tests/test_db_manager.py::TestDBManager::test_connection_error_handling - Failed: DID NOT RAISE <class 'psycopg2.Error'>
FAILED tests/test_db_manager.py::TestDBManager::test_edge_cases_and_boundary_conditions - KeyError: <MagicMock name='connect().cursor().connection.encoding' id='13...
======================= 11 failed, 31 passed in 1.48s ========================
~/workspace$ 