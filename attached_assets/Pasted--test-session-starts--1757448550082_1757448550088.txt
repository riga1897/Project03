============================================ test session starts =============================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 2125 items                                                                                         

tests/test_01_abstract_models_coverage.py ....                                                         [  0%]
tests/test_02_models_coverage.py ........................                                              [  1%]
tests/test_03_api_modules_coverage.py .....F............F..........                                    [  2%]
tests/test_04_config_coverage.py ....................                                                  [  3%]
tests/test_05_utils_coverage.py .......................................                                [  5%]
tests/test_06_storage_coverage.py ...F..........                                                       [  6%]
tests/test_07_parsers_coverage.py ...................                                                  [  7%]
tests/test_09_config_simple.py ..............F...............                                          [  8%]
tests/test_10_api_modules_coverage.py ...........................F...                                  [  9%]
tests/test_12_user_interface_coverage.py F............F.                                               [ 10%]
tests/test_13_ui_interfaces_coverage.py ............................                                   [ 11%]
tests/test_14_vacancy_stats_coverage.py ...................F..............................             [ 14%]
tests/test_15_abstract_models_coverage.py .......................................                      [ 16%]
tests/test_16_models_coverage.py ................................................................      [ 19%]
tests/test_17_real_business_logic_coverage.py ......................                                   [ 20%]
tests/test_18_data_normalizers_coverage.py ..............................................              [ 22%]
tests/test_19_decorators_coverage.py .........................                                         [ 23%]
tests/test_21_vacancy_repository_coverage.py ........................                                  [ 24%]
tests/test_22_vacancy_validator_coverage.py ..........................................                 [ 26%]
tests/test_23_app_config_coverage.py .....................                                             [ 27%]
tests/test_24_target_companies_coverage.py ..............................................              [ 29%]
tests/test_25_api_config_coverage.py ........................                                          [ 30%]
tests/test_26_ui_config_coverage.py .....................................                              [ 32%]
tests/test_27_db_config_coverage.py ..............................                                     [ 34%]
tests/test_28_hh_api_config_coverage.py .....^C

================================================== FAILURES ==================================================
___________________________________ TestCachedAPI.test_cached_api_request ____________________________________

self = <tests.test_03_api_modules_coverage.TestCachedAPI object at 0x7ff0be547dd0>
mock_mkdir = <MagicMock name='mkdir' id='140671918723408'>
mock_file_cache = <MagicMock name='FileCache' id='140671918733008'>

    @patch('src.api_modules.cached_api.FileCache')
    @patch('pathlib.Path.mkdir')
    def test_cached_api_request(self, mock_mkdir, mock_file_cache):
        """Покрытие кэшированного запроса."""
        api = ConcreteCachedAPI("test_cache")
    
        # Тестируем метод через декоратор, используя простые типы для кэш-ключа
        # Передаем простые hashable параметры
        result = api._cached_api_request("http://test.com", "test_params", "test")
        # Метод возвращает пустой словарь если данных в кэше нет
>       assert result == {}
E       assert None == {}

tests/test_03_api_modules_coverage.py:116: AssertionError
--------------------------------------------- Captured log call ----------------------------------------------
ERROR    src.api_modules.cached_api:cached_api.py:84 Ошибка API запроса в кэшированном методе test: Unexpected error: 'str' object has no attribute 'items'
____________________________________ TestHeadHunterAPI.test_get_vacancies ____________________________________

args = (<tests.test_03_api_modules_coverage.TestHeadHunterAPI object at 0x7ff0be554110>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7ff0be53f590>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.hh_api.HeadHunterAPI'> does not have the attribute '_HeadHunterAPI__connect'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________________ TestConcreteImplementations.test_concrete_db_manager ____________________________

self = <tests.test_06_storage_coverage.TestConcreteImplementations object at 0x7ff0bdf9b510>

    def test_concrete_db_manager(self):
        """Покрытие конкретной реализации AbstractDBManager."""
>       manager = ConcreteDBManager()
                  ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteDBManager with abstract methods check_connection, create_tables, populate_companies_table

tests/test_06_storage_coverage.py:102: TypeError
_______________________ TestTargetCompanies.test_target_companies_search_functionality _______________________

self = <tests.test_09_config_simple.TestTargetCompanies object at 0x7ff0bdfe5610>

    def test_target_companies_search_functionality(self):
        """Покрытие функциональности поиска."""
        # Тестируем что можем получить доступ к списку компаний
        companies = TargetCompanies.COMPANIES
        assert len(companies) > 0
    
        # Найдем компанию напрямую из списка
        yandex_found = False
        for company in companies:
            if company.name == "Яндекс":
                yandex_found = True
                assert company.hh_id == "1740"
                break
>       assert yandex_found
E       assert False

tests/test_09_config_simple.py:176: AssertionError
_______________________________ TestAPIIntegration.test_api_config_integration _______________________________

self = <tests.test_10_api_modules_coverage.TestAPIIntegration object at 0x7ff0bdb14950>

    def test_api_config_integration(self):
        """Покрытие интеграции с конфигурациями."""
        hh_api = HeadHunterAPI()
        sj_api = SuperJobAPI()
    
        # Проверяем что HH API использует конфигурацию
        assert hasattr(hh_api, 'config')
>       assert isinstance(hh_api.config, APIConfig)
E       assert False
E        +  where False = isinstance(HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}), APIConfig)
E        +    where HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}) = <src.api_modules.hh_api.HeadHunterAPI object at 0x7ff0bbac2e50>.config

tests/test_10_api_modules_coverage.py:284: AssertionError
____________________________________ TestUserInterface.test_main_success _____________________________________

self = <MagicMock name='AppConfig' id='140671922806864'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'AppConfig' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_12_user_interface_coverage.TestUserInterface object at 0x7ff0bdb74150>
mock_db_manager_class = <MagicMock name='DBManager' id='140671905199760'>
mock_app_config = <MagicMock name='AppConfig' id='140671922806864'>
mock_storage_factory = <MagicMock name='StorageFactory' id='140671904395280'>
mock_ui = <MagicMock name='UserInterface' id='140671904392400'>

    @patch('src.user_interface.UserInterface')
    @patch('src.user_interface.StorageFactory')
    @patch('src.user_interface.AppConfig')
    @patch('src.storage.db_manager.DBManager')
    def test_main_success(self, mock_db_manager_class, mock_app_config,
                         mock_storage_factory, mock_ui):
        """Покрытие успешного выполнения main()."""
        # Настраиваем мок БД
        mock_db_manager = Mock()
        mock_db_manager._ensure_database_exists.return_value = None
        mock_db_manager.check_connection.return_value = True
        mock_db_manager.create_tables.return_value = None
        mock_db_manager.populate_companies_table.return_value = None
        mock_db_manager.get_companies_and_vacancies_count.return_value = [
            ("Company1", 10), ("Company2", 5)
        ]
        mock_db_manager_class.return_value = mock_db_manager
    
        # Настраиваем мок конфигурации
        mock_config = Mock()
        mock_config.default_storage_type = "postgres"
        mock_app_config.return_value = mock_config
    
        # Настраиваем мок хранилища
        mock_storage = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage
    
        # Настраиваем мок UI
        mock_ui_instance = Mock()
        mock_ui.return_value = mock_ui_instance
    
        # Выполняем функцию
        src.user_interface.main()
    
        # Проверяем что компоненты инициализированы
        mock_db_manager_class.assert_called_once()
>       mock_app_config.assert_called_once()
E       AssertionError: Expected 'AppConfig' to have been called once. Called 0 times.

tests/test_12_user_interface_coverage.py:59: AssertionError
-------------------------------------------- Captured stdout call --------------------------------------------
❌ Ошибка проверки таблиц: 'Mock' object does not support the context manager protocol
__________________________ TestUserInterfaceIntegration.test_full_integration_flow ___________________________

self = <Mock name='DBManager()._ensure_database_exists' id='140671905118032'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected '_ensure_database_exists' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_12_user_interface_coverage.TestUserInterfaceIntegration object at 0x7ff0bdb7c810>
mock_logger = <MagicMock name='logger' id='140671916952400'>
mock_ui = <MagicMock name='UserInterface' id='140671905361104'>
mock_storage_factory = <MagicMock name='StorageFactory' id='140671905360144'>
mock_app_config = <MagicMock name='AppConfig' id='140671905418576'>
mock_db_manager_class = <MagicMock name='DBManager' id='140671905424272'>
mock_logging_config = <MagicMock name='basicConfig' id='140671905422800'>

    @patch('src.user_interface.logging.basicConfig')
    @patch('src.storage.db_manager.DBManager')
    @patch('src.user_interface.AppConfig')
    @patch('src.user_interface.StorageFactory')
    @patch('src.user_interface.UserInterface')
    @patch('src.user_interface.logger')
    def test_full_integration_flow(self, mock_logger, mock_ui, mock_storage_factory,
                                  mock_app_config, mock_db_manager_class, mock_logging_config):
        """Покрытие полного потока интеграции компонентов."""
        # Настраиваем все моки для успешного сценария
        mock_db_manager = Mock()
        mock_db_manager._ensure_database_exists.return_value = None
        mock_db_manager.check_connection.return_value = True
        mock_db_manager.create_tables.return_value = None
        mock_db_manager.populate_companies_table.return_value = None
        mock_db_manager.get_companies_and_vacancies_count.return_value = [
            ("Company1", 10), ("Company2", 5), ("Company3", 3)
        ]
        mock_db_manager_class.return_value = mock_db_manager
    
        mock_config = Mock()
        mock_config.storage_type = "postgres"
        mock_app_config.return_value = mock_config
    
        mock_storage = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage
    
        mock_ui_instance = Mock()
        mock_ui.return_value = mock_ui_instance
    
        # Выполняем функцию
        src.user_interface.main()
    
        # Проверяем порядок вызовов
        mock_logger.info.assert_called()
>       mock_db_manager._ensure_database_exists.assert_called_once()
E       AssertionError: Expected '_ensure_database_exists' to have been called once. Called 0 times.

tests/test_12_user_interface_coverage.py:345: AssertionError
-------------------------------------------- Captured stdout call --------------------------------------------
❌ Ошибка проверки таблиц: 'Mock' object does not support the context manager protocol
____________________________ TestDisplayCompanyStats.test_vacancy_with_exception _____________________________

self = <MagicMock name='print' id='140671916911760'>
args = ('Ошибка обработки вакансии для статистики: Test error',), kwargs = {}
expected = call('Ошибка обработки вакансии для статистики: Test error'), cause = None
actual = [call('Статистика по компаниям: 1 вакансий'), call('\nТоп компаний по количеству вакансий:'), call('  Неизвестная компания: 1 вакансий')]
expected_string = "print('Ошибка обработки вакансии для статистики: Test error')"

    def assert_any_call(self, /, *args, **kwargs):
        """assert the mock has been called with the specified arguments.
    
        The assert passes if the mock has *ever* been called, unlike
        `assert_called_with` and `assert_called_once_with` that only pass if
        the call is the most recent one."""
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        cause = expected if isinstance(expected, Exception) else None
        actual = [self._call_matcher(c) for c in self.call_args_list]
        if cause or expected not in _AnyComparer(actual):
            expected_string = self._format_mock_call_signature(args, kwargs)
>           raise AssertionError(
                '%s call not found' % expected_string
            ) from cause
E           AssertionError: print('Ошибка обработки вакансии для статистики: Test error') call not found

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1010: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_14_vacancy_stats_coverage.TestDisplayCompanyStats object at 0x7ff0bdbe4150>
mock_print = <MagicMock name='print' id='140671916911760'>

    @patch('builtins.print')
    def test_vacancy_with_exception(self, mock_print):
        """Покрытие исключения при обработке вакансии."""
        # Создаем mock объект, который будет вызывать исключение при доступе к employer.name
        mock_vacancy = Mock()
        mock_employer = Mock()
    
        # Настраиваем property name чтобы вызывал исключение при обращении
        def raise_error():
            raise Exception("Test error")
    
        type(mock_employer).name = property(lambda self: raise_error())
        mock_vacancy.employer = mock_employer
    
        stats = VacancyStats()
        stats.display_company_stats([mock_vacancy])
    
        # Проверяем что сообщение об ошибке было выведено
>       mock_print.assert_any_call("Ошибка обработки вакансии для статистики: Test error")
E       AssertionError: print('Ошибка обработки вакансии для статистики: Test error') call not found
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('  Неизвестн... 1 вакансий',) == ('Ошибка обра... Test error',)
E         
E         At index 0 diff: '  Неизвестная компания: 1 вакансий' != 'Ошибка обработки вакансии для статистики: Test error'
E         Use -v to get more diff

tests/test_14_vacancy_stats_coverage.py:310: AssertionError
========================================== short test summary info ===========================================
FAILED tests/test_03_api_modules_coverage.py::TestCachedAPI::test_cached_api_request - assert None == {}
FAILED tests/test_03_api_modules_coverage.py::TestHeadHunterAPI::test_get_vacancies - AttributeError: <class 'src.api_modules.hh_api.HeadHunterAPI'> does not have the attribute '_HeadHunterAP...
FAILED tests/test_06_storage_coverage.py::TestConcreteImplementations::test_concrete_db_manager - TypeError: Can't instantiate abstract class ConcreteDBManager with abstract methods check_connection, cre...
FAILED tests/test_09_config_simple.py::TestTargetCompanies::test_target_companies_search_functionality - assert False
FAILED tests/test_10_api_modules_coverage.py::TestAPIIntegration::test_api_config_integration - assert False
FAILED tests/test_12_user_interface_coverage.py::TestUserInterface::test_main_success - AssertionError: Expected 'AppConfig' to have been called once. Called 0 times.
FAILED tests/test_12_user_interface_coverage.py::TestUserInterfaceIntegration::test_full_integration_flow - AssertionError: Expected '_ensure_database_exists' to have been called once. Called 0 times.
FAILED tests/test_14_vacancy_stats_coverage.py::TestDisplayCompanyStats::test_vacancy_with_exception - AssertionError: print('Ошибка обработки вакансии для статистики: Test error') call not found