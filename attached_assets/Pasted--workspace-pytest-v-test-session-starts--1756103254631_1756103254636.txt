~/workspace$ pytest -v
================================ test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.14.1
collected 131 items                                                                 

tests/test_api_modules.py::TestHeadHunterAPI::test_api_initialization PASSED  [  0%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_valid PASSED [  1%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_invalid PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_page_success PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_empty_response PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_empty_response_structure PASSED [  4%]
tests/test_api_modules.py::TestSuperJobAPI::test_api_initialization_with_custom_key PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_valid PASSED [  6%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_invalid PASSED [  6%]
tests/test_api_modules.py::TestSuperJobAPI::test_get_vacancies_page_with_source PASSED [  7%]
tests/test_api_modules.py::TestSuperJobAPI::test_empty_response_structure PASSED [  8%]
tests/test_cache.py::TestFileCache::test_cache_initialization PASSED          [  9%]
tests/test_cache.py::TestFileCache::test_generate_params_hash PASSED          [  9%]
tests/test_cache.py::TestFileCache::test_generate_params_hash_different_params PASSED [ 10%]
tests/test_cache.py::TestFileCache::test_save_and_load_response PASSED        [ 11%]
tests/test_cache.py::TestFileCache::test_load_response_nonexistent PASSED     [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_source PASSED            [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_all PASSED               [ 13%]
tests/test_cache.py::TestFileCache::test_cache_with_complex_params PASSED     [ 14%]
tests/test_cache.py::TestFileCache::test_cache_file_corrupted PASSED          [ 15%]
tests/test_cache.py::TestFileCache::test_cache_unicode_support PASSED         [ 16%]
tests/test_config.py::TestAppConfig::test_default_initialization PASSED       [ 16%]
tests/test_config.py::TestAppConfig::test_get_storage_type PASSED             [ 17%]
tests/test_config.py::TestAppConfig::test_set_storage_type_valid PASSED       [ 18%]
tests/test_config.py::TestAppConfig::test_set_storage_type_invalid PASSED     [ 19%]
tests/test_config.py::TestAppConfig::test_get_db_config PASSED                [ 19%]
tests/test_config.py::TestAppConfig::test_db_config_from_env PASSED           [ 20%]
tests/test_config.py::TestDatabaseConfig::test_default_initialization SKIPPED [ 21%]
tests/test_config.py::TestDatabaseConfig::test_initialization_with_env PASSED [ 22%]
tests/test_config.py::TestDatabaseConfig::test_get_connection_params PASSED   [ 22%]
tests/test_config.py::TestDatabaseConfig::test_get_dsn PASSED                 [ 23%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_success PASSED [ 24%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_failure PASSED [ 25%]
tests/test_config.py::TestHHAPIConfig::test_initialization SKIPPED (HHAPI...) [ 25%]
tests/test_config.py::TestHHAPIConfig::test_get_headers PASSED                [ 26%]
tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url PASSED          [ 27%]
tests/test_config.py::TestHHAPIConfig::test_get_employers_url PASSED          [ 28%]
tests/test_config.py::TestHHAPIConfig::test_get_areas_url PASSED              [ 29%]
tests/test_config.py::TestHHAPIConfig::test_get_request_params PASSED         [ 29%]
tests/test_config.py::TestSJAPIConfig::test_initialization PASSED             [ 30%]
tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key PASSED [ 31%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key PASSED    [ 32%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key PASSED       [ 32%]
tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url PASSED          [ 33%]
tests/test_config.py::TestSJAPIConfig::test_set_secret_key PASSED             [ 34%]
tests/test_config.py::TestSJAPIConfig::test_is_configured PASSED              [ 35%]
tests/test_config.py::TestSJAPIConfig::test_get_request_params PASSED         [ 35%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED   [ 36%]
tests/test_db_manager.py::TestDBManager::test_get_connection_failure PASSED   [ 37%]
tests/test_db_manager.py::TestDBManager::test_create_tables_success PASSED    [ 38%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table PASSED [ 38%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count PASSED [ 39%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies PASSED        [ 40%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED           [ 41%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED   [ 41%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary PASSED [ 42%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword PASSED [ 43%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 44%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats PASSED       [ 45%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success PASSED [ 45%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [ 46%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED  [ 47%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration FAILED [ 48%]
tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration FAILED [ 48%]
tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration FAILED [ 49%]
tests/test_integration.py::TestCacheIntegration::test_cached_api_integration FAILED [ 50%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow FAILED [ 51%]
tests/test_integration.py::TestFullWorkflowIntegration::test_error_handling_integration PASSED [ 51%]
tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration FAILED [ 52%]
tests/test_storage.py::TestPostgresSaver::test_postgres_saver_initialization PASSED [ 53%]
tests/test_storage.py::TestPostgresSaver::test_get_connection PASSED          [ 54%]
tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data FAILED [ 54%]
tests/test_storage.py::TestPostgresSaver::test_ensure_database_exists PASSED  [ 55%]
tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data FAILED     [ 56%]
tests/test_storage.py::TestStorageFactory::test_get_storage_postgres FAILED   [ 57%]
tests/test_storage.py::TestStorageFactory::test_get_storage_invalid_type PASSED [ 58%]
tests/test_storage.py::TestStorageFactory::test_get_storage_missing_config PASSED [ 58%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_valid PASSED [ 59%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_invalid_then_valid PASSED [ 60%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_non_numeric PASSED [ 61%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_title PASSED [ 61%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_description PASSED [ 62%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_case_insensitive PASSED [ 63%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_no_matches PASSED [ 64%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_both_values PASSED [ 64%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_min PASSED [ 65%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_max PASSED [ 66%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_single_value PASSED [ 67%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_invalid_format PASSED [ 67%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_empty_string PASSED [ 68%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_with_spaces PASSED [ 69%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief PASSED [ 70%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_number PASSED [ 70%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_salary PASSED [ 71%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_partial_salary PASSED [ 72%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_dict PASSED [ 73%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_object PASSED [ 74%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_display_vacancy_info PASSED [ 74%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_dict PASSED [ 75%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_company_info PASSED [ 76%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_company_name PASSED [ 77%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_salary_info PASSED [ 77%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_description PASSED [ 78%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_responsibilities PASSED [ 79%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_requirements PASSED [ 80%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_conditions PASSED [ 80%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines PASSED [ 81%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines_with_api_url PASSED [ 82%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_object PASSED [ 83%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_dict PASSED [ 83%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_none PASSED [ 84%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_with_dict_salary PASSED [ 85%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_without_salary PASSED [ 86%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_string_representation PASSED [ 87%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison PASSED     [ 87%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_equality PASSED       [ 88%]
tests/test_vacancy_models.py::TestSalary::test_salary_creation_from_dict PASSED [ 89%]
tests/test_vacancy_models.py::TestSalary::test_salary_string_representation PASSED [ 90%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_from PASSED        [ 90%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_to PASSED          [ 91%]
tests/test_vacancy_models.py::TestSalary::test_salary_comparison PASSED       [ 92%]
tests/test_vacancy_models.py::TestSalary::test_source_detection_from_dict PASSED [ 93%]
tests/test_vacancy_models.py::TestSalary::test_source_fallback_detection PASSED [ 93%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_get_vacancies_with_salary PASSED [ 95%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_sort_vacancies_by_salary PASSED [ 96%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_filter_vacancies_by_multiple_keywords PASSED [ 96%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_and_operator PASSED [ 97%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_or_operator PASSED [ 98%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_simple_query PASSED [ 99%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_vacancy_operations_basic_functionality PASSED [100%]

===================================== FAILURES ======================================
_________________ TestAPIIntegration.test_hh_api_search_integration _________________

self = <tests.test_integration.TestAPIIntegration object at 0x7f156aba36d0>
mock_get = <MagicMock name='get' id='139729957338448'>
mock_hh_response = {'found': 1, 'items': [{'area': {'id': '1', 'name': 'Москва'}, 'employer': {'id': '1', 'name': 'Test Company'}, 'emplo...ная занятость'}, 'experience': {'id': 'between1And3', 'name': 'От 1 года до 3 лет'}, ...}], 'page': 0, 'pages': 1, ...}

    @patch('requests.get')
    def test_hh_api_search_integration(self, mock_get, mock_hh_response):
        """Интеграционный тест поиска через HH API"""
        # Настраиваем мок ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = mock_hh_response
        mock_get.return_value = mock_response
    
        # Создаем API и выполняем поиск
        api = HeadHunterAPI()
        vacancies = api.get_vacancies("python", area="1")
    
        # Проверяем результат
>       assert len(vacancies) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_integration.py:92: AssertionError
------------------------------- Captured stderr call --------------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00,  6.61page/s, vacancies=0]
_________________ TestAPIIntegration.test_sj_api_search_integration _________________

self = <tests.test_integration.TestAPIIntegration object at 0x7f156aba0490>
mock_get = <MagicMock name='get' id='139729957257872'>

    @patch('requests.get')
    def test_sj_api_search_integration(self, mock_get):
        """Интеграционный тест поиска через SJ API"""
        mock_sj_response = {
            "objects": [
                {
                    "id": 67890,
                    "profession": "Java Developer",
                    "link": "https://www.superjob.ru/vakansii/java-developer-67890.html",
                    "payment_from": 120000,
                    "payment_to": 180000,
                    "currency": "rub",
                    "candidat": "Знание Java",
                    "work": "Разработка систем",
                    "firm_name": "SJ Test Company",
                    "town": {
                        "id": 4,
                        "title": "Москва"
                    },
                    "experience": {
                        "id": 2,
                        "title": "От 1 года до 3 лет"
                    },
                    "type_of_work": {
                        "id": 1,
                        "title": "Полная занятость"
                    },
                    "place_of_work": {
                        "id": 1,
                        "title": "Полный день"
                    },
                    "date_pub_timestamp": 1705312800
                }
            ],
            "total": 1
        }
    
        # Настраиваем мок ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = mock_sj_response
        mock_get.return_value = mock_response
    
        # Создаем API с тестовым ключом
        api = SuperJobAPI()
        api.config.secret_key = "test_key"
        vacancies = api.get_vacancies("java", town=4)
    
        # Проверяем результат
        assert len(vacancies) == 1
>       assert isinstance(vacancies[0], Vacancy)
E       AssertionError: assert False
E        +  where False = isinstance({'candidat': 'Знание Java', 'currency': 'rub', 'date_pub_timestamp': 1705312800, 'experience': {'id': 2, 'title': 'От 1 года до 3 лет'}, ...}, Vacancy)

tests/test_integration.py:147: AssertionError
------------------------------- Captured stderr call --------------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 2775.85page/s, vacancies=1]
______________ TestStorageIntegration.test_postgres_saver_integration _______________

self = <tests.test_integration.TestStorageIntegration object at 0x7f156aba0cd0>
mock_connect = <MagicMock name='connect' id='139729961508560'>
sample_vacancies = [<src.vacancies.models.Vacancy object at 0x7f156ab17b60>, <src.vacancies.models.Vacancy object at 0x7f156a7ece60>]

    @patch('src.storage.postgres_saver.psycopg2.connect')
    def test_postgres_saver_integration(self, mock_connect, sample_vacancies):
        """Интеграционный тест PostgresSaver"""
        # Настраиваем мок соединения
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.cursor.return_value = mock_cursor
    
        # Настраиваем мок для существования БД и таблиц
        mock_cursor.fetchone.side_effect = [
            [True],  # DB exists check
            None,    # Source column check
            None,    # Company_id column check
            [],      # Company mapping query
            []       # Existing vacancies check
        ]
        mock_cursor.fetchall.return_value = []
    
        # Создаем сохранялку
        db_config = {
            'host': 'localhost',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
    
        with patch.object(PostgresSaver, '_ensure_database_exists'), \
             patch.object(PostgresSaver, '_ensure_tables_exist'), \
             patch.object(PostgresSaver, '_ensure_companies_table_exists'):
    
            saver = PostgresSaver(db_config)
    
            # Сохраняем вакансии
>           messages = saver.add_vacancy(sample_vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:485: in add_vacancy
    return self._add_vacancy_small_batch(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:705: in _add_vacancy_small_batch
    execute_values(cursor, insert_query, insert_data, template=None, page_size=100)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='connect().cursor()' id='139729980711440'>
sql = '\n                INSERT INTO vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary... employment, schedule, employer, area, source, published_at, company_id\n                ) VALUES %s\n                '
argslist = [('test_1', 'Python Developer', 'https://test.com/vacancy/1', 100000, 150000, 'RUR', ...), ('test_2', 'Java Developer', 'https://test.com/vacancy/2', 120000, 180000, 'RUR', ...)]
template = None, page_size = 100, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='connect().cursor().connection.encoding' id='139729957453136'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
_________________ TestCacheIntegration.test_cached_api_integration __________________

self = <tests.test_integration.TestCacheIntegration object at 0x7f156ab84550>
mock_get = <MagicMock name='get' id='139729961760080'>
temp_cache_dir = '/tmp/tmp34wtipoz'

    @patch('requests.get')
    def test_cached_api_integration(self, mock_get, temp_cache_dir):
        """Интеграционный тест кэширования API"""
        from src.api_modules.cached_api import CachedAPI
    
        # Мок ответ от API
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [],
            "found": 0
        }
        mock_get.return_value = mock_response
    
        # Создаем кэшированное API
        hh_api = HeadHunterAPI()
        file_cache = FileCache(temp_cache_dir)
>       cached_api = CachedAPI(hh_api, file_cache, 'hh')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_integration.py:258: TypeError
_____________ TestFullWorkflowIntegration.test_search_and_save_workflow _____________

args = (<tests.test_integration.TestFullWorkflowIntegration object at 0x7f156ab84410>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
___________ TestFullWorkflowIntegration.test_data_consistency_integration ___________

self = <tests.test_integration.TestFullWorkflowIntegration object at 0x7f156ab85850>
mock_get = <MagicMock name='get' id='139729961711056'>

    @patch('requests.get')
    def test_data_consistency_integration(self, mock_get):
        """Тест консистентности данных между компонентами"""
        # Мок ответ от HH API
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "test_123",
                    "name": "Test Position",
                    "url": "https://api.hh.ru/vacancies/test_123",
                    "salary": {
                        "from": 50000,
                        "to": 100000,
                        "currency": "RUR"
                    },
                    "snippet": {
                        "requirement": "Test requirement",
                        "responsibility": "Test responsibility"
                    },
                    "employer": {"name": "Test Employer"},
                    "area": {"name": "Test City"},
                    "experience": {"name": "Test Experience"},
                    "employment": {"name": "Test Employment"},
                    "schedule": {"name": "Test Schedule"},
                    "published_at": "2024-01-15T10:00:00+0300"
                }
            ],
            "found": 1
        }
        mock_get.return_value = mock_response
    
        # Получаем данные через API
        api = HeadHunterAPI()
        vacancies = api.get_vacancies("test")
    
        # Проверяем, что данные корректно преобразованы
>       assert len(vacancies) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_integration.py:401: AssertionError
------------------------------- Captured stderr call --------------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00,  6.61page/s, vacancies=0]
________________ TestPostgresSaver.test_add_vacancy_with_sample_data ________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f156ab0f510>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f156ab94bd0>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f156a7ed400>

    def test_add_vacancy_with_sample_data(self, postgres_saver, sample_vacancy):
        """Тест добавления вакансии с примерными данными"""
        with patch.object(postgres_saver, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_get_conn.return_value = mock_connection
            mock_connection.cursor.return_value = mock_cursor
            mock_cursor.__enter__ = Mock(return_value=mock_cursor)
            mock_cursor.__exit__ = Mock(return_value=None)
            mock_cursor.fetchall.return_value = []
            # Мокаем connection для psycopg2
            mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
            mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
            mock_connection.encoding = 'UTF8'
    
>           result = postgres_saver.add_vacancy([sample_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:485: in add_vacancy
    return self._add_vacancy_small_batch(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:705: in _add_vacancy_small_batch
    execute_values(cursor, insert_query, insert_data, template=None, page_size=100)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='_get_connection().cursor()' id='139729961201424'>
sql = '\n                INSERT INTO vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary... employment, schedule, employer, area, source, published_at, company_id\n                ) VALUES %s\n                '
argslist = [('12345', 'Python Developer', 'https://hh.ru/vacancy/12345', 100000, 150000, 'RUR', ...)]
template = None, page_size = 100, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='_get_connection().cursor().connection.encoding' id='139729961203088'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
------------------------------- Captured stderr call --------------------------------
ERROR:src.storage.postgres_saver:Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
--------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:538 Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
____________________ TestPostgresSaver.test_format_vacancy_data _____________________

self = <tests.test_storage.TestPostgresSaver object at 0x7f156ab0e5d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f156a75c290>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f156a7ecc80>

    def test_format_vacancy_data(self, postgres_saver, sample_vacancy):
        """Тест форматирования данных вакансии"""
        # Метод _format_vacancy_data был удален, тестируем через add_vacancy
        with patch.object(postgres_saver, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_get_conn.return_value = mock_connection
            mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
            mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
            mock_cursor.fetchall.return_value = []
    
            # Проверяем, что метод add_vacancy работает
>           result = postgres_saver.add_vacancy([sample_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:485: in add_vacancy
    return self._add_vacancy_small_batch(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f156a75c290>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f156a7ecc80>]

    def _add_vacancy_small_batch(self, vacancies: List[Vacancy]) -> List[str]:
        """Оригинальный алгоритм для небольших batch-операций"""
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor(cursor_factory=RealDictCursor)
    
            # Получаем соответствие employer -> company_id из таблицы companies
            company_mapping = {}
            try:
                # Ensure companies table exists before querying
                self._ensure_companies_table_exists()
    
                cursor.execute("SELECT hh_id, company_id, name FROM companies")
                companies = cursor.fetchall()
    
                for company in companies:
                    hh_id, company_id, name = company
                    company_mapping[hh_id] = company_id
                    company_mapping[name.lower()] = company_id
    
                    # Добавляем альтернативные названия
                    alt_names = {
                        'Яндекс': ['яндекс'],
                        'Тинькофф': ['т-банк', 'tinkoff', 'тинькофф'],
                        'Сбер': ['сбербанк', 'сбер', 'sberbank'],
                        'Wildberries': ['wildberries', 'wb'],
                        'Ozon': ['ozon'],
                        'VK': ['vk', 'вконтакте', 'вк'],
                        'Kaspersky': ['kaspersky', 'лаборатория касперского'],
                        'Авито': ['авито', 'avito'],
                        'X5 Retail Group': ['x5', 'x5 retail group'],
                        'Ростелеком': ['ростелеком', 'rostelecom'], # Removed 'билайн' as it's a different company
                        'Альфа-Банк': ['альфа-банк', 'alfa-bank'],
                        'JetBrains': ['jetbrains'],
                        '2GIS': ['2гис', '2gis'],
                        'Skyeng': ['skyeng'],
                        'Delivery Club': ['delivery club']
                    }
    
                    if name in alt_names:
                        for alt_name in alt_names[name]:
                            company_mapping[alt_name.lower()] = company_id
    
            except Exception as e:
                logger.error(f"Ошибка при получении соответствия компаний: {e}")
    
    
            # Batch проверка существования вакансий
            vacancy_ids = [v.vacancy_id for v in vacancies]
            placeholders = ','.join(['%s'] * len(vacancy_ids))
    
            cursor.execute(
                f"SELECT vacancy_id, title, url, description, salary_from, salary_to, salary_currency, company_id FROM vacancies WHERE vacancy_id IN ({placeholders})",
                vacancy_ids
            )
    
>           existing_map = {row['vacancy_id']: row for row in cursor.fetchall()}
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:550: TypeError
------------------------------- Captured stderr call --------------------------------
ERROR:src.storage.postgres_saver:Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
--------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:538 Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
___________________ TestStorageFactory.test_get_storage_postgres ____________________

self = <tests.test_storage.TestStorageFactory object at 0x7f156ab0c6d0>

    def test_get_storage_postgres(self):
        """Тест получения PostgreSQL хранилища"""
        config = {'type': 'postgres', 'host': 'localhost'}
    
        with patch.object(PostgresSaver, '_ensure_database_exists'), \
             patch.object(PostgresSaver, '_ensure_tables_exist'), \
             patch.object(PostgresSaver, '_ensure_companies_table_exists'):
>           storage = StorageFactory.create_storage(config)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

storage_type = {'host': 'localhost', 'type': 'postgres'}

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: {'type': 'postgres', 'host': 'localhost'}

src/storage/storage_factory.py:22: ValueError
============================== short test summary info ==============================
FAILED tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration - assert 0 == 1
FAILED tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration - AssertionError: assert False
FAILED tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration - KeyError: <Mock name='connect().cursor().connection.encoding' id='139729957453136'>
FAILED tests/test_integration.py::TestCacheIntegration::test_cached_api_integration - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get...
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow - AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration - assert 0 == 1
FAILED tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data - KeyError: <Mock name='_get_connection().cursor().connection.encoding' id='139729...
FAILED tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data - TypeError: 'Mock' object is not iterable
FAILED tests/test_storage.py::TestStorageFactory::test_get_storage_postgres - ValueError: Поддерживается только PostgreSQL хранилище, получен: {'type': 'postg...
===================== 9 failed, 120 passed, 2 skipped in 1.57s ======================
~/workspace$ 