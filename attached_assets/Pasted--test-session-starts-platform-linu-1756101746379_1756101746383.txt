================================ test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.14.1
collected 131 items                                                                 

tests/test_api_modules.py::TestHeadHunterAPI::test_api_initialization PASSED  [  0%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_valid PASSED [  1%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_invalid PASSED [  2%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_page_success PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_empty_response PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_empty_response_structure PASSED [  4%]
tests/test_api_modules.py::TestSuperJobAPI::test_api_initialization_with_custom_key PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_valid PASSED [  6%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_invalid PASSED [  6%]
tests/test_api_modules.py::TestSuperJobAPI::test_get_vacancies_page_with_source PASSED [  7%]
tests/test_api_modules.py::TestSuperJobAPI::test_empty_response_structure PASSED [  8%]
tests/test_cache.py::TestFileCache::test_cache_initialization PASSED          [  9%]
tests/test_cache.py::TestFileCache::test_generate_params_hash PASSED          [  9%]
tests/test_cache.py::TestFileCache::test_generate_params_hash_different_params PASSED [ 10%]
tests/test_cache.py::TestFileCache::test_save_and_load_response PASSED        [ 11%]
tests/test_cache.py::TestFileCache::test_load_response_nonexistent PASSED     [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_source PASSED            [ 12%]
tests/test_cache.py::TestFileCache::test_clear_cache_all PASSED               [ 13%]
tests/test_cache.py::TestFileCache::test_cache_with_complex_params PASSED     [ 14%]
tests/test_cache.py::TestFileCache::test_cache_file_corrupted PASSED          [ 15%]
tests/test_cache.py::TestFileCache::test_cache_unicode_support PASSED         [ 16%]
tests/test_config.py::TestAppConfig::test_default_initialization PASSED       [ 16%]
tests/test_config.py::TestAppConfig::test_get_storage_type PASSED             [ 17%]
tests/test_config.py::TestAppConfig::test_set_storage_type_valid PASSED       [ 18%]
tests/test_config.py::TestAppConfig::test_set_storage_type_invalid PASSED     [ 19%]
tests/test_config.py::TestAppConfig::test_get_db_config PASSED                [ 19%]
tests/test_config.py::TestAppConfig::test_db_config_from_env PASSED           [ 20%]
tests/test_config.py::TestDatabaseConfig::test_default_initialization FAILED  [ 21%]
tests/test_config.py::TestDatabaseConfig::test_initialization_with_env FAILED [ 22%]
tests/test_config.py::TestDatabaseConfig::test_get_connection_params FAILED   [ 22%]
tests/test_config.py::TestDatabaseConfig::test_get_dsn FAILED                 [ 23%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_success FAILED [ 24%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_failure FAILED [ 25%]
tests/test_config.py::TestHHAPIConfig::test_initialization FAILED             [ 25%]
tests/test_config.py::TestHHAPIConfig::test_get_headers FAILED                [ 26%]
tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url FAILED          [ 27%]
tests/test_config.py::TestHHAPIConfig::test_get_employers_url FAILED          [ 28%]
tests/test_config.py::TestHHAPIConfig::test_get_areas_url FAILED              [ 29%]
tests/test_config.py::TestHHAPIConfig::test_get_request_params FAILED         [ 29%]
tests/test_config.py::TestSJAPIConfig::test_initialization FAILED             [ 30%]
tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key FAILED [ 31%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key FAILED    [ 32%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key FAILED       [ 32%]
tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url FAILED          [ 33%]
tests/test_config.py::TestSJAPIConfig::test_set_secret_key FAILED             [ 34%]
tests/test_config.py::TestSJAPIConfig::test_is_configured FAILED              [ 35%]
tests/test_config.py::TestSJAPIConfig::test_get_request_params FAILED         [ 35%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED   [ 36%]
tests/test_db_manager.py::TestDBManager::test_get_connection_failure PASSED   [ 37%]
tests/test_db_manager.py::TestDBManager::test_create_tables_success PASSED    [ 38%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table FAILED [ 38%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count FAILED [ 39%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies PASSED        [ 40%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED           [ 41%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED   [ 41%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary PASSED [ 42%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword PASSED [ 43%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 44%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats PASSED       [ 45%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success PASSED [ 45%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [ 46%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED  [ 47%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration FAILED [ 48%]
tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration FAILED [ 48%]
tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration FAILED [ 49%]
tests/test_integration.py::TestCacheIntegration::test_cached_api_integration FAILED [ 50%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow FAILED [ 51%]
tests/test_integration.py::TestFullWorkflowIntegration::test_error_handling_integration FAILED [ 51%]
tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration FAILED [ 52%]
tests/test_storage.py::TestPostgresSaver::test_postgres_saver_initialization PASSED [ 53%]
tests/test_storage.py::TestPostgresSaver::test_get_connection PASSED          [ 54%]
tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data FAILED [ 54%]
tests/test_storage.py::TestPostgresSaver::test_ensure_database_exists PASSED  [ 55%]
tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data FAILED     [ 56%]
tests/test_storage.py::TestStorageFactory::test_get_storage_postgres FAILED   [ 57%]
tests/test_storage.py::TestStorageFactory::test_get_storage_invalid_type FAILED [ 58%]
tests/test_storage.py::TestStorageFactory::test_get_storage_missing_config FAILED [ 58%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_valid PASSED [ 59%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_invalid_then_valid PASSED [ 60%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_non_numeric PASSED [ 61%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_title PASSED [ 61%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_description PASSED [ 62%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_case_insensitive PASSED [ 63%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_no_matches PASSED [ 64%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_both_values PASSED [ 64%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_min PASSED [ 65%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_max PASSED [ 66%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_single_value PASSED [ 67%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_invalid_format PASSED [ 67%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_empty_string PASSED [ 68%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_with_spaces PASSED [ 69%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief ERROR [ 70%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_number ERROR [ 70%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_salary ERROR [ 71%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_partial_salary ERROR [ 72%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_dict PASSED [ 73%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_object ERROR [ 74%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_display_vacancy_info ERROR [ 74%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_dict PASSED [ 75%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_company_info PASSED [ 76%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_company_name PASSED [ 77%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_salary_info PASSED [ 77%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_description PASSED [ 78%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_responsibilities ERROR [ 79%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_requirements ERROR [ 80%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_conditions ERROR [ 80%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines ERROR [ 81%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines_with_api_url ERROR [ 82%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_object ERROR [ 83%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_dict PASSED [ 83%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_none PASSED [ 84%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_with_dict_salary PASSED [ 85%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_without_salary PASSED [ 86%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_string_representation PASSED [ 87%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison PASSED     [ 87%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_equality PASSED       [ 88%]
tests/test_vacancy_models.py::TestSalary::test_salary_creation_from_dict PASSED [ 89%]
tests/test_vacancy_models.py::TestSalary::test_salary_string_representation PASSED [ 90%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_from PASSED        [ 90%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_to PASSED          [ 91%]
tests/test_vacancy_models.py::TestSalary::test_salary_comparison PASSED       [ 92%]
tests/test_vacancy_models.py::TestSalary::test_source_detection_from_dict PASSED [ 93%]
tests/test_vacancy_models.py::TestSalary::test_source_fallback_detection PASSED [ 93%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_get_vacancies_with_salary PASSED [ 95%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_sort_vacancies_by_salary PASSED [ 96%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_filter_vacancies_by_multiple_keywords PASSED [ 96%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_and_operator PASSED [ 97%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_or_operator PASSED [ 98%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_simple_query PASSED [ 99%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_vacancy_operations_basic_functionality PASSED [100%]

====================================== ERRORS =======================================
_________ ERROR at setup of TestVacancyFormatter.test_format_vacancy_brief __________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7345750>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
____ ERROR at setup of TestVacancyFormatter.test_format_vacancy_brief_no_number _____

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7345150>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
____ ERROR at setup of TestVacancyFormatter.test_format_vacancy_brief_no_salary _____

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7345510>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
__ ERROR at setup of TestVacancyFormatter.test_format_vacancy_brief_partial_salary __

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7345790>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
____ ERROR at setup of TestVacancyFormatter.test_format_vacancy_info_with_object ____

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7345fd0>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
_________ ERROR at setup of TestVacancyFormatter.test_display_vacancy_info __________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d7347e50>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
_______ ERROR at setup of TestVacancyFormatter.test_extract_responsibilities ________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d77f9690>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
_________ ERROR at setup of TestVacancyFormatter.test_extract_requirements __________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d77f8410>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
__________ ERROR at setup of TestVacancyFormatter.test_extract_conditions ___________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d77da790>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
__________ ERROR at setup of TestVacancyFormatter.test_build_vacancy_lines __________

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d77f3bd0>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
___ ERROR at setup of TestVacancyFormatter.test_build_vacancy_lines_with_api_url ____

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d853fa90>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
_______ ERROR at setup of TestVacancyFormatter.test_format_salary_with_object _______

self = <tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fe2d77da150>

    @pytest.fixture
    def sample_salary(self):
        """Фикстура для тестовой зарплаты"""
>       return Salary(100000, 150000, "RUR")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_vacancy_formatter.py:19: TypeError
===================================== FAILURES ======================================
__________________ TestDatabaseConfig.test_default_initialization ___________________

self = <tests.test_config.TestDatabaseConfig object at 0x7fe2d77d1190>

    def test_default_initialization(self):
        """Тест инициализации по умолчанию"""
        config = DatabaseConfig()
    
>       assert config.host == 'localhost'
               ^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'host'

tests/test_config.py:81: AttributeError
__________________ TestDatabaseConfig.test_initialization_with_env __________________

self = <tests.test_config.TestDatabaseConfig object at 0x7fe2d77d1710>

    @patch.dict(os.environ, {
        'PGHOST': 'custom_host',
        'PGPORT': '5433',
        'PGDATABASE': 'custom_db',
        'PGUSER': 'custom_user',
        'PGPASSWORD': 'custom_pass'
    })
    def test_initialization_with_env(self):
        """Тест инициализации с переменными окружения"""
        config = DatabaseConfig()
    
>       assert config.host == 'custom_host'
               ^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'host'

tests/test_config.py:98: AttributeError
___________________ TestDatabaseConfig.test_get_connection_params ___________________

self = <tests.test_config.TestDatabaseConfig object at 0x7fe2d77d1d10>

    def test_get_connection_params(self):
        """Тест получения параметров подключения"""
        config = DatabaseConfig()
        params = config.get_connection_params()
    
        expected_keys = {'host', 'port', 'database', 'user', 'password'}
        assert set(params.keys()) == expected_keys
    
>       assert params['host'] == config.host
                                 ^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'host'

tests/test_config.py:112: AttributeError
__________________________ TestDatabaseConfig.test_get_dsn __________________________

self = <tests.test_config.TestDatabaseConfig object at 0x7fe2d77d2350>

    def test_get_dsn(self):
        """Тест получения DSN строки"""
        config = DatabaseConfig()
>       dsn = config.get_dsn()
              ^^^^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'get_dsn'

tests/test_config.py:121: AttributeError
__________________ TestDatabaseConfig.test_test_connection_success __________________

args = (<tests.test_config.TestDatabaseConfig object at 0x7fe2d77d2910>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.config.db_config.psycopg2'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.config.db_config' has no attribute 'psycopg2'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
__________________ TestDatabaseConfig.test_test_connection_failure __________________

args = (<tests.test_config.TestDatabaseConfig object at 0x7fe2d77d2ed0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.config.db_config.psycopg2'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.config.db_config' has no attribute 'psycopg2'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
________________________ TestHHAPIConfig.test_initialization ________________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77d3610>

    def test_initialization(self):
        """Тест инициализации конфигурации HH API"""
        config = HHAPIConfig()
    
>       assert config.base_url == "https://api.hh.ru"
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'base_url'

tests/test_config.py:160: AttributeError
_________________________ TestHHAPIConfig.test_get_headers __________________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77d3c10>

    def test_get_headers(self):
        """Тест получения заголовков"""
        config = HHAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'

tests/test_config.py:169: AttributeError
______________________ TestHHAPIConfig.test_get_vacancies_url _______________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77d8310>

    def test_get_vacancies_url(self):
        """Тест получения URL для вакансий"""
        config = HHAPIConfig()
>       url = config.get_vacancies_url()
              ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_vacancies_url'

tests/test_config.py:178: AttributeError
______________________ TestHHAPIConfig.test_get_employers_url _______________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77d8a10>

    def test_get_employers_url(self):
        """Тест получения URL для работодателей"""
        config = HHAPIConfig()
>       url = config.get_employers_url()
              ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_employers_url'

tests/test_config.py:185: AttributeError
________________________ TestHHAPIConfig.test_get_areas_url _________________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77d2a90>

    def test_get_areas_url(self):
        """Тест получения URL для регионов"""
        config = HHAPIConfig()
>       url = config.get_areas_url()
              ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_areas_url'

tests/test_config.py:192: AttributeError
______________________ TestHHAPIConfig.test_get_request_params ______________________

self = <tests.test_config.TestHHAPIConfig object at 0x7fe2d77cbf50>

    def test_get_request_params(self):
        """Тест получения базовых параметров запроса"""
        config = HHAPIConfig()
>       params = config.get_request_params()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_request_params'

tests/test_config.py:199: AttributeError
________________________ TestSJAPIConfig.test_initialization ________________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d8d90>

    def test_initialization(self):
        """Тест инициализации конфигурации SJ API"""
        config = SJAPIConfig()
    
>       assert config.base_url == "https://api.superjob.ru/2.0"
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'base_url'

tests/test_config.py:213: AttributeError
________________ TestSJAPIConfig.test_initialization_with_secret_key ________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d90d0>

    @patch.dict(os.environ, {'SJ_SECRET_KEY': 'test_secret_key'})
    def test_initialization_with_secret_key(self):
        """Тест инициализации с секретным ключом из окружения"""
        config = SJAPIConfig()
    
>       assert config.secret_key == 'test_secret_key'
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'secret_key'

tests/test_config.py:222: AttributeError
___________________ TestSJAPIConfig.test_get_headers_without_key ____________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d9410>

    def test_get_headers_without_key(self):
        """Тест получения заголовков без ключа"""
        config = SJAPIConfig()
        config.secret_key = ""
    
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config.py:229: AttributeError
_____________________ TestSJAPIConfig.test_get_headers_with_key _____________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d9790>

    def test_get_headers_with_key(self):
        """Тест получения заголовков с ключом"""
        config = SJAPIConfig()
        config.secret_key = "test_key"
    
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config.py:239: AttributeError
______________________ TestSJAPIConfig.test_get_vacancies_url _______________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d9ad0>

    def test_get_vacancies_url(self):
        """Тест получения URL для вакансий"""
        config = SJAPIConfig()
>       url = config.get_vacancies_url()
              ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_vacancies_url'

tests/test_config.py:248: AttributeError
________________________ TestSJAPIConfig.test_set_secret_key ________________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77d9fd0>

    def test_set_secret_key(self):
        """Тест установки секретного ключа"""
        config = SJAPIConfig()
>       config.set_secret_key("new_secret_key")
        ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'set_secret_key'

tests/test_config.py:255: AttributeError
________________________ TestSJAPIConfig.test_is_configured _________________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77da5d0>

    def test_is_configured(self):
        """Тест проверки конфигурации"""
        config = SJAPIConfig()
    
        # Без ключа
        config.secret_key = ""
>       assert config.is_configured() is False
               ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'is_configured'

tests/test_config.py:265: AttributeError
______________________ TestSJAPIConfig.test_get_request_params ______________________

self = <tests.test_config.TestSJAPIConfig object at 0x7fe2d77dabd0>

    def test_get_request_params(self):
        """Тест получения базовых параметров запроса"""
        config = SJAPIConfig()
>       params = config.get_request_params()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_request_params'

tests/test_config.py:274: AttributeError
____________________ TestDBManager.test_populate_companies_table ____________________

args = (<tests.test_db_manager.TestDBManager object at 0x7fe2d77f8950>,)
keywargs = {'db_manager': <src.storage.db_manager.DBManager object at 0x7fe2d6f3be50>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe2d77f1810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.db_manager' from '/home/runner/workspace/src/storage/db_manager.py'> does not have the attribute 'TARGET_COMPANIES'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestDBManager.test_get_companies_and_vacancies_count ________________

args = (<tests.test_db_manager.TestDBManager object at 0x7fe2d77f8d10>,)
keywargs = {'db_manager': <src.storage.db_manager.DBManager object at 0x7fe2d7305c50>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe2d77f1b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.db_manager' from '/home/runner/workspace/src/storage/db_manager.py'> does not have the attribute 'TARGET_COMPANIES'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIIntegration.test_hh_api_search_integration _________________

self = <tests.test_integration.TestAPIIntegration object at 0x7fe2d73b7250>
mock_get = <MagicMock name='get' id='140612232999888'>
mock_hh_response = {'found': 1, 'items': [{'area': {'id': '1', 'name': 'Москва'}, 'employer': {'id': '1', 'name': 'Test Company'}, 'emplo...ная занятость'}, 'experience': {'id': 'between1And3', 'name': 'От 1 года до 3 лет'}, ...}], 'page': 0, 'pages': 1, ...}

    @patch('requests.get')
    def test_hh_api_search_integration(self, mock_get, mock_hh_response):
        """Интеграционный тест поиска через HH API"""
        # Настраиваем мок ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = mock_hh_response
        mock_get.return_value = mock_response
    
        # Создаем API и выполняем поиск
        api = HeadHunterAPI()
>       vacancies = api.search_vacancies("python", area="1")
                    ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_integration.py:89: AttributeError
_________________ TestAPIIntegration.test_sj_api_search_integration _________________

self = <tests.test_integration.TestAPIIntegration object at 0x7fe2d73b7c10>
mock_get = <MagicMock name='get' id='140612258186640'>

    @patch('requests.get')
    def test_sj_api_search_integration(self, mock_get):
        """Интеграционный тест поиска через SJ API"""
        mock_sj_response = {
            "objects": [
                {
                    "id": 67890,
                    "profession": "Java Developer",
                    "link": "https://www.superjob.ru/vakansii/java-developer-67890.html",
                    "payment_from": 120000,
                    "payment_to": 180000,
                    "currency": "rub",
                    "candidat": "Знание Java",
                    "work": "Разработка систем",
                    "firm_name": "SJ Test Company",
                    "town": {
                        "id": 4,
                        "title": "Москва"
                    },
                    "experience": {
                        "id": 2,
                        "title": "От 1 года до 3 лет"
                    },
                    "type_of_work": {
                        "id": 1,
                        "title": "Полная занятость"
                    },
                    "place_of_work": {
                        "id": 1,
                        "title": "Полный день"
                    },
                    "date_pub_timestamp": 1705312800
                }
            ],
            "total": 1
        }
    
        # Настраиваем мок ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = mock_sj_response
        mock_get.return_value = mock_response
    
        # Создаем API с тестовым ключом
        api = SuperJobAPI()
        api.config.secret_key = "test_key"
>       vacancies = api.search_vacancies("java", town=4)
                    ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'

tests/test_integration.py:143: AttributeError
______________ TestStorageIntegration.test_postgres_saver_integration _______________

self = <tests.test_integration.TestStorageIntegration object at 0x7fe2d73a5650>
mock_connect = <MagicMock name='connect' id='140612233549136'>
sample_vacancies = [<src.vacancies.models.Vacancy object at 0x7fe2d73f0b90>, <src.vacancies.models.Vacancy object at 0x7fe2d73f1c70>]

    @patch('src.storage.postgres_saver.psycopg2.connect')
    def test_postgres_saver_integration(self, mock_connect, sample_vacancies):
        """Интеграционный тест PostgresSaver"""
        # Настраиваем мок соединения
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.cursor.return_value = mock_cursor
    
        # Настраиваем мок для существования БД и таблиц
        mock_cursor.fetchone.side_effect = [
            [True],  # DB exists check
            None,    # Source column check
            None,    # Company_id column check
            [],      # Company mapping query
            []       # Existing vacancies check
        ]
        mock_cursor.fetchall.return_value = []
    
        # Создаем сохранялку
        db_config = {
            'host': 'localhost',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
    
        with patch.object(PostgresSaver, '_ensure_database_exists'), \
             patch.object(PostgresSaver, '_ensure_tables_exist'), \
             patch.object(PostgresSaver, '_ensure_companies_table_exists'):
    
            saver = PostgresSaver(db_config)
    
            # Сохраняем вакансии
>           messages = saver.add_vacancy(sample_vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:485: in add_vacancy
    return self._add_vacancy_small_batch(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:705: in _add_vacancy_small_batch
    execute_values(cursor, insert_query, insert_data, template=None, page_size=100)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='connect().cursor()' id='140612245685328'>
sql = '\n                INSERT INTO vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary... employment, schedule, employer, area, source, published_at, company_id\n                ) VALUES %s\n                '
argslist = [('test_1', 'Python Developer', 'https://test.com/vacancy/1', 100000, 150000, 'RUR', ...), ('test_2', 'Java Developer', 'https://test.com/vacancy/2', 120000, 180000, 'RUR', ...)]
template = None, page_size = 100, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='connect().cursor().connection.encoding' id='140612232994768'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
_________________ TestCacheIntegration.test_cached_api_integration __________________

self = <tests.test_integration.TestCacheIntegration object at 0x7fe2d73a4bd0>
mock_get = <MagicMock name='get' id='140612285676432'>
temp_cache_dir = '/tmp/tmp16izs4y2'

    @patch('requests.get')
    def test_cached_api_integration(self, mock_get, temp_cache_dir):
        """Интеграционный тест кэширования API"""
        from src.api_modules.cached_api import CachedAPI
    
        # Мок ответ от API
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [],
            "found": 0
        }
        mock_get.return_value = mock_response
    
        # Создаем кэшированное API
        hh_api = HeadHunterAPI()
>       file_cache = FileCache(base_cache_dir=temp_cache_dir)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'base_cache_dir'

tests/test_integration.py:257: TypeError
_____________ TestFullWorkflowIntegration.test_search_and_save_workflow _____________

args = (<tests.test_integration.TestFullWorkflowIntegration object at 0x7fe2d73a5d50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestFullWorkflowIntegration.test_error_handling_integration ____________

self = <tests.test_integration.TestFullWorkflowIntegration object at 0x7fe2d73a5b50>

    def test_error_handling_integration(self):
        """Тест обработки ошибок в интегрированной системе"""
        from src.api_modules.hh_api import HeadHunterAPI
    
        # Тестируем обработку ошибок API
        with patch('requests.get') as mock_get:
            mock_get.side_effect = Exception("Network error")
    
            api = HeadHunterAPI()
>           vacancies = api.search_vacancies("python")
                        ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_integration.py:357: AttributeError
___________ TestFullWorkflowIntegration.test_data_consistency_integration ___________

self = <tests.test_integration.TestFullWorkflowIntegration object at 0x7fe2d73a6990>
mock_get = <MagicMock name='get' id='140612254414608'>

    @patch('requests.get')
    def test_data_consistency_integration(self, mock_get):
        """Тест консистентности данных между компонентами"""
        # Мок ответ от HH API
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "test_123",
                    "name": "Test Position",
                    "url": "https://api.hh.ru/vacancies/test_123",
                    "salary": {
                        "from": 50000,
                        "to": 100000,
                        "currency": "RUR"
                    },
                    "snippet": {
                        "requirement": "Test requirement",
                        "responsibility": "Test responsibility"
                    },
                    "employer": {"name": "Test Employer"},
                    "area": {"name": "Test City"},
                    "experience": {"name": "Test Experience"},
                    "employment": {"name": "Test Employment"},
                    "schedule": {"name": "Test Schedule"},
                    "published_at": "2024-01-15T10:00:00+0300"
                }
            ],
            "found": 1
        }
        mock_get.return_value = mock_response
    
        # Получаем данные через API
        api = HeadHunterAPI()
>       vacancies = api.search_vacancies("test")
                    ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_integration.py:397: AttributeError
________________ TestPostgresSaver.test_add_vacancy_with_sample_data ________________

self = <tests.test_storage.TestPostgresSaver object at 0x7fe2d77d30d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe2d5ea7250>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7fe2d73f07d0>

    def test_add_vacancy_with_sample_data(self, postgres_saver, sample_vacancy):
        """Тест добавления вакансии с примерными данными"""
        with patch.object(postgres_saver, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_get_conn.return_value = mock_connection
            mock_connection.cursor.return_value = mock_cursor
            mock_cursor.__enter__ = Mock(return_value=mock_cursor)
            mock_cursor.__exit__ = Mock(return_value=None)
            mock_cursor.fetchall.return_value = []
    
>           result = postgres_saver.add_vacancy([sample_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:485: in add_vacancy
    return self._add_vacancy_small_batch(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:705: in _add_vacancy_small_batch
    execute_values(cursor, insert_query, insert_data, template=None, page_size=100)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='_get_connection().cursor()' id='140612233036624'>
sql = '\n                INSERT INTO vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary... employment, schedule, employer, area, source, published_at, company_id\n                ) VALUES %s\n                '
argslist = [('12345', 'Python Developer', 'https://hh.ru/vacancy/12345', 100000, 150000, 'RUR', ...)]
template = None, page_size = 100, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='_get_connection().cursor().connection.encoding' id='140612233044560'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
------------------------------- Captured stderr call --------------------------------
ERROR:src.storage.postgres_saver:Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
--------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:538 Ошибка при получении соответствия компаний: 'Mock' object is not subscriptable
____________________ TestPostgresSaver.test_format_vacancy_data _____________________

self = <tests.test_storage.TestPostgresSaver object at 0x7fe2d739a410>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe2d5e125d0>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7fe2d73f2120>

    def test_format_vacancy_data(self, postgres_saver, sample_vacancy):
        """Тест форматирования данных вакансии"""
>       formatted_data = postgres_saver._format_vacancy_data(sample_vacancy)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute '_format_vacancy_data'

tests/test_storage.py:89: AttributeError
___________________ TestStorageFactory.test_get_storage_postgres ____________________

self = <tests.test_storage.TestStorageFactory object at 0x7fe2d7399cd0>

    def test_get_storage_postgres(self):
        """Тест получения PostgreSQL хранилища"""
        config = {'type': 'postgres', 'host': 'localhost'}
    
        with patch.object(PostgresSaver, '_ensure_database_exists'), \
             patch.object(PostgresSaver, '_ensure_tables_exist'), \
             patch.object(PostgresSaver, '_ensure_companies_table_exists'):
>           storage = StorageFactory.get_storage(config)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'StorageFactory' has no attribute 'get_storage'

tests/test_storage.py:107: AttributeError
_________________ TestStorageFactory.test_get_storage_invalid_type __________________

self = <tests.test_storage.TestStorageFactory object at 0x7fe2d739a010>

    def test_get_storage_invalid_type(self):
        """Тест получения хранилища с неверным типом"""
        config = {'type': 'invalid_type'}
    
        with pytest.raises(ValueError):
>           StorageFactory.get_storage(config)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'StorageFactory' has no attribute 'get_storage'

tests/test_storage.py:116: AttributeError
________________ TestStorageFactory.test_get_storage_missing_config _________________

self = <tests.test_storage.TestStorageFactory object at 0x7fe2d739a910>

    def test_get_storage_missing_config(self):
        """Тест получения хранилища без конфигурации"""
        with pytest.raises((ValueError, TypeError)):
>           StorageFactory.get_storage(None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'StorageFactory' has no attribute 'get_storage'

tests/test_storage.py:121: AttributeError
============================== short test summary info ==============================
FAILED tests/test_config.py::TestDatabaseConfig::test_default_initialization - AttributeError: 'DatabaseConfig' object has no attribute 'host'
FAILED tests/test_config.py::TestDatabaseConfig::test_initialization_with_env - AttributeError: 'DatabaseConfig' object has no attribute 'host'
FAILED tests/test_config.py::TestDatabaseConfig::test_get_connection_params - AttributeError: 'DatabaseConfig' object has no attribute 'host'
FAILED tests/test_config.py::TestDatabaseConfig::test_get_dsn - AttributeError: 'DatabaseConfig' object has no attribute 'get_dsn'
FAILED tests/test_config.py::TestDatabaseConfig::test_test_connection_success - AttributeError: module 'src.config.db_config' has no attribute 'psycopg2'
FAILED tests/test_config.py::TestDatabaseConfig::test_test_connection_failure - AttributeError: module 'src.config.db_config' has no attribute 'psycopg2'
FAILED tests/test_config.py::TestHHAPIConfig::test_initialization - AttributeError: 'HHAPIConfig' object has no attribute 'base_url'
FAILED tests/test_config.py::TestHHAPIConfig::test_get_headers - AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url - AttributeError: 'HHAPIConfig' object has no attribute 'get_vacancies_url'
FAILED tests/test_config.py::TestHHAPIConfig::test_get_employers_url - AttributeError: 'HHAPIConfig' object has no attribute 'get_employers_url'
FAILED tests/test_config.py::TestHHAPIConfig::test_get_areas_url - AttributeError: 'HHAPIConfig' object has no attribute 'get_areas_url'
FAILED tests/test_config.py::TestHHAPIConfig::test_get_request_params - AttributeError: 'HHAPIConfig' object has no attribute 'get_request_params'
FAILED tests/test_config.py::TestSJAPIConfig::test_initialization - AttributeError: 'SJAPIConfig' object has no attribute 'base_url'
FAILED tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key - AttributeError: 'SJAPIConfig' object has no attribute 'secret_key'
FAILED tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_vacancies_url'
FAILED tests/test_config.py::TestSJAPIConfig::test_set_secret_key - AttributeError: 'SJAPIConfig' object has no attribute 'set_secret_key'
FAILED tests/test_config.py::TestSJAPIConfig::test_is_configured - AttributeError: 'SJAPIConfig' object has no attribute 'is_configured'
FAILED tests/test_config.py::TestSJAPIConfig::test_get_request_params - AttributeError: 'SJAPIConfig' object has no attribute 'get_request_params'
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - AttributeError: <module 'src.storage.db_manager' from '/home/runner/workspace/sr...
FAILED tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count - AttributeError: <module 'src.storage.db_manager' from '/home/runner/workspace/sr...
FAILED tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration - AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'
FAILED tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration - KeyError: <Mock name='connect().cursor().connection.encoding' id='140612232994768'>
FAILED tests/test_integration.py::TestCacheIntegration::test_cached_api_integration - TypeError: FileCache.__init__() got an unexpected keyword argument 'base_cache_dir'
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow - AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_error_handling_integration - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data - KeyError: <Mock name='_get_connection().cursor().connection.encoding' id='140612...
FAILED tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data - AttributeError: 'PostgresSaver' object has no attribute '_format_vacancy_data'
FAILED tests/test_storage.py::TestStorageFactory::test_get_storage_postgres - AttributeError: type object 'StorageFactory' has no attribute 'get_storage'
FAILED tests/test_storage.py::TestStorageFactory::test_get_storage_invalid_type - AttributeError: type object 'StorageFactory' has no attribute 'get_storage'
FAILED tests/test_storage.py::TestStorageFactory::test_get_storage_missing_config - AttributeError: type object 'StorageFactory' has no attribute 'get_storage'
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_number - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_salary - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_partial_salary - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_object - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_display_vacancy_info - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_responsibilities - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_requirements - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_conditions - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines_with_api_url - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...
ERROR tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_object - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were g...