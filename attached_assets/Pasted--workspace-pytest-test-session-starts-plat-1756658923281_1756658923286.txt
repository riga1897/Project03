~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 288 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py FFFF                                     [  5%]
tests/test_app_config.py FFFFF                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 13%]
tests/test_cached_api.py FFFF.                                    [ 15%]
tests/test_db_manager.py .F.FFFFFFF                               [ 19%]
tests/test_decorators.py .......                                  [ 21%]
tests/test_env_loader.py .FFFFFF.F                                [ 24%]
tests/test_file_handlers.py ............                          [ 28%]
tests/test_get_api.py ......                                      [ 30%]
tests/test_hh_api.py FFFFFFF                                      [ 33%]
tests/test_hh_api_config.py FFFF.                                 [ 35%]
tests/test_hh_parser.py .F..FFF.                                  [ 37%]
tests/test_menu_manager.py FFFF.FFFFF                             [ 41%]
tests/test_paginator.py FFFFFF                                    [ 43%]
tests/test_postgres_saver.py .......                              [ 45%]
tests/test_salary_utils.py .FF.................                   [ 52%]
tests/test_search_utils.py ......FFFF.                            [ 56%]
tests/test_sj_api.py FF.FFFF                                      [ 59%]
tests/test_sj_api_config.py FF.F.                                 [ 60%]
tests/test_sj_parser.py ........                                  [ 63%]
tests/test_storage_factory.py .F...F..                            [ 66%]
tests/test_target_companies.py FF.F.                              [ 68%]
tests/test_ui_config.py FF...                                     [ 69%]
tests/test_ui_helpers.py ...........                              [ 73%]
tests/test_unified_api.py .................                       [ 79%]
tests/test_user_interface.py .FF..F..                             [ 82%]
tests/test_vacancy_display_handler.py .FFFFFF                     [ 84%]
tests/test_vacancy_formatter.py ..F..F.                           [ 87%]
tests/test_vacancy_models.py ......F.FFFFFFFF                     [ 92%]
tests/test_vacancy_operations_coordinator.py FF.FFFF.             [ 95%]
tests/test_vacancy_search_handler.py FFFFFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestAPIConfig.test_api_config_initialization ______________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f429e9b4d10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429eff1290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestAPIConfig.test_api_config_urls ___________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f429e9b5290>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9a72d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIConfig.test_api_config_headers _________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f429e9b5810>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9adc10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestAPIConfig.test_api_config_parameters ________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f429e9b5dd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9adcd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestAppConfig.test_app_config_initialization ______________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f429e9d7e50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9c5010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'pathlib'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestAppConfig.test_app_config_database _________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f429e9d8410>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9c7810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'pathlib'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAppConfig.test_app_config_logging _________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f429e9d8990>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9c9f90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'pathlib'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestAppConfig.test_app_config_cache __________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f429e9d8f50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9d47d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'pathlib'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestAppConfig.test_app_config_api_settings _______________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f429e9d9550>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e9d7290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'pathlib'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestCachedAPI.test_cached_api_initialization ______________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f429e528c50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e518ad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.cached_api' from '/home/runner/workspace/tests/../src/api_modules/cached_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f429e5291d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e51c650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.cached_api' from '/home/runner/workspace/tests/../src/api_modules/cached_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f429e529750>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e524250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.cached_api' from '/home/runner/workspace/tests/../src/api_modules/cached_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestCachedAPI.test_cache_integration __________________

args = (<workspace.tests.test_cached_api.TestCachedAPI object at 0x7f429e529d10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429e527e90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.cached_api' from '/home/runner/workspace/tests/../src/api_modules/cached_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e5300d0>
mock_connect = <MagicMock name='connect' id='139924071393808'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:39: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object does not support the context manager protocol
___________________ TestDBManager.test_create_tables ____________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e530e10>
mock_connect = <MagicMock name='connect' id='139924084040016'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
>       db_manager.create_tables()

tests/test_db_manager.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f429d531710>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
            with self._get_connection() as conn:
>               with conn.cursor() as cursor:
E               TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:69: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
_________ TestDBManager.test_get_companies_and_vacancies_count __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e531490>
mock_connect = <MagicMock name='connect' id='139924076351568'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect):
        """Тест получения количества компаний и вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("Test Company", 5),
            ("Another Company", 3)
        ]
    
        db_manager = DBManager()
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       AssertionError: assert 12 == 2
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:89: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:288 Нет подключения к базе данных
_________________ TestDBManager.test_get_all_vacancies __________________

self = <Mock name='connect().cursor().execute' id='139924070591120'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e531b10>
mock_connect = <MagicMock name='connect' id='139924070589712'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test Company", 100000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:111: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e532190>
mock_connect = <MagicMock name='connect' id='139924114334544'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchone.return_value = (125000.0,)
    
        db_manager = DBManager()
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert None == 125000.0

tests/test_db_manager.py:129: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <Mock name='connect().cursor().execute' id='139924084214160'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e532810>
mock_connect = <MagicMock name='connect' id='139924084227792'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:151: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
_____________ TestDBManager.test_get_vacancies_with_keyword _____________

self = <Mock name='connect().cursor().execute' id='139924069326352'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e532e90>
mock_connect = <MagicMock name='connect' id='139924069320272'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect):
        """Тест получения вакансий по ключевому слову"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        # Настраиваем возвращаемые данные
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test Company", 100000, "Москва", "https://test.com")
        ]
    
        db_manager = DBManager()
        result = db_manager.get_vacancies_with_keyword("Python")
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager.py:172: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'Mock' object does not support the context manager protocol
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f429e5334d0>
mock_connect = <MagicMock name='connect' id='139924070663248'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
>       db_manager.populate_companies_table()

tests/test_db_manager.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f429c870bd0>

    def populate_companies_table(self):
        """Заполняет таблицу companies целевыми компаниями"""
        try:
            # Используем контекстный менеджер для безопасной работы с подключением
            with self._get_connection() as connection:
>               with connection.cursor() as cursor:
E               TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:204: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:252 Ошибка при заполнении таблицы companies: 'Mock' object does not support the context manager protocol
_______________ TestEnvLoader.test_load_env_file_success ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54c0d0>
mock_exists = <MagicMock name='exists' id='139924084163600'>
mock_file = <MagicMock name='open' id='139924080542736'>

    @patch('builtins.open', new_callable=mock_open, read_data='KEY1=value1\nKEY2=value2\n# Comment\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_success(self, mock_exists, mock_file):
        """Тест успешной загрузки .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:23: AttributeError
______________ TestEnvLoader.test_load_env_file_not_found _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54c690>
mock_exists = <MagicMock name='exists' id='139924100819088'>

    @patch('os.path.exists', return_value=False)
    def test_load_env_file_not_found(self, mock_exists):
        """Тест загрузки несуществующего .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:32: AttributeError
______________ TestEnvLoader.test_load_env_file_read_error ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54cc90>
mock_exists = <MagicMock name='exists' id='139924084076304'>
mock_file = <MagicMock name='open' id='139924071555024'>

    @patch('builtins.open', side_effect=OSError("Read error"))
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_read_error(self, mock_exists, mock_file):
        """Тест ошибки чтения .env файла"""
        loader = EnvLoader()
>       result = loader.load_file(".env")
                 ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

tests/test_env_loader.py:41: AttributeError
________________ TestEnvLoader.test_parse_env_line_valid ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54d290>

    def test_parse_env_line_valid(self):
        """Тест парсинга валидной строки .env"""
        loader = EnvLoader()
    
>       key, value = loader.parse_line("KEY=value")
                     ^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_line'

tests/test_env_loader.py:49: AttributeError
_______________ TestEnvLoader.test_parse_env_line_invalid _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54d890>

    def test_parse_env_line_invalid(self):
        """Тест парсинга невалидной строки .env"""
        loader = EnvLoader()
    
        # Комментарий
>       result = loader.parse_line("# This is a comment")
                 ^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_line'

tests/test_env_loader.py:62: AttributeError
______________ TestEnvLoader.test_set_environment_variable ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54de10>

    @patch.dict(os.environ, {}, clear=True)
    def test_set_environment_variable(self):
        """Тест установки переменной окружения"""
        loader = EnvLoader()
>       loader.set_env_var("TEST_KEY", "test_value")
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'set_env_var'

tests/test_env_loader.py:77: AttributeError
_______________ TestEnvLoader.test_load_env_file_function _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f429e54e9d0>
mock_exists = <MagicMock name='exists' id='139924071553040'>
mock_file = <MagicMock name='open' id='139924072215056'>

    @patch('builtins.open', new_callable=mock_open, read_data='API_KEY=secret123\nDEBUG=true\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_function(self, mock_exists, mock_file):
        """Тест функции load_env_file"""
        with patch.dict(os.environ, {}, clear=True):
>           result = load_env_file(".env")
                     ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
_____________ TestHeadHunterAPI.test_hh_api_initialization ______________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d928750>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429ddebe90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestHeadHunterAPI.test_hh_api_with_connector ______________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d928dd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429eff0fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestHeadHunterAPI.test_get_vacancies_success ______________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d929410>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429d901f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestHeadHunterAPI.test_get_vacancies_empty_response __________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d929a90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429d90b450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestHeadHunterAPI.test_get_vacancies_api_error _____________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d92a0d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429d914b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestHeadHunterAPI.test_validate_vacancy_valid _____________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d92a710>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429d91e190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestHeadHunterAPI.test_validate_vacancy_invalid ____________

args = (<workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f429d92ad50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1561: in __enter__
    arg = self._exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f429d927790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.hh_api' from '/home/runner/workspace/tests/../src/api_modules/hh_api.py'> does not have the attribute 'CacheManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestHHAPIConfig.test_hh_config_initialization _____________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f429d92be10>

    def test_hh_config_initialization(self):
        """Тест инициализации HH API конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'BASE_URL')

tests/test_hh_api_config.py:11: AssertionError
__________________ TestHHAPIConfig.test_hh_config_urls __________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f429d929790>

    def test_hh_config_urls(self):
        """Тест URL конфигурации"""
        config = HHAPIConfig()
>       assert config.BASE_URL.startswith('https://api.hh.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'BASE_URL'

tests/test_hh_api_config.py:18: AttributeError
_______________ TestHHAPIConfig.test_hh_config_parameters _______________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f429d934810>

    def test_hh_config_parameters(self):
        """Тест параметров конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'DEFAULT_PER_PAGE')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'DEFAULT_PER_PAGE')

tests/test_hh_api_config.py:25: AssertionError
________________ TestHHAPIConfig.test_hh_config_timeout _________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f429d934b90>

    def test_hh_config_timeout(self):
        """Тест настроек таймаута"""
        config = HHAPIConfig()
>       assert hasattr(config, 'TIMEOUT')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'TIMEOUT')

tests/test_hh_api_config.py:33: AssertionError
__________________ TestHHParser.test_parse_hh_vacancy ___________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f429d937350>

    def test_parse_hh_vacancy(self):
        """Тест парсинга вакансии HH"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['id'] == '123456'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:31: KeyError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f429d9385d0>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {'items': [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies_list(data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_vacancies_list'

tests/test_hh_parser.py:55: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f429d938c90>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {'id': '123', 'name': 'Test Job'}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result['id'] == '123'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:63: KeyError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f429d939350>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['company'] == 'Test Company'
               ^^^^^^^^^^^^^^^^^
E       KeyError: 'company'

tests/test_hh_parser.py:70: KeyError
___________ TestMenuManager.test_menu_manager_initialization ____________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94c410>

    def test_menu_manager_initialization(self):
        """Тест инициализации MenuManager"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:21: TypeError
___________________ TestMenuManager.test_display_menu ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d936ed0>
mock_print = <MagicMock name='print' id='139924076362768'>

    @patch('builtins.print')
    def test_display_menu(self, mock_print):
        """Тест отображения меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:32: TypeError
_______________ TestMenuManager.test_get_menu_item_valid ________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94c5d0>

    def test_get_menu_item_valid(self):
        """Тест получения валидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:45: TypeError
______________ TestMenuManager.test_get_menu_item_invalid _______________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94c950>

    def test_get_menu_item_invalid(self):
        """Тест получения невалидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:56: TypeError
_________________ TestMenuManager.test_menu_validation __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94cfd0>

    def test_menu_validation(self):
        """Тест валидации пунктов меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:70: TypeError
_________________ TestMenuManager.test_get_user_choice __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94d490>
mock_input = <MagicMock name='input' id='139924071040656'>

    @patch('builtins.input', return_value='1')
    def test_get_user_choice(self, mock_input):
        """Тест получения выбора пользователя"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:82: TypeError
__________________ TestMenuManager.test_add_menu_item ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94da90>

    def test_add_menu_item(self):
        """Тест добавления пункта меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:92: TypeError
_________________ TestMenuManager.test_remove_menu_item _________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94e090>

    def test_remove_menu_item(self):
        """Тест удаления пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:107: TypeError
___________ TestMenuManager.test_remove_nonexistent_menu_item ___________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f429d94e650>

    def test_remove_nonexistent_menu_item(self):
        """Тест удаления несуществующего пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:120: TypeError
______________ TestPaginator.test_paginator_initialization ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d958a50>

    def test_paginator_initialization(self):
        """Тест инициализации Paginator"""
        items = ["item1", "item2", "item3"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:56: TypeError
_________________ TestPaginator.test_paginator_get_page _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d959150>

    def test_paginator_get_page(self):
        """Тест получения страницы"""
        items = ["item1", "item2", "item3", "item4", "item5"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:66: TypeError
_______________ TestPaginator.test_paginator_invalid_page _______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d959810>

    def test_paginator_invalid_page(self):
        """Тест получения невалидной страницы"""
        items = ["item1", "item2"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:80: TypeError
_______________ TestPaginator.test_paginator_empty_items ________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d959f10>

    def test_paginator_empty_items(self):
        """Тест пагинатора с пустым списком"""
>       paginator = Paginator([], items_per_page=5)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:91: TypeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d95a590>
mock_print = <MagicMock name='print' id='139924079864528'>
mock_input = <MagicMock name='input' id='139924079858320'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:106: TypeError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f429d95ac10>
mock_print = <MagicMock name='print' id='139924076361936'>
mock_input = <MagicMock name='input' id='139924084346896'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter, items_per_page=5)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:120: TypeError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f429d9854d0>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
>       assert parse_salary_range("invalid") is None
E       AssertionError: assert (None, None) is None
E        +  where (None, None) = parse_salary_range('invalid')

tests/test_salary_utils.py:84: AssertionError
_________ TestSalaryUtils.test_parse_salary_range_reverse_order _________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f429d985ad0>

    def test_parse_salary_range_reverse_order(self):
        """Тест парсинга диапазона в обратном порядке"""
        result = parse_salary_range("150000 - 100000")
        # Должно автоматически поменять местами
>       assert result == (100000, 150000)
E       assert (150000, 100000) == (100000, 150000)
E         
E         At index 0 diff: 150000 != 100000
E         Use -v to get more diff

tests/test_salary_utils.py:93: AssertionError
___________ TestAdvancedSearch.test_search_with_and_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f429d991a90>

    def test_search_with_and_operator(self):
        """Тест поиска с оператором AND"""
        vacancies = [
            Vacancy("123", "Python Django Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Python Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "Django Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_and(vacancies, ["python", "django"])
    
        # Должна найтись только первая вакансия
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_search_utils.py:76: AssertionError
____________ TestAdvancedSearch.test_search_with_or_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f429d991dd0>

    def test_search_with_or_operator(self):
        """Тест поиска с оператором OR"""
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "C++ Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["python", "java"])
    
        # Должны найтись первые две вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:91: AssertionError
____________ TestAdvancedSearch.test_search_case_insensitive ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f429d992310>

    def test_search_case_insensitive(self):
        """Тест поиска без учета регистра"""
        vacancies = [
            Vacancy("123", "PYTHON Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "python developer", "https://test2.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["Python"])
    
        # Должны найтись обе вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:104: AssertionError
_____________ TestAdvancedSearch.test_search_in_description _____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f429d992910>

    def test_search_in_description(self):
        """Тест поиска в описании вакансии"""
        vacancies = [
>           Vacancy("123", "Developer", "https://test.com", "hh.ru",
                   description="Work with Python and Django"),
            Vacancy("124", "Developer", "https://test2.com", "hh.ru",
                   description="Work with Java")
        ]
E       TypeError: Vacancy.__init__() got multiple values for argument 'description'

tests/test_search_utils.py:109: TypeError
______________ TestSuperJobAPI.test_sj_api_initialization _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9a9c10>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJobAPI"""
        api = SuperJobAPI()
>       assert hasattr(api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f429c87c350>, 'base_url')

tests/test_sj_api.py:16: AssertionError
_______________ TestSuperJobAPI.test_sj_api_with_api_key ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9aa210>

    def test_sj_api_with_api_key(self):
        """Тест инициализации с API ключом"""
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:21: TypeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9aae10>
mock_get = <MagicMock name='get' id='139924084496400'>

    @patch('requests.Session.get')
    def test_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "firm_name": "Test Company",
                    "payment_from": 100000,
                    "payment_to": 150000,
                    "town": {"title": "Москва"}
                }
            ],
            "total": 1
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:52: TypeError
____________ TestSuperJobAPI.test_get_vacancy_by_id_success _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9ab3d0>
mock_get = <MagicMock name='get' id='139924069376592'>

    @patch('requests.Session.get')
    def test_get_vacancy_by_id_success(self, mock_get):
        """Тест успешного получения вакансии по ID"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "profession": "Python Developer",
            "firm_name": "Test Company"
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:70: TypeError
________________ TestSuperJobAPI.test_api_key_validation ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9ab9d0>

    def test_api_key_validation(self):
        """Тест валидации API ключа"""
        api = SuperJobAPI()
    
        # Проверяем обработку отсутствующего API ключа
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f429c94aa10>, 'api_key')

tests/test_sj_api.py:81: AssertionError
_____________ TestSuperJobAPI.test_api_key_from_environment _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f429d9abf50>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'env_test_key'})
    def test_api_key_from_environment(self):
        """Тест получения API ключа из переменной окружения"""
        api = SuperJobAPI()
        # API должен использовать ключ из окружения
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f429cdf9750>, 'api_key')

tests/test_sj_api.py:88: AssertionError
_____________ TestSJAPIConfig.test_sj_config_initialization _____________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f429d9823d0>

    def test_sj_config_initialization(self):
        """Тест инициализации SuperJob API конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'BASE_URL')

tests/test_sj_api_config.py:11: AssertionError
__________________ TestSJAPIConfig.test_sj_config_urls __________________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f429d9b4450>

    def test_sj_config_urls(self):
        """Тест URL конфигурации"""
        config = SJAPIConfig()
>       assert config.BASE_URL.startswith('https://api.superjob.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'BASE_URL'

tests/test_sj_api_config.py:17: AttributeError
_______________ TestSJAPIConfig.test_sj_config_parameters _______________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f429d9b4b10>

    def test_sj_config_parameters(self):
        """Тест параметров конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'DEFAULT_COUNT')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'DEFAULT_COUNT')

tests/test_sj_api_config.py:31: AssertionError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f429c77aa10>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=postgres"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f429d9b48d0>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='139924076208080'>
mock_app_config = <MagicMock name='AppConfig' id='139924076470416'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_postgres_storage(self, mock_postgres_saver, mock_app_config):
        """Тест создания PostgreSQL хранилища с моками"""
        # Настраиваем моки
        mock_config_instance = Mock()
        mock_config_instance.get_db_config.return_value = {'host': 'localhost'}
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=Project03"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'Project03', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД Project03: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных Project03 недоступна и не может быть создана
_________ TestStorageFactory.test_create_storage_with_db_config _________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f429c883190>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=postgres'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f429d9c36d0>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='139924070824144'>
mock_app_config = <MagicMock name='AppConfig' id='139924070818256'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_storage_with_db_config(self, mock_postgres_saver, mock_app_config):
        """Тест создания хранилища с конфигурацией БД"""
        # Настраиваем моки
        mock_config_instance = Mock()
        test_db_config = {
            'host': 'test_host',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
        mock_config_instance.get_db_config.return_value = test_db_config
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=test_db'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'test_db', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД test_db: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных test_db недоступна и не может быть создана
_______ TestTargetCompanies.test_target_companies_initialization ________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f429d9c8e90>

    def test_target_companies_initialization(self):
        """Тест инициализации списка целевых компаний"""
        companies = TargetCompanies()
>       assert hasattr(companies, 'companies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.target_companies.TargetCompanies object at 0x7f429c9b9910>, 'companies')

tests/test_target_companies.py:44: AssertionError
________ TestTargetCompanies.test_get_target_companies_function _________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f429d9c9490>

    def test_get_target_companies_function(self):
        """Тест функции получения целевых компаний"""
        companies = get_target_companies()
>       assert isinstance(companies, (list, dict))
E       AssertionError: assert False
E        +  where False = isinstance(<src.config.target_companies.TargetCompanies object at 0x7f429cdf3f50>, (<class 'list'>, <class 'dict'>))

tests/test_target_companies.py:50: AssertionError
_____________ TestTargetCompanies.test_companies_not_empty ______________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f429d9ca0d0>

    def test_companies_not_empty(self):
        """Тест что список компаний не пустой"""
        companies = get_target_companies()
>       assert len(companies) > 0
               ^^^^^^^^^^^^^^
E       TypeError: object of type 'TargetCompanies' has no len()

tests/test_target_companies.py:67: TypeError
______________ TestUIConfig.test_ui_config_initialization _______________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f429d9cbcd0>

    def test_ui_config_initialization(self):
        """Тест инициализации UI конфигурации"""
        config = UIConfig()
>       assert hasattr(config, 'PAGINATION_SIZE')
E       AssertionError: assert False
E        +  where False = hasattr(UIConfig(items_per_page=5, max_display_items=20), 'PAGINATION_SIZE')

tests/test_ui_config.py:10: AssertionError
________________ TestUIConfig.test_ui_config_pagination _________________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f429d9d8850>

    def test_ui_config_pagination(self):
        """Тест настроек пагинации"""
        config = UIConfig()
>       assert config.PAGINATION_SIZE > 0
               ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIConfig' object has no attribute 'PAGINATION_SIZE'

tests/test_ui_config.py:16: AttributeError
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <MagicMock name='_handle_choice' id='139924075660112'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_handle_choice' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f429d5e7bd0>
mock_stdout = <_io.StringIO object at 0x7f429cdce170>
mock_input = <MagicMock name='input' id='139924071610832'>

    @patch('builtins.input', return_value='0')
    @patch('sys.stdout', new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
        with patch.object(ui, '_display_menu'):
            with patch.object(ui, '_handle_choice') as mock_handle:
                mock_handle.return_value = False
                ui.run()
>               mock_handle.assert_called()
E               AssertionError: Expected '_handle_choice' to have been called.

tests/test_user_interface.py:63: AssertionError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <MagicMock name='_search_vacancies' id='139924080553872'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_search_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f429d5e72d0>
mock_input = <MagicMock name='input' id='139924088196752'>

    @patch('builtins.input', return_value='1')
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
        with patch.object(ui, '_search_vacancies') as mock_search:
            result = ui._handle_choice('1')
            if hasattr(ui, '_search_vacancies'):
>               mock_search.assert_called()
E               AssertionError: Expected '_search_vacancies' to have been called.

tests/test_user_interface.py:72: AssertionError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f429d5e5850>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        with patch('builtins.input', side_effect=KeyboardInterrupt):
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

tests/test_user_interface.py:92: Failed
______ TestVacancyDisplayHandler.test_display_vacancies_empty_list ______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5cd150>
mock_print = <MagicMock name='print' id='139924072119248'>

    @patch('builtins.print')
    def test_display_vacancies_empty_list(self, mock_print):
        """Тест отображения пустого списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       handler.display_vacancies([])
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:84: AttributeError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5ce210>
mock_print = <MagicMock name='print' id='139924070974544'>

    @patch('builtins.print')
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru")
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:100: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5ce850>
mock_paginate = <MagicMock name='quick_paginate' id='139924071033488'>

    @patch('src.ui_interfaces.vacancy_display_handler.quick_paginate')
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:115: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5ce0d0>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:131: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5ce890>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124",
            title="Junior Developer",
            url="https://test.com/vacancy/124",
            source="hh.ru",
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:153: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f429d5cf110>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(
            id="125",
            title="Intern",
            url="https://test.com/vacancy/125",
            source="hh.ru",
            salary=salary
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:174: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f429d5b4ed0>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f429cde28c0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f429d5b5f10>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость"
        )

tests/test_vacancy_formatter.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f429cd5c7c0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____ TestVacancyEmployer.test_vacancy_employer_str_representation ______

self = <workspace.tests.test_vacancy_models.TestVacancyEmployer object at 0x7f429d106b90>

    def test_vacancy_employer_str_representation(self):
        """Тест строкового представления VacancyEmployer"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       assert str(employer) == "Test Company"
E       AssertionError: assert 'VacancyEmplo...rusted=False)' == 'Test Company'
E         
E         - Test Company
E         + VacancyEmployer(id='1', name='Test Company', url=None, trusted=False)

tests/test_vacancy_models.py:88: AssertionError
________________ TestVacancy.test_vacancy_initialization ________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d9e1b10>

    def test_vacancy_initialization(self):
        """Тест инициализации Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:102: TypeError
_________________ TestVacancy.test_vacancy_with_salary __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d9e20d0>

    def test_vacancy_with_salary(self):
        """Тест вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            salary=str(salary), # Assuming salary is converted to string for the placeholder Vacancy
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:120: TypeError
________________ TestVacancy.test_vacancy_with_employer _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d9e3750>

    def test_vacancy_with_employer(self):
        """Тест вакансии с работодателем"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:133: TypeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d5be4d0>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:149: TypeError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d5bf710>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            vacancy_id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"],
            source="hh.ru"
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:204: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d5bfe90>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            vacancy_id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"],
            source="superjob.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:224: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d5bc590>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:243: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f429d5bca10>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary),
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:266: TypeError
___ TestVacancyOperationsCoordinator.test_coordinator_initialization ____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f429d5a3ed0>

    def test_coordinator_initialization(self):
        """Тест инициализации VacancyOperationsCoordinator"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
>       assert coordinator.api == mock_api
               ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyOperationsCoordinator' object has no attribute 'api'

tests/test_vacancy_operations_coordinator.py:21: AttributeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f429d5a3450>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='139924075957456'>

    @patch('src.ui_interfaces.vacancy_search_handler.VacancySearchHandler')
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7f429f20b890>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f429d5a0b50>
mock_print = <MagicMock name='print' id='139924084079952'>
mock_input = <MagicMock name='input' id='139924075670608'>

    @patch('builtins.input', return_value='5')
    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, mock_input):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
>       from src.vacancies.models import Vacancy, VacancySalary
E       ImportError: cannot import name 'VacancySalary' from 'src.vacancies.models' (/home/runner/workspace/tests/../src/vacancies/models.py)

tests/test_vacancy_operations_coordinator.py:62: ImportError
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f429d5a0210>
mock_print = <MagicMock name='print' id='139924076207056'>
mock_input = <MagicMock name='input' id='139924069232016'>

    @patch('builtins.input', return_value='Python')
    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, mock_input):