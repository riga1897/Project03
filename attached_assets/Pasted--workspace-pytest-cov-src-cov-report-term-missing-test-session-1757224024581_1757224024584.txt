/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 682 items                                                                

tests/test_abstract_db_manager_100_coverage.py ...........                   [  1%]
tests/test_abstract_filter_100_coverage.py .........                         [  2%]
tests/test_abstract_models_100_coverage.py .F.F.F.FF.FF.                     [  4%]
tests/test_abstractions_complete_coverage.py .....................           [  7%]
tests/test_all_modules_real_imports.py .......................FFFF..FFF      [ 12%]
tests/test_api_config_modules_100_coverage.py ...........................    [ 16%]
tests/test_api_storage_modules_100_coverage.py ......................        [ 19%]
tests/test_app_config_100_coverage.py ...................                    [ 22%]
tests/test_complete_coverage_all_modules.py ....FFFF.FFFF                    [ 24%]
tests/test_config_modules_100_coverage.py .................................. [ 29%]
............                                                                 [ 31%]
tests/test_db_config_100_coverage.py .................                       [ 33%]
tests/test_description_parser_100_coverage.py ......................         [ 36%]
tests/test_file_handlers_100_coverage.py ......F.............                [ 39%]
tests/test_parsers_100_coverage.py .........................                 [ 43%]
tests/test_remaining_config_100_coverage.py ................................ [ 48%]
.....                                                                        [ 48%]
tests/test_salary_utils_100_coverage.py .................................... [ 54%]
.......                                                                      [ 55%]
tests/test_storage_abstract_100_coverage.py .............                    [ 57%]
tests/test_storage_components_100_coverage.py .............................. [ 61%]
..............                                                               [ 63%]
tests/test_target_companies_100_coverage.py ...............................  [ 68%]
tests/test_ui_config_100_coverage.py ......................                  [ 71%]
tests/test_utils_100_coverage.py ........................................... [ 77%]
.............................                                                [ 81%]
tests/test_utils_modules_100_coverage.py ................................... [ 87%]
..                                                                           [ 87%]
tests/test_vacancies_abstract_100_coverage.py ..........                     [ 88%]
tests/test_vacancy_abstract_models_100_coverage.py ................          [ 91%]
tests/test_vacancy_models_100_coverage.py FF.FF..F.FF..F...F...F..FFF.FF..FF [ 96%]
FF.FF..FFFFFFFFFFFFFFFFFFF                                                   [100%]

===================================== FAILURES =====================================
_______________ TestAbstractEmployer.test_concrete_employer_methods ________________

self = <test_abstract_models_100_coverage.TestAbstractEmployer object at 0x7f1cc53d4250>

    def test_concrete_employer_methods(self):
        """Тест конкретной реализации всех методов - покрывает строки 18, 23, 28, 33, 38, 44"""
>       employer = ConcreteEmployer(
            name="Google Inc",
            employer_id="12345",
            trusted=True,
            url="https://google.com"
        )

tests/test_abstract_models_100_coverage.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:26: in __init__
    self.name = name
    ^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteEmployer(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteEmployer' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
_____________ TestAbstractExperience.test_concrete_experience_methods ______________

self = <test_abstract_models_100_coverage.TestAbstractExperience object at 0x7f1cc53d4ad0>

    def test_concrete_experience_methods(self):
        """Тест конкретной реализации всех методов - покрывает строки 53, 58, 63, 69, 75"""
>       experience = ConcreteExperience(name="3-6 лет", exp_id="between3and6")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:65: in __init__
    self.name = name
    ^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteExperience(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteExperience' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
_____________ TestAbstractEmployment.test_concrete_employment_methods ______________

self = <test_abstract_models_100_coverage.TestAbstractEmployment object at 0x7f1cc53d5850>

    def test_concrete_employment_methods(self):
        """Тест конкретной реализации всех методов - покрывает строки 84, 89, 94, 100, 106"""
>       employment = ConcreteEmployment(name="Полная занятость", employment_id="full")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:90: in __init__
    self.name = name
    ^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteEmployment(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteEmployment' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
_________________ TestAbstractSalary.test_concrete_salary_methods __________________

self = <test_abstract_models_100_coverage.TestAbstractSalary object at 0x7f1cc53d66d0>

    def test_concrete_salary_methods(self):
        """Тест конкретной реализации всех методов - покрывает строки 115, 120, 125, 130, 135, 140, 146"""
>       salary = ConcreteSalary(from_amount=100000, to_amount=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:116: in __init__
    self.from_amount = from_amount
    ^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteSalary(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteSalary' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
____________________ TestAbstractSalary.test_salary_edge_cases _____________________

self = <test_abstract_models_100_coverage.TestAbstractSalary object at 0x7f1cc53d6cd0>

    def test_salary_edge_cases(self):
        """Тест граничных случаев для зарплаты"""
        # Только минимальная зарплата
>       salary_min = ConcreteSalary(from_amount=80000)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:116: in __init__
    self.from_amount = from_amount
    ^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteSalary(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteSalary' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
_______________ TestAbstractSchedule.test_concrete_schedule_methods ________________

self = <test_abstract_models_100_coverage.TestAbstractSchedule object at 0x7f1cc53d79d0>

    def test_concrete_schedule_methods(self):
        """Тест конкретной реализации всех методов - покрывает строки 155, 160, 165, 171, 177"""
>       schedule = ConcreteSchedule(name="Полный день", schedule_id="fullDay")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:161: in __init__
    self.name = name
    ^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteSchedule(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteSchedule' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
___________ TestAbstractMethodCoverage.test_all_abstract_methods_covered ___________

self = <test_abstract_models_100_coverage.TestAbstractMethodCoverage object at 0x7f1cc53d8290>

    def test_all_abstract_methods_covered(self):
        """Проверяем что все абстрактные методы имеют реализацию в тестах"""
    
        # Создаем экземпляры всех конкретных классов
>       employer = ConcreteEmployer("Test")
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_abstract_models_100_coverage.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_abstract_models_100_coverage.py:26: in __init__
    self.name = name
    ^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:998: in __setattr__
    setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:114: in <lambda>
    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ConcreteEmployer(), item = '__pydantic_extra__'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
>                   return super().__getattribute__(item)  # Raises AttributeError if appropriate
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'ConcreteEmployer' object has no attribute '__pydantic_extra__'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:988: AttributeError
___________________ TestVacancyModels.test_employer_all_methods ____________________

self = <test_all_modules_real_imports.TestVacancyModels object at 0x7f1cc4f35510>

    def test_employer_all_methods(self):
        """100% покрытие Employer"""
        # Тест инициализации
>       employer = Employer("Test Company", "123", True, "http://test.com")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 5 were given

tests/test_all_modules_real_imports.py:396: TypeError
__________________ TestVacancyModels.test_experience_all_methods ___________________

self = <test_all_modules_real_imports.TestVacancyModels object at 0x7f1cc4f35850>

    def test_experience_all_methods(self):
        """100% покрытие Experience"""
        # Тест инициализации (первый параметр - name)
>       exp = Experience("От 1 до 3 лет", "between1And3")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_all_modules_real_imports.py:462: TypeError
__________________ TestVacancyModels.test_employment_all_methods ___________________

self = <test_all_modules_real_imports.TestVacancyModels object at 0x7f1cc4f35b90>

    def test_employment_all_methods(self):
        """100% покрытие Employment"""
        # Тест инициализации (первый параметр - name)
>       emp = Employment("Полная занятость", "full")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_all_modules_real_imports.py:497: TypeError
____________________ TestVacancyModels.test_vacancy_all_methods ____________________

self = <test_all_modules_real_imports.TestVacancyModels object at 0x7f1cc4f361d0>

    def test_vacancy_all_methods(self):
        """100% покрытие Vacancy"""
        # Тест минимальной инициализации
>       vacancy = Vacancy("Test Job", "http://test.com")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_all_modules_real_imports.py:525: TypeError
____________________ TestIntegration.test_inheritance_hierarchy ____________________

self = <test_all_modules_real_imports.TestIntegration object at 0x7f1cc4f37610>

    def test_inheritance_hierarchy(self):
        """Тест правильности иерархии наследования"""
        from abc import ABC
    
        # Проверяем что абстрактные классы наследуются от ABC
        assert issubclass(AbstractVacancy, ABC)
        assert issubclass(AbstractEmployer, ABC)
        assert issubclass(AbstractExperience, ABC)
        assert issubclass(AbstractEmployment, ABC)
        assert issubclass(AbstractSalary, ABC)
        assert issubclass(AbstractVacancyStorage, ABC)
        assert issubclass(AbstractDBManager, ABC)
        assert issubclass(BaseJobAPI, ABC)
        assert issubclass(AbstractDataFilter, ABC)
    
        # Проверяем что конкретные классы наследуются от абстрактных
>       assert issubclass(Employer, AbstractEmployer)
E       assert False
E        +  where False = issubclass(Employer, AbstractEmployer)

tests/test_all_modules_real_imports.py:625: AssertionError
__________________ TestIntegration.test_full_workflow_simulation ___________________

self = <test_all_modules_real_imports.TestIntegration object at 0x7f1cc4f37c10>

    def test_full_workflow_simulation(self):
        """Тест симуляции полного рабочего процесса"""
        # 1. Загружаем переменные окружения
        EnvLoader._loaded = False
        with patch('os.path.exists', return_value=False):
            EnvLoader.load_env_file(".env")
    
        # 2. Создаем конфигурации
        api_config = APIConfig()
        app_config = AppConfig()
    
        # 3. Получаем список компаний
        companies = TargetCompanies.get_all_companies()
    
        # 4. Создаем модели
>       employer = Employer("Test Company", "123")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_all_modules_real_imports.py:645: TypeError
-------------------------------- Captured log call ---------------------------------
WARNING  src.utils.env_loader:env_loader.py:36 Файл .env не найден в следующих местах: ['.env']
WARNING  src.utils.env_loader:env_loader.py:37 Используются переменные окружения системы.
________________ TestIntegration.test_error_handling_comprehensive _________________

self = <test_all_modules_real_imports.TestIntegration object at 0x7f1cc4f44290>

    def test_error_handling_comprehensive(self):
        """Комплексное тестирование обработки ошибок"""
        # AppConfig с невалидным типом
        app_config = AppConfig()
        with pytest.raises(ValueError):
            app_config.set_storage_type("invalid_type")
    
        # EnvLoader с исключением
        EnvLoader._loaded = False
        with patch('os.path.exists', return_value=True):
            with patch('builtins.open', side_effect=IOError("Test error")):
                EnvLoader.load_env_file(".env")  # Не должно падать
    
        # EnvLoader с невалидным int
        with patch.dict(os.environ, {"INVALID_INT": "not_a_number"}):
            result = EnvLoader.get_env_var_int("INVALID_INT", 42)
            assert result == 42
    
        # Создание моделей с None значениями
>       employer = Employer(None)
                   ^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 2 were given

tests/test_all_modules_real_imports.py:686: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.env_loader:env_loader.py:75 Ошибка при загрузке .env: Test error
WARNING  src.utils.env_loader:env_loader.py:110 Не удалось преобразовать INVALID_INT в int, используется значение по умолчанию: 42
__________________ TestCompleteCoverage.test_employer_all_methods __________________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4f84bd0>

    def test_employer_all_methods(self):
        """100% покрытие Employer"""
        # Тест инициализации
>       employer = Employer("Test Company", "123", True, "http://test.com")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 5 were given

tests/test_complete_coverage_all_modules.py:135: TypeError
_________________ TestCompleteCoverage.test_experience_all_methods _________________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa46d0>

    def test_experience_all_methods(self):
        """100% покрытие Experience"""
        # Тест инициализации
>       exp = Experience("От 1 до 3 лет", "between1And3")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_complete_coverage_all_modules.py:182: TypeError
_________________ TestCompleteCoverage.test_employment_all_methods _________________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa4a10>

    def test_employment_all_methods(self):
        """100% покрытие Employment"""
        # Тест инициализации
>       emp = Employment("Полная занятость", "full")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_complete_coverage_all_modules.py:211: TypeError
__________________ TestCompleteCoverage.test_vacancy_all_methods ___________________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa4d50>

    def test_vacancy_all_methods(self):
        """100% покрытие Vacancy"""
        # Тест минимальной инициализации
>       vacancy = Vacancy("Test Job", "http://test.com")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 3 were given

tests/test_complete_coverage_all_modules.py:236: TypeError
______________ TestCompleteCoverage.test_module_imports_and_structure ______________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa57d0>

    def test_module_imports_and_structure(self):
        """Тест импортов и структуры всех модулей"""
        # Проверяем что все основные классы импортируются
        assert APIConfig is not None
        assert AppConfig is not None
        assert TargetCompanies is not None
        assert CompanyInfo is not None
        assert EnvLoader is not None
        assert Employer is not None
        assert Experience is not None
        assert Employment is not None
        assert Vacancy is not None
    
        # Проверяем методы классов
        config = APIConfig()
        assert hasattr(config, 'get_pagination_params')
    
        app_config = AppConfig()
        assert hasattr(app_config, 'get_storage_type')
        assert hasattr(app_config, 'set_storage_type')
    
>       employer = Employer("Test")
                   ^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 2 were given

tests/test_complete_coverage_all_modules.py:311: TypeError
_____________ TestCompleteCoverage.test_error_handling_and_edge_cases ______________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa5dd0>

    def test_error_handling_and_edge_cases(self):
        """Тест обработки ошибок и крайних случаев"""
        # Тест AppConfig с невалидным типом
        app_config = AppConfig()
        with pytest.raises(ValueError):
            app_config.set_storage_type("invalid_type")
    
        # Тест EnvLoader с исключением
        EnvLoader._loaded = False
        with patch('os.path.exists', return_value=True):
            with patch('builtins.open', side_effect=IOError("Test error")):
                EnvLoader.load_env_file(".env")  # Не должно падать
    
        # Тест EnvLoader с невалидным int
        with patch.dict(os.environ, {"INVALID_INT": "not_a_number"}):
            result = EnvLoader.get_env_var_int("INVALID_INT", 42)
            assert result == 42
    
        # Тест создания моделей с None значениями
>       employer = Employer(None)
                   ^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 2 were given

tests/test_complete_coverage_all_modules.py:335: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.env_loader:env_loader.py:75 Ошибка при загрузке .env: Test error
WARNING  src.utils.env_loader:env_loader.py:110 Не удалось преобразовать INVALID_INT в int, используется значение по умолчанию: 42
_____________ TestCompleteCoverage.test_all_to_dict_from_dict_methods ______________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa63d0>

    def test_all_to_dict_from_dict_methods(self):
        """Тест всех методов сериализации/десериализации"""
        # Employer
>       employer = Employer("Test", "123", True, "http://test.com")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 5 were given

tests/test_complete_coverage_all_modules.py:351: TypeError
______________ TestCompleteCoverage.test_properties_and_compatibility ______________

self = <test_complete_coverage_all_modules.TestCompleteCoverage object at 0x7f1cc4fa69d0>

    def test_properties_and_compatibility(self):
        """Тест свойств и обратной совместимости"""
>       employer = Employer("Prop Test", "prop123", True, "http://prop.com")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: BaseModel.__init__() takes 1 positional argument but 5 were given

tests/test_complete_coverage_all_modules.py:376: TypeError
____________________ TestFileOperations.test_write_json_success ____________________

self = <Mock name='parent().mkdir' id='139761523894928'>, args = ()
kwargs = {'exist_ok': True, 'parents': True}
msg = "Expected 'mkdir' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mkdir' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <test_file_handlers_100_coverage.TestFileOperations object at 0x7f1cc4b66f90>

    def test_write_json_success(self):
        """Тест успешной записи JSON файла - покрывает строки 57-67"""
        handler = FileOperations()
        file_path = Path("output.json")
        test_data = [{"id": 1, "name": "test"}]
    
        # Создаем proper контекстный менеджер для temp_file.open
        temp_file_mock = MagicMock()
        temp_file_mock.exists.return_value = False
        temp_file_mock.open.return_value.__enter__ = MagicMock()
        temp_file_mock.open.return_value.__exit__ = MagicMock()
    
        with patch('pathlib.Path.with_suffix', return_value=temp_file_mock), \
             patch('pathlib.Path.parent') as mock_parent, \
             patch('json.dump') as mock_json_dump:
    
            mock_parent_obj = Mock()
            mock_parent.return_value = mock_parent_obj
    
            # Выполняем запись
            handler.write_json(file_path, test_data)
    
            # Основные проверки
>           mock_parent_obj.mkdir.assert_called_once_with(parents=True, exist_ok=True)
E           AssertionError: Expected 'mkdir' to be called once. Called 0 times.

tests/test_file_handlers_100_coverage.py:133: AssertionError
_________________ TestEmployer.test_employer_init_with_all_params __________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4327950>

    def test_employer_init_with_all_params(self):
        """Тест инициализации Employer со всеми параметрами - покрывает строки 18-28"""
        employer = Employer(
            name="Test Company",
            employer_id="123",
            trusted=True,
            alternate_url="https://company.com"
        )
    
>       assert employer._name == "Test Company"
               ^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Employer(name='Test Company', id=None, trusted=True, alternate_url='https://company.com')
item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Employer' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
__________________ TestEmployer.test_employer_init_minimal_params __________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4327c90>

    def test_employer_init_minimal_params(self):
        """Тест инициализации Employer с минимальными параметрами"""
        employer = Employer(name="Minimal Company")
    
>       assert employer._name == "Minimal Company"
               ^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Employer(name='Minimal Company', id=None, trusted=None, alternate_url=None)
item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Employer' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
_____________________ TestEmployer.test_get_name_without_name ______________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4344390>

    def test_get_name_without_name(self):
        """Тест get_name без имени"""
>       employer = Employer(name="")
                   ^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Employer
E       name
E         String should have at least 1 character [type=string_too_short, input_value='', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/string_too_short

tests/test_vacancy_models_100_coverage.py:56: ValidationError
_____________________________ TestEmployer.test_get_id _____________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4344890>

    def test_get_id(self):
        """Тест get_id - покрывает строки 34-36"""
        employer = Employer(name="Test", employer_id="456")
    
        result = employer.get_id()
    
>       assert result == "456"
E       AssertionError: assert None == '456'

tests/test_vacancy_models_100_coverage.py:68: AssertionError
____________________________ TestEmployer.test_to_dict _____________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4345a90>

    def test_to_dict(self):
        """Тест to_dict - покрывает строки 46-48"""
        employer = Employer(
            name="Dict Company",
            employer_id="789",
            trusted=False,
            alternate_url="https://dict.com"
        )
    
        result = employer.to_dict()
    
        expected = {
            "name": "Dict Company",
            "id": "789",
            "trusted": False,
            "alternate_url": "https://dict.com"
        }
>       assert result == expected
E       AssertionError: assert {'alternate_u...usted': False} == {'alternate_u...usted': False}
E         
E         Omitting 3 identical items, use -vv to show
E         Differing items:
E         {'id': None} != {'id': '789'}
E         Use -v to get more diff

tests/test_vacancy_models_100_coverage.py:103: AssertionError
__________________ TestEmployer.test_from_dict_with_minimal_data ___________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4346650>

    def test_from_dict_with_minimal_data(self):
        """Тест from_dict с минимальными данными"""
        data = {}
    
>       employer = Employer.from_dict(data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'src.vacancies.models.Employer'>, data = {}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Employer":
        """Создание объекта из словаря"""
>       return cls(**data)
               ^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for Employer
E       name
E         Field required [type=missing, input_value={}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/missing

src/vacancies/models.py:102: ValidationError
___________________________ TestEmployer.test_str_method ___________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4346c50>

    def test_str_method(self):
        """Тест __str__ метода - покрывает строки 60-61"""
        employer = Employer(name="String Company")
    
        result = str(employer)
    
>       assert result == "String Company"
E       assert "name='String...nate_url=None" == 'String Company'
E         
E         - String Company
E         + name='String Company' id=None trusted=None alternate_url=None

tests/test_vacancy_models_100_coverage.py:138: AssertionError
__________________________ TestEmployer.test_id_property ___________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4347e50>

    def test_id_property(self):
        """Тест свойства id - покрывает строки 71-73"""
        employer = Employer(name="Test", employer_id="prop123")
    
>       assert employer.id == "prop123"
E       AssertionError: assert None == 'prop123'
E        +  where None = Employer(name='Test', id=None, trusted=None, alternate_url=None).id

tests/test_vacancy_models_100_coverage.py:158: AssertionError
_________________________ TestEmployer.test_get_method_id __________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc4344250>

    def test_get_method_id(self):
        """Тест get метода с ключом id - покрывает строки 88-89"""
        employer = Employer(name="Test", employer_id="get123")
    
        result = employer.get("id")
    
>       assert result == "get123"
E       AssertionError: assert None == 'get123'

tests/test_vacancy_models_100_coverage.py:186: AssertionError
__________________________ TestEmployer.test_eq_with_dict __________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc434d650>

    def test_eq_with_dict(self):
        """Тест __eq__ с словарем - покрывает строки 96-99"""
        employer = Employer(name="Equal Company", employer_id="eq123")
        dict_data = {"name": "Equal Company", "id": "eq123"}
    
>       assert employer == dict_data
E       AssertionError: assert Employer(name...nate_url=None) == {'id': 'eq123...qual Company'}
E         
E         Use -v to get more diff

tests/test_vacancy_models_100_coverage.py:217: AssertionError
__________________________ TestEmployer.test_hash_method ___________________________

self = <test_vacancy_models_100_coverage.TestEmployer object at 0x7f1cc434e4d0>

    def test_hash_method(self):
        """Тест __hash__ метода - покрывает строку 104-105"""
        employer = Employer(name="Hash Company", employer_id="hash123")
    
        # Должен возвращать хеш без ошибок
>       hash_value = hash(employer)
                     ^^^^^^^^^^^^^^
E       TypeError: unhashable type: 'Employer'

tests/test_vacancy_models_100_coverage.py:238: TypeError
_______________ TestExperience.test_experience_init_with_all_params ________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc434ed50>

    def test_experience_init_with_all_params(self):
        """Тест инициализации Experience со всеми параметрами"""
        experience = Experience(name="1-3 года", experience_id="exp123")
    
>       assert experience._name == "1-3 года"
               ^^^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:250: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Experience(name='1-3 года', id=None), item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Experience' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
___________________ TestExperience.test_experience_init_minimal ____________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc434f350>

    def test_experience_init_minimal(self):
        """Тест инициализации Experience с минимальными параметрами"""
        experience = Experience(name="Опыт не требуется")
    
>       assert experience._name == "Опыт не требуется"
               ^^^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Experience(name='Опыт не требуется', id=None), item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Experience' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
____________________________ TestExperience.test_get_id ____________________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc434ff90>

    def test_get_id(self):
        """Тест get_id"""
        experience = Experience(name="Опыт", experience_id="test_id")
    
        result = experience.get_id()
    
>       assert result == "test_id"
E       AssertionError: assert None == 'test_id'

tests/test_vacancy_models_100_coverage.py:274: AssertionError
___________________________ TestExperience.test_to_dict ____________________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc43505d0>

    def test_to_dict(self):
        """Тест to_dict"""
        experience = Experience(name="Более 6 лет", experience_id="exp456")
    
        result = experience.to_dict()
    
        expected = {"name": "Более 6 лет", "id": "exp456"}
>       assert result == expected
E       AssertionError: assert {'id': None, ...'Более 6 лет'} == {'id': 'exp45...'Более 6 лет'}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'id': None} != {'id': 'exp456'}
E         Use -v to get more diff

tests/test_vacancy_models_100_coverage.py:283: AssertionError
__________________________ TestExperience.test_str_method __________________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc43517d0>

    def test_str_method(self):
        """Тест __str__"""
        experience = Experience(name="Средний опыт")
    
        result = str(experience)
    
>       assert result == "Средний опыт"
E       assert "name='Средний опыт' id=None" == 'Средний опыт'
E         
E         - Средний опыт
E         + name='Средний опыт' id=None

tests/test_vacancy_models_100_coverage.py:309: AssertionError
_________________________ TestExperience.test_repr_method __________________________

self = <test_vacancy_models_100_coverage.TestExperience object at 0x7f1cc4351dd0>

    def test_repr_method(self):
        """Тест __repr__"""
        experience = Experience(name="Большой опыт", experience_id="big_exp")
    
        result = repr(experience)
    
>       assert result == "Experience(name='Большой опыт')"
E       assert "Experience(n...ыт', id=None)" == "Experience(n...ольшой опыт')"
E         
E         - Experience(name='Большой опыт')
E         + Experience(name='Большой опыт', id=None)
E         ?                               +++++++++

tests/test_vacancy_models_100_coverage.py:317: AssertionError
_______________ TestEmployment.test_employment_init_with_all_params ________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc43525d0>

    def test_employment_init_with_all_params(self):
        """Тест инициализации Employment со всеми параметрами"""
        employment = Employment(name="Полная занятость", employment_id="full123")
    
>       assert employment._name == "Полная занятость"
               ^^^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Employment(name='Полная занятость', id=None), item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Employment' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
___________________ TestEmployment.test_employment_init_minimal ____________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc4352bd0>

    def test_employment_init_minimal(self):
        """Тест инициализации Employment с минимальными параметрами"""
        employment = Employment(name="Частичная занятость")
    
>       assert employment._name == "Частичная занятость"
               ^^^^^^^^^^^^^^^^

tests/test_vacancy_models_100_coverage.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Employment(name='Частичная занятость', id=None), item = '_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Employment' object has no attribute '_name'

.pythonlibs/lib/python3.11/site-packages/pydantic/main.py:991: AttributeError
____________________________ TestEmployment.test_get_id ____________________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc4353810>

    def test_get_id(self):
        """Тест get_id"""
        employment = Employment(name="Стажировка", employment_id="intern123")
    
        result = employment.get_id()
    
>       assert result == "intern123"
E       AssertionError: assert None == 'intern123'

tests/test_vacancy_models_100_coverage.py:351: AssertionError
___________________________ TestEmployment.test_to_dict ____________________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc4353e10>

    def test_to_dict(self):
        """Тест to_dict"""
        employment = Employment(name="Волонтерство", employment_id="vol456")
    
        result = employment.to_dict()
    
        expected = {"name": "Волонтерство", "id": "vol456"}
>       assert result == expected
E       AssertionError: assert {'id': None, ...Волонтерство'} == {'id': 'vol45...Волонтерство'}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'id': None} != {'id': 'vol456'}
E         Use -v to get more diff

tests/test_vacancy_models_100_coverage.py:360: AssertionError
__________________________ TestEmployment.test_str_method __________________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc4352ad0>

    def test_str_method(self):
        """Тест __str__"""
        employment = Employment(name="Сменная работа")
    
        result = str(employment)
    
>       assert result == "Сменная работа"
E       assert "name='Сменна...бота' id=None" == 'Сменная работа'
E         
E         - Сменная работа
E         + name='Сменная работа' id=None

tests/test_vacancy_models_100_coverage.py:386: AssertionError
_________________________ TestEmployment.test_repr_method __________________________

self = <test_vacancy_models_100_coverage.TestEmployment object at 0x7f1cc4352290>

    def test_repr_method(self):
        """Тест __repr__"""
        employment = Employment(name="Вахтовый метод", employment_id="vahta123")
    
        result = repr(employment)
    
>       assert result == "Employment(name='Вахтовый метод')"
E       assert "Employment(n...од', id=None)" == "Employment(n...товый метод')"
E         
E         - Employment(name='Вахтовый метод')
E         + Employment(name='Вахтовый метод', id=None)
E         ?                                 +++++++++

tests/test_vacancy_models_100_coverage.py:394: AssertionError
______________________ TestVacancy.test_vacancy_init_minimal _______________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc434dd10>
mock_datetime = <MagicMock name='datetime' id='139761517410704'>
mock_uuid = <MagicMock name='uuid4' id='139761515223760'>

    @patch('src.vacancies.models.uuid.uuid4')
    @patch('src.vacancies.models.datetime')
    def test_vacancy_init_minimal(self, mock_datetime, mock_uuid):
        """Тест инициализации Vacancy с минимальными параметрами"""
        mock_uuid.return_value.hex = "test_uuid_hex"
        mock_datetime.now.return_value.isoformat.return_value = "2024-01-01T12:00:00"
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Test Job",
            url="https://test.com"
        )
E       pydantic_core._pydantic_core.ValidationError: 2 validation errors for Vacancy
E       name
E         Field required [type=missing, input_value={'vacancy_id': '123', 'ti...rl': 'https://test.com'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/missing
E       alternate_url
E         Field required [type=missing, input_value={'vacancy_id': '123', 'ti...rl': 'https://test.com'}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/missing

tests/test_vacancy_models_100_coverage.py:407: ValidationError
__________________ TestVacancy.test_vacancy_init_with_all_params ___________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc434d850>

    def test_vacancy_init_with_all_params(self):
        """Тест инициализации Vacancy со всеми параметрами"""
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        employer = Employer(name="Test Company")
    
        with patch('src.vacancies.models.uuid.uuid4') as mock_uuid:
            mock_uuid.return_value.hex = "test_uuid"
    
>           vacancy = Vacancy(
                vacancy_id="456",
                title="Senior Developer",
                url="https://senior.com",
                salary=salary_data,
                description="Great job",
                requirements="Python skills",
                responsibilities="Coding",
                employer=employer,
                area="Moscow",
                experience="3-6 лет",
                employment="Полная занятость",
                schedule="Полный день",
                published_at="2024-01-01",
                source="test_source"
            )
E           pydantic_core._pydantic_core.ValidationError: 5 validation errors for Vacancy
E           name
E             Field required [type=missing, input_value={'vacancy_id': '456', 'ti...'source': 'test_source'}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           alternate_url
E             Field required [type=missing, input_value={'vacancy_id': '456', 'ti...'source': 'test_source'}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           experience
E             Input should be a valid dictionary or instance of Experience [type=model_type, input_value='3-6 лет', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/model_type
E           employment
E             Input should be a valid dictionary or instance of Employment [type=model_type, input_value='Полная занятость', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/model_type
E           schedule
E             Input should be a valid dictionary or instance of Schedule [type=model_type, input_value='Полный день', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.11/v/model_type

tests/test_vacancy_models_100_coverage.py:425: ValidationError
_________________________ TestVacancy.test_salary_property _________________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc4358310>

    def test_salary_property(self):
        """Тест свойства salary"""
        with patch('src.vacancies.models.uuid.uuid4'):
>           vacancy = Vacancy(
                vacancy_id="123",
                title="Test",
                url="url",
                salary={"from": 50000}
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for Vacancy
E           name
E             Field required [type=missing, input_value={'vacancy_id': '123', 'ti...alary': {'from': 50000}}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           alternate_url
E             Field required [type=missing, input_value={'vacancy_id': '123', 'ti...alary': {'from': 50000}}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

tests/test_vacancy_models_100_coverage.py:458: ValidationError
_____________________ TestVacancy.test_employer_property_dict ______________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc4358910>

    def test_employer_property_dict(self):
        """Тест свойства employer с словарем"""
        employer_data = {"name": "Dict Company", "id": "dict123"}
    
        with patch('src.vacancies.models.uuid.uuid4'):
>           vacancy = Vacancy("123", "Test", "url", employer=employer_data)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: BaseModel.__init__() takes 1 positional argument but 4 were given

tests/test_vacancy_models_100_coverage.py:472: TypeError
____________________ TestVacancy.test_employer_property_object _____________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc4358e10>

    def test_employer_property_object(self):
        """Тест свойства employer с объектом"""
        employer_obj = Employer(name="Object Company")
    
        with patch('src.vacancies.models.uuid.uuid4'):
>           vacancy = Vacancy("123", "Test", "url", employer=employer_obj)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: BaseModel.__init__() takes 1 positional argument but 4 were given

tests/test_vacancy_models_100_coverage.py:482: TypeError
_____________________ TestVacancy.test_from_dict_complete_data _____________________

self = <test_vacancy_models_100_coverage.TestVacancy object at 0x7f1cc4359410>

    def test_from_dict_complete_data(self):
        """Тест from_dict с полными данными"""
        data = {
            "id": "from_dict_123",
            "name": "From Dict Job",
            "title": "Alternative Title",
            "alternate_url": "https://fromdict.com",
            "url": "https://direct.com",
            "salary": {"from": 80000, "to": 120000},
            "snippet": {
                "requirement": "Python",
                "responsibility": "Development"
            },