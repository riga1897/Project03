platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 531 items                                                    

tests/test_abstract.py ........                                  [  1%]
tests/test_abstract_db_manager.py ....                           [  2%]
tests/test_api_config.py ....                                    [  3%]
tests/test_api_data_filter.py ........                           [  4%]
tests/test_app_config.py .....                                   [  5%]
tests/test_base_api.py ......                                    [  6%]
tests/test_base_formatter.py ..........                          [  8%]
tests/test_base_parser.py ......                                 [  9%]
tests/test_cache.py .......                                      [ 10%]
tests/test_cache_manager.py .....F.......                        [ 13%]
tests/test_cached_api.py ...........                             [ 15%]
tests/test_console_interface.py ......                           [ 16%]
tests/test_db_config.py .....                                    [ 17%]
tests/test_db_manager.py .................                       [ 20%]
tests/test_decorators.py .......                                 [ 22%]
tests/test_env_loader.py ............                            [ 24%]
tests/test_file_handlers.py ............                         [ 26%]
tests/test_get_api.py ......                                     [ 27%]
tests/test_hh_api.py .......                                     [ 29%]
tests/test_hh_api_config.py .....                                [ 29%]
tests/test_hh_parser.py ........                                 [ 31%]
tests/test_menu_manager.py ..........                            [ 33%]
tests/test_menu_system.py .................F..                   [ 37%]
tests/test_paginator.py ......                                   [ 38%]
tests/test_postgres_saver.py .......                             [ 39%]
tests/test_salary_utils.py ......................                [ 43%]
tests/test_search_utils.py ............................          [ 48%]
tests/test_sj_api.py ..............                              [ 51%]
tests/test_sj_api_config.py .....                                [ 52%]
tests/test_sj_parser.py ........                                 [ 54%]
tests/test_source_manager.py .................                   [ 57%]
tests/test_source_selector.py ..................                 [ 60%]
tests/test_storage_factory.py ........                           [ 62%]
tests/test_target_companies.py .....                             [ 63%]
tests/test_ui_config.py .....                                    [ 64%]
tests/test_ui_helpers.py ...........                             [ 66%]
tests/test_ui_navigation.py ......FF.........                    [ 69%]
tests/test_unified_api.py .................                      [ 72%]
tests/test_user_interface.py .F.FF....F..                        [ 74%]
tests/test_vacancy_display_handler.py ..............             [ 77%]
tests/test_vacancy_formatter.py ........                         [ 78%]
tests/test_vacancy_models.py ................................... [ 85%]
..............                                                   [ 88%]
tests/test_vacancy_operations.py ......                          [ 89%]
tests/test_vacancy_operations_coordinator.py .F.FF..F..E...EF... [ 92%]
......                                                           [ 93%]
tests/test_vacancy_search_handler.py .FFF.E.EFFEFFFFF.FFFF       [ 97%]
tests/test_vacancy_stats.py EEEF.E.F...                          [100%]

================================ ERRORS ================================
_ ERROR at setup of TestVacancyOperationsCoordinator.test_storage_integration _

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f1e350>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Senior Python Developer",
                url="https://hh.ru/vacancy/111",
                vacancy_id="111",
                source="hh.ru",
                employer={"name": "TechCorp"},
>               salary=Salary(150000, 200000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                description="Python разработчик с опытом Django"
            ),
            Vacancy(
                title="Java Backend Developer",
                url="https://superjob.ru/vacancy/222",
                vacancy_id="222",
                source="superjob.ru",
                employer={"name": "DevCompany"},
                salary=Salary(120000, 180000),
                description="Java разработчик для backend приложений"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_operations_coordinator.py:580: TypeError
_ ERROR at setup of TestVacancyOperationsCoordinator.test_vacancy_management_workflow _

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f4b390>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Senior Python Developer",
                url="https://hh.ru/vacancy/111",
                vacancy_id="111",
                source="hh.ru",
                employer={"name": "TechCorp"},
>               salary=Salary(150000, 200000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                description="Python разработчик с опытом Django"
            ),
            Vacancy(
                title="Java Backend Developer",
                url="https://superjob.ru/vacancy/222",
                vacancy_id="222",
                source="superjob.ru",
                employer={"name": "DevCompany"},
                salary=Salary(120000, 180000),
                description="Java разработчик для backend приложений"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_operations_coordinator.py:580: TypeError
_ ERROR at setup of TestVacancySearchHandler.test_save_search_results __

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2fdf250>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
>               salary=Salary(120000, 180000)
                       ^^^^^^^^^^^^^^^^^^^^^^
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary(100000, 160000)
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_search_handler.py:177: TypeError
_ ERROR at setup of TestVacancySearchHandler.test_storage_integration __

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd4b90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
>               salary=Salary(120000, 180000)
                       ^^^^^^^^^^^^^^^^^^^^^^
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary(100000, 160000)
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_search_handler.py:177: TypeError
__ ERROR at setup of TestVacancySearchHandler.test_search_statistics ___

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd5ed0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
>               salary=Salary(120000, 180000)
                       ^^^^^^^^^^^^^^^^^^^^^^
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary(100000, 160000)
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_search_handler.py:177: TypeError
_____ ERROR at setup of TestVacancyStats.test_company_distribution _____

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f84ad0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
>               salary=Salary(100000, 150000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary(120000, 180000),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_stats.py:357: TypeError
_____ ERROR at setup of TestVacancyStats.test_source_distribution ______

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f84250>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
>               salary=Salary(100000, 150000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary(120000, 180000),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_stats.py:357: TypeError
______ ERROR at setup of TestVacancyStats.test_salary_percentiles ______

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f85c90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
>               salary=Salary(100000, 150000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary(120000, 180000),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_stats.py:357: TypeError
____ ERROR at setup of TestVacancyStats.test_display_company_stats _____

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f868d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий"""
        return [
            Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
>               salary=Salary(100000, 150000),
                       ^^^^^^^^^^^^^^^^^^^^^^
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary(120000, 180000),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 3 were given

tests/test_vacancy_stats.py:357: TypeError
=============================== FAILURES ===============================
______________ TestCacheManager.test_cache_ttl_expiration ______________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7f93c4319ad0>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7f93c2b99910>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени
>       with patch('src.utils.cache.datetime') as mock_datetime:

tests/test_cache_manager.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f93c2b99750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/cache.py'> does not have the attribute 'datetime'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestMenuManager.test_submenu_navigation ________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7f93c37691d0>
mock_print = <MagicMock name='print' id='140272599693328'>
mock_input = <MagicMock name='input' id='140272599671696'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7f93c279f390>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140272599671696'>
args = ('\nВыберите пункт меню: ',), kwargs = {}
effect = <list_iterator object at 0x7f93c3750e50>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
__________ TestUINavigation.test_quick_paginate_specific_page __________

self = <workspace.tests.test_ui_navigation.TestUINavigation object at 0x7f93c2f58c50>
mock_print = <MagicMock name='print' id='140272599267152'>
mock_input = <MagicMock name='input' id='140272599965840'>
sample_items = [{'description': 'Description 1', 'id': 1, 'title': 'Item 1'}, {'description': 'Description 2', 'id': 2, 'title': 'Ite...tion': 'Description 5', 'id': 5, 'title': 'Item 5'}, {'description': 'Description 6', 'id': 6, 'title': 'Item 6'}, ...]

    @patch('builtins.input', side_effect=["1", "q"]) # Тест перехода на 1 страницу
    @patch('builtins.print')
    def test_quick_paginate_specific_page(self, mock_print, mock_input, sample_items):
        """Тест перехода на конкретную страницу"""
        if SRC_AVAILABLE:
            quick_paginate_func = quick_paginate
            formatter_func = lambda item, number=None: f"{number}. {item['id']}: {item['title']}" if number else f"{item['id']}: {item['title']}"
        else:
            def quick_paginate_test(items, formatter, header="", items_per_page=10, show_numbers=True, custom_actions=None):
                print(f"\n{header}")
                print("=" * 50)
                total_items = len(items)
                total_pages = (total_items + items_per_page - 1) // items_per_page
                current_page = 0
                while current_page < total_pages:
                    start_idx = current_page * items_per_page
                    end_idx = min(start_idx + items_per_page, total_items)
                    for i in range(start_idx, end_idx):
                        if show_numbers:
                            print(f"{i + 1}. {formatter(items[i], i + 1)}")
                        else:
                            print(formatter(items[i]))
                    print(f"\nСтраница {current_page + 1} из {total_pages}")
                    if current_page < total_pages - 1:
                        input("Нажмите Enter для следующей страницы или 'q' для выхода: ")
                    else:
                        input("Нажмите Enter для завершения...")
                    current_page += 1
    
            quick_paginate_func = quick_paginate_test
            formatter_func = lambda item, number=None: f"{number}. {item['id']}: {item['title']}" if number else f"{item['id']}: {item['title']}"
    
>       quick_paginate_func(
            sample_items,
            formatter=formatter_func,
            header="Test Page Navigation",
            items_per_page=3
        )

tests/test_ui_navigation.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_ui_navigation.py:296: in quick_paginate_test
    input("Нажмите Enter для следующей страницы или 'q' для выхода: ")
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140272599965840'>
args = ("Нажмите Enter для следующей страницы или 'q' для выхода: ",)
kwargs = {}, effect = <list_iterator object at 0x7f93c3340100>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
____________ TestUINavigation.test_quick_paginate_next_page ____________

self = <workspace.tests.test_ui_navigation.TestUINavigation object at 0x7f93c2f58710>
mock_print = <MagicMock name='print' id='140272603711760'>
mock_input = <MagicMock name='input' id='140272603766544'>
sample_items = [{'description': 'Description 1', 'id': 1, 'title': 'Item 1'}, {'description': 'Description 2', 'id': 2, 'title': 'Ite...tion': 'Description 5', 'id': 5, 'title': 'Item 5'}, {'description': 'Description 6', 'id': 6, 'title': 'Item 6'}, ...]

    @patch('builtins.input', side_effect=["", "q"]) # Тест без ввода номера страницы
    @patch('builtins.print')
    def test_quick_paginate_next_page(self, mock_print, mock_input, sample_items):
        """Тест перехода на следующую страницу по Enter"""
        if SRC_AVAILABLE:
            quick_paginate_func = quick_paginate
            formatter_func = lambda item, number=None: f"{number}. {item['id']}: {item['title']}" if number else f"{item['id']}: {item['title']}"
        else:
            def quick_paginate_test(items, formatter, header="", items_per_page=10, show_numbers=True, custom_actions=None):
                print(f"\n{header}")
                print("=" * 50)
                total_items = len(items)
                total_pages = (total_items + items_per_page - 1) // items_per_page
                current_page = 0
                while current_page < total_pages:
                    start_idx = current_page * items_per_page
                    end_idx = min(start_idx + items_per_page, total_items)
                    for i in range(start_idx, end_idx):
                        if show_numbers:
                            print(f"{i + 1}. {formatter(items[i], i + 1)}")
                        else:
                            print(formatter(items[i]))
                    print(f"\nСтраница {current_page + 1} из {total_pages}")
                    if current_page < total_pages - 1:
                        input("Нажмите Enter для следующей страницы, 'q' для выхода: ")
                    else:
                        input("Нажмите Enter для завершения...")
                    current_page += 1
    
            quick_paginate_func = quick_paginate_test
            formatter_func = lambda item, number=None: f"{number}. {item['id']}: {item['title']}" if number else f"{item['id']}: {item['title']}"
    
>       quick_paginate_func(
            sample_items,
            formatter=formatter_func,
            header="Test Next Page",
            items_per_page=3
        )

tests/test_ui_navigation.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_ui_navigation.py:336: in quick_paginate_test
    input("Нажмите Enter для следующей страницы, 'q' для выхода: ")
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140272603766544'>
args = ("Нажмите Enter для следующей страницы, 'q' для выхода: ",)
kwargs = {}, effect = <list_iterator object at 0x7f93c37d9c30>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
_____________ TestUserInterface.test_main_function_mocked ______________

self = <MagicMock name='UserInterface' id='140272599099536'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'UserInterface' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f93c3355810>
mock_user_interface_class = <MagicMock name='UserInterface' id='140272599099536'>
mock_storage_factory = <MagicMock name='StorageFactory' id='140272599101200'>
mock_app_config_class = <MagicMock name='AppConfig' id='140272604247568'>
mock_db_manager_class = <MagicMock name='DBManager' id='140272603866960'>
mock_logging = <MagicMock name='logging' id='140272599263952'>

    @patch('src.user_interface.logging')
    @patch('src.storage.db_manager.DBManager')
    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.storage_factory.StorageFactory')
    @patch('src.ui_interfaces.console_interface.UserInterface')
    def test_main_function_mocked(
        self,
        mock_user_interface_class,
        mock_storage_factory,
        mock_app_config_class,
        mock_db_manager_class,
        mock_logging
    ):
        """Тест главной функции с полными моками"""
        try:
            from src.user_interface import main
        except ImportError:
            pytest.skip("Модуль user_interface не найден")
    
        # Настройка моков для базы данных
        mock_logger = Mock()
        mock_logging.getLogger.return_value = mock_logger
    
        mock_db_manager = Mock()
        mock_db_manager.check_connection.return_value = True
        mock_db_manager.create_tables.return_value = None
        mock_db_manager.populate_companies_table.return_value = None
        mock_db_manager.get_companies_and_vacancies_count.return_value = []
        mock_db_manager_class.return_value = mock_db_manager
    
        # Настройка моков для конфигурации
        mock_app_config = Mock()
        mock_app_config.default_storage_type = "postgres"
    
        # Мокируем методы конфигурации базы данных
        mock_db_config = Mock()
        mock_db_config.get.return_value = "localhost"  # Возвращаем строки вместо Mock объектов
        mock_app_config.get_db_config.return_value = mock_db_config
        mock_app_config_class.return_value = mock_app_config
    
        mock_storage = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage
    
        mock_ui = Mock()
        mock_ui.run.return_value = None
        mock_user_interface_class.return_value = mock_ui
    
        # Выполняем функцию main
        try:
            main()
    
            # Проверяем, что все компоненты были инициализированы
            mock_db_manager_class.assert_called_once()
            mock_app_config_class.assert_called_once()
>           mock_user_interface_class.assert_called_once()
E           AssertionError: Expected 'UserInterface' to have been called once. Called 0 times.

tests/test_user_interface.py:75: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f93c3355810>
mock_user_interface_class = <MagicMock name='UserInterface' id='140272599099536'>
mock_storage_factory = <MagicMock name='StorageFactory' id='140272599101200'>
mock_app_config_class = <MagicMock name='AppConfig' id='140272604247568'>
mock_db_manager_class = <MagicMock name='DBManager' id='140272603866960'>
mock_logging = <MagicMock name='logging' id='140272599263952'>

    @patch('src.user_interface.logging')
    @patch('src.storage.db_manager.DBManager')
    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.storage_factory.StorageFactory')
    @patch('src.ui_interfaces.console_interface.UserInterface')
    def test_main_function_mocked(
        self,
        mock_user_interface_class,
        mock_storage_factory,
        mock_app_config_class,
        mock_db_manager_class,
        mock_logging
    ):
        """Тест главной функции с полными моками"""
        try:
            from src.user_interface import main
        except ImportError:
            pytest.skip("Модуль user_interface не найден")
    
        # Настройка моков для базы данных
        mock_logger = Mock()
        mock_logging.getLogger.return_value = mock_logger
    
        mock_db_manager = Mock()
        mock_db_manager.check_connection.return_value = True
        mock_db_manager.create_tables.return_value = None
        mock_db_manager.populate_companies_table.return_value = None
        mock_db_manager.get_companies_and_vacancies_count.return_value = []
        mock_db_manager_class.return_value = mock_db_manager
    
        # Настройка моков для конфигурации
        mock_app_config = Mock()
        mock_app_config.default_storage_type = "postgres"
    
        # Мокируем методы конфигурации базы данных
        mock_db_config = Mock()
        mock_db_config.get.return_value = "localhost"  # Возвращаем строки вместо Mock объектов
        mock_app_config.get_db_config.return_value = mock_db_config
        mock_app_config_class.return_value = mock_app_config
    
        mock_storage = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage
    
        mock_ui = Mock()
        mock_ui.run.return_value = None
        mock_user_interface_class.return_value = mock_ui
    
        # Выполняем функцию main
        try:
            main()
    
            # Проверяем, что все компоненты были инициализированы
            mock_db_manager_class.assert_called_once()
            mock_app_config_class.assert_called_once()
            mock_user_interface_class.assert_called_once()
        except Exception as e:
            # Ожидаем ошибку из-за проблем с конфигурацией БД в моках
>           assert "базы данных" in str(e).lower() or "database" in str(e).lower()
E           assert ('базы данных' in "expected 'userinterface' to have been called once. called 0 times." or 'database' in "expected 'userinterface' to have been called once. called 0 times.")
E            +  where "expected 'userinterface' to have been called once. called 0 times." = <built-in method lower of str object at 0x7f93c2f274b0>()
E            +    where <built-in method lower of str object at 0x7f93c2f274b0> = "Expected 'UserInterface' to have been called once. Called 0 times.".lower
E            +      where "Expected 'UserInterface' to have been called once. Called 0 times." = str(AssertionError("Expected 'UserInterface' to have been called once. Called 0 times."))
E            +  and   "expected 'userinterface' to have been called once. called 0 times." = <built-in method lower of str object at 0x7f93c2f274b0>()
E            +    where <built-in method lower of str object at 0x7f93c2f274b0> = "Expected 'UserInterface' to have been called once. Called 0 times.".lower
E            +      where "Expected 'UserInterface' to have been called once. Called 0 times." = str(AssertionError("Expected 'UserInterface' to have been called once. Called 0 times."))

tests/test_user_interface.py:78: AssertionError
------------------------- Captured stdout call -------------------------

Критическая ошибка: invalid integer value "localhost" for connection option "port"

Обратитесь к разработчику для решения проблемы.
-------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: invalid integer value "localhost" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: invalid integer value "localhost" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД localhost: invalid integer value "localhost" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных localhost недоступна и не может быть создана
ERROR    src.user_interface:user_interface.py:67 Критическая ошибка: invalid integer value "localhost" for connection option "port"
______________ TestUserInterface.test_vacancy_model_basic ______________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f93c3354550>

    def test_vacancy_model_basic(self):
        """Тест базовой модели вакансии"""
        try:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            # Правильное создание объекта Salary согласно реальному API
>           salary = Salary(100000, 150000, "RUR")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_user_interface.py:109: TypeError
______________ TestUserInterface.test_salary_model_basic _______________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f93c3356410>

    def test_salary_model_basic(self):
        """Тест базовой модели зарплаты"""
        try:
            from src.utils.salary import Salary
    
            # Правильное создание объекта Salary
>           salary = Salary(50000, 80000, "RUR")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_user_interface.py:133: TypeError
_____________ TestUserInterface.test_logging_configuration _____________

self = <MagicMock name='logging.basicConfig' id='140272599128144'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'basicConfig' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f93c33aebd0>
mock_logging = <MagicMock name='logging' id='140272599419536'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что логирование было настроено
>           mock_logging.basicConfig.assert_called()
E           AssertionError: Expected 'basicConfig' to have been called.

tests/test_user_interface.py:219: AssertionError
_____ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f3df50>
mock_print = <MagicMock name='print' id='140272599937616'>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f93c27daa90>

    @patch('builtins.print')
    def test_handle_vacancy_search(self, mock_print, coordinator):
        """Тест обработки поиска вакансий"""
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:603: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f93c4cf31d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call -------------------------
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary _

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f3e550>
mock_print = <MagicMock name='print' id='140272599263952'>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f93c2736dd0>

    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, coordinator):
        """Тест обработки топ вакансий по зарплате"""
>       coordinator.handle_top_vacancies_by_salary()

tests/test_vacancy_operations_coordinator.py:619: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_operations_coordinator.py:55: in handle_top_vacancies_by_salary
    self.display_handler.show_top_vacancies_by_salary()
src/ui_interfaces/vacancy_display_handler.py:74: in show_top_vacancies_by_salary
    n = get_positive_integer("\nВведите количество вакансий для отображения: ")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:43: in get_positive_integer
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f93c4cf31d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call -------------------------

Введите количество вакансий для отображения: 
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword _

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f3d790>
mock_print = <MagicMock name='print' id='140272600049616'>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f93c27f44d0>

    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, coordinator):
        """Тест обработки поиска по ключевому слову"""
>       coordinator.handle_search_saved_by_keyword()

tests/test_vacancy_operations_coordinator.py:627: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_operations_coordinator.py:59: in handle_search_saved_by_keyword
    self.display_handler.search_saved_vacancies_by_keyword()
src/ui_interfaces/vacancy_display_handler.py:113: in search_saved_vacancies_by_keyword
    keyword = get_user_input("\nВведите ключевое слово для поиска в описании: ")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:23: in get_user_input
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f93c4cf31d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call -------------------------

Введите ключевое слово для поиска в описании: 
_____ TestVacancyOperationsCoordinator.test_handle_superjob_setup ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f1fb10>
mock_print = <MagicMock name='print' id='140272603296848'>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f93c2b0ee10>

    @patch('builtins.print')
    def test_handle_superjob_setup(self, mock_print, coordinator):
        """Тест обработки настройки SuperJob API"""
>       coordinator.handle_superjob_setup()

tests/test_vacancy_operations_coordinator.py:651: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_operations_coordinator.py:227: in handle_superjob_setup
    input("\nНажмите Enter для продолжения...")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f93c4cf31d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call -------------------------

Нажмите Enter для продолжения...
_____ TestVacancyOperationsCoordinator.test_superjob_configuration _____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f93c2f04f90>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f93c33bec90>

    def test_superjob_configuration(self, coordinator):
        """Тест настройки SuperJob API"""
        # Тест метода настройки
>       coordinator.handle_superjob_setup()

tests/test_vacancy_operations_coordinator.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_operations_coordinator.py:227: in handle_superjob_setup
    input("\nНажмите Enter для продолжения...")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f93c4cf31d0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call -------------------------

============================================================
НАСТРОЙКА SUPERJOB API
============================================================
SuperJob API ключ уже настроен

Для получения API ключа SuperJob:
1. Перейдите на https://api.superjob.ru/register/
2. Зарегистрируйте ваше приложение
3. Получите Secret key
4. Добавьте его в Secrets как SUPERJOB_API_KEY

Инструкция по добавлению секретов:
• Откройте панель Secrets в левом меню
• Нажмите 'New Secret'
• Введите Key: SUPERJOB_API_KEY
• Введите Value: ваш настоящий API ключ
• Нажмите 'Add Secret'
• Перезапустите приложение

============================================================

Нажмите Enter для продолжения...
_________ TestVacancySearchHandler.test_search_vacancies_basic _________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2fdeb90>
mock_print = <MagicMock name='print' id='140272595741520'>
mock_input = <MagicMock name='input' id='140272595744144'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c23d8f50>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
>       result = search_handler.search_vacancies("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:201: TypeError
_ TestVacancySearchHandler.test_search_vacancies_with_different_sources _

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2fde210>
mock_print = <MagicMock name='print' id='140272603465872'>
mock_input = <MagicMock name='input' id='140272603469072'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c2b3a790>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_with_different_sources(self, mock_print, mock_input, search_handler):
        """Тест поиска с разными источниками"""
        sources = ["hh.ru", "superjob.ru", "all"]
    
        for source in sources:
>           result = search_handler.search_vacancies("Python", source)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 3 were given

tests/test_vacancy_search_handler.py:214: TypeError
_ TestVacancySearchHandler.test_search_vacancies_with_different_periods _

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2fdf6d0>
mock_print = <MagicMock name='print' id='140272604161360'>
mock_input = <MagicMock name='input' id='140272599425744'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c3330e50>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_with_different_periods(self, mock_print, mock_input, search_handler):
        """Тест поиска с разными периодами"""
        periods = [1, 7, 15, 30]
    
        for period in periods:
>           result = search_handler.search_vacancies("Python", "hh.ru", period)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 4 were given

tests/test_vacancy_search_handler.py:224: TypeError
_____ TestVacancySearchHandler.test_search_with_invalid_parameters _____

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd4ed0>
mock_print = <MagicMock name='print' id='140272604246288'>
mock_input = <MagicMock name='input' id='140272603801744'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c378c610>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_with_invalid_parameters(self, mock_print, mock_input, search_handler):
        """Тест поиска с некорректными параметрами"""
        # Тест с пустым запросом
>       result = search_handler.search_vacancies("")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:294: TypeError
________ TestVacancySearchHandler.test_search_results_structure ________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd5d10>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c2be72d0>

    def test_search_results_structure(self, search_handler):
        """Тест структуры результатов поиска"""
>       result = search_handler.search_vacancies("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:303: TypeError
__ TestVacancySearchHandler.test_parametrized_search[Python-hh.ru-7] ___

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd6a10>
mock_print = <MagicMock name='print' id='140272594897296'>
mock_input = <MagicMock name='input' id='140272594897936'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c230d2d0>
query = 'Python', source = 'hh.ru', period = 7

    @pytest.mark.parametrize("query,source,period", [
        ("Python", "hh.ru", 7),
        ("Java", "superjob.ru", 15),
        ("DevOps", "all", 30),
        ("", "hh.ru", 1),
    ])
    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_parametrized_search(self, mock_print, mock_input, search_handler, query, source, period):
        """Параметризованный тест поиска"""
>       result = search_handler.search_vacancies(query, source, period)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 4 were given

tests/test_vacancy_search_handler.py:339: TypeError
_ TestVacancySearchHandler.test_parametrized_search[Java-superjob.ru-15] _

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd7110>
mock_print = <MagicMock name='print' id='140272599955280'>
mock_input = <MagicMock name='input' id='140272599944400'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c27ddb10>
query = 'Java', source = 'superjob.ru', period = 15

    @pytest.mark.parametrize("query,source,period", [
        ("Python", "hh.ru", 7),
        ("Java", "superjob.ru", 15),
        ("DevOps", "all", 30),
        ("", "hh.ru", 1),
    ])
    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_parametrized_search(self, mock_print, mock_input, search_handler, query, source, period):
        """Параметризованный тест поиска"""
>       result = search_handler.search_vacancies(query, source, period)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 4 were given

tests/test_vacancy_search_handler.py:339: TypeError
___ TestVacancySearchHandler.test_parametrized_search[DevOps-all-30] ___

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd7210>
mock_print = <MagicMock name='print' id='140272604110480'>
mock_input = <MagicMock name='input' id='140272607725904'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c2bd6f10>
query = 'DevOps', source = 'all', period = 30

    @pytest.mark.parametrize("query,source,period", [
        ("Python", "hh.ru", 7),
        ("Java", "superjob.ru", 15),
        ("DevOps", "all", 30),
        ("", "hh.ru", 1),
    ])
    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_parametrized_search(self, mock_print, mock_input, search_handler, query, source, period):
        """Параметризованный тест поиска"""
>       result = search_handler.search_vacancies(query, source, period)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 4 were given

tests/test_vacancy_search_handler.py:339: TypeError
_____ TestVacancySearchHandler.test_parametrized_search[-hh.ru-1] ______

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd7ad0>
mock_print = <MagicMock name='print' id='140272599676368'>
mock_input = <MagicMock name='input' id='140272599663312'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c279b450>
query = '', source = 'hh.ru', period = 1

    @pytest.mark.parametrize("query,source,period", [
        ("Python", "hh.ru", 7),
        ("Java", "superjob.ru", 15),
        ("DevOps", "all", 30),
        ("", "hh.ru", 1),
    ])
    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_parametrized_search(self, mock_print, mock_input, search_handler, query, source, period):
        """Параметризованный тест поиска"""
>       result = search_handler.search_vacancies(query, source, period)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 4 were given

tests/test_vacancy_search_handler.py:339: TypeError
__________ TestVacancySearchHandler.test_concurrent_searches ___________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd7e10>
mock_print = <MagicMock name='print' id='140272593245904'>
mock_input = <MagicMock name='input' id='140272595289616'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c217a810>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, mock_input, search_handler):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            return search_handler.search_vacancies(query)
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_vacancy_search_handler.py:355: in <listcomp>
    results = [future.result() for future in concurrent.futures.as_completed(futures)]
               ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/thread.py:58: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

query = 'JavaScript'

    def search_task(query):
>       return search_handler.search_vacancies(query)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:351: TypeError
__________ TestVacancySearchHandler.test_performance_metrics ___________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bc7690>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c27f0b50>

    def test_performance_metrics(self, search_handler):
        """Тест метрик производительности"""
        import time
    
        start_time = time.time()
>       result = search_handler.search_vacancies("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:382: TypeError
__________ TestVacancySearchHandler.test_integration_workflow __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bd4850>
mock_print = <MagicMock name='print' id='140272600040336'>
mock_input = <MagicMock name='input' id='140272600051216'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c27f5010>
mock_storage = <Mock id='140272600042960'>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_integration_workflow(self, mock_print, mock_input, search_handler, mock_storage):
        """Тест интеграционного рабочего процесса"""
        search_handler.storage = mock_storage
    
        # Полный цикл: поиск -> сохранение -> статистика
>       vacancies = search_handler.search_vacancies("Python")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:396: TypeError
______________ TestVacancySearchHandler.test_memory_usage ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2fc55d0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c2751f50>

    def test_memory_usage(self, search_handler):
        """Тест использования памяти"""
        import gc
    
        # Выполняем поиск и проверяем, что память освобождается
        initial_objects = len(gc.get_objects())
    
        for _ in range(10):
>           result = search_handler.search_vacancies("Python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.search_vacancies() takes 1 positional argument but 2 were given

tests/test_vacancy_search_handler.py:414: TypeError
______ TestVacancySearchHandler.test_user_interaction_simulation _______

self = <MagicMock name='print' id='140272603383952'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f93c2bc7310>
mock_print = <MagicMock name='print' id='140272603383952'>
mock_input = <MagicMock name='input' id='140272603384528'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f93c2b26110>

    @patch('builtins.input', return_value="q")  # Имитируем выход
    @patch('builtins.print')
    def test_user_interaction_simulation(self, mock_print, mock_input, search_handler):
        """Тест симуляции пользовательского взаимодействия"""
        # Проверяем корректность обработки пользовательского ввода
        if hasattr(search_handler, 'handle_search_workflow'):
            try:
                search_handler.handle_search_workflow()
            except Exception as e:
                # Ошибки должны быть обработаны
                assert isinstance(e, Exception)
    
>       mock_print.assert_called()
E       AssertionError: Expected 'print' to have been called.

tests/test_vacancy_search_handler.py:435: AssertionError
______________ TestVacancyStats.test_empty_vacancies_list ______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f86810>

    def test_empty_vacancies_list(self):
        """Тест с пустым списком вакансий"""
        empty_list = []
    
>       distribution = VacancyStats.get_company_distribution(empty_list)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:417: AttributeError
__________ TestVacancyStats.test_company_statistics_detailed ___________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f93c2f87d10>

    def test_company_statistics_detailed(self):
        """Тест детальной статистики по компаниям"""
        vacancies = [
            Vacancy(
                title="Job 1",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 2",
                url="https://test.com/2",
                vacancy_id="2",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 3",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "Company B", "id": "456"}
            )
        ]
    
>       stats = VacancyStats.get_company_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:491: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

vacancies = [<src.vacancies.models.Vacancy object at 0x7f93c23ee4e0>, <src.vacancies.models.Vacancy object at 0x7f93c23ef930>, <src.vacancies.models.Vacancy object at 0x7f93c23ef380>]

    def get_company_statistics(vacancies: List[Vacancy]) -> Dict[str, Any]:
>       company_stats = VacancyStats.get_company_distribution(vacancies)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:281: AttributeError
======================= short test summary info ========================
FAILED tests/test_cache_manager.py::TestCacheManager::test_cache_ttl_expiration - AttributeError: <module 'src.utils.cache' from '/home/runner/worksp...
FAILED tests/test_menu_system.py::TestMenuManager::test_submenu_navigation - StopIteration
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_specific_page - StopIteration
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_next_page - StopIteration
FAILED tests/test_user_interface.py::TestUserInterface::test_main_function_mocked - assert ('базы данных' in "expected 'userinterface' to have been cal...
FAILED tests/test_user_interface.py::TestUserInterface::test_vacancy_model_basic - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
FAILED tests/test_user_interface.py::TestUserInterface::test_salary_model_basic - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
FAILED tests/test_user_interface.py::TestUserInterface::test_logging_configuration - AssertionError: Expected 'basicConfig' to have been called.
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_vacancy_search - OSError: pytest: reading from stdin while output is captured!  Cons...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_top_vacancies_by_salary - OSError: pytest: reading from stdin while output is captured!  Cons...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_search_saved_by_keyword - OSError: pytest: reading from stdin while output is captured!  Cons...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_superjob_setup - OSError: pytest: reading from stdin while output is captured!  Cons...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_superjob_configuration - OSError: pytest: reading from stdin while output is captured!  Cons...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_basic - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_with_different_sources - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_with_different_periods - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_with_invalid_parameters - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_results_structure - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search[Python-hh.ru-7] - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search[Java-superjob.ru-15] - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search[DevOps-all-30] - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search[-hh.ru-1] - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_concurrent_searches - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_performance_metrics - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_integration_workflow - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_memory_usage - TypeError: VacancySearchHandler.search_vacancies() takes 1 position...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_user_interaction_simulation - AssertionError: Expected 'print' to have been called.
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_empty_vacancies_list - AttributeError: type object 'VacancyStats' has no attribute 'get_co...
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_company_statistics_detailed - AttributeError: type object 'VacancyStats' has no attribute 'get_co...
ERROR tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_storage_integration - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_vacancy_management_workflow - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_save_search_results - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_storage_integration - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_statistics - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_company_distribution - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_source_distribution - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_salary_percentiles - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
ERROR tests/test_vacancy_stats.py::TestVacancyStats::test_display_company_stats - TypeError: Salary.__init__() takes from 1 to 2 positional arguments...
=============== 29 failed, 493 passed, 9 errors in 3.11s ===============
~/workspace$ 