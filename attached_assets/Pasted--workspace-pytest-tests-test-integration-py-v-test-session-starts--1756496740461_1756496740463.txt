~/workspace$ pytest tests/test_integration.py -v
============================ test session starts ============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace/tests
configfile: pytest.ini
plugins: mock-3.14.1, cov-6.2.1
collected 11 items                                                          

tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration FAILED [  9%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_integration PASSED [ 18%]
tests/test_integration.py::TestAPIIntegration::test_superjob_api_integration PASSED [ 27%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow FAILED [ 36%]
tests/test_integration.py::TestCacheIntegration::test_cache_integration PASSED [ 45%]
tests/test_integration.py::TestErrorHandlingIntegration::test_api_error_handling PASSED [ 54%]
tests/test_integration.py::TestErrorHandlingIntegration::test_database_error_handling PASSED [ 63%]
tests/test_integration.py::TestFormatterIntegration::test_vacancy_formatter_integration PASSED [ 72%]
tests/test_integration.py::TestFormatterIntegration::test_brief_formatter_integration PASSED [ 81%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_filters PASSED [ 90%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_search PASSED [100%]

================================= FAILURES ==================================
__________ TestStorageIntegration.test_postgres_saver_integration ___________

self = <tests.test_integration.TestStorageIntegration object at 0x7f9b22d93b10>
mock_connect = <MagicMock name='connect' id='140304268171216'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f9b23646820>

    @patch("psycopg2.connect")
    def test_postgres_saver_integration(self, mock_connect, sample_vacancy):
        """Тест интеграции с PostgreSQL"""
        # Настраиваем мок подключения
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_cursor.fetchall.return_value = []
        # Исправляем мок для field_info - возвращаем правильную структуру
        # Добавляем больше ответов для всех возможных запросов
        mock_responses = [
            (0,),  # для check database exists
        ]
        # Добавляем ответы для каждого поля в required_fields (около 20 полей)
        for _ in range(25):
            mock_responses.extend([
                ("column_name", "integer"),
                ("column_name", "text"),
                ("column_name", "varchar"),
                ("column_name", "timestamp"),
            ])
    
        mock_cursor.fetchone.side_effect = mock_responses
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Создаем хранилище и тестируем операции
        storage = PostgresSaver()
    
        # Тест добавления
>       result = storage.add_vacancy(sample_vacancy)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:678: in add_vacancy
    return self.add_vacancy_batch_optimized(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:551: in add_vacancy_batch_optimized
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='connect().cursor()' id='140304268252112'>
sql = 'INSERT INTO temp_new_vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary_currency...rience,\n                    employment, schedule, area, source, published_at, company_id\n                ) VALUES %s'
argslist = [('test_1', 'Test Vacancy', 'https://test.com/vacancy/1', 100000, 150000, 'RUR', ...)]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='connect().cursor().connection.encoding' id='140304268510928'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
_________ TestFullWorkflowIntegration.test_search_and_save_workflow _________

self = <tests.test_integration.TestFullWorkflowIntegration object at 0x7f9b225f8810>
mock_connect_api = <MagicMock name='_CachedAPI__connect_to_api' id='140304264832912'>
mock_connect_db = <MagicMock name='connect' id='140304264829776'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f9b21d40120>

    @patch("psycopg2.connect")
    @patch("src.api_modules.hh_api.HeadHunterAPI._CachedAPI__connect_to_api")
    def test_search_and_save_workflow(self, mock_connect_api, mock_connect_db, sample_vacancy):
        """Тест полного процесса поиска и сохранения"""
        # Настраиваем мок для API
        mock_connect_api.return_value = {
            "items": [
                {
                    "id": "789",
                    "name": "Integration Test Job",
                    "alternate_url": "https://hh.ru/vacancy/789",
                    "employer": {"name": "Integration Company"},
                    "published_at": "2024-01-01T00:00:00+03:00",
                    "source": "hh.ru",
                }
            ],
            "found": 1,
            "pages": 1,
        }
    
        # Настраиваем мок для базы данных
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_cursor.fetchall.return_value = []
        # Настраиваем правильные ответы для всех запросов
        mock_responses = [
            (0,),  # для check database exists
        ]
        # Добавляем ответы для каждого поля в required_fields (около 20 полей)
        for _ in range(25):
            mock_responses.extend([
                ("column_name", "integer"),
                ("column_name", "text"),
                ("column_name", "varchar"),
                ("column_name", "timestamp"),
            ])
    
        mock_cursor.fetchone.side_effect = mock_responses
        mock_conn.cursor.return_value = mock_cursor
        mock_connect_db.return_value = mock_conn
    
        # Выполняем поиск
        api = HeadHunterAPI()
        vacancies_data = api.get_vacancies(search_query="python")
    
        # Конвертируем в объекты Vacancy
        vacancies = [Vacancy.from_dict(item) for item in vacancies_data]
    
        # Сохраняем результаты
        storage = PostgresSaver()
        for vacancy in vacancies:
>           result = storage.add_vacancy(vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:678: in add_vacancy
    return self.add_vacancy_batch_optimized(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:551: in add_vacancy_batch_optimized
    execute_values(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cur = <Mock name='connect().cursor()' id='140304264664016'>
sql = 'INSERT INTO temp_new_vacancies (\n                    vacancy_id, title, url, salary_from, salary_to, salary_currency...rience,\n                    employment, schedule, area, source, published_at, company_id\n                ) VALUES %s'
argslist = [('789', 'Integration Test Job', 'https://hh.ru/vacancy/789', None, None, 'RUR', ...)]
template = None, page_size = 1000, fetch = False

    def execute_values(cur, sql, argslist, template=None, page_size=100, fetch=False):
        '''Execute a statement using :sql:`VALUES` with a sequence of parameters.
    
        :param cur: the cursor to use to execute the query.
    
        :param sql: the query to execute. It must contain a single ``%s``
            placeholder, which will be replaced by a `VALUES list`__.
            Example: ``"INSERT INTO mytable (id, f1, f2) VALUES %s"``.
    
        :param argslist: sequence of sequences or dictionaries with the arguments
            to send to the query. The type and content must be consistent with
            *template*.
    
        :param template: the snippet to merge to every item in *argslist* to
            compose the query.
    
            - If the *argslist* items are sequences it should contain positional
              placeholders (e.g. ``"(%s, %s, %s)"``, or ``"(%s, %s, 42)``" if there
              are constants value...).
    
            - If the *argslist* items are mappings it should contain named
              placeholders (e.g. ``"(%(id)s, %(f1)s, 42)"``).
    
            If not specified, assume the arguments are sequence and use a simple
            positional template (i.e.  ``(%s, %s, ...)``), with the number of
            placeholders sniffed by the first element in *argslist*.
    
        :param page_size: maximum number of *argslist* items to include in every
            statement. If there are more items the function will execute more than
            one statement.
    
        :param fetch: if `!True` return the query results into a list (like in a
            `~cursor.fetchall()`).  Useful for queries with :sql:`RETURNING`
            clause.
    
        .. __: https://www.postgresql.org/docs/current/static/queries-values.html
    
        After the execution of the function the `cursor.rowcount` property will
        **not** contain a total result.
    
        While :sql:`INSERT` is an obvious candidate for this function it is
        possible to use it with other statements, for example::
    
            >>> cur.execute(
            ... "create table test (id int primary key, v1 int, v2 int)")
    
            >>> execute_values(cur,
            ... "INSERT INTO test (id, v1, v2) VALUES %s",
            ... [(1, 2, 3), (4, 5, 6), (7, 8, 9)])
    
            >>> execute_values(cur,
            ... """UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1)
            ... WHERE test.id = data.id""",
            ... [(1, 20), (4, 50)])
    
            >>> cur.execute("select * from test order by id")
            >>> cur.fetchall()
            [(1, 20, 3), (4, 50, 6), (7, 8, 9)])
    
        '''
        from psycopg2.sql import Composable
        if isinstance(sql, Composable):
            sql = sql.as_string(cur)
    
        # we can't just use sql % vals because vals is bytes: if sql is bytes
        # there will be some decoding error because of stupid codec used, and Py3
        # doesn't implement % on bytes.
        if not isinstance(sql, bytes):
>           sql = sql.encode(_ext.encodings[cur.connection.encoding])
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: <Mock name='connect().cursor().connection.encoding' id='140304264108816'>

.pythonlibs/lib/python3.11/site-packages/psycopg2/extras.py:1287: KeyError
--------------------------- Captured stderr call ----------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 5121.25page/s, vacancies=1]
========================== short test summary info ==========================
FAILED tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration - KeyError: <Mock name='connect().cursor().connection.encoding' id='140304...
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow - KeyError: <Mock name='connect().cursor().connection.encoding' id='140304...
======================== 2 failed, 9 passed in 0.30s ========================
~/workspace$ 