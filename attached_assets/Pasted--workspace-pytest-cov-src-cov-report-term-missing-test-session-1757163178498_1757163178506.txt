~/workspace$ pytest --cov=src --cov-report=term-missing
============================== test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 2032 items                                                            

tests/test_abstract.py ........                                           [  0%]
tests/test_abstract_db_manager.py ....                                    [  0%]
tests/test_abstract_filter_complete.py .........                          [  1%]
tests/test_api_complete.py ...................                            [  1%]
tests/test_api_config.py ....                                             [  2%]
tests/test_api_data_filter.py ......                                      [  2%]
tests/test_api_fixes.py .......                                           [  2%]
tests/test_api_infrastructure_final.py F...FF..FF.FFF......F.F            [  3%]
tests/test_api_modules.py ............................                    [  5%]
tests/test_api_modules_consolidated.py ....                               [  5%]
tests/test_api_modules_coverage.py ..F...F............                    [  6%]
tests/test_app_config.py .........                                        [  6%]
tests/test_base_api.py ...............                                    [  7%]
tests/test_base_formatter.py ..........                                   [  8%]
tests/test_base_formatter_complete.py ..............................      [  9%]
tests/test_base_parser.py ......                                          [  9%]
tests/test_cache.py ......................                                [ 10%]
tests/test_cached_api.py ....                                             [ 11%]
tests/test_cached_api_complete.py ................                        [ 11%]
tests/test_components_fixed.py ...                                        [ 12%]
tests/test_comprehensive_coverage_boost.py .............................. [ 13%]
.........                                                                 [ 14%]
tests/test_comprehensive_coverage_final.py ss...s.....sF.......F..        [ 15%]
tests/test_comprehensive_fixed.py .....                                   [ 15%]
tests/test_comprehensive_missing_coverage.py F.....FFFF.................. [ 16%]
.                                                                         [ 16%]
tests/test_config_consolidated.py .....                                   [ 17%]
tests/test_config_missing_coverage.py .....sssss.............ss...        [ 18%]
tests/test_config_modules_consolidated.py ......                          [ 18%]
tests/test_config_modules_coverage.py ...................FFF..........    [ 20%]
tests/test_console_interface.py ......                                    [ 20%]
tests/test_console_interface_coverage.py ..................               [ 21%]
tests/test_core_functionality_consolidated.py .....                       [ 21%]
tests/test_core_infrastructure_final.py ..F.......FF....F..FF..F..        [ 23%]
tests/test_core_modules_comprehensive.py ........                         [ 23%]
tests/test_critical_missing_coverage.py ......F.......................    [ 24%]
tests/test_data_normalizers_comprehensive.py ............................ [ 26%]
                                                                          [ 26%]
tests/test_database_connection.py ........                                [ 26%]
tests/test_db_config.py .....                                             [ 26%]
tests/test_db_manager.py .................                                [ 27%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                        [ 28%]
tests/test_decorators.py .......                                          [ 28%]
tests/test_description_parser.py ..........                               [ 29%]
tests/test_env_loader.py ................                                 [ 30%]
tests/test_filter_utils.py ......                                         [ 30%]
tests/test_final_coverage_fixes.py .FF...................                 [ 31%]
tests/test_final_critical_coverage.py ..FFF.............FF.               [ 32%]
tests/test_formatters_coverage.py ...........................             [ 33%]
tests/test_get_api_complete.py ....................                       [ 34%]
tests/test_hh_api_complete.py .................                           [ 35%]
tests/test_hh_api_config.py .....                                         [ 35%]
tests/test_hh_parser.py ........                                          [ 36%]
tests/test_integration.py .............                                   [ 37%]
tests/test_interfaces.py .ss                                              [ 37%]
tests/test_interfaces_coverage.py ..F..F...s........                      [ 38%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F...... [ 39%]
FF                                                                        [ 39%]
tests/test_main_application_interface.py ...                              [ 39%]
tests/test_main_application_interface_complete.py ....................... [ 40%]
....................                                                      [ 41%]
tests/test_main_consolidated.py .........                                 [ 42%]
tests/test_menu_manager.py ..........                                     [ 42%]
tests/test_missing_components.py .........                                [ 43%]
tests/test_missing_coverage_components.py .FF......FFFFF.....F            [ 44%]
tests/test_missing_coverage_extended.py ............F.FFF...........F.... [ 45%]
................FFF...                                                    [ 46%]
tests/test_models_coverage.py ...........................                 [ 48%]
tests/test_models_fixed.py ...                                            [ 48%]
tests/test_paginator.py ......                                            [ 48%]
tests/test_parsers_complete.py ............                               [ 49%]
tests/test_parsers_coverage.py .............................              [ 50%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                  [ 51%]
tests/test_real_components_coverage.py ........EEFE......F.               [ 52%]
tests/test_repository_fixed.py ..                                         [ 52%]
tests/test_salary_fixed.py ...........                                    [ 53%]
tests/test_salary_utils.py ......................                         [ 54%]
tests/test_search_utils.py ............................                   [ 55%]
tests/test_search_utils_complete.py ..................................... [ 57%]
.........                                                                 [ 57%]
tests/test_services_consolidated.py ....                                  [ 58%]
tests/test_services_coverage.py ............................              [ 59%]
tests/test_services_storage_consolidated.py ..........                    [ 59%]
tests/test_simple_db_adapter.py .........                                 [ 60%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                          [ 61%]
tests/test_sj_api.py ..............                                       [ 61%]
tests/test_sj_api_complete.py .............F....                          [ 62%]
tests/test_sj_api_config.py .....                                         [ 62%]
tests/test_sj_parser.py ........                                          [ 63%]
tests/test_sj_parser_complete.py ..............                           [ 64%]
tests/test_skip_conditions_removal.py ............                        [ 64%]
tests/test_source_manager.py .................                            [ 65%]
tests/test_source_selector.py .................                           [ 66%]
tests/test_storage_abstractions.py ........                               [ 66%]
tests/test_storage_abstractions_coverage.py ........                      [ 67%]
tests/test_storage_complete.py .............                              [ 67%]
tests/test_storage_components_complete.py ......F....FF...............F   [ 69%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF     [ 70%]
tests/test_storage_components_fixes.py ....F....F...............          [ 71%]
tests/test_storage_factory.py ........                                    [ 72%]
tests/test_storage_modules_consolidated.py ....                           [ 72%]
tests/test_target_companies.py .....                                      [ 72%]
tests/test_typed_data_processor.py ................                       [ 73%]
tests/test_ui_components_complete.py .................................... [ 75%]
..                                                                        [ 75%]
tests/test_ui_components_extended.py ..................                   [ 76%]
tests/test_ui_components_missing_tests.py ..........FEEE...........FEEE   [ 77%]
tests/test_ui_config.py .......................                           [ 78%]
tests/test_ui_helpers_comprehensive.py .................................. [ 80%]
.....                                                                     [ 80%]
tests/test_ui_helpers_extended.py ....................................... [ 82%]
.                                                                         [ 82%]
tests/test_ui_modules_consolidated.py .....                               [ 82%]
tests/test_ui_navigation.py ......................                        [ 83%]
tests/test_ui_navigation_complete.py ..s..                                [ 84%]
tests/test_ui_navigation_comprehensive.py ......                          [ 84%]
tests/test_ui_navigation_extended.py .......F...........................  [ 86%]
tests/test_unified_api.py ................F...F.                          [ 87%]
tests/test_unified_api_complete.py ......F......................          [ 88%]
tests/test_unified_api_fixed.py ...                                       [ 88%]
tests/test_user_interface.py ...............                              [ 89%]
tests/test_user_interface_consolidated.py F.F                             [ 89%]
tests/test_user_interface_coverage.py ssssssFEEEEE                        [ 90%]
tests/test_user_interface_fixed.py ...                                    [ 90%]
tests/test_utils_consolidated.py .....                                    [ 90%]
tests/test_utils_coverage.py ......s..s...ssssssss                        [ 91%]
tests/test_utils_ui_consolidated.py ......                                [ 92%]
tests/test_vacancy_abstractions.py .................                      [ 92%]
tests/test_vacancy_display_handler.py ...................                 [ 93%]
tests/test_vacancy_formatter.py ........                                  [ 94%]
tests/test_vacancy_models_complete.py ....                                [ 94%]
tests/test_vacancy_models_consolidated.py ....                            [ 94%]
tests/test_vacancy_operations.py ......                                   [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................  [ 96%]
tests/test_vacancy_operations_coordinator_complete.py ................... [ 97%]
...                                                                       [ 97%]
tests/test_vacancy_processing_coordinator.py .............                [ 97%]
tests/test_vacancy_repository.py .........                                [ 98%]
tests/test_vacancy_stats.py ............                                  [ 98%]
tests/test_vacancy_stats_fixed.py .........                               [ 99%]
tests/test_vacancy_validator.py ............                              [100%]

==================================== ERRORS =====================================
_____ ERROR at setup of TestFileCacheRealMethods.test_cache_key_generation ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fe999054e50>
temp_cache_dir = '/tmp/tmpwqo6qhti'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
______ ERROR at setup of TestFileCacheRealMethods.test_save_and_load_cycle ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fe999055210>
temp_cache_dir = '/tmp/tmppadl_nh1'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
____ ERROR at setup of TestFileCacheRealMethods.test_invalid_cache_handling _____

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fe999055c90>
temp_cache_dir = '/tmp/tmpj_w4bk9v'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_application_lifecycle _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7fe998cffc50>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_main_application_flow _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7fe998d042d0>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_configuration_management _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7fe998d04950>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_with_different_datasets __

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7fe998d08b10>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_navigation_comprehensive _

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7fe998d09150>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_______ ERROR at setup of TestPaginatorFixed.test_paginator_configuration _______

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7fe998d097d0>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_startup_sequence _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c45b50>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_menu_display_functionality _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c40d10>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_user_interaction_handling _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c54290>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_error_handling_in_interface _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c54bd0>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_lifecycle _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c54f50>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
=================================== FAILURES ====================================
____________ TestHeadHunterAPICore.test_hh_api_get_vacancies_success ____________

self = <MagicMock name='get' id='140641277276112'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7fe999639290>
mock_get = <MagicMock name='get' id='140641277276112'>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fe999a96010>

    @patch('requests.get')
    def test_hh_api_get_vacancies_success(self, mock_get, hh_api):
        """Тест успешного получения вакансий от HH API"""
        if not HH_API_AVAILABLE:
            return
    
        # Мокируем успешный ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Tech Corp"},
                    "salary": {"from": 100000, "to": 150000, "currency": "RUR"}
                }
            ],
            "found": 1,
            "pages": 1,
            "page": 0
        }
        mock_get.return_value = mock_response
    
        result = hh_api.get_vacancies("python")
    
        assert isinstance(result, list)
>       mock_get.assert_called()
E       AssertionError: Expected 'get' to have been called.

tests/test_api_infrastructure_final.py:91: AssertionError
----------------------------- Captured stderr call ------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 575.59page/s, vacancies=931]
_________________ TestHeadHunterAPICore.test_hh_api_pagination __________________

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7fe999617350>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fe99355df10>

    def test_hh_api_pagination(self, hh_api):
        """Тест пагинации"""
        if not HH_API_AVAILABLE:
            return
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "items": [],
                "found": 100,
                "pages": 5,
                "page": 0
            }
            mock_get.return_value = mock_response
    
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("python", page=2)
>               assert isinstance(result, dict)
E               AssertionError: assert False
E                +  where False = isinstance([{'accept_incomplete_resumes': False, 'accept_temporary': False, 'address': {'building': '3к2Б', 'city': 'Санкт-Петерб...тро Спортивная', 'city': 'Санкт-Петербург', 'description': None, 'id': '5687491', ...}, 'adv_context': None, ...}, ...], dict)

tests/test_api_infrastructure_final.py:149: AssertionError
_______________ TestSuperJobAPICore.test_sj_api_with_auth_header ________________

self = <tests.test_api_infrastructure_final.TestSuperJobAPICore object at 0x7fe99963aa10>
mock_get = <MagicMock name='get' id='140641254461264'>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fe998034890>

    @patch('requests.get')
    def test_sj_api_with_auth_header(self, mock_get, sj_api):
        """Тест SJ API с заголовком авторизации"""
        if not SJ_API_AVAILABLE:
            return
    
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 456,
                    "profession": "Python Developer",
                    "link": "https://superjob.ru/vacancy/456",
                    "firm_name": "SJ Corp",
                    "payment_from": 80000,
                    "payment_to": 120000,
                    "currency": "rub"
                }
            ],
            "total": 1
        }
        mock_get.return_value = mock_response
    
        result = sj_api.get_vacancies("python")
        assert isinstance(result, list)
    
        # Проверяем что использовался правильный заголовок
>       call_kwargs = mock_get.call_args[1]
                      ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/test_api_infrastructure_final.py:189: TypeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:163 SuperJob API ключ не настроен или используется тестовый ключ
________________ TestUnifiedAPICore.test_unified_api_aggregation ________________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7fe99963b6d0>
mock_sj = <MagicMock name='get_vacancies' id='140641179600656'>
mock_hh = <MagicMock name='get_vacancies' id='140641179601168'>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe9938d2050>

    @patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies')
    @patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies')
    def test_unified_api_aggregation(self, mock_sj, mock_hh, unified_api):
        """Тест агрегации данных от разных источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Мокируем ответы от разных API
        mock_hh.return_value = [{"id": "hh1", "source": "hh"}]
        mock_sj.return_value = [{"id": "sj1", "source": "sj"}]
    
>       result = unified_api.get_vacancies("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:238: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICore.test_unified_api_error_resilience ______________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7fe99963bc10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe998b77310>

    def test_unified_api_error_resilience(self, unified_api):
        """Тест устойчивости к ошибкам отдельных API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', side_effect=Exception("HH Error")), \
             patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies', return_value=[{"id": "sj1"}]):
    
>           result = unified_api.get_vacancies("python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:249: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestCachedAPICore.test_cached_api_cache_hit __________________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fe999644a90>
mock_save = <MagicMock name='save_response' id='140641271369104'>
mock_load = <MagicMock name='load_response' id='140641272904080'>
cached_api = <Mock spec='CachedAPI' id='140641271429392'>

    @patch('src.utils.cache.FileCache.load_response')
    @patch('src.utils.cache.FileCache.save_response')
    def test_cached_api_cache_hit(self, mock_save, mock_load, cached_api):
        """Тест попадания в кэш"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем попадание в кэш
        cached_data = {
            "items": [{"id": "cached1", "title": "Cached Job"}],
            "timestamp": datetime.now().timestamp()
        }
        mock_load.return_value = cached_data
    
        if hasattr(cached_api, 'get_vacancies'):
            result = cached_api.get_vacancies("python")
>           assert isinstance(result, list)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140641277551888'>, list)

tests/test_api_infrastructure_final.py:289: AssertionError
_________________ TestCachedAPICore.test_cached_api_cache_miss __________________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fe999645010>
mock_api = <MagicMock name='get_vacancies' id='140641270495952'>
mock_save = <MagicMock name='save_response' id='140641270495888'>
mock_load = <MagicMock name='load_response' id='140641276176784'>
cached_api = <Mock spec='CachedAPI' id='140641275463120'>

    @patch('src.utils.cache.FileCache.load_response')
    @patch('src.utils.cache.FileCache.save_response')
    @patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies')
    def test_cached_api_cache_miss(self, mock_api, mock_save, mock_load, cached_api):
        """Тест промаха кэша"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем промах кэша
        mock_load.return_value = None
        mock_api.return_value = [{"id": "new1", "title": "New Job"}]
    
        if hasattr(cached_api, 'get_vacancies'):
            result = cached_api.get_vacancies("python")
>           assert isinstance(result, list)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140641177973840'>, list)

tests/test_api_infrastructure_final.py:307: AssertionError
______________ TestCachedAPICore.test_cached_api_cache_expiration _______________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fe999645650>
cached_api = <Mock spec='CachedAPI' id='140641277165392'>

    def test_cached_api_cache_expiration(self, cached_api):
        """Тест истечения срока действия кэша"""
        if not CACHED_API_AVAILABLE:
            return
    
        # Мокируем устаревшие данные кэша
        old_timestamp = (datetime.now() - timedelta(hours=25)).timestamp()
        expired_data = {
            "items": [{"id": "old1"}],
            "timestamp": old_timestamp
        }
    
        with patch('src.utils.cache.FileCache.load_response', return_value=expired_data), \
             patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', return_value=[]):
    
            if hasattr(cached_api, 'get_vacancies'):
                result = cached_api.get_vacancies("python")
>               assert isinstance(result, list)
E               AssertionError: assert False
E                +  where False = isinstance(<Mock name='mock.get_vacancies()' id='140641174624272'>, list)

tests/test_api_infrastructure_final.py:329: AssertionError
_______________ TestAPIPerformanceCore.test_api_request_batching ________________

self = <tests.test_api_infrastructure_final.TestAPIPerformanceCore object at 0x7fe99964c710>

    def test_api_request_batching(self):
        """Тест батчинга запросов"""
        if UNIFIED_API_AVAILABLE:
            unified_api = UnifiedAPI()
    
            # Мокируем множественные запросы
            with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', return_value=[]) as mock_hh:
                queries = ["python", "java", "javascript"]
    
                if hasattr(unified_api, 'get_vacancies_batch'):
                    results = unified_api.get_vacancies_batch(queries)
                    assert isinstance(results, dict)
                else:
                    # Если батчинг не поддерживается, тестируем последовательные запросы
                    for query in queries:
>                       result = unified_api.get_vacancies(query)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E                       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:439: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestAPIIntegrationCore.test_full_api_pipeline _________________

self = <tests.test_api_infrastructure_final.TestAPIIntegrationCore object at 0x7fe99964d510>
mock_get = <MagicMock name='get' id='140641282076432'>

    @patch('requests.get')
    def test_full_api_pipeline(self, mock_get):
        """Тест полного пайплайна API"""
        if not (HH_API_AVAILABLE and UNIFIED_API_AVAILABLE):
            return
    
        # Мокируем весь пайплайн
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "test123",
                    "name": "Full Stack Developer",
                    "alternate_url": "https://hh.ru/vacancy/test123",
                    "employer": {"name": "Integration Corp"},
                    "salary": {"from": 120000, "to": 180000, "currency": "RUR"},
                    "snippet": {
                        "requirement": "Python, Django",
                        "responsibility": "Development"
                    },
                    "area": {"name": "Moscow"},
                    "published_at": "2025-01-20T10:30:00+0300"
                }
            ],
            "found": 1
        }
        mock_get.return_value = mock_response
    
        unified_api = UnifiedAPI()
>       vacancies = unified_api.get_vacancies("python")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:507: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________ TestUnifiedAPICoverage.test_search_with_filters ________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fe99968dc10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe993edfc50>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
        with patch.object(unified_api.hh_api, 'get_vacancies') as mock_hh, \
             patch.object(unified_api.sj_api, 'get_vacancies') as mock_sj:
    
            mock_hh.return_value = []
            mock_sj.return_value = []
    
>           result = unified_api.search_with_filters(search_params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'search_with_filters'

tests/test_api_modules_coverage.py:89: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____________ TestUnifiedAPICoverage.test_error_handling_api_failures ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fe99968f550>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe9990a5a10>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:162: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestStorageModules.test_postgres_saver_functionality ______________

self = <tests.test_comprehensive_coverage_final.TestStorageModules object at 0x7fe999412750>

    def test_postgres_saver_functionality(self):
        """Тест функциональности PostgreSQL сохранения"""
        if 'postgres_saver' not in MODULES_TO_TEST:
            pytest.skip("PostgresSaver not available")
    
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641177825616'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________ TestIntegrationCoverage.test_full_pipeline_coverage ______________

self = <tests.test_comprehensive_coverage_final.TestIntegrationCoverage object at 0x7fe999418850>

    def test_full_pipeline_coverage(self):
        """Тест полного пайплайна обработки данных"""
        # Создаем тестовые данные
        test_vacancy_data = {
            "id": "123456789",
            "name": "Senior Python Developer",
            "employer": {"name": "TechCorp"},
            "salary": {"from": 150000, "to": 200000, "currency": "RUR"},
            "area": {"name": "Москва"},
            "experience": {"name": "От 3 до 6 лет"},
            "description": "We are looking for a senior Python developer..."
        }
    
        # Тестируем цепочку: API -> Parser -> Model -> Storage
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка моков
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [test_vacancy_data]}
            mock_get.return_value = mock_response
    
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641184003920'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success ______

self = <Mock name='mock.execute' id='140641179670928'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7fe99943ce90>
mock_connect = <MagicMock name='connect' id='140641256903120'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe998235a50>
mock_connection = (<Mock name='connect()' id='140641256176080'>, <Mock id='140641256170256'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
_________ TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fe99943f590>
mock_connect = <MagicMock name='connect' id='140641177841744'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe99389ca10>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fe998255e60>

    @patch('psycopg2.connect')
    def test_save_vacancies_single_vacancy(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения одной вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
            # Используем реальный объект Vacancy
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe99389ca10>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe998255e60>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestPostgresSaverCoverage.test_delete_vacancy_by_id_success __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fe99943fb50>
mock_connect = <MagicMock name='connect' id='140641256377232'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f70190>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id_success(self, mock_connect, postgres_saver):
        """Тест успешного удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.rowcount = 1
    
            if hasattr(postgres_saver, 'delete_vacancy_by_id'):
>               result = postgres_saver.delete_vacancy_by_id('test123')
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f70190>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_______ TestPostgresSaverCoverage.test_error_handling_in_save_operations ________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f31f90>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe998257520>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
>           cursor = connection.cursor()
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'cursor'

src/storage/postgres_saver.py:352: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fe999444250>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f31f90>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fe998257520>

    def test_error_handling_in_save_operations(self, postgres_saver, mock_vacancy):
        """Тест обработки ошибок при сохранении"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch.object(postgres_saver, '_get_connection', return_value=None):
            # Тест с недоступным подключением
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f31f90>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe998257520>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
                if new_count > 5:
                    update_messages.append(f"... и еще {new_count - 5} новых вакансий")
                if updated_count > 5:
                    update_messages.append(f"... и еще {updated_count - 5} обновленных вакансий")
    
            connection.commit()
    
            total_input = len(vacancies)
    
            logger.info("Batch операция через временные таблицы:")
            logger.info(f"  Входящих вакансий: {total_input}")
            logger.info(f"  Добавлено в БД: {new_count}")
            logger.info(f"  Обновлено в БД: {updated_count}")
    
            # Дополнительная проверка количества записей в БД
            cursor.execute("SELECT COUNT(*) FROM vacancies")
            total_in_db = cursor.fetchone()[0]
            logger.info(f"  Итого записей в БД после операции: {total_in_db}")
    
            # Показываем сводку результатов
            logger.info(
                f"Результат: сохранено {new_count + updated_count} из {total_input} вакансий (новых: {new_count}, обновлено: {updated_count})"
            )
    
        except PsycopgError as e:
            logger.error(f"Ошибка при batch операции через временные таблицы: {e}")
            if not connection.closed:
                try:
                    connection.rollback()
                except Exception:
                    pass
            raise
        finally:
            if "cursor" in locals():
                cursor.close()
>           connection.close()
            ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'close'

src/storage/postgres_saver.py:638: AttributeError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fe999444890>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998049390>

    def test_batch_operations(self, postgres_saver):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        # Создаем набор тестовых вакансий
        test_vacancies = []
        for i in range(5):
            vacancy_data = {
                'vacancy_id': f'test{i}',
                'title': f'Job {i}',
                'url': f'https://test{i}.com',
                'description': f'Description {i}',
                'employer': {'name': f'Company {i}', 'employer_id': f'comp{i}'},
                'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
                'source': 'test'
            }
            test_vacancies.append(vacancy_data)
    
        # Мокаем соединение для пакетной операции
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            mock_conn.return_value = Mock()
>           result = postgres_saver.save_vacancies(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998049390>
vacancies = [{'description': 'Description 0', 'employer': {'employer_id': 'comp0', 'name': 'Company 0'}, 'salary': {'currency': 'R...d': 'comp4', 'name': 'Company 4'}, 'salary': {'currency': 'RUR', 'from': 100000, 'to': 150000}, 'source': 'test', ...}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________________ TestSJAPIConfigCoverage.test_get_api_key ____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fe9992a8210>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
___________________ TestSJAPIConfigCoverage.test_get_base_url ___________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fe9992a8850>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_______________ TestSJAPIConfigCoverage.test_get_request_headers ________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fe9992a8ed0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
_______________ TestVacancyModelsCore.test_employer_functionality _______________

self = <tests.test_core_infrastructure_final.TestVacancyModelsCore object at 0x7fe999309710>

    def test_employer_functionality(self):
        """Тест функциональности Employer"""
        if not VACANCY_MODELS_AVAILABLE:
            return
    
        employer = Employer(name="Tech Corp", employer_id="emp123")
        assert employer.name == "Tech Corp"
>       assert employer.employer_id == "emp123"
               ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'Employer' object has no attribute 'employer_id'

tests/test_core_infrastructure_final.py:105: AttributeError
_______ TestPostgresSaverCoreFixed.test_postgres_saver_with_real_vacancy ________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7fe999311090>
mock_connect = <MagicMock name='connect' id='140641185847120'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993e2e0d0>
real_vacancy_object = <src.vacancies.models.Vacancy object at 0x7fe993f3ab60>

    @patch('psycopg2.connect')
    def test_postgres_saver_with_real_vacancy(self, mock_connect, postgres_saver, real_vacancy_object):
        """Тест сохранения реального объекта вакансии"""
        if not POSTGRES_SAVER_AVAILABLE or not VACANCY_MODELS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Тестируем с реальным объектом Vacancy
>           result = postgres_saver.save_vacancies([real_vacancy_object])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993e2e0d0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe993f3ab60>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________ TestPostgresSaverCoreFixed.test_postgres_type_validation_fix __________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7fe999311650>
mock_connect = <MagicMock name='connect' id='140641178977296'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9981dcdd0>

    @patch('psycopg2.connect')
    def test_postgres_type_validation_fix(self, mock_connect, postgres_saver):
        """Тест исправления валидации типов"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 0
        mock_connect.return_value = mock_conn
    
        # Тест с невалидными данными (словари вместо объектов Vacancy)
        invalid_data = [
            {"id": "1", "title": "Job 1", "company_name": "Company 1"},
            {"id": "2", "title": "Job 2", "company_name": "Company 2"}
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать невалидные типы
>           result = postgres_saver.save_vacancies(invalid_data)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9981dcdd0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestUtilsCoreFunctionality.test_menu_manager_functionality ___________

self = <tests.test_core_infrastructure_final.TestUtilsCoreFunctionality object at 0x7fe9993094d0>

    def test_menu_manager_functionality(self):
        """Тест функциональности менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            menu_manager = MenuManager()
    
            if hasattr(menu_manager, 'display_menu'):
                with patch('builtins.print'):
                    menu_items = ['Option 1', 'Option 2', 'Exit']
>                   menu_manager.display_menu(menu_items)
E                   TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_core_infrastructure_final.py:428: TypeError
__________ TestCacheCoreFunctionality.test_file_cache_core_operations ___________

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7fe999313750>

    def test_file_cache_core_operations(self):
        """Тест основных операций файлового кэша"""
        try:
            from src.utils.cache import FileCache
    
            with tempfile.TemporaryDirectory() as temp_dir:
                cache = FileCache(cache_dir=temp_dir)
    
                test_data = {"test": "data", "items": [1, 2, 3]}
                test_params = {"query": "python", "page": 1}
    
                # Тест сохранения
                cache.save_response("test_source", test_params, test_data)
    
                # Тест загрузки
                loaded_data = cache.load_response("test_source", test_params)
    
                # Тест валидации
>               is_valid = cache.is_valid_response(test_data)
                           ^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'FileCache' object has no attribute 'is_valid_response'

tests/test_core_infrastructure_final.py:498: AttributeError
_____________ TestCacheCoreFunctionality.test_cache_error_handling ______________

self = PosixPath('/invalid/path'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           FileNotFoundError: [Errno 2] No such file or directory: '/invalid/path'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7fe999313a90>

    def test_cache_error_handling(self):
        """Тест обработки ошибок кэша"""
        try:
            from src.utils.cache import FileCache
    
            # Тест с недоступной директорией
>           cache = FileCache(cache_dir="/invalid/path")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/cache.py:17: in __init__
    self._ensure_dir_exists()
src/utils/cache.py:21: in _ensure_dir_exists
    self.cache_dir.mkdir(parents=True, exist_ok=True)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1120: in mkdir
    self.parent.mkdir(parents=True, exist_ok=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PosixPath('/invalid'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           OSError: [Errno 30] Read-only file system: '/invalid'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: OSError
___________ TestEdgeCasesCoreFinal.test_none_and_empty_data_handling ____________

self = <tests.test_core_infrastructure_final.TestEdgeCasesCoreFinal object at 0x7fe999318c50>

    def test_none_and_empty_data_handling(self):
        """Тест обработки None и пустых данных"""
        test_modules = [
            ('src.utils.data_normalizers', 'normalize_area_data'),
            ('src.utils.file_handlers', 'FileHandler'),
            ('src.utils.cache', 'FileCache')
        ]
    
        for module_name, class_or_func_name in test_modules:
            try:
                module = __import__(module_name, fromlist=[class_or_func_name])
>               target = getattr(module, class_or_func_name)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: module 'src.utils.file_handlers' has no attribute 'FileHandler'

tests/test_core_infrastructure_final.py:577: AttributeError
__________ TestPostgresSaverCriticalCoverage.test_transaction_rollback __________

self = <tests.test_critical_missing_coverage.TestPostgresSaverCriticalCoverage object at 0x7fe999332910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998b6edd0>
mock_connection = (<Mock id='140641179344080'>, <Mock id='140641178459024'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_cursor.execute.side_effect = Exception("Database error")
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            if hasattr(postgres_saver, 'save_vacancies'):
                test_vacancy = {'id': 'error_test', 'title': 'Error Job'}
>               result = postgres_saver.save_vacancies([test_vacancy])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_critical_missing_coverage.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998b6edd0>
vacancies = [{'id': 'error_test', 'title': 'Error Job'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______________ TestDBManagerCoverage.test_create_database_schema _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe99939a650>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993749150>
mock_connection = (<Mock id='140641254464784'>, <Mock name='mock.cursor()' id='140641178688592'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
_________________ TestDBManagerCoverage.test_save_company_data __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe99939aa50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993ae3150>
mock_connection = (<Mock id='140641274212176'>, <Mock name='mock.cursor()' id='140641274215056'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
_____________ TestDBManagerCoverage.test_save_vacancy_comprehensive _____________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe99939ae50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9937ba3d0>
mock_connection = (<Mock id='140641178467344'>, <Mock name='mock.cursor()' id='140641178468240'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
________________ TestDBManagerCoverage.test_bulk_save_operations ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe99939b3d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993739c50>
mock_connection = (<Mock id='140641177938832'>, <Mock name='mock.cursor()' id='140641177939984'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
__________________ TestDBManagerCoverage.test_query_operations __________________

self = <Mock name='mock.cursor().execute' id='140641179337232'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe99939bad0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993c98cd0>
mock_connection = (<Mock id='140641183577552'>, <Mock name='mock.cursor()' id='140641183579536'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140641179613904'>, исправляем...
________________ TestDBManagerCoverage.test_search_functionality ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991ac210>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993b19b50>
mock_connection = (<Mock id='140641181998480'>, <Mock name='mock.cursor()' id='140641181998096'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
_________________ TestDBManagerCoverage.test_filter_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991ac910>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe990f67a50>
mock_connection = (<Mock id='140641136174224'>, <Mock name='mock.cursor()' id='140641136177680'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
_______________ TestDBManagerCoverage.test_aggregation_operations _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991acfd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993722c10>
mock_connection = (<Mock id='140641177832784'>, <Mock name='mock.cursor()' id='140641177845200'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
_________________ TestDBManagerCoverage.test_update_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991ad6d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe99937f550>
mock_connection = (<Mock id='140641274805136'>, <Mock name='mock.cursor()' id='140641274794128'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
_________________ TestDBManagerCoverage.test_delete_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991addd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe99386f590>
mock_connection = (<Mock id='140641179203408'>, <Mock name='mock.cursor()' id='140641179202128'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
_______________ TestDBManagerCoverage.test_transaction_management _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fe9991ae4d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe99389dbd0>
mock_connection = (<Mock id='140641179398544'>, <Mock name='mock.cursor()' id='140641179394768'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
__________ TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ___________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fe99921c050>
mock_connect = <MagicMock name='connect' id='140641179155728'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe99387e650>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fe99825a4e0>

    @patch('psycopg2.connect')
    def test_save_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения реальных объектов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe99387e650>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe99825a4e0>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________ TestPostgresSaverFinalFixes.test_vacancy_type_validation ____________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fe99921c690>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9938a5750>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9938a5750>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
________ TestPostgresSaverFixedCoverage.test_database_schema_operations _________

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7fe999248f10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993856fd0>
mock_connection_complete = (<Mock id='140641178371984'>, <Mock id='140641178374480'>)

    def test_database_schema_operations(self, postgres_saver, mock_connection_complete):
        """Полное покрытие операций со схемой БД"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe9937a4fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fe993856fd0> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestPostgresSaverFixedCoverage.test_bulk_operations_complete __________

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7fe999249590>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993c9bf50>
mock_connection_complete = (<Mock id='140641254548816'>, <Mock id='140641254554960'>)

    def test_bulk_operations_complete(self, postgres_saver, mock_connection_complete):
        """Полное покрытие массовых операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
        test_companies = [
            {'company_id': 'comp1', 'name': 'Company 1', 'url': 'http://comp1.com'},
            {'company_id': 'comp2', 'name': 'Company 2', 'url': 'http://comp2.com'}
        ]
    
        test_vacancies = [
            {
                'vacancy_id': 'vac1',
                'title': 'Python Developer',
                'company_id': 'comp1',
                'salary_from': 100000,
                'salary_to': 150000,
                'currency': 'RUR',
                'description': 'Python development',
                'url': 'http://vacancy1.com',
                'published_at': datetime.now()
            }
        ]
    
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe998048bd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fe993c9bf50> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestPostgresSaverFixedCoverage.test_error_handling_and_transactions ______

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7fe999249bd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993826190>
mock_connection_complete = (<Mock id='140641179208848'>, <Mock id='140641179209744'>)

    def test_error_handling_and_transactions(self, postgres_saver, mock_connection_complete):
        """Полное покрытие обработки ошибок и транзакций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
        # Тест обработки ошибок подключения
        with patch('psycopg2.connect', side_effect=Exception("Database error")):
            if hasattr(postgres_saver, 'save_vacancies'):
                result = postgres_saver.save_vacancies([])
                assert isinstance(result, (int, list, type(None)))
    
        # Тест обработки ошибок выполнения
        mock_cursor.execute.side_effect = Exception("SQL error")
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993872010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fe993826190> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____ TestUnifiedAPIFixedCoverage.test_unified_api_error_resilience_complete _____

self = <tests.test_final_critical_coverage.TestUnifiedAPIFixedCoverage object at 0x7fe99924c510>
unified_api = <Mock spec='UnifiedAPI' id='140641254549840'>

    def test_unified_api_error_resilience_complete(self, unified_api):
        """Полное покрытие устойчивости к ошибкам"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Конфигурируем обработку ошибок
>       unified_api.handle_api_error.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_critical_coverage.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock spec='UnifiedAPI' id='140641254549840'>, name = 'handle_api_error'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
>               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'handle_api_error'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:653: AttributeError
__________ TestAppConfigFixedCoverage.test_app_config_loading_complete __________

self = <tests.test_final_critical_coverage.TestAppConfigFixedCoverage object at 0x7fe99924fa90>
app_config = <Mock spec='AppConfig' id='140641178704272'>

    def test_app_config_loading_complete(self, app_config):
        """Полное покрытие загрузки конфигурации"""
        if not APP_CONFIG_AVAILABLE:
            return
    
        # Конфигурируем Mock для методов конфигурации
>       app_config.load_config.return_value = {}
        ^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_critical_coverage.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock spec='AppConfig' id='140641178704272'>, name = 'load_config'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
>               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'load_config'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:653: AttributeError
_______ TestMainApplicationInterfaceCoverage.test_concrete_implementation _______

self = <tests.test_interfaces_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe9990ca450>

    def test_concrete_implementation(self):
        """Тест конкретной реализации интерфейса"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        # Создаем конкретную реализацию
        class ConcreteInterface(MainApplicationInterface):
            def run_application(self):
                return "Running"
    
>       interface = ConcreteInterface()
                    ^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_interfaces_coverage.py:87: TypeError
_____ TestVacancyDisplayHandlerCoverage.test_display_handler_methods_exist ______

self = <tests.test_interfaces_coverage.TestVacancyDisplayHandlerCoverage object at 0x7fe9990c4850>

    def test_display_handler_methods_exist(self):
        """Тест существования методов обработчика"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        mock_storage = Mock()
        try:
            handler = VacancyDisplayHandler(mock_storage)
        except TypeError:
            handler = VacancyDisplayHandler()
    
        # Проверяем наличие ожидаемых методов
        expected_methods = ['display_vacancies', 'display_vacancy_details', 'show_vacancies']
    
        existing_methods = [method for method in expected_methods if hasattr(handler, method)]
>       assert len(existing_methods) > 0, "Handler should have at least one display method"
E       AssertionError: Handler should have at least one display method
E       assert 0 > 0
E        +  where 0 = len([])

tests/test_interfaces_coverage.py:144: AssertionError
___________ TestDBManagerFixed.test_get_companies_and_vacancies_count ___________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990eac50>
mock_connect = <MagicMock name='connect' id='140640878310864'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe98197a790>
mock_connection = (<Mock name='connect()' id='140640878307792'>, <Mock id='140640878308240'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
___________________ TestDBManagerFixed.test_get_all_vacancies ___________________

self = <Mock name='mock.execute' id='140640878846992'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990eb210>
mock_connect = <MagicMock name='connect' id='140640877168464'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe98197a910>
mock_connection = (<Mock name='connect()' id='140640877166992'>, <Mock id='140640877166864'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640878462736'>, исправляем...
____________________ TestDBManagerFixed.test_get_avg_salary _____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990eb7d0>
mock_connect = <MagicMock name='connect' id='140640878706064'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe981979910>
mock_connection = (<Mock name='connect()' id='140640878702928'>, <Mock id='140640878691984'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640878571600'>, исправляем...
___________ TestDBManagerFixed.test_get_vacancies_with_higher_salary ____________

self = <Mock name='mock.execute' id='140640877656016'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990ebdd0>
mock_connect = <MagicMock name='connect' id='140640876787856'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe981807dd0>
mock_connection = (<Mock name='connect()' id='140640876788176'>, <Mock id='140640876788752'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640877553680'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640877546064'>, исправляем...
______________ TestDBManagerFixed.test_get_vacancies_with_keyword _______________

self = <Mock name='mock.execute' id='140640877315472'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990e43d0>
mock_connect = <MagicMock name='connect' id='140640878853008'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9818bed50>
mock_connection = (<Mock name='connect()' id='140640878844240'>, <Mock id='140640878850576'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640877434448'>, исправляем...
__________________ TestDBManagerFixed.test_get_database_stats ___________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fe9990e4990>
mock_connect = <MagicMock name='connect' id='140640877459024'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9818ab210>
mock_connection = (<Mock name='connect()' id='140640877459600'>, <Mock id='140640877458128'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640877002512'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_____ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects ______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fe9990e5290>
mock_connect = <MagicMock name='connect' id='140641185645776'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9818cc550>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fe993b17ba0>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9818cc550>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fe993b17ba0>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______________ TestPostgresSaverFixed.test_delete_vacancy_by_id ________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fe9990e5e10>
mock_connect = <MagicMock name='connect' id='140640876959888'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f314d0>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993f314d0>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count ________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fe9990e6d90>
mock_connect = <MagicMock name='connect' id='140641178589712'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9981ebf10>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
________________ TestSimpleDBAdapterFixed.test_get_all_vacancies ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fe9990e7350>
mock_connect = <MagicMock name='connect' id='140641256081680'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9981c1f50>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
___________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword ____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fe9990e7910>
mock_connect = <MagicMock name='connect' id='140641178002960'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993748890>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
______________ TestSimpleDBAdapterFixed.test_init_database_schema _______________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fe9990e7f90>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9981c0790>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe9981c1ad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9981c0790> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestAPIModulesFixed.test_hh_api_methods_coverage ________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fe9990fd790>
mock_get = <MagicMock name='get' id='140641174823696'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
____________ TestAPIModulesFixed.test_cached_api_basic_functionality ____________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fe9990fe1d0>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
___________________ TestEdgeCasesFixed.test_db_empty_results ____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fe999109250>
mock_connect = <MagicMock name='connect' id='140640877180560'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140641178697616'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140640877224016'>, исправляем...
_______________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _______________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fe999109850>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
___________ TestAPIModulesIntegration.test_sj_api_basic_functionality ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7fe999179c10>

    def test_sj_api_basic_functionality(self):
        """Тест базовой функциональности SuperJob API"""
        if not SJ_API_AVAILABLE:
            pytest.skip("SuperJobAPI not available")
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"objects": [], "total": 0}
            mock_get.return_value = mock_response
    
            sj_api = SuperJobAPI()
            assert sj_api is not None
    
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:86: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________ TestAPIModulesIntegration.test_unified_api_filter_methods ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7fe99917a210>

    def test_unified_api_filter_methods(self):
        """Тест методов фильтрации UnifiedAPI"""
        if not UNIFIED_API_AVAILABLE:
            pytest.skip("UnifiedAPI not available")
    
        api = UnifiedAPI()
        assert api is not None
    
        # Тест пустого списка
        if hasattr(api, '_filter_by_target_companies'):
            result = api._filter_by_target_companies([])
            assert result == []
    
        # Тест с данными
        test_vacancies = [
            {"employer": {"id": "123"}, "title": "Test Job"}
        ]
    
>       with patch.object(api, '_get_target_company_ids', return_value=[]):

tests/test_missing_coverage_components.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe998048610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7fe9819d9a90> does not have the attribute '_get_target_company_ids'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________ TestDBManagerCoverage.test_get_companies_and_vacancies_count __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fe9991793d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9938d1ad0>

    def test_get_companies_and_vacancies_count(self, db_manager):
        """Тест получения количества компаний и вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = [("Company A", 10), ("Company B", 5)]
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641186382480'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_________________ TestDBManagerCoverage.test_get_all_vacancies __________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fe999154a90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9818f9ed0>

    def test_get_all_vacancies(self, db_manager):
        """Тест получения всех вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140640877786768'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___________________ TestDBManagerCoverage.test_get_avg_salary ___________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fe999189010>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe998037490>

    def test_get_avg_salary(self, db_manager):
        """Тест получения средней зарплаты"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (125000,)
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641254463632'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestDBManagerCoverage.test_get_vacancies_with_higher_salary __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fe9991893d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe9938e6190>

    def test_get_vacancies_with_higher_salary(self, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641179695568'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____________ TestDBManagerCoverage.test_get_vacancies_with_keyword _____________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fe999189750>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe999179e10>

    def test_get_vacancies_with_keyword(self, db_manager):
        """Тест получения вакансий по ключевому слову"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140640877587664'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestIntegrationScenarios.test_api_and_database_integration ___________

self = <tests.test_missing_coverage_components.TestIntegrationScenarios object at 0x7fe99918b9d0>

    def test_api_and_database_integration(self):
        """Тест интеграции API и базы данных"""
        if not (UNIFIED_API_AVAILABLE and DB_MANAGER_AVAILABLE):
            pytest.skip("Required modules not available")
    
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            # Настройка DB
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140641181992464'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________________ TestPaginatorCoverage.test_get_page ______________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fe998fb1cd0>
paginator = <Mock id='140641256557840'>

    def test_get_page(self, paginator):
        """Тест получения страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'get_page'):
            page_data = paginator.get_page(0)
>           assert isinstance(page_data, list) or page_data is None
E           AssertionError: assert (False or <Mock name='mock.get_page()' id='140641256566160'> is None)
E            +  where False = isinstance(<Mock name='mock.get_page()' id='140641256566160'>, list)

tests/test_missing_coverage_extended.py:339: AssertionError
___________________ TestPaginatorCoverage.test_previous_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fe998fad910>
paginator = <Mock id='140641186563600'>

    def test_previous_page(self, paginator):
        """Тест перехода к предыдущей странице"""
        if not PAGINATOR_AVAILABLE:
            return
    
        # Сначала переходим на следующую страницу
        if hasattr(paginator, 'next_page'):
            paginator.next_page()
    
        if hasattr(paginator, 'previous_page'):
            initial_page = getattr(paginator, 'current_page', 2)
            result = paginator.previous_page()
            if result:
                new_page = getattr(paginator, 'current_page', 1)
>               assert new_page == initial_page - 1
E               assert 0 == (0 - 1)

tests/test_missing_coverage_extended.py:367: AssertionError
___________________ TestPaginatorCoverage.test_has_next_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fe998fb11d0>
paginator = <Mock id='140641255302864'>

    def test_has_next_page(self, paginator):
        """Тест проверки наличия следующей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_next_page'):
            result = paginator.has_next_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_next_page()' id='140641255304080'>, bool)

tests/test_missing_coverage_extended.py:376: AssertionError
_________________ TestPaginatorCoverage.test_has_previous_page __________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fe998fb2810>
paginator = <Mock id='140641174782608'>

    def test_has_previous_page(self, paginator):
        """Тест проверки наличия предыдущей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_previous_page'):
            result = paginator.has_previous_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_previous_page()' id='140641174789136'>, bool)

tests/test_missing_coverage_extended.py:385: AssertionError
________________ TestVacancyFormatterCoverage.test_format_salary ________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7fe998fbf210>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7fe98183ce90>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:555: TypeError
_________ TestUIInterfacesCoverage.test_vacancy_display_handler_display _________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fe998fd2210>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:836: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_search_handler_search __________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fe998fd2850>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ____

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fe998fd2e50>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:859: TypeError
__________ TestPostgresSaverCoverage.test_database_connection_methods ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999036250>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe981986910>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
______________ TestPostgresSaverCoverage.test_create_tables_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe9990368d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9818a4a10>
mock_connection = (<Mock id='140640877429840'>, <Mock name='mock.cursor()' id='140640877442896'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
______________ TestPostgresSaverCoverage.test_save_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999036f90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993855a50>
mock_connection = (<Mock id='140641179091664'>, <Mock name='mock.cursor()' id='140641179093584'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
____________ TestPostgresSaverCoverage.test_save_multiple_vacancies _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999037610>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe999036a10>
mock_connection = (<Mock id='140641179013776'>, <Mock name='mock.cursor()' id='140641177573136'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140641186391376'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140641186391376'> = <Mock name='mock.cursor()' id='140641177573136'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
______________ TestPostgresSaverCoverage.test_get_vacancies_method ______________

self = <Mock name='mock.cursor().execute' id='140640877448528'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999037c90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9938404d0>
mock_connection = (<Mock id='140641256764752'>, <Mock name='mock.cursor()' id='140641256751312'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
__________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999044350>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe99379c050>
mock_connection = (<Mock id='140641178339024'>, <Mock name='mock.cursor()' id='140641178346000'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
_____________ TestPostgresSaverCoverage.test_filter_by_salary_range _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe9990449d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9818c9810>
mock_connection = (<Mock id='140640877588112'>, <Mock name='mock.cursor()' id='140640877589456'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
______________ TestPostgresSaverCoverage.test_get_companies_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999045050>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998232210>
mock_connection = (<Mock id='140641256539088'>, <Mock name='mock.cursor()' id='140641256538768'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_____________ TestPostgresSaverCoverage.test_delete_vacancy_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999045690>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998248f10>
mock_connection = (<Mock id='140641256640720'>, <Mock name='mock.cursor()' id='140641256644496'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998248f10>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
_________________ TestPostgresSaverCoverage.test_clear_all_data _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe9990363d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9981c0290>
mock_connection = (<Mock id='140641256092048'>, <Mock name='mock.cursor()' id='140641256093136'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_____________ TestPostgresSaverCoverage.test_get_statistics_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999025150>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9938f55d0>
mock_connection = (<Mock id='140641179746512'>, <Mock name='mock.cursor()' id='140641179752912'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
_________________ TestPostgresSaverCoverage.test_export_to_json _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999044790>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe9936e0d10>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
________________ TestPostgresSaverCoverage.test_import_from_json ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999045d50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe981984450>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
______________ TestPostgresSaverCoverage.test_transaction_rollback ______________

self = <Mock name='mock.rollback' id='140641183345040'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe9990464d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993c1f550>
mock_connection = (<Mock id='140641179757008'>, <Mock name='mock.cursor()' id='140641183068112'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fe999046890>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993c6a610>
mock_connection = (<Mock id='140641183372624'>, <Mock name='mock.cursor()' id='140641183377552'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe993c6a610>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
________________ TestFileCacheRealMethods.test_cache_expiration _________________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fe9990555d0>
temp_cache_dir = '/tmp/tmpo619ur20'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш с очень коротким TTL
>       cache = FileCache(cache_dir=temp_cache_dir, ttl_seconds=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:273: TypeError
________ TestIntegrationWithRealClasses.test_cache_with_api_integration _________

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7fe999060ed0>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:424: KeyError
___________ TestSimpleDBAdapterCoverage.test_connect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f35710>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9980fe950>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
__________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f35d50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9981dd410>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f363d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993bc6650>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993bc7110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993bc6650> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f36a10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe981805c90>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe9818051d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe981805c90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f37050>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993bb9150>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993bb8550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993bb9150> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f37690>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993d037d0>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993d01890>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993d037d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f37cd0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe99386ce50>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe99386f450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe99386ce50> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f40350>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9937d8110>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe9937dbe10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9937d8110> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f40950>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993e92190>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993e90510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993e92190> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f40f90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993e95f10>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993e95710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993e95f10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_error_handling_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fe998f41690>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993f71b50>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe993f70550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe993f71b50> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSuperJobAPIComplete.test_deduplicate_vacancies _______________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7fe998f6d990>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fe98165dc10>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe98185c210>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestPostgresSaver.test_save_vacancies_batch __________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7fe998e06cd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe98187e2d0>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe98187e9d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fe98187e2d0> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_insert_vacancy ____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fe998e15090>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe98182ce50>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe98182c810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe98182ce50> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_get_vacancies _____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fe998e15710>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9980d3ed0>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe9980d1b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fe9980d3ed0> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestStorageIntegration.test_repository_with_validator_integration _______

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7fe998e1ee90>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock id='140640876773712'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestVacancyStorageServiceCoverage.test_storage_service_initialization _____

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fe998e16f10>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
__________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ___________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fe998e2cbd0>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fe9819f40d0>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
__________ TestVacancyStorageServiceCoverage.test_search_functionality __________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fe998e2d690>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fe993edc9d0>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
___________ TestVacancyStorageServiceCoverage.test_delete_operations ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fe998e2da10>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fe993edc950>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fe998e2e910>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fe9819fce90>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_______ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field ________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fe998e2ef50>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fe9819f5490>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
___________ TestDeduplicationServiceCoverage.test_identify_duplicates ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fe998e2f5d0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fe998f7dc10>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
___________ TestFilteringServiceCoverage.test_filter_by_salary_range ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fe998e34510>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fe98185db50>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_keyword ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fe998e34b50>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fe993c6bbd0>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_company ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fe998e351d0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fe993a97a10>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
______________ TestFilteringServiceCoverage.test_complex_filtering ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fe998e35810>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fe993eddfd0>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
_______________ TestVacancyRepositoryCoverage.test_create_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fe998e36710>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe993f49690>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_____________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fe998e36d50>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe9981c26d0>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
_______________ TestVacancyRepositoryCoverage.test_update_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fe998e373d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe993c14290>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe993c14290>
vacancy = <Mock id='140641183031632'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140641183033872'>: 'Mock' object does not support the context manager protocol
_____________ TestVacancyRepositoryCoverage.test_get_all_vacancies ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fe998e2e090>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe9980d1390>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe9980d1390>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
______________ TestVacancyRepositoryCoverage.test_count_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fe998e34990>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fe9938de110>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fe998e37dd0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fe993c16c10>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_required_fields ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fe998e401d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fe993d01850>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
_____________ TestVacancyValidatorCoverage.test_validate_data_types _____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fe998e40550>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fe993bf1750>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________________ TestDBManagerFixed.test_database_operations __________________

self = <tests.test_storage_components_fixes.TestDBManagerFixed object at 0x7fe998e4d490>
db_manager = <src.storage.db_manager.DBManager object at 0x7fe993c1db90>
mock_db_connection = (<Mock id='140640878099152'>, <Mock id='140640878087632'>)

    def test_database_operations(self, db_manager, mock_db_connection):
        """Тест операций с базой данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_db_connection
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            # Тестируем различные операции
            operations = ['create_tables', 'drop_tables', 'clear_data']
    
            for operation in operations:
                if hasattr(db_manager, operation):
>                   result = getattr(db_manager, operation)()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fe993c1db90>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:147: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.db_manager:db_manager.py:277 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
_________________ TestPostgresSaverFixed.test_delete_operations _________________

self = <tests.test_storage_components_fixes.TestPostgresSaverFixed object at 0x7fe998e4ea10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998046290>
mock_connection = (<Mock id='140641183563856'>, <Mock id='140641183566096'>)

    def test_delete_operations(self, postgres_saver, mock_connection):
        """Тест операций удаления"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            delete_methods = ['delete_vacancy_by_id', 'delete_all_vacancies', 'clear_companies']
    
            for method_name in delete_methods:
                if hasattr(postgres_saver, method_name):
                    if method_name == 'delete_vacancy_by_id':
>                       result = getattr(postgres_saver, method_name)('test_id')
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fe998046290>
vacancy_id = 'test_id'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
___ TestMainApplicationInterfaceFixed.test_main_app_interface_initialization ____

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7fe998cff610>

    def test_main_app_interface_initialization(self):
        """Тест инициализации главного интерфейса приложения"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return
    
>       mai = MainApplicationInterface()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:303: TypeError
_______________ TestPaginatorFixed.test_paginator_initialization ________________

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7fe998d084d0>

    def test_paginator_initialization(self):
        """Тест инициализации пагинатора"""
        if not PAGINATOR_AVAILABLE:
            return
    
>       pag = Paginator(page_size=10)
              ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:678: TypeError
_________ TestUINavigationExtended.test_paginate_display_custom_actions _________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7fe998bd6b50>
mock_print = <MagicMock name='print' id='140640878781072'>
mock_input = <MagicMock name='input' id='140640877966864'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='140640878780752'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
________________ TestUnifiedAPI.test_filter_by_target_companies _________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fe998c0d4d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe9980d1590>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
_________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources __________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fe998c0edd0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe993f89d90>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
____________ TestUnifiedAPIComplete.test_filter_by_target_companies _____________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7fe998c21850>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fe981639ad0>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestUserInterfaceConsolidated.test_main_interface_complete ___________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fe998c43f10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fe998c42f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestUserInterfaceConsolidated.test_interface_components_integration ______

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fe998c44b10>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
_ TestMainApplicationInterfaceCoverage.test_main_application_interface_initialization _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fe998c54710>

    def test_main_application_interface_initialization(self):
        """Тест инициализации MainApplicationInterface"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
>       interface = MainApplicationInterface()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:148: TypeError
================================ tests coverage =================================
_______________ coverage: platform linux, python 3.11.13-final-0 ________________

Name                                                     Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------------
src/__init__.py                                              0      0   100%
src/api_modules/__init__.py                                  0      0   100%
src/api_modules/base_api.py                                 23      0   100%
src/api_modules/cached_api.py                              168     47    72%   114-115, 144-147, 157, 159, 166-168, 183, 186-187, 203, 215-238, 247, 267-269, 289, 298-299, 308-310, 335-336, 340-342
src/api_modules/get_api.py                                  53     19    64%   46-54, 64, 73-74, 102-103, 116-118, 124, 126-132, 134, 136
src/api_modules/hh_api.py                                  142     25    82%   77-85, 169, 178-180, 219-221, 233, 256, 276, 289, 293-295, 329-331
src/api_modules/sj_api.py                                  128     28    78%   99-106, 206-210, 222, 263-264, 277-279, 291-292, 296-308
src/api_modules/unified_api.py                             270     77    71%   124, 133, 154-155, 175-176, 212-213, 221-240, 245, 291-293, 304-306, 316-322, 390-391, 401-418, 422-432, 436-458
src/config/__init__.py                                       0      0   100%
src/config/api_config.py                                    13      0   100%
src/config/app_config.py                                    17      0   100%
src/config/db_config.py                                     61     25    59%   24, 44-48, 85-88, 96-99, 104, 133-136, 156-172
src/config/hh_api_config.py                                 21      2    90%   31, 37
src/config/sj_api_config.py                                 49     17    65%   59, 62, 68-75, 79-87
src/config/target_companies.py                              61     24    61%   124-130, 135-138, 143-146, 151, 156-162, 167, 185, 190
src/config/ui_config.py                                     27      0   100%
src/interfaces/__init__.py                                   0      0   100%
src/interfaces/main_application_interface.py               121     88    27%   76, 89-98, 109-136, 140-152, 156-161, 166-180, 184-214, 224-225, 230, 234-236
src/storage/__init__.py                                      6      0   100%
src/storage/abstract.py                                     14      0   100%
src/storage/abstract_db_manager.py                          21      6    71%   16, 26, 36, 46, 59, 69
src/storage/components/__init__.py                           0      0   100%
src/storage/components/database_connection.py               53     11    79%   14-16, 19-20, 77-78, 88-89, 97-98
src/storage/components/vacancy_repository.py               113     61    46%   50-51, 119-134, 146-150, 174-178, 190-209, 221-291
src/storage/components/vacancy_validator.py                 65     22    66%   62, 65, 73-74, 78-79, 92, 99, 110, 115, 120, 138-152
src/storage/db_manager.py                                  348    188    46%   17-24, 63, 83-139, 223-228, 246-247, 262-272, 282-338, 348-361, 376-405, 419-451, 519-522, 525-528, 533-535, 574-576, 593-594, 646-651, 665, 715-718, 723-728, 818-820, 832, 844-845, 857-859, 871-877, 892-1022
src/storage/interfaces/typed_data_processor.py              46     25    46%   32, 45, 64, 78, 94, 100, 106-117, 124, 130-133, 139-148
src/storage/postgres_saver.py                              790    495    37%   10-13, 72-74, 109-111, 124-125, 133-140, 145-146, 148-151, 176-183, 188-194, 199-200, 202-205, 263-265, 280-281, 295-305, 310-317, 322-323, 325-328, 338, 342-343, 374-380, 399-400, 404-409, 417-419, 442-445, 452, 455-458, 473, 480, 487, 594-598, 604-606, 628-634, 655, 662-664, 678, 690-692, 705, 721-779, 783-895, 918-958, 961, 974-992, 1002-1007, 1010-1016, 1024-1048, 1067-1098, 1107-1109, 1125-1180, 1184-1196, 1218-1237, 1240, 1245-1247, 1264-1303, 1323-1574, 1626-1627, 1633-1635
src/storage/services/__init__.py                             4      0   100%
src/storage/services/abstract_filter_service.py             30      7    77%   34, 44, 64, 88, 101, 114, 127
src/storage/services/abstract_storage_service.py            25      6    76%   34, 47, 60, 73, 83, 93
src/storage/services/company_id_filter_service.py           94     62    34%   49, 62, 68-76, 85-135, 141-202, 206-214, 223
src/storage/services/deduplication_service.py               64     43    33%   15-16, 20-21, 43, 56-129, 133-142, 146-154, 183, 192
src/storage/services/filtering_service.py                  105     66    37%   15-16, 20-21, 25-26, 48, 76-88, 95-132, 143-155, 159-170, 189-199, 228, 237
src/storage/services/sql_deduplication_service.py           64     49    23%   44-64, 68-111, 116-148, 152-160, 173-182
src/storage/services/sql_filter_service.py                  89     63    29%   47, 59-78, 82-146, 152-191, 195-202, 207-209, 218-247
src/storage/services/vacancy_processing_coordinator.py      44      0   100%
src/storage/services/vacancy_storage_service.py            334    239    28%   15-16, 20-21, 25-26, 31-32, 37-38, 42-43, 47-48, 52-53, 57-58, 93-94, 119-146, 150-170, 176-194, 211-215, 226-238, 244-320, 334, 338-339, 360-362, 366-395, 417-469, 499, 511-535, 539-590, 594-601, 606, 610, 614, 618
src/storage/simple_db_adapter.py                           142     84    41%   21, 42-43, 64-71, 78-80, 94-101, 112-115, 117, 121, 125-165, 169-202, 206-210, 219
src/storage/storage_factory.py                              13      0   100%
src/ui_interfaces/__init__.py                                0      0   100%
src/ui_interfaces/console_interface.py                     394    306    22%   23-25, 69, 82, 84, 86, 88, 90, 92, 94, 97, 100, 102-110, 116-127, 157, 161, 165, 169, 173-224, 228-301, 305, 309, 319-355, 359, 370-371, 382-385, 395-544, 548-579, 584-604
src/ui_interfaces/source_selector.py                        44     14    68%   39-40, 42-43, 45-46, 48-49, 64, 74-79
src/ui_interfaces/vacancy_display_handler.py                72     58    19%   32-70, 74-107, 111-141
src/ui_interfaces/vacancy_operations_coordinator.py        194    105    46%   68-79, 100, 102, 104, 108, 116-122, 126-165, 169-192, 196-198, 211, 248-273, 302-32