~/workspace$ pytest tests/test_03_api_modules_coverage.py 
=================================== test session starts ====================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 29 items                                                                         

tests/test_03_api_modules_coverage.py ....FF.....F.................                  [100%]

========================================= FAILURES =========================================
______________________________ TestCachedAPI.test_init_cache _______________________________

self = <MagicMock name='mkdir' id='139910025977680'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mkdir' to have been called once. Called 2 times.
E           Calls: [call(parents=True, exist_ok=True), call(parents=True, exist_ok=True)].

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_03_api_modules_coverage.TestCachedAPI object at 0x7f3f577d0c50>
mock_file_cache = <MagicMock name='FileCache' id='139910025983440'>
mock_mkdir = <MagicMock name='mkdir' id='139910025977680'>

    @patch('pathlib.Path.mkdir')
    @patch('src.utils.cache.FileCache')
    def test_init_cache(self, mock_file_cache, mock_mkdir):
        """Покрытие инициализации кэша."""
        api = ConcreteCachedAPI("test_cache")
    
>       mock_mkdir.assert_called_once()
E       AssertionError: Expected 'mkdir' to have been called once. Called 2 times.
E       Calls: [call(parents=True, exist_ok=True), call(parents=True, exist_ok=True)].
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'exist_ok': ...arents': True} == {}
E         
E         Left contains 2 more items:
E         {'exist_ok': True, 'parents': True}
E         Use -v to get more diff

tests/test_03_api_modules_coverage.py:101: AssertionError
__________________________ TestCachedAPI.test_cached_api_request ___________________________

self = <tests.test_03_api_modules_coverage.TestCachedAPI object at 0x7f3f577d1210>
mock_mkdir = <MagicMock name='mkdir' id='139910025585744'>
mock_file_cache = <MagicMock name='FileCache' id='139910025590992'>

    @patch('src.utils.cache.FileCache')
    @patch('pathlib.Path.mkdir')
    def test_cached_api_request(self, mock_mkdir, mock_file_cache):
        """Покрытие кэшированного запроса."""
        api = ConcreteCachedAPI("test_cache")
    
        # Тестируем метод через декоратор
>       result = api._cached_api_request("http://test.com", {}, "test")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_03_api_modules_coverage.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<tests.test_03_api_modules_coverage.ConcreteCachedAPI object at 0x7f3f576025d0>, 'http://test.com', {}, 'test')
kwargs = {}, actual_ttl = 300, current_time = 1757226524.6266434
cache_key = ((<tests.test_03_api_modules_coverage.ConcreteCachedAPI object at 0x7f3f576025d0>, 'http://test.com', {}, 'test'), frozenset())

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # Получаем TTL из переменных окружения или используем переданное значение
        actual_ttl = ttl if ttl is not None else EnvLoader.get_env_var_int("CACHE_TTL", 3600)
        current_time = time.time()
    
        cache_key = (args, frozenset(kwargs.items()))
    
        # Проверяем существующий кэш
>       if cache_key in cache:
           ^^^^^^^^^^^^^^^^^^
E       TypeError: unhashable type: 'dict'

src/utils/decorators.py:30: TypeError
__________________________ TestAPIConnector.test_connect_timeout ___________________________

self = <src.api_modules.get_api.APIConnector object at 0x7f3f57592750>
url = 'http://test.com', params = {}, delay = 0.15, show_progress = False
progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
>           response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )

src/api_modules/get_api.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='get' id='139910025128080'>, args = ('http://test.com',)
kwargs = {'headers': {'Accept': 'application/json', 'User-Agent': 'MyVacancyApp/1.0'}, 'params': {}, 'timeout': 15}
effect = Exception('Timeout')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Timeout

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception

During handling of the above exception, another exception occurred:

self = <tests.test_03_api_modules_coverage.TestAPIConnector object at 0x7f3f577d3950>
mock_get = <MagicMock name='get' id='139910025128080'>

    @patch('requests.get')
    def test_connect_timeout(self, mock_get):
        """Покрытие обработки таймаута."""
        mock_get.side_effect = Exception("Timeout")
    
        connector = APIConnector()
>       result = connector.connect("http://test.com", {})
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_03_api_modules_coverage.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f3f57592750>
url = 'http://test.com', params = {}, delay = 0.15, show_progress = False
progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
            raise ConnectionError(f"Connection error: {str(e)}")
        except ValueError as e:
            raise ConnectionError(f"JSON decode error: {str(e)}")
        except Exception as e:
>           raise ConnectionError(f"Unexpected error: {str(e)}")
E           ConnectionError: Unexpected error: Timeout

src/api_modules/get_api.py:138: ConnectionError
================================= short test summary info ==================================
FAILED tests/test_03_api_modules_coverage.py::TestCachedAPI::test_init_cache - AssertionError: Expected 'mkdir' to have been called once. Called 2 times.
FAILED tests/test_03_api_modules_coverage.py::TestCachedAPI::test_cached_api_request - TypeError: unhashable type: 'dict'
FAILED tests/test_03_api_modules_coverage.py::TestAPIConnector::test_connect_timeout - ConnectionError: Unexpected error: Timeout
=============================== 3 failed, 26 passed in 1.06s ===============================
~/workspace$ 