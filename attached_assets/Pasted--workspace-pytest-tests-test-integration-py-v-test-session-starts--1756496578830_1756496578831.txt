~/workspace$ pytest tests/test_integration.py -v
============================ test session starts ============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace/tests
configfile: pytest.ini
plugins: mock-3.14.1, cov-6.2.1
collected 11 items                                                          

tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration FAILED [  9%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_integration PASSED [ 18%]
tests/test_integration.py::TestAPIIntegration::test_superjob_api_integration PASSED [ 27%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow FAILED [ 36%]
tests/test_integration.py::TestCacheIntegration::test_cache_integration PASSED [ 45%]
tests/test_integration.py::TestErrorHandlingIntegration::test_api_error_handling PASSED [ 54%]
tests/test_integration.py::TestErrorHandlingIntegration::test_database_error_handling PASSED [ 63%]
tests/test_integration.py::TestFormatterIntegration::test_vacancy_formatter_integration PASSED [ 72%]
tests/test_integration.py::TestFormatterIntegration::test_brief_formatter_integration PASSED [ 81%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_filters FAILED [ 90%]
tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_search PASSED [100%]

================================= FAILURES ==================================
__________ TestStorageIntegration.test_postgres_saver_integration ___________

self = <tests.test_integration.TestStorageIntegration object at 0x7f49eab4b050>
mock_connect = <MagicMock name='connect' id='139955443535952'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f49ebdc6820>

    @patch("psycopg2.connect")
    def test_postgres_saver_integration(self, mock_connect, sample_vacancy):
        """Тест интеграции с PostgreSQL"""
        # Настраиваем мок подключения
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_cursor.fetchall.return_value = []
        # Исправляем мок для field_info - возвращаем правильную структуру
        # Добавляем больше ответов для всех возможных запросов
        mock_responses = [
            (0,),  # для check database exists
        ]
        # Добавляем ответы для каждого поля в required_fields (около 20 полей)
        for _ in range(25):
            mock_responses.extend([
                ("column_name", "integer"),
                ("column_name", "text"),
                ("column_name", "varchar"),
                ("column_name", "timestamp"),
            ])
    
        mock_cursor.fetchone.side_effect = mock_responses
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Создаем хранилище и тестируем операции
        storage = PostgresSaver()
    
        # Тест добавления
>       result = storage.add_vacancy(sample_vacancy)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:678: in add_vacancy
    return self.add_vacancy_batch_optimized(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f49ea7f1210>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f49ebdc6820>]

    def add_vacancy_batch_optimized(self, vacancies: Union[Vacancy, List[Vacancy]]) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний из БД с расширенным поиском
            cursor.execute(
                """
                SELECT id, name, LOWER(name) as normalized_name
                FROM companies
            """
            )
    
            company_mapping = {}
            company_patterns = {}  # Для поиска по частичному совпадению
    
            results = cursor.fetchall()
            for row in results:
                comp_id, original_name, normalized_name = row[0], row[1], row[2]
                company_mapping[normalized_name] = comp_id
                company_patterns[original_name] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
    
                # 1. Приоритет: поиск по hh_id/sj_id из данных вакансии
                if employer_id:
                    cursor.execute(
                        """
                        SELECT id FROM companies
                        WHERE hh_id = %s OR sj_id = %s
                        LIMIT 1
                    """,
                        (employer_id, employer_id),
                    )
    
                    result = cursor.fetchone()
                    if result:
                        mapped_company_id = result[0]  # Используем индекс для обычного cursor
                        logger.debug(
                            f"Найдено точное соответствие по ID: employer_id={employer_id} -> company_id={mapped_company_id}"
                        )
    
                # 2. Fallback: поиск по названию только если не найден по ID
                if not mapped_company_id and employer_name:
                    employer_lower = employer_name.lower()
    
                    # 2.1. Поиск точного соответствия в нормализованных названиях
                    mapped_company_id = company_mapping.get(employer_lower)
    
                    # 2.2. Поиск по частичному соответствию с ключевыми словами
                    if not mapped_company_id:
                        for pattern_name, comp_id in company_patterns.items():
                            pattern_lower = pattern_name.lower()
                            # Проверяем вхождение ключевых слов
                            if len(pattern_lower) > 3:
                                if pattern_lower in employer_lower or employer_lower in pattern_lower:
                                    mapped_company_id = comp_id
                                    logger.debug(
                                        f"Найдено соответствие по частичному совпадению: '{employer_name}' -> '{pattern_name}' (company_id: {comp_id})"
                                    )
                                    break
    
                    # 2.3. Дополнительный поиск по альтернативным названиям
                    if not mapped_company_id:
                        for alt_name, comp_id in company_mapping.items():
                            if isinstance(alt_name, str) and len(alt_name) > 2:
                                if alt_name in employer_lower:
                                    mapped_company_id = comp_id
                                    logger.debug(
                                        f"Найдено соответствие по альтернативному названию: '{employer_name}' -> '{alt_name}' (company_id: {comp_id})"
                                    )
                                    break
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
>               mapped_company_id = vacancy_company_mapping[vacancy.vacancy_id]
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'test_1'

src/storage/postgres_saver.py:502: KeyError
_________ TestFullWorkflowIntegration.test_search_and_save_workflow _________

self = <tests.test_integration.TestFullWorkflowIntegration object at 0x7f49ea7d3e50>
mock_connect_api = <MagicMock name='_CachedAPI__connect_to_api' id='139955439305872'>
mock_connect_db = <MagicMock name='connect' id='139955439314896'>
sample_vacancy = <src.vacancies.models.Vacancy object at 0x7f49ecbfec30>

    @patch("psycopg2.connect")
    @patch("src.api_modules.hh_api.HeadHunterAPI._CachedAPI__connect_to_api")
    def test_search_and_save_workflow(self, mock_connect_api, mock_connect_db, sample_vacancy):
        """Тест полного процесса поиска и сохранения"""
        # Настраиваем мок для API
        mock_connect_api.return_value = {
            "items": [
                {
                    "id": "789",
                    "name": "Integration Test Job",
                    "alternate_url": "https://hh.ru/vacancy/789",
                    "employer": {"name": "Integration Company"},
                    "published_at": "2024-01-01T00:00:00+03:00",
                    "source": "hh.ru",
                }
            ],
            "found": 1,
            "pages": 1,
        }
    
        # Настраиваем мок для базы данных
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.rowcount = 1
        mock_cursor.fetchall.return_value = []
        # Настраиваем правильные ответы для всех запросов
        mock_responses = [
            (0,),  # для check database exists
        ]
        # Добавляем ответы для каждого поля в required_fields (около 20 полей)
        for _ in range(25):
            mock_responses.extend([
                ("column_name", "integer"),
                ("column_name", "text"),
                ("column_name", "varchar"),
                ("column_name", "timestamp"),
            ])
    
        mock_cursor.fetchone.side_effect = mock_responses
        mock_conn.cursor.return_value = mock_cursor
        mock_connect_db.return_value = mock_conn
    
        # Выполняем поиск
        api = HeadHunterAPI()
        vacancies_data = api.get_vacancies(search_query="python")
    
        # Конвертируем в объекты Vacancy
        vacancies = [Vacancy.from_dict(item) for item in vacancies_data]
    
        # Сохраняем результаты
        storage = PostgresSaver()
        for vacancy in vacancies:
>           result = storage.add_vacancy(vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:678: in add_vacancy
    return self.add_vacancy_batch_optimized(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f49ea3e0910>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f49eb3272b0>]

    def add_vacancy_batch_optimized(self, vacancies: Union[Vacancy, List[Vacancy]]) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний из БД с расширенным поиском
            cursor.execute(
                """
                SELECT id, name, LOWER(name) as normalized_name
                FROM companies
            """
            )
    
            company_mapping = {}
            company_patterns = {}  # Для поиска по частичному совпадению
    
            results = cursor.fetchall()
            for row in results:
                comp_id, original_name, normalized_name = row[0], row[1], row[2]
                company_mapping[normalized_name] = comp_id
                company_patterns[original_name] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
    
                # 1. Приоритет: поиск по hh_id/sj_id из данных вакансии
                if employer_id:
                    cursor.execute(
                        """
                        SELECT id FROM companies
                        WHERE hh_id = %s OR sj_id = %s
                        LIMIT 1
                    """,
                        (employer_id, employer_id),
                    )
    
                    result = cursor.fetchone()
                    if result:
                        mapped_company_id = result[0]  # Используем индекс для обычного cursor
                        logger.debug(
                            f"Найдено точное соответствие по ID: employer_id={employer_id} -> company_id={mapped_company_id}"
                        )
    
                # 2. Fallback: поиск по названию только если не найден по ID
                if not mapped_company_id and employer_name:
                    employer_lower = employer_name.lower()
    
                    # 2.1. Поиск точного соответствия в нормализованных названиях
                    mapped_company_id = company_mapping.get(employer_lower)
    
                    # 2.2. Поиск по частичному соответствию с ключевыми словами
                    if not mapped_company_id:
                        for pattern_name, comp_id in company_patterns.items():
                            pattern_lower = pattern_name.lower()
                            # Проверяем вхождение ключевых слов
                            if len(pattern_lower) > 3:
                                if pattern_lower in employer_lower or employer_lower in pattern_lower:
                                    mapped_company_id = comp_id
                                    logger.debug(
                                        f"Найдено соответствие по частичному совпадению: '{employer_name}' -> '{pattern_name}' (company_id: {comp_id})"
                                    )
                                    break
    
                    # 2.3. Дополнительный поиск по альтернативным названиям
                    if not mapped_company_id:
                        for alt_name, comp_id in company_mapping.items():
                            if isinstance(alt_name, str) and len(alt_name) > 2:
                                if alt_name in employer_lower:
                                    mapped_company_id = comp_id
                                    logger.debug(
                                        f"Найдено соответствие по альтернативному названию: '{employer_name}' -> '{alt_name}' (company_id: {comp_id})"
                                    )
                                    break
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
>               mapped_company_id = vacancy_company_mapping[vacancy.vacancy_id]
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: '789'

src/storage/postgres_saver.py:502: KeyError
--------------------------- Captured stderr call ----------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 6452.78page/s, vacancies=1]
_____ TestVacancyOperationsIntegration.test_vacancy_operations_filters ______

self = <tests.test_integration.TestVacancyOperationsIntegration object at 0x7f49ea7dee90>
test_vacancies = [<src.vacancies.models.Vacancy object at 0x7f49e9f1b040>, <src.vacancies.models.Vacancy object at 0x7f49e9f1a820>, <src.vacancies.models.Vacancy object at 0x7f49e9f1a750>]

    def test_vacancy_operations_filters(self, test_vacancies):
        """Тест фильтрации вакансий"""
        ops = VacancyOperations()
    
        # Тест фильтрации по зарплате
        with_salary = ops.get_vacancies_with_salary(test_vacancies)
        assert len(with_salary) == 2
    
        # Тест фильтрации по минимальной зарплате
        # Java Developer имеет salary_from=120000, что >= 110000
        # Python Developer имеет salary_from=100000, что < 110000
        high_salary = ops.filter_vacancies_by_min_salary(test_vacancies, 110000)
        assert len(high_salary) == 1  # Только Java Developer
    
        # Тест сортировки по зарплате
>       sorted_vacancies = ops.sort_vacancies_by_salary(test_vacancies)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:374: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancies = [<src.vacancies.models.Vacancy object at 0x7f49e9f1b040>, <src.vacancies.models.Vacancy object at 0x7f49e9f1a820>, <src.vacancies.models.Vacancy object at 0x7f49e9f1a750>]
reverse = True

    @staticmethod
    def sort_vacancies_by_salary(vacancies: List[Vacancy], reverse: bool = True) -> List[Vacancy]:
        """
        Сортировка вакансий по зарплате
    
        Args:
            vacancies: Список вакансий для сортировки
            reverse: Сортировка по убыванию (True) или возрастанию (False)
    
        Returns:
            List[Vacancy]: Отсортированный список вакансий
        """
>       return sorted(vacancies, key=lambda x: x.salary.get_max_salary() if x.salary else 0, reverse=reverse)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'int' and 'NoneType'

src/utils/vacancy_operations.py:38: TypeError
========================== short test summary info ==========================
FAILED tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration - KeyError: 'test_1'
FAILED tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow - KeyError: '789'
FAILED tests/test_integration.py::TestVacancyOperationsIntegration::test_vacancy_operations_filters - TypeError: '<' not supported between instances of 'int' and 'NoneType'
======================== 3 failed, 8 passed in 0.32s ========================
~/workspace$ 