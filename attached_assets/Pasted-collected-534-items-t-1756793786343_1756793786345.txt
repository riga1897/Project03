collected 534 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  2%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  4%]
tests/test_app_config.py .....                                                           [  5%]
tests/test_base_api.py ......                                                            [  6%]
tests/test_base_formatter.py ..........                                                  [  8%]
tests/test_base_parser.py ......                                                         [  9%]
tests/test_cache.py .......                                                              [ 10%]
tests/test_cache_manager.py .....F.......                                                [ 13%]
tests/test_cached_api.py ...........                                                     [ 15%]
tests/test_console_interface.py ......                                                   [ 16%]
tests/test_db_config.py .....                                                            [ 17%]
tests/test_db_manager.py .................                                               [ 20%]
tests/test_decorators.py .......                                                         [ 21%]
tests/test_env_loader.py ............                                                    [ 24%]
tests/test_file_handlers.py ............                                                 [ 26%]
tests/test_get_api.py ......                                                             [ 27%]
tests/test_hh_api.py .......                                                             [ 28%]
tests/test_hh_api_config.py .....                                                        [ 29%]
tests/test_hh_parser.py ........                                                         [ 31%]
tests/test_menu_manager.py ..........                                                    [ 33%]
tests/test_menu_system.py .................F..                                           [ 36%]
tests/test_paginator.py ......                                                           [ 38%]
tests/test_postgres_saver.py .......                                                     [ 39%]
tests/test_salary_utils.py ......................                                        [ 43%]
tests/test_search_utils.py ............................                                  [ 48%]
tests/test_sj_api.py ..............                                                      [ 51%]
tests/test_sj_api_config.py .....                                                        [ 52%]
tests/test_sj_parser.py ........                                                         [ 53%]
tests/test_source_manager.py .................                                           [ 56%]
tests/test_source_selector.py ..................                                         [ 60%]
tests/test_storage_factory.py ........                                                   [ 61%]
tests/test_target_companies.py .....                                                     [ 62%]
tests/test_ui_config.py .....                                                            [ 63%]
tests/test_ui_helpers.py ...........                                                     [ 65%]
tests/test_unified_api.py .................                                              [ 68%]
tests/test_user_interface.py ...F.....F...F........                                      [ 73%]
tests/test_vacancy_display_handler.py ..............                                     [ 75%]
tests/test_vacancy_formatter.py ........                                                 [ 77%]
tests/test_vacancy_models.py .................................................           [ 86%]
tests/test_vacancy_operations.py ......                                                  [ 87%]
tests/test_vacancy_operations_coordinator.py ........EE...E............                  [ 92%]
tests/test_vacancy_search_handler.py .FFE.EFFEFFFF.FFF....EF                             [ 96%]
tests/test_vacancy_stats.py EEEF.E.F...EEFFFFF                                           [100%]

============================================ ERRORS ============================================
_________ ERROR at setup of TestVacancyOperationsCoordinator.test_storage_integration __________

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f2053342a10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Senior Python Developer",
                url="https://hh.ru/vacancy/111",
                vacancy_id="111",
                source="hh.ru",
                employer={"name": "TechCorp"},
                salary=Salary.from_range(150000, 200000) if not SRC_AVAILABLE else Salary({'from': 150000, 'to': 200000}),
                description="Python разработчик с опытом Django"
            ),
            Vacancy(
                title="Java Backend Developer",
                url="https://superjob.ru/vacancy/222",
                vacancy_id="222",
                source="superjob.ru",
                employer={"name": "DevCompany"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                description="Java разработчик для backend приложений"
            )
        ]

tests/test_vacancy_operations_coordinator.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052f0dae0>
salary_data = <src.utils.salary.Salary object at 0x7f2052f0d600>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____ ERROR at setup of TestVacancyOperationsCoordinator.test_vacancy_management_workflow ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f2053342fd0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Senior Python Developer",
                url="https://hh.ru/vacancy/111",
                vacancy_id="111",
                source="hh.ru",
                employer={"name": "TechCorp"},
                salary=Salary.from_range(150000, 200000) if not SRC_AVAILABLE else Salary({'from': 150000, 'to': 200000}),
                description="Python разработчик с опытом Django"
            ),
            Vacancy(
                title="Java Backend Developer",
                url="https://superjob.ru/vacancy/222",
                vacancy_id="222",
                source="superjob.ru",
                employer={"name": "DevCompany"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                description="Java разработчик для backend приложений"
            )
        ]

tests/test_vacancy_operations_coordinator.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f205282b460>
salary_data = <src.utils.salary.Salary object at 0x7f205282b3a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_______ ERROR at setup of TestVacancyOperationsCoordinator.test_coordinator_type_safety ________

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f2053348b50>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Senior Python Developer",
                url="https://hh.ru/vacancy/111",
                vacancy_id="111",
                source="hh.ru",
                employer={"name": "TechCorp"},
                salary=Salary.from_range(150000, 200000) if not SRC_AVAILABLE else Salary({'from': 150000, 'to': 200000}),
                description="Python разработчик с опытом Django"
            ),
            Vacancy(
                title="Java Backend Developer",
                url="https://superjob.ru/vacancy/222",
                vacancy_id="222",
                source="superjob.ru",
                employer={"name": "DevCompany"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                description="Java разработчик для backend приложений"
            )
        ]

tests/test_vacancy_operations_coordinator.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f205282ba60>
salary_data = <src.utils.salary.Salary object at 0x7f205282b9a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____________ ERROR at setup of TestVacancySearchHandler.test_save_search_results ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053350690>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f20528321a0>
salary_data = <src.utils.salary.Salary object at 0x7f2052832140>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____________ ERROR at setup of TestVacancySearchHandler.test_storage_integration ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053351350>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052833220>
salary_data = <src.utils.salary.Salary object at 0x7f2052833160>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancySearchHandler.test_search_statistics _______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053352790>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f20528b08e0>
salary_data = <src.utils.salary.Salary object at 0x7f20528b09a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ ERROR at setup of TestVacancySearchHandler.test_search_handler_type_safety __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053362750>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f20528447c0>
salary_data = <src.utils.salary.Salary object at 0x7f2052844760>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_company_distribution _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f205337db90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052846f20>
salary_data = <src.utils.salary.Salary object at 0x7f2052847160>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_source_distribution __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f205337e1d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052887400>
salary_data = <src.utils.salary.Salary object at 0x7f2052887220>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ ERROR at setup of TestVacancyStats.test_salary_percentiles __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f205337e890>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052887b20>
salary_data = <src.utils.salary.Salary object at 0x7f2052886380>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
________________ ERROR at setup of TestVacancyStats.test_display_company_stats _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f205337fcd0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052886260>
salary_data = <src.utils.salary.Salary object at 0x7f2052887d60>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_type_safety _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f2053380d10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052887c40>
salary_data = <src.utils.salary.Salary object at 0x7f20528875e0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_performance _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f2053381090>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052887e80>
salary_data = <src.utils.salary.Salary object at 0x7f2052887b80>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
__________________________ TestCacheManager.test_cache_ttl_expiration __________________________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7f2054711fd0>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7f20533ba690>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени
>       with patch('src.utils.cache.datetime') as mock_datetime:

tests/test_cache_manager.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f20533ba9d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.utils.cache' from '/home/runner/workspace/tests/../src/utils/cache.py'> does not have the attribute 'datetime'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________________ TestMenuManager.test_submenu_navigation ____________________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7f2053b614d0>
mock_print = <MagicMock name='print' id='139776807504912'>
mock_input = <MagicMock name='input' id='139776807517712'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7f2052f58990>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='139776807517712'>, args = ('\nВыберите пункт меню: ',)
kwargs = {}, effect = <list_iterator object at 0x7f2053b48eb0>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
__________________________ TestUserInterface.test_vacancy_model_basic __________________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f2053785fd0>

    def test_vacancy_model_basic(self):
        """Тест базовой модели вакансии"""
        try:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            # Правильное создание объекта Salary согласно реальному API
            salary_data = {'from': 100000, 'to': 150000, 'currency': 'RUR'}
            salary = Salary(salary_data)
    
>           vacancy = Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh",
                employer={"name": "Test Company"},
                salary=salary,
                description="Test job"
            )

tests/test_user_interface.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f2052b1c6a0>
salary_data = <src.utils.salary.Salary object at 0x7f2052b1c760>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________________ TestUserInterface.test_logging_configuration _________________________

self = <MagicMock name='logging.getLogger' id='139776807221392'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'getLogger' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f2053790390>
mock_logging = <MagicMock name='logging' id='139776807951632'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что модуль загружен
            assert hasattr(src.user_interface, 'main')
    
            # Логирование может быть настроено при импорте или в main
            # Проверяем хотя бы то, что getLogger был вызван
>           mock_logging.getLogger.assert_called()
E           AssertionError: Expected 'getLogger' to have been called.

tests/test_user_interface.py:237: AssertionError
_____________________ TestUserInterface.test_interface_workflow_simulation _____________________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f2053791e90>
mock_print = <MagicMock name='print' id='139776812202512'>
consolidated_mocks = {'app_config': <Mock id='139776812200144'>, 'db_config': <Mock name='mock.get_db_config()' id='139776812196688'>, 'db_manager': <Mock id='139776812188560'>, 'logger': <Mock id='139776812201936'>, ...}

    @patch('builtins.print')
    def test_interface_workflow_simulation(self, mock_print, consolidated_mocks):
        """Тест симуляции рабочего процесса интерфейса"""
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            ui = UserInterface(
                storage=consolidated_mocks['storage'],
                db_manager=consolidated_mocks['db_manager']
            )
    
            # Мокируем все пользовательские взаимодействия
            with patch('builtins.input', return_value="0"), \
>                patch('src.utils.ui_helpers.get_user_input', return_value="0") if SRC_AVAILABLE else patch('builtins.input', return_value="0"):
                                                                                   ^^^^^^^^^^^^^
E                NameError: name 'SRC_AVAILABLE' is not defined

tests/test_user_interface.py:306: NameError
_____________________ TestVacancySearchHandler.test_search_vacancies_basic _____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f205334fa90>
mock_print = <MagicMock name='print' id='139776807321040'>
mock_input = <MagicMock name='input' id='139776803179088'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052f2a810>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
        if SRC_AVAILABLE:
            # Мокируем интерактивные элементы для реального класса
>           with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python"), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15):

tests/test_vacancy_search_handler.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052fc76d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestVacancySearchHandler.test_search_vacancies_workflow ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053350050>
mock_print = <MagicMock name='print' id='139776803565392'>
mock_input = <MagicMock name='input' id='139776803569104'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052b94bd0>
consolidated_mocks = {'input': <Mock id='139776803556496'>, 'print': <Mock id='139776803556944'>, 'source_selector': <Mock id='139776803560272'>, 'storage': <Mock id='139776803553808'>, ...}

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_workflow(self, mock_print, mock_input, search_handler, consolidated_mocks):
        """Тест рабочего процесса поиска вакансий"""
        # Настройка моков для полного рабочего процесса
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052b978d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_with_mocked_input ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053351910>
mock_print = <MagicMock name='print' id='139776798973264'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052735fd0>
consolidated_mocks = {'input': <Mock id='139776798974608'>, 'print': <Mock id='139776798974544'>, 'source_selector': <Mock id='139776798973520'>, 'storage': <Mock id='139776798974096'>, ...}

    @patch('builtins.print')
    def test_search_with_mocked_input(self, mock_print, search_handler, consolidated_mocks):
        """Тест поиска с замокированным вводом"""
        # Полностью мокируем все input операции
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052735950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancySearchHandler.test_search_results_structure ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053351fd0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052bebe10>
consolidated_mocks = {'input': <Mock id='139776803897744'>, 'print': <Mock id='139776803904016'>, 'source_selector': <Mock id='139776803913552'>, 'storage': <Mock id='139776803904144'>, ...}

    def test_search_results_structure(self, search_handler, consolidated_mocks):
        """Тест структуры результатов поиска"""
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052beb950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario0] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053353790>
mock_print = <MagicMock name='print' id='139776803626832'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052ba7710>
test_scenario = {'name': 'python_search', 'query': 'Python', 'source': 'hh.ru'}
consolidated_mocks = {'input': <Mock id='139776803622096'>, 'print': <Mock id='139776803622992'>, 'source_selector': <Mock id='139776803628432'>, 'storage': <Mock id='139776803624848'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052ba5d50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario1] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053353a10>
mock_print = <MagicMock name='print' id='139776807469328'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052f52cd0>
test_scenario = {'name': 'java_search', 'query': 'Java', 'source': 'superjob.ru'}
consolidated_mocks = {'input': <Mock id='139776807477904'>, 'print': <Mock id='139776807473680'>, 'source_selector': <Mock id='139776807484688'>, 'storage': <Mock id='139776807482128'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f20533c76d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario2] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053353c90>
mock_print = <MagicMock name='print' id='139776807585680'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052f6dcd0>
test_scenario = {'name': 'empty_search', 'query': '', 'source': 'all'}
consolidated_mocks = {'input': <Mock id='139776807592400'>, 'print': <Mock id='139776807586256'>, 'source_selector': <Mock id='139776807589392'>, 'storage': <Mock id='139776807586896'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052f10210>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_concurrent_searches _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053360210>
mock_print = <MagicMock name='print' id='139776803675664'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052bb2390>
consolidated_mocks = {'input': <Mock id='139776803682512'>, 'print': <Mock id='139776803669648'>, 'source_selector': <Mock id='139776803682832'>, 'storage': <Mock id='139776803676496'>, ...}

    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, search_handler, consolidated_mocks):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
                 patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_vacancy_search_handler.py:400: in <listcomp>
    results = [future.result() for future in concurrent.futures.as_completed(futures)]
               ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/thread.py:58: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_vacancy_search_handler.py:394: in search_task
    with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052b94f90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_performance_metrics _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f20533516d0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052f390d0>
consolidated_mocks = {'input': <Mock id='139776803261008'>, 'print': <Mock id='139776807376784'>, 'source_selector': <Mock id='139776803274384'>, 'storage': <Mock id='139776803274320'>, ...}

    def test_performance_metrics(self, search_handler, consolidated_mocks):
        """Тест метрик производительности"""
        import time
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052f39290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestVacancySearchHandler.test_integration_workflow ______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053360710>
mock_print = <MagicMock name='print' id='139776803178064'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052b3b890>
consolidated_mocks = {'input': <Mock id='139776803189008'>, 'print': <Mock id='139776803183056'>, 'source_selector': <Mock id='139776803188496'>, 'storage': <Mock id='139776803191184'>, ...}

    @patch('builtins.print')
    def test_integration_workflow(self, mock_print, search_handler, consolidated_mocks):
        """Тест интеграционного рабочего процесса"""
        search_handler.storage = consolidated_mocks['storage']
        consolidated_mocks['storage'].add_vacancy.return_value = True
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052b39cd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancySearchHandler.test_memory_usage __________________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053360f90>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052beb090>
consolidated_mocks = {'input': <Mock id='139776803902480'>, 'print': <Mock id='139776803906640'>, 'source_selector': <Mock id='139776803901520'>, 'storage': <Mock id='139776803901072'>, ...}

    def test_memory_usage(self, search_handler, consolidated_mocks):
        """Тест использования памяти"""
        import gc
    
        # Выполняем поиск и проверяем, что память освобождается
        initial_objects = len(gc.get_objects())
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):

tests/test_vacancy_search_handler.py:469: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f2052be80d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_search_handler' from '/home/runner/workspace/tests/../src/ui_interfaces/vacancy_search_handler.py'> does not have the attribute 'get_positive_integer'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestVacancySearchHandler.test_search_handler_workflow_complete ________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f2053362d10>
mock_print = <MagicMock name='print' id='139776803330768'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f2052b5dc10>
consolidated_mocks = {'input': <Mock id='139776803331216'>, 'print': <Mock id='139776803327248'>, 'source_selector': <Mock id='139776803339664'>, 'storage': <Mock id='139776803327632'>, ...}

    @patch('builtins.print')
    def test_search_handler_workflow_complete(self, mock_print, search_handler, consolidated_mocks):
        """Тест полного рабочего процесса обработчика"""
        # Настройка консолидированных моков для полного workflow
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
        consolidated_mocks['storage'].add_vacancy.return_value = True
        consolidated_mocks['unified_api'].get_vacancies.return_value = []
    
        # Мокируем все пользовательские взаимодействия
        mock_inputs = {
            'get_user_input': "Python",
            'get_positive_integer': 15,
            'input': "1"
        }
    
>       with patch('src.ui_interfaces.vacancy_search_handler.get_user_input', return_value=mock_inputs['get_user_input']) if SRC_AVAILABLE else patch('builtins.input', return_value=mock_inputs['input']), \
             patch('src.ui_interfaces.vacancy_search_handler.get_positive_integer', return_value=mock_inputs['get_positive_integer']) if SRC_AVAILABLE else patch('builtins.input', return_value=str(mock_inputs['get_positive_integer'])):
