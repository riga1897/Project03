~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 289 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py FFFF                                     [  5%]
tests/test_app_config.py FFFFF                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 13%]
tests/test_cached_api.py FFFFF                                    [ 15%]
tests/test_db_manager.py FF..FF.F                                 [ 18%]
tests/test_decorators.py .......                                  [ 20%]
tests/test_env_loader.py ...FFFFFFFFF                             [ 24%]
tests/test_file_handlers.py ............                          [ 29%]
tests/test_get_api.py ......                                      [ 31%]
tests/test_hh_api.py ..F....                                      [ 33%]
tests/test_hh_api_config.py FFFF.                                 [ 35%]
tests/test_hh_parser.py .F..FFF.                                  [ 38%]
tests/test_menu_manager.py FFFF.FFFFF                             [ 41%]
tests/test_paginator.py FFFFFF                                    [ 43%]
tests/test_postgres_saver.py .......                              [ 46%]
tests/test_salary_utils.py .FF.................                   [ 52%]
tests/test_search_utils.py ......FFFF.                            [ 56%]
tests/test_sj_api.py FF.FFFF                                      [ 59%]
tests/test_sj_api_config.py FF.F.                                 [ 60%]
tests/test_sj_parser.py ........                                  [ 63%]
tests/test_storage_factory.py .F...F..                            [ 66%]
tests/test_target_companies.py FF.F.                              [ 68%]
tests/test_ui_config.py FF...                                     [ 69%]
tests/test_ui_helpers.py ...........                              [ 73%]
tests/test_unified_api.py .................                       [ 79%]
tests/test_user_interface.py .FF..F..                             [ 82%]
tests/test_vacancy_display_handler.py .FFFFFF                     [ 84%]
tests/test_vacancy_formatter.py ..F..F.                           [ 87%]
tests/test_vacancy_models.py ......F.FFFFFFFF                     [ 92%]
tests/test_vacancy_operations_coordinator.py FF.FFFF.             [ 95%]
tests/test_vacancy_search_handler.py FFFFFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestAPIConfig.test_api_config_initialization ______________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f3ca552bcd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca6be7050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'SJAPIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestAPIConfig.test_api_config_urls ___________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f3ca552a810>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca552ba50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'SJAPIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIConfig.test_api_config_headers _________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f3ca5529b90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca552b850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'SJAPIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestAPIConfig.test_api_config_parameters ________________

args = (<workspace.tests.test_api_config.TestAPIConfig object at 0x7f3ca552a310>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca552b510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.api_config' from '/home/runner/workspace/tests/../src/config/api_config.py'> does not have the attribute 'SJAPIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestAppConfig.test_app_config_initialization ______________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f3ca55360d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca5d2bad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'UIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestAppConfig.test_app_config_database _________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f3ca5535f10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca5d2f790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'UIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAppConfig.test_app_config_logging _________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f3ca5535c50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca54fd9d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'UIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestAppConfig.test_app_config_cache __________________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f3ca5537310>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca54fecd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'UIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestAppConfig.test_app_config_api_settings _______________

args = (<workspace.tests.test_app_config.TestAppConfig object at 0x7f3ca5537f50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca54fe050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.app_config' from '/home/runner/workspace/tests/../src/config/app_config.py'> does not have the attribute 'UIConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestCachedAPI.test_cached_api_initialization ______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f3ca5567f50>
mock_file_cache = <MagicMock name='FileCache' id='139898415321168'>

    @patch('src.utils.cache.FileCache')
    def test_cached_api_initialization(self, mock_file_cache):
        """Тест инициализации CachedAPI"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = TestCachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TestCachedAPIImplementation with abstract methods get_vacancies, get_vacancies_page

tests/test_cached_api.py:36: TypeError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f3ca55673d0>
mock_file_cache = <MagicMock name='FileCache' id='139898423500048'>

    @patch('src.utils.cache.FileCache')
    def test_cached_api_with_cache_manager(self, mock_file_cache):
        """Тест CachedAPI с кэш менеджером"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = TestCachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TestCachedAPIImplementation with abstract methods get_vacancies, get_vacancies_page

tests/test_cached_api.py:45: TypeError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f3ca5567d10>
mock_file_cache = <MagicMock name='FileCache' id='139898414317648'>

    @patch('src.utils.cache.FileCache')
    def test_cached_api_abstract_methods(self, mock_file_cache):
        """Тест абстрактных методов CachedAPI"""
>       api = TestCachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TestCachedAPIImplementation with abstract methods get_vacancies, get_vacancies_page

tests/test_cached_api.py:51: TypeError
_________________ TestCachedAPI.test_cache_integration __________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f3ca55645d0>
mock_file_cache = <MagicMock name='FileCache' id='139898454598416'>

    @patch('src.utils.cache.FileCache')
    def test_cache_integration(self, mock_file_cache):
        """Тест интеграции с кэшем"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None
        mock_cache_instance.set.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = TestCachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TestCachedAPIImplementation with abstract methods get_vacancies, get_vacancies_page

tests/test_cached_api.py:68: TypeError
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f3ca5564810>
mock_file_cache = <MagicMock name='FileCache' id='139898415459408'>

    @patch('src.utils.cache.FileCache')
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = TestCachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TestCachedAPIImplementation with abstract methods get_vacancies, get_vacancies_page

tests/test_cached_api.py:80: TypeError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f3ca555f850>
mock_connect = <MagicMock name='connect' id='139898414332560'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:69: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'MockConnection' object has no attribute 'set_client_encoding'
___________________ TestDBManager.test_create_tables ____________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f3ca555fe50>
mock_connect = <MagicMock name='connect' id='139898415460432'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
>       db_manager.create_tables()

tests/test_db_manager.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:68: in create_tables
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f3ca39a1f90>

    def _get_connection(self) -> psycopg2.extensions.connection:
        """
        Создает подключение к базе данных используя SQL-драйвер psycopg2
    
        Returns:
            psycopg2.extensions.connection: Подключение к БД
    
        Raises:
            psycopg2.Error: При ошибке подключения к БД
        """
        try:
            connection_params = self.db_config.get_connection_params()
            # Добавляем явное указание кодировки UTF-8
            connection_params["client_encoding"] = "utf8"
            connection = psycopg2.connect(**connection_params)
    
            # Устанавливаем кодировку для соединения
>           connection.set_client_encoding("UTF8")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'MockConnection' object has no attribute 'set_client_encoding'

src/storage/db_manager.py:56: AttributeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'MockConnection' object has no attribute 'set_client_encoding'
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f3ca555de90>
mock_connect = <MagicMock name='connect' id='139898428266384'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor.fetch_data = [(125000.0,)]
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем check_connection и create_tables
        with patch.object(db_manager, 'check_connection', return_value=True):
            with patch.object(db_manager, 'create_tables'):
>               result = db_manager.get_avg_salary()
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:514: in get_avg_salary
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f3ca396cd90>

    def _get_connection(self) -> psycopg2.extensions.connection:
        """
        Создает подключение к базе данных используя SQL-драйвер psycopg2
    
        Returns:
            psycopg2.extensions.connection: Подключение к БД
    
        Raises:
            psycopg2.Error: При ошибке подключения к БД
        """
        try:
            connection_params = self.db_config.get_connection_params()
            # Добавляем явное указание кодировки UTF-8
            connection_params["client_encoding"] = "utf8"
            connection = psycopg2.connect(**connection_params)
    
            # Устанавливаем кодировку для соединения
>           connection.set_client_encoding("UTF8")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'MockConnection' object has no attribute 'set_client_encoding'

src/storage/db_manager.py:56: AttributeError
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f3ca555dc90>
mock_connect = <MagicMock name='connect' id='139898423831504'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor.fetch_data = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем check_connection и create_tables
        with patch.object(db_manager, 'check_connection', return_value=True):
            with patch.object(db_manager, 'create_tables'):
>               result = db_manager.get_vacancies_with_higher_salary()
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:536: in get_vacancies_with_higher_salary
    avg_salary = self.get_avg_salary()
                 ^^^^^^^^^^^^^^^^^^^^^
src/storage/db_manager.py:514: in get_avg_salary
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f3ca3db6c10>

    def _get_connection(self) -> psycopg2.extensions.connection:
        """
        Создает подключение к базе данных используя SQL-драйвер psycopg2
    
        Returns:
            psycopg2.extensions.connection: Подключение к БД
    
        Raises:
            psycopg2.Error: При ошибке подключения к БД
        """
        try:
            connection_params = self.db_config.get_connection_params()
            # Добавляем явное указание кодировки UTF-8
            connection_params["client_encoding"] = "utf8"
            connection = psycopg2.connect(**connection_params)
    
            # Устанавливаем кодировку для соединения
>           connection.set_client_encoding("UTF8")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'MockConnection' object has no attribute 'set_client_encoding'

src/storage/db_manager.py:56: AttributeError
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7f3ca513ba50>
mock_connect = <MagicMock name='connect' id='139898448235472'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем get_target_companies
>       with patch('src.storage.db_manager.get_target_companies', return_value=[]):

tests/test_db_manager.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3ca3513290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.db_manager' from '/home/runner/workspace/tests/../src/storage/db_manager.py'> does not have the attribute 'get_target_companies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestEnvLoader.test_load_env_file_success ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5173d90>
mock_exists = <MagicMock name='exists' id='139898448414224'>
mock_file = <MagicMock name='open' id='139898423622032'>

    @patch('builtins.open', new_callable=mock_open, read_data='KEY1=value1\nKEY2=value2\n# Comment\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_success(self, mock_exists, mock_file):
        """Тест успешной загрузки .env файла"""
        with patch.dict(os.environ, {}, clear=True):
>           result = load_env_file(".env")
                     ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
______________ TestEnvLoader.test_load_env_file_not_found _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5170f50>
mock_exists = <MagicMock name='exists' id='139898415554576'>

    @patch('os.path.exists', return_value=False)
    def test_load_env_file_not_found(self, mock_exists):
        """Тест загрузки несуществующего .env файла"""
>       result = load_env_file(".env")
                 ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
______________ TestEnvLoader.test_load_env_file_read_error ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5171a90>
mock_exists = <MagicMock name='exists' id='139898454597392'>
mock_file = <MagicMock name='open' id='139898423317264'>

    @patch('builtins.open', side_effect=OSError("Read error"))
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_read_error(self, mock_exists, mock_file):
        """Тест ошибки чтения .env файла"""
>       result = load_env_file(".env")
                 ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
________________ TestEnvLoader.test_parse_env_line_valid ________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5171c50>

    def test_parse_env_line_valid(self):
        """Тест парсинга валидной строки .env"""
        # Используем статический метод напрямую
>       key, value = EnvLoader._parse_line("KEY=value")
                     ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'EnvLoader' has no attribute '_parse_line'

tests/test_env_loader.py:56: AttributeError
_______________ TestEnvLoader.test_parse_env_line_invalid _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5172050>

    def test_parse_env_line_invalid(self):
        """Тест парсинга невалидной строки .env"""
        # Комментарий
>       result = EnvLoader._parse_line("# This is a comment")
                 ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'EnvLoader' has no attribute '_parse_line'

tests/test_env_loader.py:63: AttributeError
______________ TestEnvLoader.test_set_environment_variable ______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca51703d0>

    @patch.dict(os.environ, {}, clear=True)
    def test_set_environment_variable(self):
        """Тест установки переменной окружения"""
>       EnvLoader._set_env_var("TEST_KEY", "test_value")
        ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'EnvLoader' has no attribute '_set_env_var'

tests/test_env_loader.py:77: AttributeError
_______________ TestEnvLoader.test_load_env_file_function _______________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca5170910>
mock_exists = <MagicMock name='exists' id='139898454602128'>
mock_file = <MagicMock name='open' id='139898448199568'>

    @patch('builtins.open', new_callable=mock_open, read_data='API_KEY=secret123\nDEBUG=true\n')
    @patch('os.path.exists', return_value=True)
    def test_load_env_file_function(self, mock_exists, mock_file):
        """Тест функции load_env_file"""
        with patch.dict(os.environ, {}, clear=True):
>           result = load_env_file(".env")
                     ^^^^^^^^^^^^^^^^^^^^^

tests/test_env_loader.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file_path = '.env'

    def load_env_file(file_path=".env"):
        """Функция для загрузки .env файла"""
        loader = EnvLoader()
>       return loader.load_file(file_path)
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_file'

src/utils/env_loader.py:51: AttributeError
____________ TestEnvLoader.test_env_var_parsing_with_quotes _____________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca516b490>

    def test_env_var_parsing_with_quotes(self):
        """Тест парсинга переменных с кавычками"""
>       key, value = EnvLoader._parse_line('KEY="quoted value"')
                     ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'EnvLoader' has no attribute '_parse_line'

tests/test_env_loader.py:90: AttributeError
____________ TestEnvLoader.test_env_var_parsing_with_spaces _____________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f3ca516bfd0>

    def test_env_var_parsing_with_spaces(self):
        """Тест парсинга переменных с пробелами"""
>       key, value = EnvLoader._parse_line('KEY = value with spaces ')
                     ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'EnvLoader' has no attribute '_parse_line'

tests/test_env_loader.py:96: AttributeError
_____________ TestHeadHunterAPI.test_get_vacancies_success ______________

self = <workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7f3ca49d8090>
mock_paginator = <MagicMock name='Paginator' id='139898415322064'>
mock_api_config = <MagicMock name='APIConfig' id='139898415137552'>
mock_cache = <MagicMock name='FileCache' id='139898413913744'>
mock_connector = <MagicMock name='APIConnector' id='139898413908048'>

    @patch('src.api_modules.hh_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.hh_api.APIConfig')
    @patch('src.api_modules.hh_api.Paginator')
    def test_get_vacancies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения вакансий"""
        # Мок ответа API
        mock_response = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "employer": {"name": "Test Company"},
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "source": "hh.ru"
                }
            ],
            "found": 1,
            "pages": 1
        }
    
        # Настраиваем все моки
        mock_config_instance = Mock()
        mock_config_instance.hh_config.get_params.return_value = {"text": "python", "page": 0}
        mock_config_instance.get_pagination_params.return_value = {"max_pages": 20}
        mock_api_config.return_value = mock_config_instance
    
        api = HeadHunterAPI()
    
        # Мокаем метод подключения к API
        with patch.object(api, '_CachedAPI__connect_to_api', return_value=mock_response):
            result = api.get_vacancies("python")
    
>       assert isinstance(result, list)
E       AssertionError: assert False
E        +  where False = isinstance(<MagicMock name='Paginator().paginate()' id='139898419519888'>, list)

tests/test_hh_api.py:76: AssertionError
_____________ TestHHAPIConfig.test_hh_config_initialization _____________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f3ca49d1ad0>

    def test_hh_config_initialization(self):
        """Тест инициализации HH API конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'BASE_URL')

tests/test_hh_api_config.py:11: AssertionError
__________________ TestHHAPIConfig.test_hh_config_urls __________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f3ca49d29d0>

    def test_hh_config_urls(self):
        """Тест URL конфигурации"""
        config = HHAPIConfig()
>       assert config.BASE_URL.startswith('https://api.hh.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'BASE_URL'

tests/test_hh_api_config.py:18: AttributeError
_______________ TestHHAPIConfig.test_hh_config_parameters _______________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f3ca49d2ed0>

    def test_hh_config_parameters(self):
        """Тест параметров конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'DEFAULT_PER_PAGE')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'DEFAULT_PER_PAGE')

tests/test_hh_api_config.py:25: AssertionError
________________ TestHHAPIConfig.test_hh_config_timeout _________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7f3ca49d0090>

    def test_hh_config_timeout(self):
        """Тест настроек таймаута"""
        config = HHAPIConfig()
>       assert hasattr(config, 'TIMEOUT')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'TIMEOUT')

tests/test_hh_api_config.py:33: AssertionError
__________________ TestHHParser.test_parse_hh_vacancy ___________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f3ca49bc910>

    def test_parse_hh_vacancy(self):
        """Тест парсинга вакансии HH"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['id'] == '123456'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:31: KeyError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f3ca49bcf50>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {'items': [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies_list(data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_vacancies_list'

tests/test_hh_parser.py:55: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f3ca49be850>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {'id': '123', 'name': 'Test Job'}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result['id'] == '123'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:63: KeyError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7f3ca49bdc50>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['company'] == 'Test Company'
               ^^^^^^^^^^^^^^^^^
E       KeyError: 'company'

tests/test_hh_parser.py:70: KeyError
___________ TestMenuManager.test_menu_manager_initialization ____________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a4dd0>

    def test_menu_manager_initialization(self):
        """Тест инициализации MenuManager"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:21: TypeError
___________________ TestMenuManager.test_display_menu ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a5410>
mock_print = <MagicMock name='print' id='139898415260880'>

    @patch('builtins.print')
    def test_display_menu(self, mock_print):
        """Тест отображения меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:32: TypeError
_______________ TestMenuManager.test_get_menu_item_valid ________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a58d0>

    def test_get_menu_item_valid(self):
        """Тест получения валидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:45: TypeError
______________ TestMenuManager.test_get_menu_item_invalid _______________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a6c50>

    def test_get_menu_item_invalid(self):
        """Тест получения невалидного пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:56: TypeError
_________________ TestMenuManager.test_menu_validation __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a7510>

    def test_menu_validation(self):
        """Тест валидации пунктов меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:70: TypeError
_________________ TestMenuManager.test_get_user_choice __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49be190>
mock_input = <MagicMock name='input' id='139898415443408'>

    @patch('builtins.input', return_value='1')
    def test_get_user_choice(self, mock_input):
        """Тест получения выбора пользователя"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:82: TypeError
__________________ TestMenuManager.test_add_menu_item ___________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a7d90>

    def test_add_menu_item(self):
        """Тест добавления пункта меню"""
>       manager = MenuManager([])
                  ^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:92: TypeError
_________________ TestMenuManager.test_remove_menu_item _________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a6010>

    def test_remove_menu_item(self):
        """Тест удаления пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"},
            {"id": "2", "title": "Option 2", "description": "Second option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:107: TypeError
___________ TestMenuManager.test_remove_nonexistent_menu_item ___________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7f3ca49a7e90>

    def test_remove_nonexistent_menu_item(self):
        """Тест удаления несуществующего пункта меню"""
        menu_items = [
            {"id": "1", "title": "Option 1", "description": "First option"}
        ]
    
>       manager = MenuManager(menu_items)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:120: TypeError
______________ TestPaginator.test_paginator_initialization ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca49cf150>

    def test_paginator_initialization(self):
        """Тест инициализации Paginator"""
        items = ["item1", "item2", "item3"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:56: TypeError
_________________ TestPaginator.test_paginator_get_page _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca49cf310>

    def test_paginator_get_page(self):
        """Тест получения страницы"""
        items = ["item1", "item2", "item3", "item4", "item5"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:66: TypeError
_______________ TestPaginator.test_paginator_invalid_page _______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca49cf750>

    def test_paginator_invalid_page(self):
        """Тест получения невалидной страницы"""
        items = ["item1", "item2"]
>       paginator = Paginator(items, items_per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:80: TypeError
_______________ TestPaginator.test_paginator_empty_items ________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca49cc250>

    def test_paginator_empty_items(self):
        """Тест пагинатора с пустым списком"""
>       paginator = Paginator([], items_per_page=5)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator.__init__() got an unexpected keyword argument 'items_per_page'

tests/test_paginator.py:91: TypeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca49ccd10>
mock_print = <MagicMock name='print' id='139898415044560'>
mock_input = <MagicMock name='input' id='139898415044240'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:106: TypeError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7f3ca4997550>
mock_print = <MagicMock name='print' id='139898415254096'>
mock_input = <MagicMock name='input' id='139898415267152'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
>       quick_paginate(items, formatter=simple_formatter, items_per_page=5)
E       TypeError: quick_paginate() got an unexpected keyword argument 'formatter'

tests/test_paginator.py:120: TypeError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f3ca4507450>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
>       assert parse_salary_range("invalid") is None
E       AssertionError: assert (None, None) is None
E        +  where (None, None) = parse_salary_range('invalid')

tests/test_salary_utils.py:84: AssertionError
_________ TestSalaryUtils.test_parse_salary_range_reverse_order _________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7f3ca4507a50>

    def test_parse_salary_range_reverse_order(self):
        """Тест парсинга диапазона в обратном порядке"""
        result = parse_salary_range("150000 - 100000")
        # Должно автоматически поменять местами
>       assert result == (100000, 150000)
E       assert (150000, 100000) == (100000, 150000)
E         
E         At index 0 diff: 150000 != 100000
E         Use -v to get more diff

tests/test_salary_utils.py:93: AssertionError
___________ TestAdvancedSearch.test_search_with_and_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f3ca4524e90>

    def test_search_with_and_operator(self):
        """Тест поиска с оператором AND"""
        vacancies = [
            Vacancy("123", "Python Django Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Python Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "Django Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_and(vacancies, ["python", "django"])
    
        # Должна найтись только первая вакансия
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_search_utils.py:76: AssertionError
____________ TestAdvancedSearch.test_search_with_or_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f3ca45254d0>

    def test_search_with_or_operator(self):
        """Тест поиска с оператором OR"""
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "C++ Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["python", "java"])
    
        # Должны найтись первые две вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:91: AssertionError
____________ TestAdvancedSearch.test_search_case_insensitive ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f3ca4513bd0>

    def test_search_case_insensitive(self):
        """Тест поиска без учета регистра"""
        vacancies = [
            Vacancy("123", "PYTHON Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "python developer", "https://test2.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["Python"])
    
        # Должны найтись обе вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:104: AssertionError
_____________ TestAdvancedSearch.test_search_in_description _____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7f3ca450fa90>

    def test_search_in_description(self):
        """Тест поиска в описании вакансии"""
        vacancies = [
>           Vacancy("123", "Developer", "https://test.com", "hh.ru",
                   description="Work with Python and Django"),
            Vacancy("124", "Developer", "https://test2.com", "hh.ru",
                   description="Work with Java")
        ]
E       TypeError: Vacancy.__init__() got multiple values for argument 'description'

tests/test_search_utils.py:109: TypeError
______________ TestSuperJobAPI.test_sj_api_initialization _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca4527550>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJobAPI"""
        api = SuperJobAPI()
>       assert hasattr(api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f3ca3d3b250>, 'base_url')

tests/test_sj_api.py:16: AssertionError
_______________ TestSuperJobAPI.test_sj_api_with_api_key ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca4527950>

    def test_sj_api_with_api_key(self):
        """Тест инициализации с API ключом"""
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:21: TypeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca4534590>
mock_get = <MagicMock name='get' id='139898415546704'>

    @patch('requests.Session.get')
    def test_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "firm_name": "Test Company",
                    "payment_from": 100000,
                    "payment_to": 150000,
                    "town": {"title": "Москва"}
                }
            ],
            "total": 1
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:52: TypeError
____________ TestSuperJobAPI.test_get_vacancy_by_id_success _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca4534b50>
mock_get = <MagicMock name='get' id='139898428283856'>

    @patch('requests.Session.get')
    def test_get_vacancy_by_id_success(self, mock_get):
        """Тест успешного получения вакансии по ID"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "profession": "Python Developer",
            "firm_name": "Test Company"
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:70: TypeError
________________ TestSuperJobAPI.test_api_key_validation ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca4535150>

    def test_api_key_validation(self):
        """Тест валидации API ключа"""
        api = SuperJobAPI()
    
        # Проверяем обработку отсутствующего API ключа
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f3ca3598e90>, 'api_key')

tests/test_sj_api.py:81: AssertionError
_____________ TestSuperJobAPI.test_api_key_from_environment _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3ca45356d0>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'env_test_key'})
    def test_api_key_from_environment(self):
        """Тест получения API ключа из переменной окружения"""
        api = SuperJobAPI()
        # API должен использовать ключ из окружения
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7f3ca35a9290>, 'api_key')

tests/test_sj_api.py:88: AssertionError
_____________ TestSJAPIConfig.test_sj_config_initialization _____________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f3ca45366d0>

    def test_sj_config_initialization(self):
        """Тест инициализации SuperJob API конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'BASE_URL')

tests/test_sj_api_config.py:11: AssertionError
__________________ TestSJAPIConfig.test_sj_config_urls __________________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f3ca4536cd0>

    def test_sj_config_urls(self):
        """Тест URL конфигурации"""
        config = SJAPIConfig()
>       assert config.BASE_URL.startswith('https://api.superjob.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'BASE_URL'

tests/test_sj_api_config.py:17: AttributeError
_______________ TestSJAPIConfig.test_sj_config_parameters _______________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7f3ca4537910>

    def test_sj_config_parameters(self):
        """Тест параметров конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'DEFAULT_COUNT')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'DEFAULT_COUNT')

tests/test_sj_api_config.py:31: AssertionError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f3ca35e2d90>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=postgres"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f3ca4548c10>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='139898415319440'>
mock_app_config = <MagicMock name='AppConfig' id='139898415618128'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_postgres_storage(self, mock_postgres_saver, mock_app_config):
        """Тест создания PostgreSQL хранилища с моками"""
        # Настраиваем моки
        mock_config_instance = Mock()
        mock_config_instance.get_db_config.return_value = {'host': 'localhost'}
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=Project03"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'Project03', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД Project03: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных Project03 недоступна и не может быть создана
_________ TestStorageFactory.test_create_storage_with_db_config _________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f3ca356db50>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=postgres'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7f3ca454a3d0>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='139898414411856'>
mock_app_config = <MagicMock name='AppConfig' id='139898415141712'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_storage_with_db_config(self, mock_postgres_saver, mock_app_config):
        """Тест создания хранилища с конфигурацией БД"""
        # Настраиваем моки
        mock_config_instance = Mock()
        test_db_config = {
            'host': 'test_host',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
        mock_config_instance.get_db_config.return_value = test_db_config
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=test_db'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'test_db', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД test_db: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных test_db недоступна и не может быть создана
_______ TestTargetCompanies.test_target_companies_initialization ________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f3ca454b490>

    def test_target_companies_initialization(self):
        """Тест инициализации списка целевых компаний"""
        companies = TargetCompanies()
>       assert hasattr(companies, 'companies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.target_companies.TargetCompanies object at 0x7f3ca390fc10>, 'companies')

tests/test_target_companies.py:44: AssertionError
________ TestTargetCompanies.test_get_target_companies_function _________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f3ca454b750>

    def test_get_target_companies_function(self):
        """Тест функции получения целевых компаний"""
        companies = get_target_companies()
>       assert isinstance(companies, (list, dict))
E       AssertionError: assert False
E        +  where False = isinstance(<src.config.target_companies.TargetCompanies object at 0x7f3ca39bb910>, (<class 'list'>, <class 'dict'>))

tests/test_target_companies.py:50: AssertionError
_____________ TestTargetCompanies.test_companies_not_empty ______________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7f3ca45499d0>

    def test_companies_not_empty(self):
        """Тест что список компаний не пустой"""
        companies = get_target_companies()
>       assert len(companies) > 0
               ^^^^^^^^^^^^^^
E       TypeError: object of type 'TargetCompanies' has no len()

tests/test_target_companies.py:67: TypeError
______________ TestUIConfig.test_ui_config_initialization _______________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f3ca4554d50>

    def test_ui_config_initialization(self):
        """Тест инициализации UI конфигурации"""
        config = UIConfig()
>       assert hasattr(config, 'PAGINATION_SIZE')
E       AssertionError: assert False
E        +  where False = hasattr(UIConfig(items_per_page=5, max_display_items=20), 'PAGINATION_SIZE')

tests/test_ui_config.py:10: AssertionError
________________ TestUIConfig.test_ui_config_pagination _________________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7f3ca4555650>

    def test_ui_config_pagination(self):
        """Тест настроек пагинации"""
        config = UIConfig()
>       assert config.PAGINATION_SIZE > 0
               ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIConfig' object has no attribute 'PAGINATION_SIZE'

tests/test_ui_config.py:16: AttributeError
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <MagicMock name='_handle_choice' id='139898415396112'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_handle_choice' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f3ca45ce390>
mock_stdout = <_io.StringIO object at 0x7f3ca34eb760>
mock_input = <MagicMock name='input' id='139898419648016'>

    @patch('builtins.input', return_value='0')
    @patch('sys.stdout', new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
        with patch.object(ui, '_display_menu'):
            with patch.object(ui, '_handle_choice') as mock_handle:
                mock_handle.return_value = False
                ui.run()
>               mock_handle.assert_called()
E               AssertionError: Expected '_handle_choice' to have been called.

tests/test_user_interface.py:63: AssertionError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <MagicMock name='_search_vacancies' id='139898414980944'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_search_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f3ca45cecd0>
mock_input = <MagicMock name='input' id='139898415696336'>

    @patch('builtins.input', return_value='1')
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
        with patch.object(ui, '_search_vacancies') as mock_search:
            result = ui._handle_choice('1')
            if hasattr(ui, '_search_vacancies'):
>               mock_search.assert_called()
E               AssertionError: Expected '_search_vacancies' to have been called.

tests/test_user_interface.py:72: AssertionError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f3ca45ce210>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        with patch('builtins.input', side_effect=KeyboardInterrupt):
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

tests/test_user_interface.py:92: Failed
______ TestVacancyDisplayHandler.test_display_vacancies_empty_list ______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45dbad0>
mock_print = <MagicMock name='print' id='139898415546768'>

    @patch('builtins.print')
    def test_display_vacancies_empty_list(self, mock_print):
        """Тест отображения пустого списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       handler.display_vacancies([])
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:84: AttributeError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45c00d0>
mock_print = <MagicMock name='print' id='139898415147984'>

    @patch('builtins.print')
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru")
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:100: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45c06d0>
mock_paginate = <MagicMock name='quick_paginate' id='139898415442832'>

    @patch('src.ui_interfaces.vacancy_display_handler.quick_paginate')
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:115: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45c0cd0>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:131: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45c12d0>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124",
            title="Junior Developer",
            url="https://test.com/vacancy/124",
            source="hh.ru",
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:153: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f3ca45c18d0>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(
            id="125",
            title="Intern",
            url="https://test.com/vacancy/125",
            source="hh.ru",
            salary=salary
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:174: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f3ca45c3b90>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3ca347a680>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f3ca45c8dd0>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость"
        )

tests/test_vacancy_formatter.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3ca41b21a0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____ TestVacancyEmployer.test_vacancy_employer_str_representation ______

self = <workspace.tests.test_vacancy_models.TestVacancyEmployer object at 0x7f3ca45e04d0>

    def test_vacancy_employer_str_representation(self):
        """Тест строкового представления VacancyEmployer"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       assert str(employer) == "Test Company"
E       AssertionError: assert 'VacancyEmplo...rusted=False)' == 'Test Company'
E         
E         - Test Company
E         + VacancyEmployer(id='1', name='Test Company', url=None, trusted=False)

tests/test_vacancy_models.py:88: AssertionError
________________ TestVacancy.test_vacancy_initialization ________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e1350>

    def test_vacancy_initialization(self):
        """Тест инициализации Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:102: TypeError
_________________ TestVacancy.test_vacancy_with_salary __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e1950>

    def test_vacancy_with_salary(self):
        """Тест вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            salary=str(salary), # Assuming salary is converted to string for the placeholder Vacancy
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:120: TypeError
________________ TestVacancy.test_vacancy_with_employer _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e1f50>

    def test_vacancy_with_employer(self):
        """Тест вакансии с работодателем"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:133: TypeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e2590>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:149: TypeError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e2b90>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            vacancy_id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"],
            source="hh.ru"
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:204: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e31d0>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            vacancy_id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"],
            source="superjob.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:224: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e37d0>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:243: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3ca45e3dd0>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary),
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:266: TypeError
___ TestVacancyOperationsCoordinator.test_coordinator_initialization ____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca41089d0>

    def test_coordinator_initialization(self):
        """Тест инициализации VacancyOperationsCoordinator"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
>       assert coordinator.api == mock_api
               ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyOperationsCoordinator' object has no attribute 'api'

tests/test_vacancy_operations_coordinator.py:21: AttributeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca4108f90>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='139898423318416'>

    @patch('src.ui_interfaces.vacancy_search_handler.VacancySearchHandler')
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7f3ca5d2ffd0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca4109b50>
mock_print = <MagicMock name='print' id='139898419461136'>
mock_input = <MagicMock name='input' id='139898419457360'>

    @patch('builtins.input', return_value='5')
    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, mock_input):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
>       from src.vacancies.models import Vacancy, VacancySalary
E       ImportError: cannot import name 'VacancySalary' from 'src.vacancies.models' (/home/runner/workspace/tests/../src/vacancies/models.py)

tests/test_vacancy_operations_coordinator.py:62: ImportError
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca410a110>
mock_print = <MagicMock name='print' id='139898432395792'>
mock_input = <MagicMock name='input' id='139898415323600'>

    @patch('builtins.input', return_value='Python')
    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, mock_input):
        """Тест поиска сохраненных вакансий по ключевому слову"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:86: NameError
_____ TestVacancyOperationsCoordinator.test_handle_delete_vacancies _____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca410a6d0>
mock_input = <MagicMock name='input' id='139898414841552'>

    @patch('builtins.input', return_value='Python')
    def test_handle_delete_vacancies(self, mock_input):
        """Тест удаления вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:103: NameError
______ TestVacancyOperationsCoordinator.test_handle_cache_cleanup _______

self = <Mock name='mock.clear_cache' id='139898415398544'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear_cache' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7f3ca410acd0>

    def test_handle_cache_cleanup(self):
        """Тест очистки кэша"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
        with patch('builtins.print'):
            coordinator.handle_cache_cleanup()
    
        # Проверяем, что очистка кэша была вызвана
>       mock_api.clear_cache.assert_called()
E       AssertionError: Expected 'clear_cache' to have been called.

tests/test_vacancy_operations_coordinator.py:126: AssertionError
------------------------- Captured stdout call --------------------------
Ваш выбор: 
--------------------------- Captured log call ---------------------------
ERROR    src.ui_interfaces.vacancy_operations_coordinator:vacancy_operations_coordinator.py:78 Ошибка при очистке кэша: pytest: reading from stdin while output is captured!  Consider using `-s`.
__ TestVacancySearchHandler.test_vacancy_search_handler_initialization __