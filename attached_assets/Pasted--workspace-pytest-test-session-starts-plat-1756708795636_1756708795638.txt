~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 341 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  3%]
tests/test_api_config.py ....                                     [  4%]
tests/test_app_config.py .....                                    [  6%]
tests/test_base_api.py ......                                     [  7%]
tests/test_base_parser.py ......                                  [  9%]
tests/test_cache.py .......                                       [ 11%]
tests/test_cached_api.py FFFFFFFFFFF                              [ 14%]
tests/test_db_manager.py .................                        [ 19%]
tests/test_decorators.py .......                                  [ 21%]
tests/test_env_loader.py ............                             [ 25%]
tests/test_file_handlers.py ............                          [ 29%]
tests/test_get_api.py ......                                      [ 30%]
tests/test_hh_api.py .......                                      [ 32%]
tests/test_hh_api_config.py .....                                 [ 34%]
tests/test_hh_parser.py ........                                  [ 36%]
tests/test_menu_manager.py ..........                             [ 39%]
tests/test_paginator.py ......                                    [ 41%]
tests/test_postgres_saver.py .......                              [ 43%]
tests/test_salary_utils.py ......................                 [ 49%]
tests/test_search_utils.py ..................                     [ 55%]
tests/test_sj_api.py .FFF.F...FF..F                               [ 59%]
tests/test_sj_api_config.py .....                                 [ 60%]
tests/test_sj_parser.py ........                                  [ 63%]
tests/test_storage_factory.py ........                            [ 65%]
tests/test_target_companies.py .....                              [ 66%]
tests/test_ui_config.py .....                                     [ 68%]
tests/test_ui_helpers.py ...........                              [ 71%]
tests/test_unified_api.py .................                       [ 76%]
tests/test_user_interface.py ........                             [ 78%]
tests/test_vacancy_display_handler.py .........                   [ 81%]
tests/test_vacancy_formatter.py ...F.F........                    [ 85%]
tests/test_vacancy_models.py FF.FF...FF.F...F.FF.FFF..            [ 92%]
tests/test_vacancy_operations_coordinator.py ...........          [ 96%]
tests/test_vacancy_search_handler.py ......                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestCachedAPI.test_cached_api_initialization ______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f36059cbd90>
mock_file_cache = <MagicMock name='FileCache' id='139869978173200'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_initialization(self, mock_file_cache):
        """Тест инициализации CachedAPI"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:44: TypeError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f36059d4390>
mock_file_cache = <MagicMock name='FileCache' id='139869977885520'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_with_cache_manager(self, mock_file_cache):
        """Тест CachedAPI с кэш менеджером"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:54: TypeError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f36059d49d0>
mock_file_cache = <MagicMock name='FileCache' id='139869978332304'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_abstract_methods(self, mock_file_cache):
        """Тест реализации абстрактных методов CachedAPI"""
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:60: TypeError
_________________ TestCachedAPI.test_cache_integration __________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f36059d5090>
mock_file_cache = <MagicMock name='FileCache' id='139869973267664'>

    @patch("src.utils.cache.FileCache")
    def test_cache_integration(self, mock_file_cache):
        """Тест интеграции с кэшем"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None
        mock_cache_instance.set.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:78: TypeError
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7f36059d5710>
mock_file_cache = <MagicMock name='FileCache' id='139869977884752'>

    @patch("src.utils.cache.FileCache")
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:97: TypeError
_________ TestCachedAPIEdgeCases.test_cached_api_empty_response _________

self = <workspace.tests.test_cached_api.TestCachedAPIEdgeCases object at 0x7f36059d5f50>
mock_file_cache = <MagicMock name='FileCache' id='139869973220112'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_empty_response(self, mock_file_cache):
        """Тест обработки пустого ответа"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:118: TypeError
___________ TestCachedAPIEdgeCases.test_cached_api_cache_miss ___________

self = <workspace.tests.test_cached_api.TestCachedAPIEdgeCases object at 0x7f36059d6590>
mock_file_cache = <MagicMock name='FileCache' id='139869978094608'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_cache_miss(self, mock_file_cache):
        """Тест кэш-промаха"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None  # Кэш-промах
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:130: TypeError
___________ TestCachedAPIEdgeCases.test_cached_api_cache_hit ____________

self = <workspace.tests.test_cached_api.TestCachedAPIEdgeCases object at 0x7f36059d6c10>
mock_file_cache = <MagicMock name='FileCache' id='139869973277648'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_cache_hit(self, mock_file_cache):
        """Тест кэш-попадания"""
        cached_data = [
            Vacancy("123", "Python Developer", "https://test.com", "test_source")
        ]
    
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = cached_data
        mock_file_cache.return_value = mock_cache_instance
    
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:145: TypeError
_____________ TestCachedAPIHelpers.test_make_request_method _____________

self = <workspace.tests.test_cached_api.TestCachedAPIHelpers object at 0x7f36059d7450>
mock_file_cache = <MagicMock name='FileCache' id='139869978110352'>

    @patch("src.utils.cache.FileCache")
    def test_make_request_method(self, mock_file_cache):
        """Тест метода _make_request"""
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:158: TypeError
____________ TestCachedAPIHelpers.test_parse_response_method ____________

self = <workspace.tests.test_cached_api.TestCachedAPIHelpers object at 0x7f36059d7a90>
mock_file_cache = <MagicMock name='FileCache' id='139869978141008'>

    @patch("src.utils.cache.FileCache")
    def test_parse_response_method(self, mock_file_cache):
        """Тест метода _parse_response"""
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:166: TypeError
___________ TestCachedAPIHelpers.test_cached_api_inheritance ____________

self = <workspace.tests.test_cached_api.TestCachedAPIHelpers object at 0x7f36059dc150>
mock_file_cache = <MagicMock name='FileCache' id='139870025964688'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_inheritance(self, mock_file_cache):
        """Тест наследования от CachedAPI"""
>       api = ConcreteCachedAPI()
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_cached_api.py:175: TypeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f3604509f50>
mock_paginator = <MagicMock name='Paginator' id='139869973916368'>
mock_api_config = <MagicMock name='APIConfig' id='139869973707984'>
mock_cache = <MagicMock name='FileCache' id='139869978110096'>
mock_connector = <MagicMock name='APIConnector' id='139869973222864'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_vacancies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения вакансий"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
        mock_connector_instance.get.return_value = {"objects": [], "total": 0}
    
        mock_paginator_instance = Mock()
        mock_paginator_instance.items = []
        mock_paginator_instance.found = 0
        mock_paginator.return_value = mock_paginator_instance
    
        api = SuperJobAPI()
    
        # Мокируем внутренние методы, чтобы избежать реальных запросов
>       with patch.object(api, '_get_vacancies_from_api', return_value=[]):

tests/test_sj_api.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3604113990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f360622b210> does not have the attribute '_get_vacancies_from_api'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSuperJobAPI.test_get_companies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f360450a410>
mock_paginator = <MagicMock name='Paginator' id='139869973700624'>
mock_api_config = <MagicMock name='APIConfig' id='139869973693200'>
mock_cache = <MagicMock name='FileCache' id='139869973208080'>
mock_connector = <MagicMock name='APIConnector' id='139869973829008'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_companies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения компаний"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
        mock_connector_instance.get.return_value = {"objects": [], "total": 0}
    
        api = SuperJobAPI()
    
        # Мокируем метод получения компаний
>       with patch.object(api, '_get_companies_from_api', return_value=[]):

tests/test_sj_api.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f36041ac890>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36041ae650> does not have the attribute '_get_companies_from_api'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPI.test_parse_vacancy_data ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f360450b050>
mock_paginator = <MagicMock name='Paginator' id='139870024539920'>
mock_api_config = <MagicMock name='APIConfig' id='139869978139152'>
mock_cache = <MagicMock name='FileCache' id='139869973811280'>
mock_connector = <MagicMock name='APIConnector' id='139869973813904'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_parse_vacancy_data(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест парсинга данных вакансии"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        api = SuperJobAPI()
    
        # Тестовые данные вакансии
        vacancy_data = {
            "id": 123,
            "profession": "Python Developer",
            "link": "https://superjob.ru/vacancy/123",
            "payment_from": 100000,
            "payment_to": 150000,
            "currency": "rub",
            "firm": {"title": "Test Company"}
        }
    
        # Мокируем парсер
>       with patch('src.api_modules.sj_api.SJParser') as mock_parser:

tests/test_sj_api.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f36041aa190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.sj_api' from '/home/runner/workspace/tests/../src/api_modules/sj_api.py'> does not have the attribute 'SJParser'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSuperJobAPI.test_api_request_handling _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7f360450bf10>
mock_paginator = <MagicMock name='Paginator' id='139869973187792'>
mock_api_config = <MagicMock name='APIConfig' id='139869973767568'>
mock_cache = <MagicMock name='FileCache' id='139870023833488'>
mock_connector = <MagicMock name='APIConnector' id='139869978066768'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_api_request_handling(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест обработки API запросов"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        mock_connector_instance = Mock()
        mock_connector_instance.get.return_value = {"objects": [], "total": 0}
        mock_connector.return_value = mock_connector_instance
    
        api = SuperJobAPI()
    
        # Проверяем что API может обрабатывать запросы
        assert hasattr(api, 'get_vacancies')
    
        # Тестируем без реальных запросов
>       with patch.object(api, '_get_vacancies_from_api', return_value=[]):

tests/test_sj_api.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f360651cad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36045b4d90> does not have the attribute '_get_vacancies_from_api'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSuperJobAPIEdgeCases.test_empty_query_handling ___________

self = <workspace.tests.test_sj_api.TestSuperJobAPIEdgeCases object at 0x7f360450ab50>
mock_paginator = <MagicMock name='Paginator' id='139869977919120'>
mock_api_config = <MagicMock name='APIConfig' id='139870038543696'>
mock_cache = <MagicMock name='FileCache' id='139869969237456'>
mock_connector = <MagicMock name='APIConnector' id='139869977971088'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_empty_query_handling(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест обработки пустого запроса"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        api = SuperJobAPI()
    
>       with patch.object(api, '_get_vacancies_from_api', return_value=[]):

tests/test_sj_api.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f36071fb250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f3604591b10> does not have the attribute '_get_vacancies_from_api'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSuperJobAPIEdgeCases.test_large_result_set _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPIEdgeCases object at 0x7f3604508510>
mock_paginator = <MagicMock name='Paginator' id='139869973643664'>
mock_api_config = <MagicMock name='APIConfig' id='139869973655056'>
mock_cache = <MagicMock name='FileCache' id='139869973653520'>
mock_connector = <MagicMock name='APIConnector' id='139869973762832'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_large_result_set(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест обработки большого набора результатов"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        # Имитируем большой набор данных
        mock_paginator_instance = Mock()
        mock_paginator_instance.items = [{"id": i, "profession": f"Job {i}"} for i in range(100)]
        mock_paginator_instance.found = 1000
        mock_paginator.return_value = mock_paginator_instance
    
        api = SuperJobAPI()
    
>       with patch.object(api, '_get_vacancies_from_api', return_value=mock_paginator_instance.items):

tests/test_sj_api.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3604161410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36041615d0> does not have the attribute '_get_vacancies_from_api'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSuperJobAPIHelpers.test_api_response_parsing ____________

self = <workspace.tests.test_sj_api.TestSuperJobAPIHelpers object at 0x7f3604509c10>
mock_paginator = <MagicMock name='Paginator' id='139869969617360'>
mock_api_config = <MagicMock name='APIConfig' id='139869969613968'>
mock_cache = <MagicMock name='FileCache' id='139869973296400'>
mock_connector = <MagicMock name='APIConnector' id='139869973250832'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_api_response_parsing(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест парсинга ответа API"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        api = SuperJobAPI()
    
        # Тестируем парсинг ответа
        test_response = {
            "objects": [
                {"id": 123, "profession": "Python Developer"},
                {"id": 124, "profession": "Java Developer"}
            ],
            "total": 2
        }
    
        # Мокируем методы парсинга
>       with patch('src.api_modules.sj_api.SJParser') as mock_parser:

tests/test_sj_api.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3604122490>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.sj_api' from '/home/runner/workspace/tests/../src/api_modules/sj_api.py'> does not have the attribute 'SJParser'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f360498ce50>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary_dict = {
            "from": 100000,
            "to": 150000,
            "currency": "RUR"
        }
        employer_dict = {"name": "Test Company", "id": "123"}
    
        vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary_dict,
            employer=employer_dict,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость",
        )
    
        formatter = VacancyFormatter()
        result = formatter.format_vacancy_info(vacancy)
    
        assert "Python Developer" in result
        assert "Test Company" in result
        # Проверяем отформатированные числа
>       assert "100 000" in result or "150 000" in result
E       AssertionError: assert ('100 000' in 'ID: 123\nНазвание: Python Developer\nКомпания: Test Company\nЗарплата: от 100,000 до 150,000 руб. в месяц\nОпыт: От 1 года до 3 лет\nЗанятость: Полная занятость\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123' or '150 000' in 'ID: 123\nНазвание: Python Developer\nКомпания: Test Company\nЗарплата: от 100,000 до 150,000 руб. в месяц\nОпыт: От 1 года до 3 лет\nЗанятость: Полная занятость\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123')

tests/test_vacancy_formatter.py:123: AssertionError
______ TestVacancyFormatter.test_format_vacancy_with_salary_object ______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7f360498d650>

    def test_format_vacancy_with_salary_object(self):
        """Тест форматирования вакансии с объектом Salary"""
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f36045f6860>
salary_data = <src.utils.salary.Salary object at 0x7f36045f75e0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
________________ TestVacancy.test_vacancy_initialization ________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f360451f690>

    def test_vacancy_initialization(self):
        """Тест инициализации вакансии"""
        vacancy = Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
>       assert vacancy.vacancy_id == "123"
E       AssertionError: assert '8983aa4d-1ad...-f43bdff0beb6' == '123'
E         
E         - 123
E         + 8983aa4d-1ada-46be-aaac-f43bdff0beb6

tests/test_vacancy_models.py:72: AssertionError
_________________ TestVacancy.test_vacancy_with_salary __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f36049a7a10>

    def test_vacancy_with_salary(self):
        """Тест создания вакансии с зарплатой"""
        # Используем правильные параметры для Salary
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_models.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3604169960>
salary_data = <src.utils.salary.Salary object at 0x7f3603d7f7c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f360498f210>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
        vacancy1 = TestableVacancy("123", "Python Developer", "https://test.com", "hh.ru")
        vacancy2 = TestableVacancy("123", "Python Developer", "https://test.com", "hh.ru")
        vacancy3 = TestableVacancy("124", "Java Developer", "https://test2.com", "hh.ru")
    
>       assert vacancy1 == vacancy2
E       AssertionError: assert Vacancy(id=922cc30e-c872-4fbe-80e3-2ea7f79d3b03, title='123', source='unknown') == Vacancy(id=df3abbfb-bf3c-4976-a37e-31149004ca7a, title='123', source='unknown')

tests/test_vacancy_models.py:113: AssertionError
_____________________ TestVacancy.test_vacancy_hash _____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f360498e0d0>

    def test_vacancy_hash(self):
        """Тест хэширования вакансий"""
        vacancy1 = TestableVacancy("123", "Python Developer", "https://test.com", "hh.ru")
        vacancy2 = TestableVacancy("123", "Python Developer", "https://test.com", "hh.ru")
    
>       assert hash(vacancy1) == hash(vacancy2)
E       AssertionError: assert -4985188028546871695 == 7028772502792966961
E        +  where -4985188028546871695 = hash(Vacancy(id=b2983426-9f33-4bbf-b5bf-8f1722694ba7, title='123', source='unknown'))
E        +  and   7028772502792966961 = hash(Vacancy(id=1d7f0671-1bda-4f15-9734-498418e696e8, title='123', source='unknown'))

tests/test_vacancy_models.py:121: AssertionError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f3604568250>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        # Создаем зарплату с правильными параметрами
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_models.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3603d12500>
salary_data = <src.utils.salary.Salary object at 0x7f3603d124a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ TestVacancy.test_vacancy_minimal_data _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f360456a910>

    def test_vacancy_minimal_data(self):
        """Тест создания вакансии с минимальными данными"""
        vacancy = Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
>       assert vacancy.vacancy_id == "123"
E       AssertionError: assert '965fc5d1-787...-6d59ac5bbc9d' == '123'
E         
E         - 123
E         + 965fc5d1-787d-465b-ae4f-6d59ac5bbc9d

tests/test_vacancy_models.py:173: AssertionError
______________ TestVacancy.test_vacancy_salary_properties _______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f36049229d0>

    def test_vacancy_salary_properties(self):
        """Тест свойств зарплаты вакансии"""
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_models.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3604169720>
salary_data = <src.utils.salary.Salary object at 0x7f36049aa980>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ TestVacancy.test_vacancy_source_formatting _______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7f36049037d0>

    def test_vacancy_source_formatting(self):
        """Тест форматирования источника вакансии"""
        hh_vacancy = TestableVacancy("123", "Python Developer", "https://test.com", "hh.ru")
>       assert hh_vacancy.get_formatted_source() == "HH.RU"
E       AssertionError: assert 'UNKNOWN' == 'HH.RU'
E         
E         - HH.RU
E         + UNKNOWN

tests/test_vacancy_models.py:255: AssertionError
____________ TestVacancyEdgeCases.test_vacancy_empty_fields _____________

self = <workspace.tests.test_vacancy_models.TestVacancyEdgeCases object at 0x7f3604901850>

    def test_vacancy_empty_fields(self):
        """Тест вакансии с пустыми полями"""
        vacancy = Vacancy("", "", "", "")
>       assert vacancy.vacancy_id == ""
E       AssertionError: assert '4466d689-3a3...-b140e32255a0' == ''
E         
E         + 4466d689-3a38-4550-a85c-b140e32255a0

tests/test_vacancy_models.py:281: AssertionError
_____________ TestVacancyEdgeCases.test_vacancy_none_salary _____________

self = <workspace.tests.test_vacancy_models.TestVacancyEdgeCases object at 0x7f3604903c50>

    def test_vacancy_none_salary(self):
        """Тест вакансии без зарплаты"""
>       vacancy = Vacancy("123", "Python Developer", "https://test.com", "hh.ru", salary=None)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.__init__() got multiple values for argument 'salary'

tests/test_vacancy_models.py:288: TypeError
___________ TestVacancyEdgeCases.test_vacancy_with_all_fields ___________

self = <workspace.tests.test_vacancy_models.TestVacancyEdgeCases object at 0x7f36049024d0>

    def test_vacancy_with_all_fields(self):
        """Тест вакансии со всеми полями"""
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
        employer = {"name": "Test Company", "id": "123"}
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary,
            employer=employer,
            description="Test description",
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость",
            published_at=datetime.now()
        )

tests/test_vacancy_models.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3603d138e0>
salary_data = <src.utils.salary.Salary object at 0x7f36045f5360>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_______ TestVacancyDataTransformation.test_vacancy_dict_roundtrip _______

self = <workspace.tests.test_vacancy_models.TestVacancyDataTransformation object at 0x7f3604902850>

    def test_vacancy_dict_roundtrip(self):
        """Тест преобразования вакансии в словарь и обратно"""
        # Создаем оригинальную вакансию
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       original_vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_models.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3603df7280>
salary_data = <src.utils.salary.Salary object at 0x7f3604169ba0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
___ TestVacancyDataTransformation.test_vacancy_dict_with_complex_data ___

self = <workspace.tests.test_vacancy_models.TestVacancyDataTransformation object at 0x7f3604903490>

    def test_vacancy_dict_with_complex_data(self):
        """Тест преобразования сложных данных в словарь"""
        employer = {"name": "Test Company", "id": "123", "trusted": True}
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com",
            source="hh.ru",
            salary=salary,
            employer=employer,
            description="Long description",
            area="Москва"
        )

tests/test_vacancy_models.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7f3603df4160>
salary_data = <src.utils.salary.Salary object at 0x7f3603df4880>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================== warnings summary ============================
tests/test_sj_api.py:14
  /home/runner/workspace/tests/test_sj_api.py:14: PytestCollectionWarning: cannot collect test class 'TestableSuperjobAPI' because it has a __init__ constructor (from: tests/test_sj_api.py)
    class TestableSuperjobAPI(SuperJobAPI):

tests/test_vacancy_display_handler.py:30
  /home/runner/workspace/tests/test_vacancy_display_handler.py:30: PytestCollectionWarning: cannot collect test class 'TestableVacancyDisplayHandler' because it has a __init__ constructor (from: tests/test_vacancy_display_handler.py)
    class TestableVacancyDisplayHandler(VacancyDisplayHandler):

tests/test_vacancy_formatter.py:16
  /home/runner/workspace/tests/test_vacancy_formatter.py:16: PytestCollectionWarning: cannot collect test class 'TestableVacancyFormatter' because it has a __init__ constructor (from: tests/test_vacancy_formatter.py)
    class TestableVacancyFormatter(VacancyFormatter):

tests/test_vacancy_models.py:18
  /home/runner/workspace/tests/test_vacancy_models.py:18: PytestCollectionWarning: cannot collect test class 'TestableVacancy' because it has a __init__ constructor (from: tests/test_vacancy_models.py)
    class TestableVacancy(Vacancy):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== short test summary info ========================
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_initialization - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_with_cache_manager - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_abstract_methods - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPI::test_cache_integration - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPI::test_clear_cache_method - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIEdgeCases::test_cached_api_empty_response - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIEdgeCases::test_cached_api_cache_miss - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIEdgeCases::test_cached_api_cache_hit - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIHelpers::test_make_request_method - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIHelpers::test_parse_response_method - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_cached_api.py::TestCachedAPIHelpers::test_cached_api_inheritance - TypeError: Can't instantiate abstract class ConcreteCachedAPI with a...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancies_success - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_companies_success - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_parse_vacancy_data - AttributeError: <module 'src.api_modules.sj_api' from '/home/runner/...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_api_request_handling - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36...
FAILED tests/test_sj_api.py::TestSuperJobAPIEdgeCases::test_empty_query_handling - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36...
FAILED tests/test_sj_api.py::TestSuperJobAPIEdgeCases::test_large_result_set - AttributeError: <src.api_modules.sj_api.SuperJobAPI object at 0x7f36...
FAILED tests/test_sj_api.py::TestSuperJobAPIHelpers::test_api_response_parsing - AttributeError: <module 'src.api_modules.sj_api' from '/home/runner/...
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_full - AssertionError: assert ('100 000' in 'ID: 123\nНазвание: Python Deve...
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_with_salary_object - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_initialization - AssertionError: assert '8983aa4d-1ad...-f43bdff0beb6' == '123'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_with_salary - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison - AssertionError: assert Vacancy(id=922cc30e-c872-4fbe-80e3-2ea7f79d3b...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_hash - AssertionError: assert -4985188028546871695 == 7028772502792966961
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_to_dict - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_minimal_data - AssertionError: assert '965fc5d1-787...-6d59ac5bbc9d' == '123'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_salary_properties - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_source_formatting - AssertionError: assert 'UNKNOWN' == 'HH.RU'
FAILED tests/test_vacancy_models.py::TestVacancyEdgeCases::test_vacancy_empty_fields - AssertionError: assert '4466d689-3a3...-b140e32255a0' == ''
FAILED tests/test_vacancy_models.py::TestVacancyEdgeCases::test_vacancy_none_salary - TypeError: Vacancy.__init__() got multiple values for argument 'salary'
FAILED tests/test_vacancy_models.py::TestVacancyEdgeCases::test_vacancy_with_all_fields - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancyDataTransformation::test_vacancy_dict_roundtrip - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancyDataTransformation::test_vacancy_dict_with_complex_data - AttributeError: 'Salary' object has no attribute 'get'
============== 33 failed, 308 passed, 4 warnings in 3.88s ===============
~/workspace$ 