~/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1301 items / 1 error                                                     

====================================== ERRORS ======================================
____________________ ERROR collecting tests/test_api_modules.py ____________________
tests/test_api_modules.py:235: in <module>
    class TestAPIModules:
tests/test_api_modules.py:239: in TestAPIModules
    def base_api(self) -> BaseAPI:
                          ^^^^^^^
E   NameError: name 'BaseAPI' is not defined
============================= short test summary info ==============================
ERROR tests/test_api_modules.py - NameError: name 'BaseAPI' is not defined
!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!
================================= 1 error in 1.54s =================================
~/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1330 items                                                               

tests/test_abstract.py ........                                              [  0%]
tests/test_abstract_db_manager.py ....                                       [  0%]
tests/test_abstract_filter_complete.py ........F                             [  1%]
tests/test_api_complete.py ...................                               [  3%]
tests/test_api_config.py ....                                                [  3%]
tests/test_api_data_filter.py ......                                         [  3%]
tests/test_api_fixes.py .......                                              [  4%]
tests/test_api_modules.py EEFFFFEEEFFFFFFFFFFFFEFFEFFFF                      [  6%]
tests/test_api_modules_consolidated.py ....                                  [  6%]
tests/test_app_config.py .........                                           [  7%]
tests/test_base_api.py ...............                                       [  8%]
tests/test_base_formatter.py .EEEEEEEF.                                      [  9%]
tests/test_base_formatter_complete.py ..............................         [ 11%]
tests/test_base_parser.py ......                                             [ 12%]
tests/test_cache.py ......................                                   [ 13%]
tests/test_cached_api.py ....                                                [ 13%]
tests/test_cached_api_complete.py ................                           [ 15%]
tests/test_components_fixed.py ...                                           [ 15%]
tests/test_comprehensive_fixed.py .....                                      [ 15%]
tests/test_config_consolidated.py .....                                      [ 16%]
tests/test_config_missing_coverage.py ssssssssss.............ss...           [ 18%]
tests/test_config_modules_consolidated.py ......                             [ 18%]
tests/test_console_interface.py ......                                       [ 19%]
tests/test_core_functionality_consolidated.py .....                          [ 19%]
tests/test_core_modules_comprehensive.py ........                            [ 20%]
tests/test_data_normalizers_comprehensive.py ............................    [ 22%]
tests/test_database_connection.py ........                                   [ 22%]
tests/test_db_config.py .....                                                [ 23%]
tests/test_db_manager.py .................                                   [ 24%]
tests/test_decorators.py .......                                             [ 25%]
tests/test_description_parser.py ..........                                  [ 25%]
tests/test_env_loader.py ................                                    [ 26%]
tests/test_filter_utils.py ssssss                                            [ 27%]
tests/test_get_api_complete.py FEEEEEEEEEEEEEEEFFEE                          [ 28%]
tests/test_hh_api_complete.py .................                              [ 30%]
tests/test_hh_api_config.py .....                                            [ 30%]
tests/test_hh_parser.py ........                                             [ 31%]
tests/test_integration.py .............                                      [ 32%]
tests/test_interfaces.py Fss                                                 [ 32%]
tests/test_main_application_interface.py F.F                                 [ 32%]
tests/test_main_application_interface_complete.py ..FFFFF...F...F.F..F.F.FFF [ 34%]
FF.FF.F.FFF.....F                                                            [ 35%]
tests/test_main_consolidated.py .........                                    [ 36%]
tests/test_menu_manager.py ..........                                        [ 37%]
tests/test_missing_components.py .........                                   [ 37%]
tests/test_missing_coverage_components.py ......F.....FFF..                  [ 39%]
tests/test_models_fixed.py ...                                               [ 39%]
tests/test_paginator.py ......                                               [ 39%]
tests/test_parsers_complete.py sss.sss.ssss                                  [ 40%]
tests/test_repository_fixed.py ..                                            [ 40%]
tests/test_salary_fixed.py ...........                                       [ 41%]
tests/test_salary_utils.py ......................                            [ 43%]
tests/test_search_utils.py ............................                      [ 45%]
tests/test_search_utils_complete.py .................FF.FFFFFFF............. [ 48%]
......                                                                       [ 49%]
tests/test_services_consolidated.py ....                                     [ 49%]
tests/test_services_storage_consolidated.py ..........                       [ 50%]
tests/test_simple_db_adapter.py .........                                    [ 50%]
tests/test_sj_api.py ..............                                          [ 51%]
tests/test_sj_api_complete.py .............F....                             [ 53%]
tests/test_sj_api_config.py .....                                            [ 53%]
tests/test_sj_parser.py ........                                             [ 54%]
tests/test_sj_parser_complete.py ssssssssssssss                              [ 55%]
tests/test_source_manager.py .................                               [ 56%]
tests/test_source_selector.py .................                              [ 57%]
tests/test_storage_abstractions.py ssssssss                                  [ 58%]
tests/test_storage_complete.py .............                                 [ 59%]
tests/test_storage_components_complete.py ...F.FF....FF....EEEEE.....FF      [ 61%]
tests/test_storage_factory.py ........                                       [ 62%]
tests/test_storage_modules_consolidated.py .F..                              [ 62%]
tests/test_target_companies.py .....                                         [ 62%]
tests/test_typed_data_processor.py ................                          [ 63%]
tests/test_ui_components_complete.py sssssssssssssssssssssssssssss......sss  [ 66%]
tests/test_ui_components_extended.py .F................                      [ 68%]
tests/test_ui_config.py .......................                              [ 69%]
tests/test_ui_helpers_comprehensive.py ..................................... [ 72%]
..                                                                           [ 72%]
tests/test_ui_helpers_extended.py ........................................   [ 75%]
tests/test_ui_modules_consolidated.py .....                                  [ 76%]
tests/test_ui_navigation.py ......................                           [ 77%]
tests/test_ui_navigation_complete.py ..s..                                   [ 78%]
tests/test_ui_navigation_comprehensive.py ......                             [ 78%]
tests/test_ui_navigation_extended.py .......FF..........................     [ 81%]
tests/test_unified_api.py ................F...F.                             [ 83%]
tests/test_unified_api_complete.py ......F......................             [ 85%]
tests/test_unified_api_fixed.py ...                                          [ 85%]
tests/test_user_interface.py ...............                                 [ 86%]
tests/test_user_interface_consolidated.py F.F                                [ 86%]
tests/test_user_interface_fixed.py ...                                       [ 86%]
tests/test_utils_consolidated.py .....                                       [ 87%]
tests/test_utils_ui_consolidated.py ......                                   [ 87%]
tests/test_vacancy_abstractions.py .................                         [ 89%]
tests/test_vacancy_display_handler.py F..................                    [ 90%]
tests/test_vacancy_formatter.py ........                                     [ 91%]
tests/test_vacancy_models_complete.py F...                                   [ 91%]
tests/test_vacancy_models_consolidated.py ....                               [ 91%]
tests/test_vacancy_operations.py ......                                      [ 92%]
tests/test_vacancy_operations_coordinator.py ...........................     [ 94%]
tests/test_vacancy_operations_coordinator_complete.py F..................... [ 95%]
                                                                             [ 95%]
tests/test_vacancy_processing_coordinator.py .............                   [ 96%]
tests/test_vacancy_repository.py F........                                   [ 97%]
tests/test_vacancy_stats.py ............                                     [ 98%]
tests/test_vacancy_stats_fixed.py .........                                  [ 99%]
tests/test_vacancy_validator.py ............                                 [100%]

====================================== ERRORS ======================================
__________ ERROR at setup of TestAPIModules.test_base_api_initialization ___________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6ce50>

    @pytest.fixture
    def base_api(self) -> BaseJobAPI:
        """Фикстура базового API"""
>       return BaseAPI()
               ^^^^^^^
E       NameError: name 'BaseAPI' is not defined

tests/test_api_modules.py:241: NameError
______________ ERROR at setup of TestAPIModules.test_base_api_methods ______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6e0d0>

    @pytest.fixture
    def base_api(self) -> BaseJobAPI:
        """Фикстура базового API"""
>       return BaseAPI()
               ^^^^^^^
E       NameError: name 'BaseAPI' is not defined

tests/test_api_modules.py:241: NameError
_________ ERROR at setup of TestAPIModules.test_cached_api_initialization __________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6ea10>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746ef82e90>

    @pytest.fixture
    def cached_api(self, hh_api) -> CachedAPI:
        """Фикстура кэшированного API"""
>       return CachedAPI(hh_api)
               ^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_modules.py:261: TypeError
______ ERROR at setup of TestAPIModules.test_cached_api_caching_functionality ______

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6f290>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746db76b50>

    @pytest.fixture
    def cached_api(self, hh_api) -> CachedAPI:
        """Фикстура кэшированного API"""
>       return CachedAPI(hh_api)
               ^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_modules.py:261: TypeError
___________ ERROR at setup of TestAPIModules.test_cached_api_clear_cache ___________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6f8d0>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746def62d0>

    @pytest.fixture
    def cached_api(self, hh_api) -> CachedAPI:
        """Фикстура кэшированного API"""
>       return CachedAPI(hh_api)
               ^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_modules.py:261: TypeError
_____________ ERROR at setup of TestAPIModules.test_api_error_handling _____________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5d350>

    @pytest.fixture
    def base_api(self) -> BaseJobAPI:
        """Фикстура базового API"""
>       return BaseAPI()
               ^^^^^^^
E       NameError: name 'BaseAPI' is not defined

tests/test_api_modules.py:241: NameError
__________ ERROR at setup of TestAPIModules.test_api_caching_performance ___________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4e190>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746ef918d0>

    @pytest.fixture
    def cached_api(self, hh_api) -> CachedAPI:
        """Фикстура кэшированного API"""
>       return CachedAPI(hh_api)
               ^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_modules.py:261: TypeError
______ ERROR at setup of TestBaseFormatter.test_concrete_implementation_works ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee43e50>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
_____________ ERROR at setup of TestBaseFormatter.test_format_vacancy ______________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee401d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_vacancies_list __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee40590>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
___ ERROR at setup of TestBaseFormatter.test_format_vacancy_with_missing_fields ____

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746efcfc90>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_empty_vacancies_list _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee08410>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_vacancy_with_none _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee085d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
_____ ERROR at setup of TestBaseFormatter.test_format_vacancy_with_empty_dict ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee09e90>

    @pytest.fixture
    def formatter(self):
        """Фикстура форматера"""
        if not BASE_FORMATTER_AVAILABLE:
            return Mock()
>       return ConcreteFormatter()
               ^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFormatter with abstract methods clean_html_tags, format_company_name, format_currency, format_date, format_employment_type, format_experience, format_number, format_salary, format_schedule, format_text, format_vacancy_info

tests/test_base_formatter.py:42: TypeError
__________ ERROR at setup of TestGetAPIComplete.test_init_default_values ___________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed8d50>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
____________ ERROR at setup of TestGetAPIComplete.test_session_creation ____________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed9310>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
__________ ERROR at setup of TestGetAPIComplete.test_make_request_success __________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed9910>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
________ ERROR at setup of TestGetAPIComplete.test_make_request_http_error _________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed9ed0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
_____ ERROR at setup of TestGetAPIComplete.test_make_request_connection_error ______

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eeda490>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
__________ ERROR at setup of TestGetAPIComplete.test_make_request_timeout __________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eedaa50>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
_____ ERROR at setup of TestGetAPIComplete.test_make_request_json_decode_error _____

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eedb010>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
_____ ERROR at setup of TestGetAPIComplete.test_make_request_generic_exception _____

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eedb5d0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
_____ ERROR at setup of TestGetAPIComplete.test_get_vacancies_not_implemented ______

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eedbbd0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
____ ERROR at setup of TestGetAPIComplete.test_make_request_with_custom_timeout ____

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed01d0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
______ ERROR at setup of TestGetAPIComplete.test_make_request_empty_response _______

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed0790>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
___ ERROR at setup of TestGetAPIComplete.test_make_request_status_code_handling ____

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed0e10>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
___________ ERROR at setup of TestGetAPIComplete.test_session_attributes ___________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eeda7d0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
______ ERROR at setup of TestGetAPIComplete.test_make_request_params_handling ______

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed0c50>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
________ ERROR at setup of TestGetAPIComplete.test_make_request_none_params ________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed13d0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
_______ ERROR at setup of TestGetAPIComplete.test_make_request_error_logging _______

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed1dd0>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
___________ ERROR at setup of TestGetAPIComplete.test_method_signatures ____________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed2150>

    @pytest.fixture
    def get_api(self):
        """Создание экземпляра GetAPI"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
>       return GetAPI()
               ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:33: NameError
________________ ERROR at setup of TestVacancyRepository.test_init _________________

self = <tests.test_storage_components_complete.TestVacancyRepository object at 0x7f746eb40b10>

    @pytest.fixture
    def vacancy_repository(self):
        """Фикстура репозитория вакансий"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            return Mock()
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           return VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:319: TypeError
_____________ ERROR at setup of TestVacancyRepository.test_add_vacancy _____________

self = <tests.test_storage_components_complete.TestVacancyRepository object at 0x7f746eb41150>

    @pytest.fixture
    def vacancy_repository(self):
        """Фикстура репозитория вакансий"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            return Mock()
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           return VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:319: TypeError
____________ ERROR at setup of TestVacancyRepository.test_get_vacancies ____________

self = <tests.test_storage_components_complete.TestVacancyRepository object at 0x7f746eb417d0>

    @pytest.fixture
    def vacancy_repository(self):
        """Фикстура репозитория вакансий"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            return Mock()
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           return VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:319: TypeError
_____________ ERROR at setup of TestVacancyRepository.test_find_by_id ______________

self = <tests.test_storage_components_complete.TestVacancyRepository object at 0x7f746eb41f10>

    @pytest.fixture
    def vacancy_repository(self):
        """Фикстура репозитория вакансий"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            return Mock()
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           return VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:319: TypeError
___________ ERROR at setup of TestVacancyRepository.test_delete_vacancy ____________

self = <tests.test_storage_components_complete.TestVacancyRepository object at 0x7f746eb42610>

    @pytest.fixture
    def vacancy_repository(self):
        """Фикстура репозитория вакансий"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            return Mock()
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           return VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:319: TypeError
===================================== FAILURES =====================================
__________________ TestAbstractFilterIntegration.test_edge_cases ___________________

self = <tests.test_abstract_filter_complete.TestAbstractFilterIntegration object at 0x7f746f340750>

    def test_edge_cases(self):
        """Тест граничных случаев"""
        if not ABSTRACT_FILTER_AVAILABLE:
            pytest.skip("AbstractDataFilter not available")
    
        filter_instance = ConcreteDataFilter()
    
        # Тест с нулевой зарплатой
        test_data = [{'id': 1, 'salary': {'from': 0}}]
        result = filter_instance.filter_by_salary(test_data, min_salary=0)
        assert len(result) == 1
    
        # Тест с отрицательными значениями
        test_data = [{'id': 1, 'salary': {'from': -1000}}]
        result = filter_instance.filter_by_salary(test_data, min_salary=0)
>       assert len(result) == 0
E       AssertionError: assert 1 == 0
E        +  where 1 = len([{'id': 1, 'salary': {'from': -1000}}])

tests/test_abstract_filter_complete.py:192: AssertionError
____________________ TestAPIModules.test_hh_api_initialization _____________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6e7d0>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746eed2350>

    def test_hh_api_initialization(self, hh_api):
        """Тест инициализации HeadHunter API"""
        assert hh_api is not None
>       assert hh_api.base_url == "https://api.hh.ru"
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute 'base_url'

tests/test_api_modules.py:283: AttributeError
___________________ TestAPIModules.test_hh_api_search_vacancies ____________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6d310>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7f746ef26a90>

    def test_hh_api_search_vacancies(self, hh_api):
        """Тест поиска вакансий в HeadHunter API"""
>       results = hh_api.search_vacancies("Python", page=0, per_page=5)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:288: AttributeError
____________________ TestAPIModules.test_sj_api_initialization _____________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6de10>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f746e8c25d0>

    def test_sj_api_initialization(self, sj_api):
        """Тест инициализации SuperJob API"""
        assert sj_api is not None
>       assert sj_api.base_url == "https://api.superjob.ru"
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'base_url'

tests/test_api_modules.py:303: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________________ TestAPIModules.test_sj_api_search_vacancies ____________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6e550>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f746e8c46d0>

    def test_sj_api_search_vacancies(self, sj_api):
        """Тест поиска вакансий в SuperJob API"""
>       results = sj_api.search_vacancies("Java", page=0, count=3)
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:310: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestAPIModules.test_unified_api_initialization __________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6ffd0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e80ef90>

    def test_unified_api_initialization(self, unified_api):
        """Тест инициализации унифицированного API"""
        assert unified_api is not None
        assert hasattr(unified_api, 'hh_api')
        assert hasattr(unified_api, 'sj_api')
>       assert hasattr(unified_api, 'available_sources')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.unified_api.UnifiedAPI object at 0x7f746e80ef90>, 'available_sources')

tests/test_api_modules.py:360: AssertionError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestAPIModules.test_unified_api_get_available_sources _______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5fb90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746f4776d0>

    def test_unified_api_get_available_sources(self, unified_api):
        """Тест получения доступных источников"""
        sources = unified_api.get_available_sources()
    
        assert isinstance(sources, list)
>       assert "hh.ru" in sources
E       AssertionError: assert 'hh.ru' in ['hh', 'sj']

tests/test_api_modules.py:367: AssertionError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________ TestAPIModules.test_unified_api_search_single_source _______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5c210>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746efeb5d0>

    def test_unified_api_search_single_source(self, unified_api):
        """Тест поиска через один источник"""
        # Поиск только в HH
>       hh_results = unified_api.search_vacancies("Python", sources=["hh.ru"])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:374: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestAPIModules.test_unified_api_search_multiple_sources ______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5c5d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e800a90>

    def test_unified_api_search_multiple_sources(self, unified_api):
        """Тест поиска через несколько источников"""
        # Поиск во всех источниках
>       all_results = unified_api.search_vacancies("Python", sources=["all"])
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:384: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestAPIModules.test_unified_api_search_default_sources ______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5cbd0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746f477dd0>

    def test_unified_api_search_default_sources(self, unified_api):
        """Тест поиска с источниками по умолчанию"""
        # Поиск без указания источников
>       default_results = unified_api.search_vacancies("Python")
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:394: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________ TestAPIModules.test_parametrized_search_queries[Python-list] ___________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5e250>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e7c63d0>
query = 'Python', expected_type = <class 'list'>

    @pytest.mark.parametrize("query,expected_type", [
        ("Python", list),
        ("Java", list),
        ("JavaScript", list),
        ("", list)
    ])
    def test_parametrized_search_queries(self, unified_api, query, expected_type):
        """Параметризованный тест поисковых запросов"""
>       results = unified_api.search_vacancies(query)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:405: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____________ TestAPIModules.test_parametrized_search_queries[Java-list] ____________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5e310>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746df5d750>
query = 'Java', expected_type = <class 'list'>

    @pytest.mark.parametrize("query,expected_type", [
        ("Python", list),
        ("Java", list),
        ("JavaScript", list),
        ("", list)
    ])
    def test_parametrized_search_queries(self, unified_api, query, expected_type):
        """Параметризованный тест поисковых запросов"""
>       results = unified_api.search_vacancies(query)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:405: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________ TestAPIModules.test_parametrized_search_queries[JavaScript-list] _________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5e990>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746eefec90>
query = 'JavaScript', expected_type = <class 'list'>

    @pytest.mark.parametrize("query,expected_type", [
        ("Python", list),
        ("Java", list),
        ("JavaScript", list),
        ("", list)
    ])
    def test_parametrized_search_queries(self, unified_api, query, expected_type):
        """Параметризованный тест поисковых запросов"""
>       results = unified_api.search_vacancies(query)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:405: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestAPIModules.test_parametrized_search_queries[-list] ______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee5ed10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e874690>
query = '', expected_type = <class 'list'>

    @pytest.mark.parametrize("query,expected_type", [
        ("Python", list),
        ("Java", list),
        ("JavaScript", list),
        ("", list)
    ])
    def test_parametrized_search_queries(self, unified_api, query, expected_type):
        """Параметризованный тест поисковых запросов"""
>       results = unified_api.search_vacancies(query)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:405: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestAPIModules.test_parametrized_sources[hh.ru] __________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4ec50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746ee6fe90>
source = 'hh.ru'

    @pytest.mark.parametrize("source", ["hh.ru", "superjob.ru", "all"])
    def test_parametrized_sources(self, unified_api, source):
        """Параметризованный тест источников"""
>       results = unified_api.search_vacancies("Python", sources=[source])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:411: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestAPIModules.test_parametrized_sources[superjob.ru] _______________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4f010>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746f48c890>
source = 'superjob.ru'

    @pytest.mark.parametrize("source", ["hh.ru", "superjob.ru", "all"])
    def test_parametrized_sources(self, unified_api, source):
        """Параметризованный тест источников"""
>       results = unified_api.search_vacancies("Python", sources=[source])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:411: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestAPIModules.test_parametrized_sources[all] ___________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4db50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e87e1d0>
source = 'all'

    @pytest.mark.parametrize("source", ["hh.ru", "superjob.ru", "all"])
    def test_parametrized_sources(self, unified_api, source):
        """Параметризованный тест источников"""
>       results = unified_api.search_vacancies("Python", sources=[source])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:411: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________________ TestAPIModules.test_api_integration_workflow ___________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6f350>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746eeed990>

    def test_api_integration_workflow(self, unified_api):
        """Тест интеграционного рабочего процесса"""
        # Полный цикл: поиск -> получение результатов -> проверка данных
        query = "Python Developer"
>       results = unified_api.search_vacancies(query, sources=["all"])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:428: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________________ TestAPIModules.test_api_performance ________________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee6e2d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746edcaf90>

    def test_api_performance(self, unified_api):
        """Тест производительности API"""
        import time
    
        start_time = time.time()
    
        # Выполняем несколько поисковых запросов
        queries = ["Python", "Java", "JavaScript"]
        for query in queries:
>           unified_api.search_vacancies(query, sources=["hh.ru"])
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:451: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________________ TestAPIModules.test_api_memory_usage _______________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4e610>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e7e2ed0>

    def test_api_memory_usage(self, unified_api):
        """Тест использования памяти API"""
        import sys
    
        initial_refs = sys.getrefcount(unified_api)
    
        # Выполняем много запросов
        for i in range(20):
>           unified_api.search_vacancies(f"query_{i}")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:486: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________________ TestAPIModules.test_api_concurrent_requests ____________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4ec90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746e86ce50>

    def test_api_concurrent_requests(self, unified_api):
        """Тест параллельных запросов к API"""
        import threading
        import time
    
        results = []
    
        def search_worker(query):
            result = unified_api.search_vacancies(f"Python {query}")
            results.append(len(result) >= 0)  # Проверяем, что запрос прошел
    
        # Создаем несколько потоков
        threads = []
        for i in range(3):
            thread = threading.Thread(target=search_worker, args=(i,))
            threads.append(thread)
            thread.start()
    
        # Ждем завершения всех потоков
        for thread in threads:
            thread.join()
    
        # Все запросы должны завершиться успешно
        assert all(results)
>       assert len(results) == 3
E       assert 0 == 3
E        +  where 0 = len([])

tests/test_api_modules.py:517: AssertionError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________________ TestAPIModules.test_api_type_safety ________________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4e550>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746db76f90>

    def test_api_type_safety(self, unified_api):
        """Тест типобезопасности API"""
        # Проверяем типы возвращаемых значений
        sources = unified_api.get_available_sources()
        assert isinstance(sources, list)
    
>       results = unified_api.search_vacancies("Python")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules.py:525: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________________ TestAPIModules.test_import_availability ______________________

self = <tests.test_api_modules.TestAPIModules object at 0x7f746ee4f690>

    def test_import_availability(self):
        """Тест доступности импорта модулей"""
        if SRC_AVAILABLE:
            # Проверяем, что все классы импортируются корректно
            assert UnifiedAPI is not None
            assert HeadHunterAPI is not None
            assert SuperJobAPI is not None
>           assert BaseAPI is not None
                   ^^^^^^^
E           NameError: name 'BaseAPI' is not defined

tests/test_api_modules.py:538: NameError
__________________ TestBaseFormatter.test_abstract_methods_exist ___________________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f746ee08c50>

    def test_abstract_methods_exist(self):
        """Тест что абстрактные методы определены"""
        if not BASE_FORMATTER_AVAILABLE:
            pytest.skip("BaseFormatter not available")
    
        abstract_methods = BaseFormatter.__abstractmethods__
>       assert 'format_vacancy' in abstract_methods
E       AssertionError: assert 'format_vacancy' in frozenset({'clean_html_tags', 'format_company_name', 'format_currency', 'format_date', 'format_employment_type', 'format_experience', ...})

tests/test_base_formatter.py:121: AssertionError
__________________ TestGetAPIComplete.test_inheritance_structure ___________________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed8710>

    def test_inheritance_structure(self):
        """Тест структуры наследования"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
    
>       assert issubclass(GetAPI, BaseJobAPI)
                          ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:40: NameError
_____________________ TestGetAPIComplete.test_class_attributes _____________________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed1710>

    def test_class_attributes(self):
        """Тест атрибутов класса"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
    
        # Проверяем что класс имеет необходимые атрибуты
>       assert hasattr(GetAPI, '__init__')
                       ^^^^^^
E       NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:200: NameError
_______________ TestGetAPIComplete.test_abstract_method_inheritance ________________

self = <tests.test_get_api_complete.TestGetAPIComplete object at 0x7f746eed1a50>

    def test_abstract_method_inheritance(self):
        """Тест наследования абстрактных методов"""
        if not GET_API_AVAILABLE:
            pytest.skip("GetAPI not available")
    
        # Проверяем что get_vacancies является абстрактным методом
        with pytest.raises(NotImplementedError):
>           api = GetAPI()
                  ^^^^^^
E           NameError: name 'GetAPI' is not defined

tests/test_get_api_complete.py:211: NameError
_______________ TestMainApplicationInterface.test_interface_creation _______________

self = <tests.test_interfaces.TestMainApplicationInterface object at 0x7f746ece5b90>
mock_dependencies = {'api': <Mock id='140138027582672'>, 'storage': <Mock id='140138027582736'>, 'ui': <Mock id='140138027589008'>}

    def test_interface_creation(self, mock_dependencies):
        """Тест создания интерфейса"""
        if not INTERFACES_AVAILABLE:
            pytest.skip("Interfaces not available")
    
        try:
>           interface = MainApplicationInterface(**mock_dependencies)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_interfaces.py:38: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_interfaces.TestMainApplicationInterface object at 0x7f746ece5b90>
mock_dependencies = {'api': <Mock id='140138027582672'>, 'storage': <Mock id='140138027582736'>, 'ui': <Mock id='140138027589008'>}

    def test_interface_creation(self, mock_dependencies):
        """Тест создания интерфейса"""
        if not INTERFACES_AVAILABLE:
            pytest.skip("Interfaces not available")
    
        try:
            interface = MainApplicationInterface(**mock_dependencies)
            assert interface is not None
        except TypeError:
            # Если требуются другие аргументы
>           interface = MainApplicationInterface()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_interfaces.py:42: TypeError
________ TestMainApplicationInterface.test_main_application_interface_init _________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f746ece6f10>

    def test_main_application_interface_init(self):
        """Тест инициализации главного интерфейса приложения"""
        if not INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        # Создаем конкретную реализацию абстрактного класса
        class ConcreteMainApplication(MainApplicationInterface):
            def run_application(self):
                pass
    
>       interface = ConcreteMainApplication()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:33: TypeError
_ TestMainApplicationInterface.test_main_application_interface_concrete_implementation _

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f746ece7b10>

    def test_main_application_interface_concrete_implementation(self):
        """Тест конкретной реализации"""
        if not INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        class TestApplication(MainApplicationInterface):
            def run_application(self):
                return "Application started"
    
>       app = TestApplication()
              ^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:53: TypeError
________ TestMainApplicationInterfaceComplete.test_concrete_run_application ________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ecf7190>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d571390>

    def test_concrete_run_application(self, app_interface):
        """Тест конкретной реализации run_application"""
>       with patch.object(app_interface, 'start_application') as mock_start:

tests/test_main_application_interface_complete.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746d5712d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d571390> does not have the attribute 'start_application'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestMainApplicationInterfaceComplete.test_get_data_sources ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ecf7850>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746ef11310>

    def test_get_data_sources(self, app_interface):
        """Тест получения источников данных"""
        mock_sources = ["hh", "sj"]
        app_interface.data_provider.get_available_sources.return_value = mock_sources
    
>       result = app_interface.get_data_sources()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'get_data_sources'

tests/test_main_application_interface_complete.py:130: AttributeError
_________ TestMainApplicationInterfaceComplete.test_get_data_sources_error _________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ecf7690>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746e87b810>

    def test_get_data_sources_error(self, app_interface):
        """Тест обработки ошибок при получении источников"""
        app_interface.data_provider.get_available_sources.side_effect = Exception("Provider error")
    
>       result = app_interface.get_data_sources()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'get_data_sources'

tests/test_main_application_interface_complete.py:137: AttributeError
____________ TestMainApplicationInterfaceComplete.test_validate_sources ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ecf7c90>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746df3b050>

    def test_validate_sources(self, app_interface):
        """Тест валидации источников"""
        sources = ["hh", "sj"]
        app_interface.data_provider.validate_sources.return_value = sources
    
>       result = app_interface.validate_sources(sources)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'validate_sources'

tests/test_main_application_interface_complete.py:145: AttributeError
_________ TestMainApplicationInterfaceComplete.test_validate_sources_error _________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed08090>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746eee1e90>

    def test_validate_sources_error(self, app_interface):
        """Тест обработки ошибок валидации источников"""
        app_interface.data_provider.validate_sources.side_effect = Exception("Validation error")
    
>       result = app_interface.validate_sources(["invalid"])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'validate_sources'

tests/test_main_application_interface_complete.py:152: AttributeError
___________ TestMainApplicationInterfaceComplete.test_process_data_error ___________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed09450>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5d82d0>

    def test_process_data_error(self, app_interface):
        """Тест обработки ошибок при обработке данных"""
        app_interface.processor.process.side_effect = Exception("Processing error")
    
>       result = app_interface.process_data([{"id": "1"}])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:38: in process_data
    return self.processor.process(data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.process' id='140138027791632'>, args = ([{'id': '1'}],)
kwargs = {}, effect = Exception('Processing error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Processing error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
____________ TestMainApplicationInterfaceComplete.test_store_data_error ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed0aed0>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5775d0>

    def test_store_data_error(self, app_interface):
        """Тест обработки ошибок при сохранении данных"""
        app_interface.storage.save.side_effect = Exception("Storage error")
    
>       result = app_interface.store_data([{"id": "1"}])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:44: in store_data
    return self.storage.save(data)
           ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.save' id='140138027381520'>, args = ([{'id': '1'}],)
kwargs = {}, effect = Exception('Storage error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Storage error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
_________ TestMainApplicationInterfaceComplete.test_search_data_no_sources _________

self = <Mock name='mock.search' id='140138027158800'>, args = ('python',)
kwargs = {'sources': ['hh', 'sj']}, expected = call('python', sources=['hh', 'sj'])
actual = call('python', sources=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f746ddc34c0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: search('python', sources=['hh', 'sj'])
E             Actual: search('python', sources=None)

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:939: AssertionError

During handling of the above exception, another exception occurred:

self = <Mock name='mock.search' id='140138027158800'>, args = ('python',)
kwargs = {'sources': ['hh', 'sj']}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: expected call not found.
E       Expected: search('python', sources=['hh', 'sj'])
E         Actual: search('python', sources=None)
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'sources': None} == {'sources': ['hh', 'sj']}
E         
E         Differing items:
E         {'sources': None} != {'sources': ['hh', 'sj']}
E         Use -v to get more diff

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:951: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed0bd50>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d540d90>

    def test_search_data_no_sources(self, app_interface):
        """Тест поиска данных без указания источников"""
        mock_results = [{"id": "1", "title": "Python Job"}]
        available_sources = ["hh", "sj"]
    
        app_interface.data_provider.get_available_sources.return_value = available_sources
        app_interface.data_provider.search.return_value = mock_results
    
        result = app_interface.search_data("python")
        assert result == mock_results
>       app_interface.data_provider.search.assert_called_once_with("python", sources=available_sources)
E       AssertionError: expected call not found.
E       Expected: search('python', sources=['hh', 'sj'])
E         Actual: search('python', sources=None)
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'sources': None} == {'sources': ['hh', 'sj']}
E         
E         Differing items:
E         {'sources': None} != {'sources': ['hh', 'sj']}
E         Use -v to get more diff

tests/test_main_application_interface_complete.py:228: AssertionError
___________ TestMainApplicationInterfaceComplete.test_search_data_error ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed15350>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746e83e1d0>

    def test_search_data_error(self, app_interface):
        """Тест обработки ошибок при поиске"""
        app_interface.data_provider.search.side_effect = Exception("Search error")
    
>       result = app_interface.search_data("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:50: in search_data
    return self.data_provider.search(query, sources=sources)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.search' id='140138047063440'>, args = ('python',)
kwargs = {'sources': None}, effect = Exception('Search error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Search error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
________ TestMainApplicationInterfaceComplete.test_get_storage_stats_error _________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed161d0>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746e80f050>

    def test_get_storage_stats_error(self, app_interface):
        """Тест обработки ошибок при получении статистики"""
        app_interface.storage.get_stats.side_effect = Exception("Stats error")
    
>       result = app_interface.get_storage_stats()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:54: in get_storage_stats
    return self.storage.get_stats()
           ^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.get_stats' id='140138047337872'>, args = (), kwargs = {}
effect = Exception('Stats error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Stats error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
________ TestMainApplicationInterfaceComplete.test_clear_storage_data_error ________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed0b050>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746df1c710>

    def test_clear_storage_data_error(self, app_interface):
        """Тест обработки ошибок при очистке хранилища"""
        app_interface.storage.clear.side_effect = Exception("Clear error")
    
>       result = app_interface.clear_storage_data()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:58: in clear_storage_data
    return self.storage.clear()
           ^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.clear' id='140138037506128'>, args = (), kwargs = {}
effect = Exception('Clear error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Clear error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
____________ TestMainApplicationInterfaceComplete.test_get_cached_data _____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ecf5890>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d541b90>

    def test_get_cached_data(self, app_interface):
        """Тест получения кэшированных данных"""
        mock_cached_data = [{"id": "1", "title": "Cached Job"}]
        app_interface.data_provider.get_cached_data.return_value = mock_cached_data
    
>       result = app_interface.get_cached_data("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'get_cached_data'

tests/test_main_application_interface_complete.py:283: AttributeError
_________ TestMainApplicationInterfaceComplete.test_get_cached_data_error __________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed15ed0>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d604110>

    def test_get_cached_data_error(self, app_interface):
        """Тест обработки ошибок при получении кэшированных данных"""
        app_interface.data_provider.get_cached_data.side_effect = Exception("Cache error")
    
>       result = app_interface.get_cached_data("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'get_cached_data'

tests/test_main_application_interface_complete.py:291: AttributeError
____________ TestMainApplicationInterfaceComplete.test_clear_cache_data ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed14d90>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d54ce10>

    def test_clear_cache_data(self, app_interface):
        """Тест очистки кэшированных данных"""
        sources = {"hh": True, "sj": False}
        app_interface.data_provider.clear_cache.return_value = True
    
>       result = app_interface.clear_cache_data(sources)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'clear_cache_data'

tests/test_main_application_interface_complete.py:299: AttributeError
_________ TestMainApplicationInterfaceComplete.test_clear_cache_data_error _________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed17150>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5cbd50>

    def test_clear_cache_data_error(self, app_interface):
        """Тест обработки ошибок при очистке кэша"""
        app_interface.data_provider.clear_cache.side_effect = Exception("Cache clear error")
    
>       result = app_interface.clear_cache_data({"hh": True})
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteMainApp' object has no attribute 'clear_cache_data'

tests/test_main_application_interface_complete.py:307: AttributeError
___________ TestMainApplicationInterfaceComplete.test_export_data_empty ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed178d0>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5a1f90>

    def test_export_data_empty(self, app_interface):
        """Тест экспорта пустых данных"""
        result = app_interface.export_data([], "json", "/tmp/export.json")
>       assert result is None
E       AssertionError: assert <Mock name='mock.export()' id='140138027563088'> is None

tests/test_main_application_interface_complete.py:322: AssertionError
___________ TestMainApplicationInterfaceComplete.test_export_data_error ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed17e50>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5d4f50>

    def test_export_data_error(self, app_interface):
        """Тест обработки ошибок при экспорте"""
        app_interface.storage.export.side_effect = Exception("Export error")
    
>       result = app_interface.export_data([{"id": "1"}], "json", "/tmp/export.json")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:62: in export_data
    return self.storage.export(data, format_type, path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.export' id='140138027775312'>
args = ([{'id': '1'}], 'json', '/tmp/export.json'), kwargs = {}
effect = Exception('Export error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Export error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
___________ TestMainApplicationInterfaceComplete.test_import_data_error ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed1cb90>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746df4f850>

    def test_import_data_error(self, app_interface):
        """Тест обработки ошибок при импорте"""
        app_interface.storage.import_data.side_effect = Exception("Import error")
    
>       result = app_interface.import_data("/path/to/import.json", "json")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:66: in import_data
    return self.storage.import_data(path, format_type)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.import_data' id='140138037703888'>
args = ('/path/to/import.json', 'json'), kwargs = {}
effect = Exception('Import error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Import error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
__________ TestMainApplicationInterfaceComplete.test_setup_logging_error ___________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed1d890>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d5ea610>

    def test_setup_logging_error(self, app_interface):
        """Тест обработки ошибок настройки логирования"""
        with patch('logging.basicConfig', side_effect=Exception("Logging error")):
            # Не должно падать
>           app_interface.setup_logging("DEBUG")

tests/test_main_application_interface_complete.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:71: in setup_logging
    logging.basicConfig(level=level)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='basicConfig' id='140138027855632'>, args = ()
kwargs = {'level': 'DEBUG'}, effect = Exception('Logging error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Logging error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
_________ TestMainApplicationInterfaceComplete.test_validate_configuration _________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed1df10>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746d550310>

    def test_validate_configuration(self, app_interface):
        """Тест валидации конфигурации"""
        mock_config = {"api_key": "test", "db_url": "postgres://test"}
    
        with patch.object(app_interface, '_check_api_keys', return_value=True), \
             patch.object(app_interface, '_check_database_connection', return_value=True):
>           result = app_interface.validate_configuration(mock_config)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'ConcreteMainApp' object has no attribute 'validate_configuration'

tests/test_main_application_interface_complete.py:365: AttributeError
_____ TestMainApplicationInterfaceComplete.test_validate_configuration_invalid _____

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceComplete object at 0x7f746ed1e590>
app_interface = <tests.test_main_application_interface_complete.ConcreteMainApp object at 0x7f746e87e490>

    def test_validate_configuration_invalid(self, app_interface):
        """Тест валидации некорректной конфигурации"""
        mock_config = {"invalid": "config"}
    
        with patch.object(app_interface, '_check_api_keys', return_value=False):
>           result = app_interface.validate_configuration(mock_config)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'ConcreteMainApp' object has no attribute 'validate_configuration'

tests/test_main_application_interface_complete.py:373: AttributeError
___________ TestMainApplicationInterfaceIntegration.test_error_recovery ____________

self = <tests.test_main_application_interface_complete.TestMainApplicationInterfaceIntegration object at 0x7f746ed24e10>

    def test_error_recovery(self):
        """Тест восстановления после ошибок"""
        mock_provider = Mock()
        mock_processor = Mock()
        mock_storage = Mock()
    
        # Настройка ошибок
        mock_provider.search.side_effect = Exception("Search error")
    
        app = ConcreteMainApp(mock_provider, mock_processor, mock_storage)
    
        # Приложение должно справляться с ошибками
>       search_results = app.search_data("python")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main_application_interface_complete.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_main_application_interface_complete.py:50: in search_data
    return self.data_provider.search(query, sources=sources)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.search' id='140138027786320'>, args = ('python',)
kwargs = {'sources': None}, effect = Exception('Search error')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Search error

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
________ TestVacancyRepositoryFixed.test_repository_init_with_dependencies _________

self = <tests.test_missing_coverage_components.TestVacancyRepositoryFixed object at 0x7f746ed6fe90>
mock_db_connection = <Mock id='140138028154448'>
mock_validator = <Mock id='140138028145744'>

    def test_repository_init_with_dependencies(self, mock_db_connection, mock_validator):
        """Тест инициализации с зависимостями"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            pytest.skip("VacancyRepository not available")
    
        repo = VacancyRepository(mock_db_connection, mock_validator)
        assert repo is not None
>       assert repo.db_connection == mock_db_connection
               ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'db_connection'

tests/test_missing_coverage_components.py:190: AttributeError
________ TestLowCoverageComponents.test_cached_api_concrete_implementation _________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7f746ed7a090>

    def test_cached_api_concrete_implementation(self):
        """Тест конкретной реализации кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
    
            class ConcreteCachedAPI(CachedAPI):
                def _get_empty_response(self):
                    return []
    
                def _validate_vacancy(self, vacancy):
                    return bool(vacancy.get('id'))
    
                def get_vacancies(self, query, **kwargs):
                    return [{"id": "1", "title": "Test"}]
    
                def get_vacancies_page(self, query, page=0, per_page=20, **kwargs):
                    return {"items": [], "found": 0}
    
            base_api = Mock()
            with patch('src.utils.cache.FileCache'):
>               api = ConcreteCachedAPI(base_api)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:298: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/cached_api.py:41: in __init__
    self.cache_dir = Path(cache_dir)
                     ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:871: in __new__
    self = cls._from_parts(args)
           ^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:509: in _from_parts
    drv, root, parts = self._parse_args(args)
                       ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'pathlib.PosixPath'>, args = (<Mock id='140138027835344'>,)

    @classmethod
    def _parse_args(cls, args):
        # This is useful when you don't want to create an instance, just
        # canonicalize some constructor arguments.
        parts = []
        for a in args:
            if isinstance(a, PurePath):
                parts += a._parts
            else:
>               a = os.fspath(a)
                    ^^^^^^^^^^^^
E               TypeError: expected str, bytes or os.PathLike object, not Mock

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:493: TypeError
______ TestLowCoverageComponents.test_base_formatter_concrete_implementation _______

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7f746ed7a3d0>

    def test_base_formatter_concrete_implementation(self):
        """Тест конкретной реализации базового форматтера"""
        try:
            from src.utils.base_formatter import BaseFormatter
    
            class ConcreteFormatter(BaseFormatter):
                def clean_html_tags(self, text):
                    return str(text)
    
                def format_company_name(self, company):
                    return str(company)
    
                def format_currency(self, currency):
                    return str(currency)
    
                def format_date(self, date):
                    return str(date)
    
                def format_employment_type(self, employment):
                    return str(employment)
    
                def format_experience(self, experience):
                    return str(experience)
    
                def format_number(self, number):
                    return str(number)
    
                def format_salary(self, salary):
                    return str(salary)
    
                def format_schedule(self, schedule):
                    return str(schedule)
    
                def format_text(self, text):
                    return str(text)
    
                def format_vacancy_info(self, vacancy):
                    return str(vacancy)
    
            formatter = ConcreteFormatter()
            assert formatter is not None
>           result = formatter.format("test")
                     ^^^^^^^^^^^^^^^^
E           AttributeError: 'ConcreteFormatter' object has no attribute 'format'

tests/test_missing_coverage_components.py:345: AttributeError
_______________ TestLowCoverageComponents.test_api_methods_coverage ________________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7f746ed7a790>
mock_get = <MagicMock name='get' id='140138027409744'>

    @patch('requests.get')
    def test_api_methods_coverage(self, mock_get):
        """Тест покрытия методов API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
            from src.api_modules.sj_api import SuperJobAPI
    
            # Тестируем HeadHunter API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:367: AssertionError
_______ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_title_match _______

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ebffe10>

    def test_filter_vacancies_by_keyword_title_match(self):
        """Тест фильтрации по совпадению в заголовке"""
        vacancies = [
            MockVacancy(title="Python Developer"),
            MockVacancy(title="Java Developer")
        ]
    
        # Мокаем функцию фильтрации для корректного поведения
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]  # Возвращаем только Python вакансию
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746d5b4210>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746d5b6b90>])

tests/test_search_utils_complete.py:201: AssertionError
________ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_id_match _________

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec00450>

    def test_filter_vacancies_by_keyword_id_match(self):
        """Тест фильтрации по совпадению в ID"""
        vacancies = [
            MockVacancy(vacancy_id="python123"),
            MockVacancy(vacancy_id="java456")
        ]
    
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746d606e10>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746d6057d0>])

tests/test_search_utils_complete.py:213: AssertionError
_ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_responsibilities_match __

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec01050>

    def test_filter_vacancies_by_keyword_responsibilities_match(self):
        """Тест фильтрации по совпадению в обязанностях"""
        vacancies = [
            MockVacancy(responsibilities="Develop Python applications"),
            MockVacancy(responsibilities="Develop Java applications")
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746d57ecd0>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746d57f110>])

tests/test_search_utils_complete.py:235: AssertionError
____ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_description_match ____

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec01650>

    def test_filter_vacancies_by_keyword_description_match(self):
        """Тест фильтрации по совпадению в описании"""
        vacancies = [
            MockVacancy(description="Backend Python development"),
            MockVacancy(description="Frontend React development")
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746df65990>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746df641d0>])

tests/test_search_utils_complete.py:246: AssertionError
_ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_detailed_description_match _

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec01c50>

    def test_filter_vacancies_by_keyword_detailed_description_match(self):
        """Тест фильтрации по совпадению в детальном описании"""
        vacancies = [
            MockVacancy(detailed_description="Detailed Python job description"),
            MockVacancy(detailed_description="Detailed Java job description")
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746e87b810>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746e878390>])

tests/test_search_utils_complete.py:257: AssertionError
______ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_skills_match _______

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec02290>

    def test_filter_vacancies_by_keyword_skills_match(self):
        """Тест фильтрации по совпадению в навыках"""
        vacancies = [
            MockVacancy(skills=[{"name": "Python"}, {"name": "Django"}]),
            MockVacancy(skills=["Java", "Spring"])
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746df71590>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746df73750>])

tests/test_search_utils_complete.py:268: AssertionError
_____ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_employer_match ______

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec02890>

    def test_filter_vacancies_by_keyword_employer_match(self):
        """Тест фильтрации по совпадению в работодателе"""
        vacancies = [
            MockVacancy(employer={"name": "Python Solutions"}),
            MockVacancy(employer={"name": "Java Corp"})
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746d5de690>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746d5ddc50>])

tests/test_search_utils_complete.py:279: AssertionError
____ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_profession_match _____

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec02e90>

    def test_filter_vacancies_by_keyword_profession_match(self):
        """Тест фильтрации по совпадению в профессии (SuperJob)"""
        vacancies = [
            MockVacancy(profession="Python Developer"),
            MockVacancy(profession="Java Developer")
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [vacancies[0]]
            result = filter_vacancies_by_keyword(vacancies, "Python")
>           assert len(result) == 1
E           assert 2 == 1
E            +  where 2 = len([<tests.test_search_utils_complete.MockVacancy object at 0x7f746d626610>, <tests.test_search_utils_complete.MockVacancy object at 0x7f746d625910>])

tests/test_search_utils_complete.py:290: AssertionError
____ TestSearchUtilsComplete.test_filter_vacancies_by_keyword_relevance_sorting ____

self = <tests.test_search_utils_complete.TestSearchUtilsComplete object at 0x7f746ec03490>

    def test_filter_vacancies_by_keyword_relevance_sorting(self):
        """Тест сортировки по релевантности"""
        vacancies = [
            MockVacancy(title="Developer", description="Some text"),  # 3 балла
            MockVacancy(title="Python Developer", description="Python programming"),  # 13 баллов
            MockVacancy(title="Senior Python Developer", requirements="Python, Django")  # 15 баллов
        ]
        with patch('src.utils.search_utils.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = sorted(vacancies, key=lambda v: len(v.title), reverse=True)
            result = filter_vacancies_by_keyword(vacancies, "Python")
    
            # Проверяем что результаты отсортированы по релевантности
            assert len(result) == 3
>           assert "Senior Python Developer" in result[0].title
E           AssertionError: assert 'Senior Python Developer' in 'Python Developer'
E            +  where 'Python Developer' = <tests.test_search_utils_complete.MockVacancy object at 0x7f746df26c50>.title

tests/test_search_utils_complete.py:305: AssertionError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f746ec76150>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f746d592490>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746d625c10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________________ TestDBManager.test_execute_query _________________________

self = <tests.test_storage_components_complete.TestDBManager object at 0x7f746eb2b790>
mock_connect = <MagicMock name='connect' id='140138029335312'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f746d755790>

    @patch('psycopg2.connect')
    def test_execute_query(self, mock_connect, db_manager):
        """Тест выполнения запроса"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        mock_cursor = Mock()
        mock_cursor.fetchall.return_value = [('test',)]
        mock_connection = Mock()
>       mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='140138029457360'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_______________________ TestPostgresSaver.test_save_vacancy ________________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f746eb34790>
mock_connect = <MagicMock name='connect' id='140138033738192'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f746dc4a990>

    @patch('psycopg2.connect')
    def test_save_vacancy(self, mock_connect, postgres_saver):
        """Тест сохранения вакансии"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        mock_cursor = Mock()
        mock_connection = Mock()
>       mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='140138033738384'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f746eb225d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f746dab9b10>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save_vacancy', return_value=True) as mock_save:

tests/test_storage_components_complete.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746dab9bd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f746dab9b10> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f746eb35fd0>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f746d765810>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансии"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, 'connection') as mock_conn:

tests/test_storage_components_complete.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746d766710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f746d765810> does not have the attribute 'connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f746eb36650>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f746db9e210>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, 'connection') as mock_conn:

tests/test_storage_components_complete.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746db9cc50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f746db9e210> does not have the attribute 'connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestStorageIntegration.test_db_manager_with_postgres_saver_integration ______

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f746eb36d10>
mock_connect = <MagicMock name='connect' id='140138033545936'>

    @patch('psycopg2.connect')
    def test_db_manager_with_postgres_saver_integration(self, mock_connect):
        """Тест интеграции DBManager с PostgresSaver"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        mock_connection = Mock()
        mock_cursor = Mock()
>       mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='140138027154704'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f746eb34290>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        with patch('src.storage.components.database_connection.DatabaseConnection'):
>           repository = VacancyRepository()
                         ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_components_complete.py:478: TypeError
______________ TestStorageModulesConsolidated.test_vacancy_repository ______________

self = <tests.test_storage_modules_consolidated.TestStorageModulesConsolidated object at 0x7f746eb4dc50>
mock_connect = <MagicMock name='connect' id='140138028140880'>
storage_mocks = <tests.test_storage_modules_consolidated.ConsolidatedStorageMocks object at 0x7f746dd33010>

    @patch('psycopg2.connect')
    def test_vacancy_repository(self, mock_connect, storage_mocks):
        """Тестирование репозитория вакансий"""
        mock_connect.return_value = storage_mocks.connection
    
        try:
            from src.storage.components.vacancy_repository import VacancyRepository
            from src.vacancies.models import Vacancy
    
>           repo = VacancyRepository()
                   ^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyRepository.__init__() missing 2 required positional arguments: 'db_connection' and 'validator'

tests/test_storage_modules_consolidated.py:80: TypeError
____________ TestMenuManagerExtended.test_menu_manager_get_user_choice _____________

self = <tests.test_ui_components_extended.TestMenuManagerExtended object at 0x7f746e9af1d0>
mock_input = <MagicMock name='input' id='140138033976016'>

    @patch('builtins.input', return_value='1')
    def test_menu_manager_get_user_choice(self, mock_input):
        """Тестирование получения пользовательского выбора"""
        if not SRC_AVAILABLE:
            pytest.skip("Source code not available")
    
        if hasattr(self.menu_manager, 'get_user_choice'):
            choice = self.menu_manager.get_user_choice()
            assert choice == '1' or choice == 1
        else:
>           assert mock_input.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='input' id='140138033976016'>.called

tests/test_ui_components_extended.py:62: AssertionError
__________ TestUINavigationExtended.test_paginate_display_custom_actions ___________

self = <Mock id='140138028385232'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f746ea96ad0>
mock_print = <MagicMock name='print' id='140138028385616'>
mock_input = <MagicMock name='input' id='140138028985168'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
>       mock_action.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/test_ui_navigation_extended.py:136: AssertionError
________ TestUINavigationExtended.test_paginate_display_custom_action_error ________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f746ea97150>
mock_print = <MagicMock name='print' id='140138028307792'>
mock_input = <MagicMock name='input' id='140138028308560'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_action_error(self, mock_print, mock_input):
        """Тестирование ошибки в кастомном действии"""
        def error_action():
            raise ValueError("Test error")
    
        custom_actions = {"e": error_action}
        mock_input.side_effect = ["e", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Error Test",
            custom_actions=custom_actions
        )
    
        calls = [call.args[0] for call in mock_print.call_args_list]
        output = " ".join(calls)
>       assert "Ошибка при выполнении действия" in output
E       AssertionError: assert 'Ошибка при выполнении действия' in '\n\nError Test ========== 1: Item 0 2: Item 1 3: Item 2 4: Item 3 5: Item 4 \n==================== Навигация: Страница 1 из 1 Показано элементов: 1-5 из 5 --------------------'

tests/test_ui_navigation_extended.py:160: AssertionError
__________________ TestUnifiedAPI.test_filter_by_target_companies __________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f746ea407d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746d6d9d10>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
___________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources ___________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f746e8c5a90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746dc62710>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
______________ TestUnifiedAPIComplete.test_filter_by_target_companies ______________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7f746e8d6450>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f746d5db890>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestUserInterfaceConsolidated.test_main_interface_complete ____________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f746e8fa7d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f746e8fba90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterfaceConsolidated.test_interface_components_integration ________

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f746e8e40d0>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
___________ TestVacancyDisplayHandler.test_vacancy_display_handler_init ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f746e944f90>

    def test_vacancy_display_handler_init(self):
        """Тест инициализации обработчика отображения вакансий"""
>       handler = VacancyDisplayHandler()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_vacancy_display_handler.py:43: TypeError
________________ TestVacancyModelsComplete.test_base_vacancy_model _________________

self = <tests.test_vacancy_models_complete.TestVacancyModelsComplete object at 0x7f746e96c550>

    def test_base_vacancy_model(self):
        """Тест базовой модели вакансии"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy("Python Developer", "https://test.com", employer)
    
        assert vacancy.title == "Python Developer"
        assert vacancy.url == "https://test.com"
>       assert vacancy.employer is not None
E       assert None is not None
E        +  where None = <src.vacancies.models.Vacancy object at 0x7f746d8bba00>.employer

tests/test_vacancy_models_complete.py:27: AssertionError
__________ TestVacancyOperationsCoordinatorComplete.test_coordinator_init __________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f746e7aabd0>

    def test_coordinator_init(self):
        """Тест инициализации координатора операций с вакансиями"""
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_vacancy_operations_coordinator_complete.py:50: TypeError
____________________ TestVacancyRepository.test_repository_init ____________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f746e7e17d0>

    def test_repository_init(self):
        """Тест инициализации репозитория"""
        assert self.repository is not None
        # Проверяем, что репозиторий имеет необходимые атрибуты
        assert hasattr(self.repository, 'db_connection') or hasattr(self.repository, '_db_connection')
>       assert self.repository.validator == self.mock_validator
               ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'validator'

tests/test_vacancy_repository.py:37: AttributeError
================================= warnings summary =================================
tests/test_api_modules.py::TestAPIModules::test_api_concurrent_requests
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/_pytest/threadexception.py:58: PytestUnhandledThreadExceptionWarning: Exception in thread Thread-4 (search_worker)
  
  Traceback (most recent call last):
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 1045, in _bootstrap_inner
      self.run()
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 982, in run
      self._target(*self._args, **self._kwargs)
    File "/home/runner/workspace/tests/test_api_modules.py", line 501, in search_worker
      result = unified_api.search_vacancies(f"Python {query}")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
  
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.
    warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))

tests/test_api_modules.py::TestAPIModules::test_api_concurrent_requests
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/_pytest/threadexception.py:58: PytestUnhandledThreadExceptionWarning: Exception in thread Thread-3 (search_worker)
  
  Traceback (most recent call last):
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 1045, in _bootstrap_inner
      self.run()
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 982, in run
      self._target(*self._args, **self._kwargs)
    File "/home/runner/workspace/tests/test_api_modules.py", line 501, in search_worker
      result = unified_api.search_vacancies(f"Python {query}")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
  
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.
    warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))

tests/test_api_modules.py::TestAPIModules::test_api_concurrent_requests
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/_pytest/threadexception.py:58: PytestUnhandledThreadExceptionWarning: Exception in thread Thread-2 (search_worker)
  
  Traceback (most recent call last):
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 1045, in _bootstrap_inner
      self.run()
    File "/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/threading.py", line 982, in run
      self._target(*self._args, **self._kwargs)
    File "/home/runner/workspace/tests/test_api_modules.py", line 501, in search_worker
      result = unified_api.search_vacancies(f"Python {query}")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
  
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.
    warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================== tests coverage ==================================
_________________ coverage: platform linux, python 3.11.13-final-0 _________________

Name                                                     Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------------
src/__init__.py                                              0      0   100%
src/api_modules/__init__.py                                  0      0   100%
src/api_modules/base_api.py                                 23      0   100%
src/api_modules/cached_api.py                              168     46    73%   114-115, 144-147, 157, 166-168, 183, 186-187, 203, 215-238, 247, 267-269, 289, 298-299, 308-310, 335-336, 340-342
src/api_modules/get_api.py                                  53     19    64%   46-54, 64, 73-74, 102-103, 116-118, 124, 126-132, 134, 136
src/api_modules/hh_api.py                                  142     25    82%   77-85, 169, 178-180, 219-221, 233, 256, 276, 289, 293-295, 329-331
src/api_modules/sj_api.py                                  128     28    78%   99-106, 206-210, 222, 263-264, 277-279, 291-292, 296-308
src/api_modules/unified_api.py                             270     77    71%   124, 133, 154-155, 175-176, 212-213, 221-240, 245, 291-293, 304-306, 316-322, 390-391, 401-418, 422-432, 436-458
src/config/__init__.py                                       0      0   100%
src/config/api_config.py                                    13      0   100%
src/config/app_config.py                                    17      0   100%
src/config/db_config.py                                     61     27    56%   24, 44-48, 85-88, 96-99, 104, 107, 115, 133-136, 156-172
src/config/hh_api_config.py                                 21      2    90%   31, 37
src/config/sj_api_config.py                                 49     18    63%   39, 59, 62, 68-75, 79-87
src/config/target_companies.py                              61     25    59%   119, 124-130, 135-138, 143-146, 151, 156-162, 167, 185, 190
src/config/ui_config.py                                     27      8    70%   36-42, 54-58, 79
src/interfaces/__init__.py                                   0      0   100%
src/interfaces/main_application_interface.py               121     88    27%   76, 89-98, 109-136, 140-152, 156-161, 166-180, 184-214, 224-225, 230, 234-236
src/storage/__init__.py                                      6      0   100%
src/storage/abstract.py                                     14      0   100%
src/storage/abstract_db_manager.py                          21      6    71%   16, 26, 36, 46, 59, 69
src/storage/components/__init__.py                           0      0   100%
src/storage/components/database_connection.py               53     15    72%   14-16, 19-20, 72-78, 88-89, 97-98
src/storage/components/vacancy_repository.py               113     97    14%   49-98, 110-156, 165-178, 190-209, 221-291
src/storage/components/vacancy_validator.py                 65     39    40%   61-67, 73-74, 78-79, 90-103, 108-122, 138-152
src/storage/db_manager.py                                  348    224    36%   17-24, 63, 83-139, 223-228, 246-247, 262-272, 282-338, 348-361, 376-405, 419-451, 519-522, 525-528, 533-535, 574-576, 590-651, 665, 671-728, 741-813, 818-820, 832, 844-845, 857-859, 871-877, 892-1022
src/storage/interfaces/typed_data_processor.py              46     25    46%   32, 45, 64, 78, 94, 100, 106-117, 124, 130-133, 139-148
src/storage/postgres_saver.py                              790    557    29%   10-13, 72-74, 109-111, 124-125, 133-140, 145-146, 148-151, 176-183, 188-194, 199-200, 202-205, 263-265, 280-281, 295-305, 310-317, 322-323, 325-328, 338, 342-343, 346, 374-380, 389-390, 399-400, 404-409, 417-419, 427-428, 442-445, 452, 455-458, 473, 480, 487, 594-598, 603-606, 627-634, 655, 662-664, 678, 690-692, 704-708, 721-779, 783-895, 918-958, 961, 968-970, 974-992, 996-1020, 1024-1048, 1055, 1067-1098, 1102-1113, 1125-1180, 1184-1196, 1208-1251, 1264-1303, 1323-1574, 1587-1601, 1611, 1614, 1617-1635
src/storage/services/__init__.py                             4      0   100%
src/storage/services/abstract_filter_service.py             30      7    77%   34, 44, 64, 88, 101, 114, 127
src/storage/services/abstract_storage_service.py            25      6    76%   34, 47, 60, 73, 83, 93
src/storage/services/company_id_filter_service.py           94     62    34%   49, 62, 68-76, 85-135, 141-202, 206-214, 223
src/storage/services/deduplication_service.py               64     43    33%   15-16, 20-21, 43, 56-129, 133-142, 146-154, 183, 192
src/storage/services/filtering_service.py                  105     66    37%   15-16, 20-21, 25-26, 48, 76-88, 95-132, 143-155, 159-170, 189-199, 228, 237
src/storage/services/sql_deduplication_service.py           64     49    23%   44-64, 68-111, 116-148, 152-160, 173-182
src/storage/services/sql_filter_service.py                  89     63    29%   47, 59-78, 82-146, 152-191, 195-202, 207-209, 218-247
src/storage/services/vacancy_processing_coordinator.py      44      0   100%
src/storage/services/vacancy_storage_service.py            334    245    27%   15-16, 20-21, 25-26, 31-32, 37-38, 42-43, 47-48, 52-53, 57-58, 93-94, 119-146, 150-170, 176-194, 211-215, 220-222, 226-238, 244-320, 334, 338-339, 360-362, 366-395, 402-404, 417-469, 499, 511-535, 539-590, 594-601, 606, 610, 614, 618
src/storage/simple_db_adapter.py                           142    116    18%   21, 25, 29, 33, 37-43, 50-51, 54, 57, 61-101, 105-117, 121, 125-165, 169-202, 206-210, 219
src/storage/storage_factory.py                              13      0   100%
src/ui_interfaces/__init__.py                                0      0   100%
src/ui_interfaces/console_interface.py                     394    306    22%   23-25, 69, 82, 84, 86, 88, 90, 92, 94, 97, 100, 102-110, 116-127, 157, 161, 165, 169, 173-224, 228-301, 305, 309, 319-355, 359, 370-371, 382-385, 395-544, 548-579, 584-604
src/ui_interfaces/source_selector.py                        44     30    32%   25-51, 64, 74-79
src/ui_interfaces/vacancy_display_handler.py                72     58    19%   32-70, 74-107, 111-141
src/ui_interfaces/vacancy_operations_coordinator.py        194    105    46%   68-79, 100, 102, 104, 108, 116-122, 126-165, 169-192, 196-198, 211, 248-273, 302-322
src/ui_interfaces/vacancy_search_handler.py                152    127    16%   38-76, 90-114, 124, 135-170, 180-197, 209-232, 248-262, 272-308
src/user_interface.py                                       55     47    15%   26-94, 98
src/utils/__init__.py                                        0      0   100%
src/utils/abstract_filter.py                                26     14    46%   30, 47, 61, 75, 88-102
src/utils/api_data_filter.py                               154     88    43%   9-10, 25, 55-56, 71-83, 97, 105-106, 122, 130-131, 148-160, 173-185, 191-196, 206, 212, 215, 217, 223-241, 245, 256, 269, 275-284, 288-307
src/utils/base_formatter.py                                 38     11    71%   14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64
src/utils/cache.py                                         135     49    64%   45-46, 61-62, 78, 93-94, 98-100, 115-117, 124-126, 130-139, 165, 169-170, 174-176, 199-210, 221-224, 227, 236-238, 244
src/utils/data_normalizers.py                               75     13    83%   77-80, 107, 113-121, 154-162
src/utils/db_manager_demo.py                               236    218     8%   32, 38-64, 73-81, 85-103, 107-155, 159-211, 215-224, 228-272, 276-315, 319-370, 377-382, 386
src/utils/decorators.py                                     73     53    27%   24-52, 56-57, 61, 77-91, 97-106, 112-121
src/utils/description_parser.py                             70     55    21%   41-64, 77-103, 116-135, 141-177
src/utils/env_loader.py                                     59     34    42%   32-33, 41-76, 104-111
src/utils/file_handlers.py                                  38     25    34%   36-48, 57-76
src/utils/menu_manager.py                                   49      8    84%   38, 52-56, 77, 93
src/utils/paginator.py                                      28      9    68%   43-44, 51-52, 57-61
src/utils/salary.py                                        113     18    84%   35-36, 55-61, 71-72, 78, 94, 152, 157, 164, 181, 207
src/utils/search_utils.py                                  156      6    96%   204, 215, 219, 223, 227, 282
src/utils/source_manager.py                                 60     38    37%   65, 77-80, 92-95, 108-119, 131-134, 146, 158-161, 173-176, 188-191, 198-200
src/utils/ui_helpers.py                                    161      4    98%   135, 225-226, 325
src/utils/ui_navigation.py                                  99      0   100%
src/utils/vacancy_formatter.py                             167     59    65%   122, 129, 148, 154, 159-164, 170-171, 176, 182, 188-201, 206, 213, 218, 225, 229-231, 235-241, 246, 259-262, 273-304
src/utils/vacancy_operations.py                            165     99    40%   43, 64, 75-87, 111, 122-134, 159, 170-182, 220-244, 248-261, 264-265, 268-269, 290-310, 320-339, 346-370
src/utils/vacancy_stats.py                                  86     53    38%   57-60, 83-91, 95-100, 110-158, 163-165
src/vacancies/__init__.py                                    0      0   100%
src/vacancies/abstract.py                                   10      0   100%
src/vacancies/abstract_models.py                            99     28    72%   18, 23, 28, 33, 38, 44, 53, 58, 63, 69, 75, 84, 89, 94, 100, 106, 115, 120, 125, 130, 135, 140, 146, 155, 160, 165, 171, 177
src/vacancies/models.py                                    390    212    46%   40, 44, 48, 64, 77, 81, 89, 91, 93, 98-102, 106, 122, 126, 131-133, 141, 144, 149, 153, 169, 173, 178-180, 188, 191, 196, 200, 299, 317, 329-332, 344, 348, 352, 358, 370, 374, 378, 384, 404-438, 443-451, 456-651, 670, 686, 701-706, 720, 725-727, 731-733, 737-739, 743-745, 749
src/vacancies/parsers/__init__.py                           55     11    80%   16, 21, 26, 31, 36, 88, 97, 106, 111, 116, 121
src/vacancies/parsers/base_parser.py                         9      2    78%   19, 32
src/vacancies/parsers/hh_parser.py                          55     10    82%   21, 32-33, 55-57, 96-98, 119
src/vacancies/parsers/sj_parser.py                          57     47    18%   24-43, 57-65, 98-147
--------------------------------------------------------------------------------------
TOTAL                                                     7192   3820    47%
============================= short test summary info ==============================
FAILED tests/test_abstract_filter_complete.py::TestAbstractFilterIntegration::test_edge_cases - AssertionError: assert 1 == 0
FAILED tests/test_api_modules.py::TestAPIModules::test_hh_api_initialization - AttributeError: 'HeadHunterAPI' object has no attribute 'base_url'
FAILED tests/test_api_modules.py::TestAPIModules::test_hh_api_search_vacancies - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_sj_api_initialization - AttributeError: 'SuperJobAPI' object has no attribute 'base_url'
FAILED tests/test_api_modules.py::TestAPIModules::test_sj_api_search_vacancies - AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_unified_api_initialization - AssertionError: assert False
FAILED tests/test_api_modules.py::TestAPIModules::test_unified_api_get_available_sources - AssertionError: assert 'hh.ru' in ['hh', 'sj']
FAILED tests/test_api_modules.py::TestAPIModules::test_unified_api_search_single_source - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_unified_api_search_multiple_sources - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_unified_api_search_default_sources - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_search_queries[Python-list] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_search_queries[Java-list] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_search_queries[JavaScript-list] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_search_queries[-list] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_sources[hh.ru] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_sources[superjob.ru] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_parametrized_sources[all] - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_api_integration_workflow - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_api_performance - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_api_memory_usage - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_api_concurrent_requests - assert 0 == 3
FAILED tests/test_api_modules.py::TestAPIModules::test_api_type_safety - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules.py::TestAPIModules::test_import_availability - NameError: name 'BaseAPI' is not defined
FAILED tests/test_base_formatter.py::TestBaseFormatter::test_abstract_methods_exist - AssertionError: assert 'format_vacancy' in frozenset({'clean_html_tags', 'forma...
FAILED tests/test_get_api_complete.py::TestGetAPIComplete::test_inheritance_structure - NameError: name 'GetAPI' is not defined
FAILED tests/test_get_api_complete.py::TestGetAPIComplete::test_class_attributes - NameError: name 'GetAPI' is not defined
FAILED tests/test_get_api_complete.py::TestGetAPIComplete::test_abstract_method_inheritance - NameError: name 'GetAPI' is not defined
FAILED tests/test_interfaces.py::TestMainApplicationInterface::test_interface_creation - TypeError: Can't instantiate abstract class MainApplicationInterface with abstr...
FAILED tests/test_main_application_interface.py::TestMainApplicationInterface::test_main_application_interface_init - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
FAILED tests/test_main_application_interface.py::TestMainApplicationInterface::test_main_application_interface_concrete_implementation - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_concrete_run_application - AttributeError: <tests.test_main_application_interface_complete.ConcreteMainApp...
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_get_data_sources - AttributeError: 'ConcreteMainApp' object has no attribute 'get_data_sources'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_get_data_sources_error - AttributeError: 'ConcreteMainApp' object has no attribute 'get_data_sources'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_validate_sources - AttributeError: 'ConcreteMainApp' object has no attribute 'validate_sources'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_validate_sources_error - AttributeError: 'ConcreteMainApp' object has no attribute 'validate_sources'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_process_data_error - Exception: Processing error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_store_data_error - Exception: Storage error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_search_data_no_sources - AssertionError: expected call not found.
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_search_data_error - Exception: Search error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_get_storage_stats_error - Exception: Stats error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_clear_storage_data_error - Exception: Clear error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_get_cached_data - AttributeError: 'ConcreteMainApp' object has no attribute 'get_cached_data'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_get_cached_data_error - AttributeError: 'ConcreteMainApp' object has no attribute 'get_cached_data'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_clear_cache_data - AttributeError: 'ConcreteMainApp' object has no attribute 'clear_cache_data'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_clear_cache_data_error - AttributeError: 'ConcreteMainApp' object has no attribute 'clear_cache_data'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_export_data_empty - AssertionError: assert <Mock name='mock.export()' id='140138027563088'> is None
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_export_data_error - Exception: Export error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_import_data_error - Exception: Import error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_setup_logging_error - Exception: Logging error
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_validate_configuration - AttributeError: 'ConcreteMainApp' object has no attribute 'validate_configuration'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceComplete::test_validate_configuration_invalid - AttributeError: 'ConcreteMainApp' object has no attribute 'validate_configuration'
FAILED tests/test_main_application_interface_complete.py::TestMainApplicationInterfaceIntegration::test_error_recovery - Exception: Search error
FAILED tests/test_missing_coverage_components.py::TestVacancyRepositoryFixed::test_repository_init_with_dependencies - AttributeError: 'VacancyRepository' object has no attribute 'db_connection'
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_cached_api_concrete_implementation - TypeError: expected str, bytes or os.PathLike object, not Mock
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_base_formatter_concrete_implementation - AttributeError: 'ConcreteFormatter' object has no attribute 'format'
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_api_methods_coverage - assert False
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_title_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_id_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_responsibilities_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_description_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_detailed_description_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_skills_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_employer_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_profession_match - assert 2 == 1
FAILED tests/test_search_utils_complete.py::TestSearchUtilsComplete::test_filter_vacancies_by_keyword_relevance_sorting - AssertionError: assert 'Senior Python Developer' in 'Python Developer'
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have th...
FAILED tests/test_storage_components_complete.py::TestDBManager::test_execute_query - AttributeError: __enter__
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancy - AttributeError: __enter__
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f746dab9...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f74...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f74...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_db_manager_with_postgres_saver_integration - AttributeError: __enter__
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
FAILED tests/test_storage_modules_consolidated.py::TestStorageModulesConsolidated::test_vacancy_repository - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
FAILED tests/test_ui_components_extended.py::TestMenuManagerExtended::test_menu_manager_get_user_choice - AssertionError: assert False
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Expected 'mock' to have been called once. Called 0 times.
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_action_error - AssertionError: assert 'Ошибка при выполнении действия' in '\n\nError Test ====...
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCo...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_vacancy_display_handler_init - TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argum...
FAILED tests/test_vacancy_models_complete.py::TestVacancyModelsComplete::test_base_vacancy_model - assert None is not None
FAILED tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_coordinator_init - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positiona...
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_repository_init - AttributeError: 'VacancyRepository' object has no attribute 'validator'
ERROR tests/test_api_modules.py::TestAPIModules::test_base_api_initialization - NameError: name 'BaseAPI' is not defined
ERROR tests/test_api_modules.py::TestAPIModules::test_base_api_methods - NameError: name 'BaseAPI' is not defined
ERROR tests/test_api_modules.py::TestAPIModules::test_cached_api_initialization - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_api_modules.py::TestAPIModules::test_cached_api_caching_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_api_modules.py::TestAPIModules::test_cached_api_clear_cache - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_api_modules.py::TestAPIModules::test_api_error_handling - NameError: name 'BaseAPI' is not defined
ERROR tests/test_api_modules.py::TestAPIModules::test_api_caching_performance - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_concrete_implementation_works - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancies_list - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy_with_missing_fields - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_empty_vacancies_list - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy_with_none - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_vacancy_with_empty_dict - TypeError: Can't instantiate abstract class ConcreteFormatter with abstract met...
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_init_default_values - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_session_creation - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_success - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_http_error - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_connection_error - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_timeout - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_json_decode_error - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_generic_exception - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_get_vacancies_not_implemented - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_with_custom_timeout - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_empty_response - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_status_code_handling - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_session_attributes - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_params_handling - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_none_params - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_make_request_error_logging - NameError: name 'GetAPI' is not defined
ERROR tests/test_get_api_complete.py::TestGetAPIComplete::test_method_signatures - NameError: name 'GetAPI' is not defined
ERROR tests/test_storage_components_complete.py::TestVacancyRepository::test_init - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
ERROR tests/test_storage_components_complete.py::TestVacancyRepository::test_add_vacancy - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
ERROR tests/test_storage_components_complete.py::TestVacancyRepository::test_get_vacancies - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
ERROR tests/test_storage_components_complete.py::TestVacancyRepository::test_find_by_id - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
ERROR tests/test_storage_components_complete.py::TestVacancyRepository::test_delete_vacancy - TypeError: VacancyRepository.__init__() missing 2 required positional arguments...
======= 86 failed, 1123 passed, 85 skipped, 3 warnings, 36 errors in 12.23s ========
~/workspace$ ^C
~/workspace$ 