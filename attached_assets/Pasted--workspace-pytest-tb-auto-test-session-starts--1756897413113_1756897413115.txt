/workspace$ pytest --tb=auto
====================================== test session starts =======================================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.14.1
collected 1151 items                                                                             

tests/test_abstract.py ........                                                            [  0%]
tests/test_abstract_db_manager.py ....                                                     [  1%]
tests/test_advanced_coverage_comprehensive.py ..............................               [  3%]
tests/test_api_config.py ....                                                              [  3%]
tests/test_api_modules.py .............................                                    [  6%]
tests/test_api_modules_comprehensive.py ..F.s..F........FF.F..FF.F..F                      [  9%]
tests/test_app_config.py .....                                                             [  9%]
tests/test_base_api.py ......                                                              [  9%]
tests/test_base_formatter.py ..........                                                    [ 10%]
tests/test_base_parser.py ......                                                           [ 11%]
tests/test_cache.py .......                                                                [ 11%]
tests/test_cached_api.py ...........                                                       [ 12%]
tests/test_comprehensive_final.py ....................F..                                  [ 14%]
tests/test_config_modules_comprehensive.py FF.FFFFFF..FFFFFFF........................F.F.  [ 18%]
tests/test_console_interface.py ......                                                     [ 19%]
tests/test_core_modules_comprehensive.py FFF.F.....FF.FFF.                                 [ 20%]
tests/test_data_normalizers_comprehensive.py ............................                  [ 23%]
tests/test_database_connection.py F..F....                                                 [ 24%]
tests/test_db_config.py .....                                                              [ 24%]
tests/test_db_manager.py .................                                                 [ 25%]
tests/test_decorators.py .......                                                           [ 26%]
tests/test_env_loader.py ................                                                  [ 27%]
tests/test_final_complete_coverage.py FFFFF..FF.F.                                         [ 29%]
tests/test_get_api.py ......                                                               [ 29%]
tests/test_hh_api.py .......                                                               [ 30%]
tests/test_hh_api_config.py .....                                                          [ 30%]
tests/test_hh_parser.py ........                                                           [ 31%]
tests/test_integration.py .............                                                    [ 32%]
tests/test_main_application_interface.py F..........                                       [ 33%]
tests/test_menu_manager.py ..........                                                      [ 34%]
tests/test_missing_components.py .........                                                 [ 35%]
tests/test_paginator.py ......                                                             [ 35%]
tests/test_salary_fixed.py ...........                                                     [ 36%]
tests/test_salary_utils.py ......................                                          [ 38%]
tests/test_search_utils.py ............................                                    [ 40%]
tests/test_sj_api.py ..............                                                        [ 42%]
tests/test_sj_api_config.py .....                                                          [ 42%]
tests/test_sj_parser.py ........                                                           [ 43%]
tests/test_source_manager.py .................                                             [ 44%]
tests/test_source_selector.py .................                                            [ 46%]
tests/test_storage_factory.py ........                                                     [ 46%]
tests/test_storage_modules_comprehensive.py ....FFFFFFF.F....F.F.FF.....F....FF..........F [ 50%]
FF                                                                                         [ 50%]
tests/test_target_companies.py .....                                                       [ 51%]
tests/test_typed_data_processor.py F.............                                          [ 52%]
tests/test_ui_config.py .......................                                            [ 54%]
tests/test_ui_helpers_comprehensive.py ..................................F....             [ 58%]
tests/test_ui_helpers_extended.py ..........................F.............                 [ 61%]
tests/test_ui_interfaces_comprehensive.py FF.FF...F............................F...        [ 65%]
tests/test_ui_navigation.py ......................                                         [ 66%]
tests/test_ui_navigation_comprehensive.py .................F.....FF...                     [ 69%]
tests/test_ui_navigation_extended.py ......FFF..........................                   [ 72%]
tests/test_unified_api.py .................                                                [ 73%]
tests/test_user_interface_complete.py .F.....F.........                                    [ 75%]
tests/test_user_interface_comprehensive.py ..F......F..FFFFFFFFFFFFFFFFFFF.F               [ 78%]
tests/test_utilities_comprehensive.py .................................                    [ 81%]
tests/test_vacancy_display_handler.py F..................                                  [ 82%]
tests/test_vacancy_formatter.py ........                                                   [ 83%]
tests/test_vacancy_modules_comprehensive.py .............................F..........FF.F.F [ 87%]
.FFF.FFF..                                                                                 [ 88%]
tests/test_vacancy_operations.py ......                                                    [ 88%]
tests/test_vacancy_operations_coordinator.py ...........................                   [ 91%]
tests/test_vacancy_operations_coordinator_complete.py F.....................               [ 93%]
tests/test_vacancy_processing_coordinator.py .............                                 [ 94%]
tests/test_vacancy_repository.py .FFFF.FFFF                                                [ 95%]
tests/test_vacancy_search_handler_complete.py F......................                      [ 97%]
tests/test_vacancy_stats.py ............                                                   [ 98%]
tests/test_vacancy_stats_fixed.py .........                                                [ 98%]
tests/test_vacancy_validator.py ..........F.                                               [100%]

============================================ FAILURES ============================================
_____________________ TestHeadHunterAPI.test_hh_api_search_vacancies_success _____________________

self = <tests.test_api_modules_comprehensive.TestHeadHunterAPI object at 0x7f01e4663110>
mock_get = <MagicMock name='get' id='139646087001104'>

    @patch('requests.get')
    def test_hh_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска вакансий через HH API"""
        # Настраиваем мок ответа
        mock_response = Mock()
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Test Company", "id": "456"},
                    "salary": {"from": 100000, "to": 200000, "currency": "RUR"},
                    "snippet": {"requirement": "Python", "responsibility": "Development"}
                }
            ],
            "pages": 1,
            "per_page": 20,
            "page": 0,
            "found": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Выполняем поиск
        result = self.hh_api.get_vacancies("Python")
    
        # Проверяем результат
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:102: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.hh_api:hh_api.py:179 Ошибка получения вакансий: 'Mock' object does not support item assignment
______________________ TestSuperJobAPI.test_sj_api_search_vacancies_success ______________________

self = <tests.test_api_modules_comprehensive.TestSuperJobAPI object at 0x7f01e4669490>
mock_get = <MagicMock name='get' id='139646097750608'>

    @patch('requests.get')
    def test_sj_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска через SuperJob API"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 789,
                    "profession": "Python разработчик",
                    "link": "https://superjob.ru/vakansii/python-789.html",
                    "firm_name": "IT Company",
                    "payment_from": 120000,
                    "payment_to": 180000,
                    "currency": "rub",
                    "candidat": "Знание Python",
                    "work": "Разработка ПО"
                }
            ],
            "total": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        result = self.sj_api.get_vacancies("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:211: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.cached_api:cached_api.py:115 Ошибка кэша памяти: Object of type Mock is not JSON serializable. Переключаемся на файловый кэш
ERROR    src.api_modules.sj_api:sj_api.py:198 Failed to get vacancies: cannot access local variable 'filepath' where it is not associated with a value
_______________________ TestUnifiedAPI.test_unified_api_search_all_sources _______________________

self = <Mock name='mock.get_vacancies' id='139646086650064'>, args = ('Python',), kwargs = {}
msg = "Expected 'get_vacancies' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f01e466bed0>

    def test_unified_api_search_all_sources(self):
        """Тестирование поиска по всем источникам"""
        # Используем правильное имя метода
        if hasattr(self.unified_api, 'get_vacancies_from_sources'):
            result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh", "sj"])
        else:
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        assert isinstance(result, list)
        assert len(result) >= 0  # Может быть пустым из-за фильтрации
    
        # Проверяем, что все API были вызваны
>       self.mock_hh_api.get_vacancies.assert_called_once_with("Python")
E       AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

tests/test_api_modules_comprehensive.py:356: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 406.96page/s, vacancies=999]
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.cached_api:cached_api.py:164 Ошибка соединения с API sj: HTTP error 403: {"error":{"code":403,"message":"Ваш ключ приложения неверен","error":null}}
_____________________ TestUnifiedAPI.test_unified_api_search_specific_source _____________________

self = <Mock name='mock.get_vacancies' id='139646075814544'>, args = ('Python',), kwargs = {}
msg = "Expected 'get_vacancies' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f01e4670290>

    def test_unified_api_search_specific_source(self):
        """Тестирование поиска по конкретному источнику"""
        if hasattr(self.unified_api, 'get_vacancies_from_sources'):
            result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh"])
        else:
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        # Проверяем, что вызван только HH API
>       self.mock_hh_api.get_vacancies.assert_called_once_with("Python")
E       AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

tests/test_api_modules_comprehensive.py:367: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 533.82page/s, vacancies=999]
_________________________ TestUnifiedAPI.test_unified_api_error_handling _________________________

self = <Mock name='mock.get_vacancies' id='139646068775888'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f01e4670ed0>

    def test_unified_api_error_handling(self):
        """Тестирование обработки ошибок"""
        # Пропускаем тест, если метод не существует
        if not hasattr(self.unified_api, 'get_vacancies_from_sources'):
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        # Симулируем ошибку в одном из API
        self.mock_hh_api.get_vacancies.side_effect = Exception("HH API Error")
    
        # API должен продолжить работу с другими источниками
        result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh", "sj"])
        assert isinstance(result, list)
    
        # SJ API должен быть вызван несмотря на ошибку в HH
>       self.mock_sj_api.get_vacancies.assert_called_once()
E       AssertionError: Expected 'get_vacancies' to have been called once. Called 0 times.

tests/test_api_modules_comprehensive.py:393: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 604.77page/s, vacancies=999]
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.cached_api:cached_api.py:164 Ошибка соединения с API sj: HTTP error 403: {"error":{"code":403,"message":"Ваш ключ приложения неверен","error":null}}
__________________________ TestAPIConnector.test_api_connector_connect ___________________________

self = <urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/util/connection.py:60: in create_connection
    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'test.api', port = 443, family = <AddressFamily.AF_INET: 2>
type = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno -2] Name or service not known

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/socket.py:974: gaierror

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f01e37b9d50>, method = 'GET'
url = '/', body = None
headers = {'User-Agent': 'MyVacancyApp/1.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False
assert_same_host = False, timeout = Timeout(connect=15, read=15, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True, http_tunnel_required = False
err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:488: in _make_request
    raise new_e
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:464: in _make_request
    self._validate_conn(conn)
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:1093: in _validate_conn
    conn.connect()
.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:753: in connect
    self.sock = sock = self._new_conn()
                       ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
>           raise NameResolutionError(self.host, self, e) from e
E           urllib3.exceptions.NameResolutionError: <urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:205: NameResolutionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x7f01e37b9990>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET'
url = '/', response = None
error = NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)")
_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f01e37b9d50>
_stacktrace = <traceback object at 0x7f01e37a8700>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: / (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/urllib3/util/retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <src.api_modules.get_api.APIConnector object at 0x7f01e37b8690>, url = 'https://test.api'
params = {}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
>           response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )

src/api_modules/get_api.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7f01e37b9990>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: / (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:677: ConnectionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f01e46722d0>
mock_get = <MagicMock name='get' id='139646088219152'>

    @patch('requests.get')
    def test_api_connector_connect(self, mock_get):
        """Тестирование метода connect APIConnector"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"status": "ok"}
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Передаем пустой словарь параметров
>       result = api_connector.connect("https://test.api", params={})
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f01e37b8690>, url = 'https://test.api'
params = {}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
>           raise ConnectionError(f"Connection error: {str(e)}")
E           ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: / (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e37a8a90>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

src/api_modules/get_api.py:134: ConnectionError
_______________________ TestAPIConnector.test_api_connector_error_handling _______________________

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f01e4672890>
mock_get = <MagicMock name='get' id='139646102897360'>

    @patch('requests.get')
    def test_api_connector_error_handling(self, mock_get):
        """Тестирование обработки ошибок APIConnector"""
        import requests.exceptions
        api_connector = APIConnector()
        mock_get.side_effect = requests.exceptions.ConnectionError("Network error")
    
>       with pytest.raises(requests.exceptions.ConnectionError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:635: in __init__
    self.expected_exceptions = tuple(
.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:636: in <genexpr>
    self._parse_exc(e, expected="a BaseException type")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RaisesExc' object has no attribute 'expected_exceptions'") raised in repr()] RaisesExc object at 0x7f01e3608f10>
exc = <MagicMock name='mock.exceptions.ConnectionError' id='139646086452816'>
expected = 'a BaseException type'

    def _parse_exc(
        self, exc: type[BaseExcT_1] | types.GenericAlias, expected: str
    ) -> type[BaseExcT_1]:
        if isinstance(exc, type) and issubclass(exc, BaseException):
            if not issubclass(exc, Exception):
                self.is_baseexception = True
            return exc
        # because RaisesGroup does not support variable number of exceptions there's
        # still a use for RaisesExc(ExceptionGroup[Exception]).
        origin_exc: type[BaseException] | None = get_origin(exc)
        if origin_exc and issubclass(origin_exc, BaseExceptionGroup):
            exc_type = get_args(exc)[0]
            if (
                issubclass(origin_exc, ExceptionGroup) and exc_type in (Exception, Any)
            ) or (
                issubclass(origin_exc, BaseExceptionGroup)
                and exc_type in (BaseException, Any)
            ):
                if not isinstance(exc, Exception):
                    self.is_baseexception = True
                return cast(type[BaseExcT_1], origin_exc)
            else:
                raise ValueError(
                    f"Only `ExceptionGroup[Exception]` or `BaseExceptionGroup[BaseExeption]` "
                    f"are accepted as generic types but got `{exc}`. "
                    f"As `raises` will catch all instances of the specified group regardless of the "
                    f"generic argument specific nested exceptions has to be checked "
                    f"with `RaisesGroup`."
                )
        # unclear if the Type/ValueError distinction is even helpful here
        msg = f"expected exception must be {expected}, not "
        if isinstance(exc, type):
            raise ValueError(msg + f"{exc.__name__!r}")
        if isinstance(exc, BaseException):
            raise TypeError(msg + f"an exception instance ({type(exc).__name__})")
>       raise TypeError(msg + repr(type(exc).__name__))
E       TypeError: expected exception must be a BaseException type, not 'MagicMock'

.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:472: TypeError
________________________ TestAPIConnector.test_api_connector_with_params _________________________

self = <urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/util/connection.py:60: in create_connection
    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'test.api', port = 443, family = <AddressFamily.AF_INET: 2>
type = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno -2] Name or service not known

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/socket.py:974: gaierror

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f01e365b950>, method = 'GET'
url = '/?query=Python&page=1', body = None
headers = {'User-Agent': 'MyVacancyApp/1.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False
assert_same_host = False, timeout = Timeout(connect=15, read=15, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/', query='query=Python&page=1', fragment=None)
destination_scheme = None, conn = None, release_this_conn = True, http_tunnel_required = False
err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:488: in _make_request
    raise new_e
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:464: in _make_request
    self._validate_conn(conn)
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:1093: in _validate_conn
    conn.connect()
.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:753: in connect
    self.sock = sock = self._new_conn()
                       ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
>           raise NameResolutionError(self.host, self, e) from e
E           urllib3.exceptions.NameResolutionError: <urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:205: NameResolutionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x7f01e36596d0>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET'
url = '/?query=Python&page=1', response = None
error = NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)")
_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f01e365b950>
_stacktrace = <traceback object at 0x7f01e365b6c0>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/urllib3/util/retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <src.api_modules.get_api.APIConnector object at 0x7f01e3659590>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
>           response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )

src/api_modules/get_api.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7f01e36596d0>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:677: ConnectionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f01e46734d0>
mock_get = <MagicMock name='get' id='139646086778896'>

    @patch('requests.get')
    def test_api_connector_with_params(self, mock_get):
        """Тестирование APIConnector с параметрами"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"data": "test"}
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        params = {"query": "Python", "page": 1}
>       result = api_connector.connect("https://test.api", params=params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f01e3659590>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
>           raise ConnectionError(f"Connection error: {str(e)}")
E           ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f01e365abd0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

src/api_modules/get_api.py:134: ConnectionError
__________________________ TestAPIIntegration.test_full_search_workflow __________________________

self = <tests.test_api_modules_comprehensive.TestAPIIntegration object at 0x7f01e4680bd0>
mock_get = <MagicMock name='get' id='139646070403728'>

    @patch('requests.get')
    def test_full_search_workflow(self, mock_get):
        """Тестирование полного рабочего процесса поиска"""
        # Настраиваем ответы для всех API
        hh_response = Mock()
        hh_response.json.return_value = {
            "items": [{"id": "hh_1", "name": "HH Vacancy"}],
            "pages": 1,
            "page": 0
        }
        hh_response.status_code = 200
        hh_response.raise_for_status.return_value = None
    
        sj_response = Mock()
        sj_response.json.return_value = {
            "objects": [{"id": 1, "profession": "SJ Vacancy"}],
            "total": 1
        }
        sj_response.status_code = 200
        sj_response.raise_for_status.return_value = None
    
        # Настраиваем mock_get для возврата разных ответов
        def get_response(url, **kwargs):
            if "hh.ru" in url:
                return hh_response
            elif "superjob.ru" in url:
                return sj_response
            return Mock()
    
        mock_get.side_effect = get_response
    
        # Тестируем полный workflow
        with patch('src.config.api_config.APIConfig') as mock_hh_config, \
             patch('src.config.sj_api_config.SJAPIConfig') as mock_sj_config:
    
            # Настраиваем конфигурации
            mock_hh_config.return_value.get_base_url.return_value = "https://api.hh.ru"
            mock_hh_config.return_value.get_search_url.return_value = "https://api.hh.ru/vacancies"
            mock_hh_config.return_value.get_headers.return_value = {}
            mock_hh_config.return_value.get_default_parameters.return_value = {}
            mock_hh_config.return_value.should_filter_by_salary.return_value = False
    
            mock_sj_config.return_value.get_base_url.return_value = "https://api.superjob.ru"
            mock_sj_config.return_value.get_search_url.return_value = "https://api.superjob.ru/2.0/vacancies/"
            mock_sj_config.return_value.get_headers.return_value = {}
            mock_sj_config.return_value.get_default_parameters.return_value = {}
            mock_sj_config.return_value.should_filter_by_salary.return_value = False
    
            unified_api = UnifiedAPI()
>           result = unified_api.get_vacancies("Python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_modules_comprehensive.py:580: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestSpecialModules.test_vacancy_storage_service_full_coverage __________________

self = <tests.test_comprehensive_final.TestSpecialModules object at 0x7f01e46f3390>
mock_connect = <MagicMock name='connect' id='139646086695184'>

    @patch('psycopg2.connect')
    def test_vacancy_storage_service_full_coverage(self, mock_connect):
        """Полное покрытие vacancy_storage_service"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.execute.return_value = None
        mock_cursor.fetchone.return_value = (1, 'Test Company', '123')
        mock_cursor.fetchall.return_value = [(1, 'vacancy1'), (2, 'vacancy2')]
        mock_cursor.rowcount = 5
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
>           storage = VacancyStorageService()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_comprehensive_final.py:770: TypeError
__________________________ TestAPIConfig.test_api_config_initialization __________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f01e450cfd0>

    def test_api_config_initialization(self):
        """Тестирование инициализации базовой конфигурации API"""
        config = APIConfig()
        assert config is not None
>       assert hasattr(config, 'get_base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.api_config.APIConfig object at 0x7f01e2350050>, 'get_base_url')

tests/test_config_modules_comprehensive.py:34: AssertionError
_________________________ TestAPIConfig.test_api_config_abstract_methods _________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f01e450d5d0>

    def test_api_config_abstract_methods(self):
        """Тестирование абстрактных методов базовой конфигурации"""
        config = APIConfig()
    
        # Базовая конфигурация должна возвращать значения по умолчанию
>       base_url = config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:43: AttributeError
______________________________ TestHHAPIConfig.test_hh_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450e490>

    def test_hh_config_urls(self):
        """Тестирование URL конфигурации HH"""
        # Проверяем базовые атрибуты конфигурации
>       assert hasattr(self.config, 'api_url') or hasattr(self.config, 'base_url')
E       AssertionError: assert (False or False)
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}), 'api_url')
E        +    where HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}) = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450e490>.config
E        +  and   False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}), 'base_url')
E        +    where HHAPIConfig(area=113, per_page=50, only_with_salary=True, period=15, custom_params={}) = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450e490>.config

tests/test_config_modules_comprehensive.py:68: AssertionError
_____________________________ TestHHAPIConfig.test_hh_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450ea90>

    def test_hh_config_headers(self):
        """Тестирование заголовков HTTP для HH API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:81: AttributeError
_______________________ TestHHAPIConfig.test_hh_config_default_parameters ________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450f0d0>

    def test_hh_config_default_parameters(self):
        """Тестирование параметров по умолчанию для HH API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:90: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_enabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450f650>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_hh_config_salary_filter_enabled(self):
        """Тестирование фильтрации по зарплате когда включена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:102: AttributeError
_____________________ TestHHAPIConfig.test_hh_config_salary_filter_disabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e450fbd0>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'false'})
    def test_hh_config_salary_filter_disabled(self):
        """Тестирование фильтрации по зарплате когда отключена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:109: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_default ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f01e4520190>

    @patch.dict(os.environ, {}, clear=True)
    def test_hh_config_salary_filter_default(self):
        """Тестирование значения по умолчанию для фильтрации по зарплате"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:116: AttributeError
______________________________ TestSJAPIConfig.test_sj_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4521650>

    def test_sj_config_urls(self):
        """Тестирование URL конфигурации SuperJob"""
>       base_url = self.config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:144: AttributeError
_____________________________ TestSJAPIConfig.test_sj_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4521c50>

    def test_sj_config_headers(self):
        """Тестирование заголовков HTTP для SuperJob API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:154: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_with_api_key ___________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4522210>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'test_api_key_123'})
    def test_sj_config_with_api_key(self):
        """Тестирование конфигурации с API ключом"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:165: AttributeError
_________________________ TestSJAPIConfig.test_sj_config_without_api_key _________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4522790>

    @patch.dict(os.environ, {}, clear=True)
    def test_sj_config_without_api_key(self):
        """Тестирование конфигурации без API ключа"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:174: AttributeError
___________________________ TestSJAPIConfig.test_sj_config_parameters ____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4522d90>

    def test_sj_config_parameters(self):
        """Тестирование параметров SuperJob API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:181: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_salary_filter __________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f01e4523390>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_sj_config_salary_filter(self):
        """Тестирование фильтрации по зарплате в SuperJob"""
        config = SJAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:193: AttributeError
________________________ TestDatabaseConfig.test_db_config_initialization ________________________

self = <tests.test_config_modules_comprehensive.TestDatabaseConfig object at 0x7f01e450e250>

    def test_db_config_initialization(self):
        """Тестирование инициализации конфигурации БД"""
        assert self.config is not None
        assert hasattr(self.config, 'default_config')
        # Исправленная проверка на допустимые типы хранилищ
>       assert self.config.default_storage_type in ["postgresql", "json", "memory", "postgres"]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'default_storage_type'

tests/test_config_modules_comprehensive.py:209: AttributeError
________________________ TestTargetCompanies.test_company_ids_extraction _________________________

self = <tests.test_config_modules_comprehensive.TestTargetCompanies object at 0x7f01e4531810>

    def test_company_ids_extraction(self):
        """Тестирование извлечения ID компаний"""
        if hasattr(self.companies, 'get_all_ids'):
            all_ids = self.companies.get_all_ids()
>           assert isinstance(all_ids, list)
E           AssertionError: assert False
E            +  where False = isinstance({'1057', '1122', '1145', '1165', '12258', '1237', ...}, list)

tests/test_config_modules_comprehensive.py:504: AssertionError
__________________ TestConfigIntegration.test_environment_variables_propagation __________________

self = <tests.test_config_modules_comprehensive.TestConfigIntegration object at 0x7f01e4532b90>

    @patch.dict(os.environ, {
        'LOG_LEVEL': 'INFO',
        'CACHE_TTL': '7200',
        'FILTER_ONLY_WITH_SALARY': 'true',
        'DATABASE_URL': 'postgresql://test:test@localhost:5432/test'
    })
    def test_environment_variables_propagation(self):
        """Тестирование распространения переменных окружения между конфигурациями"""
        # Проверяем, что переменные окружения корректно используются
        app_config = AppConfig()
        db_config = DatabaseConfig()
        hh_config = HHAPIConfig()
    
        # Все конфигурации должны учитывать переменные окружения
        if hasattr(app_config, 'get_log_level'):
            assert app_config.get_log_level() == 'INFO'
    
        if hasattr(app_config, 'get_cache_ttl'):
            assert app_config.get_cache_ttl() == 7200
    
        db_config_values = db_config.get_config()
        assert db_config_values['host'] == 'localhost'
        assert db_config_values['database'] == 'test'
    
>       assert hh_config.should_filter_by_salary() is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:561: AttributeError
_______________________ TestUserInterfaceModule.test_main_function_success _______________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f01e459e4d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e458a9d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_db_connection_error _________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f01e459eb90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e459c350>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_keyboard_interrupt __________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f01e459f1d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e459c750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestDBManagerComprehensive.test_check_connection_success ____________________

self = <tests.test_core_modules_comprehensive.TestDBManagerComprehensive object at 0x7f01e45a4210>

    def test_check_connection_success(self) -> None:
        """Тестирование успешной проверки подключения"""
        with patch.object(self.db_manager, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.cursor.return_value = mock_cursor
            mock_get_conn.return_value = mock_connection
    
            result = self.db_manager.check_connection()
    
>           assert result is True
E           assert False is True

tests/test_core_modules_comprehensive.py:195: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.storage.db_manager:db_manager.py:790 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
________________________ TestVacancyModels.test_vacancy_validation_valid _________________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f01e45a6190>

    def test_vacancy_validation_valid(self) -> None:
        """Тестирование валидации корректной вакансии"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="Python Developer",
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is True
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:292: AttributeError
____________________ TestVacancyModels.test_vacancy_validation_invalid_title _____________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f01e45a6850>

    def test_vacancy_validation_invalid_title(self) -> None:
        """Тестирование валидации вакансии с некорректным названием"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="",  # Пустое название
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is False
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:303: AttributeError
___________________ TestAppConfigComprehensive.test_app_config_default_values ____________________

self = <tests.test_core_modules_comprehensive.TestAppConfigComprehensive object at 0x7f01e45a7690>

    def test_app_config_default_values(self) -> None:
        """Тестирование значений по умолчанию"""
        config = AppConfig()
    
        # Проверяем, что есть тип хранилища по умолчанию
>       assert config.default_storage_type in ["postgresql", "json", "memory"]
E       AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
E        +  where 'postgres' = <src.config.app_config.AppConfig object at 0x7f01e24a72d0>.default_storage_type

tests/test_core_modules_comprehensive.py:321: AssertionError
________________ TestStorageFactoryComprehensive.test_storage_factory_postgresql _________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f01e45a7f50>

    def test_storage_factory_postgresql(self) -> None:
        """Тестирование создания PostgreSQL хранилища"""
>       storage = StorageFactory.create_storage("postgresql")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:329: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
___________________ TestStorageFactoryComprehensive.test_storage_factory_json ____________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f01e45b0610>

    def test_storage_factory_json(self) -> None:
        """Тестирование создания JSON хранилища"""
>       storage = StorageFactory.create_storage("json")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'json'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: json

src/storage/storage_factory.py:20: ValueError
______________________ TestDatabaseConnection.test_database_connection_init ______________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f01e46c3ad0>
mock_connect = <MagicMock name='connect' id='139646085546576'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_database_connection_init(self, mock_connect):
        """Тест инициализации подключения к базе данных"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
    
        assert db_conn is not None
>       assert hasattr(db_conn, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.database_connection.DatabaseConnection object at 0x7f01e24b4ed0>, 'config')

tests/test_database_connection.py:38: AssertionError
__________________________ TestDatabaseConnection.test_close_connection __________________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f01e45c94d0>
mock_connect = <MagicMock name='connect' id='139646067833936'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_close_connection(self, mock_connect):
        """Тест закрытия подключения"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
        connection = db_conn.get_connection()
>       db_conn.close_connection(connection)
E       TypeError: DatabaseConnection.close_connection() takes 1 positional argument but 2 were given

tests/test_database_connection.py:70: TypeError
______________ TestCompleteAPIModuleCoverage.test_headhunter_api_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f01e4426510>
mock_get = <MagicMock name='get' id='139646068034704'>

    @patch('requests.get')
    def test_headhunter_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование HeadHunter API клиента.
    
        Покрывает все специфичные для HH.ru функции:
        - Поиск вакансий с различными параметрами
        - Получение детальной информации о вакансии
        - Обработка пагинации результатов
        - Работа с фильтрами по компаниям и регионам
        - Обработка rate limiting и ошибок API
        """
        mock_get.return_value = self.mocks['hh_response']
    
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            api = HeadHunterAPI()
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('python developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:159: AttributeError
_______________ TestCompleteAPIModuleCoverage.test_superjob_api_complete_coverage ________________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f01e4426ad0>
mock_get = <MagicMock name='get' id='139646102282960'>

    @patch('requests.get')
    def test_superjob_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование SuperJob API клиента.
    
        Покрывает все специфичные для SuperJob.ru функции:
        - Аутентификация с API ключом
        - Поиск вакансий с различными критериями
        - Обработка специфичного формата данных SuperJob
        - Работа с профессиональными каталогами
        - Региональная фильтрация
        """
        # Настраиваем мок для SuperJob ответа
        sj_response = Mock()
        sj_response.json.return_value = {
            'objects': [
                {
                    'id': 456,
                    'profession': 'Java Developer',
                    'firm_name': 'Dev Company',
                    'payment_from': 120000,
                    'payment_to': 180000,
                    'currency': 'rub'
                }
            ],
            'total': 1
        }
        mock_get.return_value = sj_response
    
        try:
            from src.api_modules.sj_api import SuperJobAPI
    
            api = SuperJobAPI('test_api_key')
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('java developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:210: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestCompleteStorageModuleCoverage.test_db_manager_complete_coverage _______________

self = <Mock name='mock.connect().cursor().execute' id='139646074859920'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f01e4427350>
mock_connect = <MagicMock name='connect' id='139646075509648'>

    @patch('psycopg2.connect')
    def test_db_manager_complete_coverage(self, mock_connect: Mock) -> None:
        """
        Полное тестирование менеджера базы данных.
    
        Покрывает все операции с PostgreSQL:
        - Создание подключения и проверка доступности
        - Создание таблиц и индексов
        - Операции CRUD для вакансий и компаний
        - Сложные запросы и агрегации
        - Транзакции и откаты
        """
        mock_connect.return_value = self.mocks['connection']
    
        try:
            from src.storage.db_manager import DBManager
    
            db = DBManager()
            assert db is not None
    
            # Тестируем проверку подключения
            is_connected = db.check_connection()
            assert isinstance(is_connected, bool)
    
            # Тестируем создание таблиц
            db.create_tables()
>           self.mocks['cursor'].execute.assert_called()
E           AssertionError: Expected 'execute' to have been called.

tests/test_final_complete_coverage.py:259: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646086982992'>, исправляем...
____________ TestCompleteStorageModuleCoverage.test_storage_factory_complete_coverage ____________

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f01e44275d0>

    def test_storage_factory_complete_coverage(self) -> None:
        """
        Полное тестирование фабрики хранилищ.
    
        Покрывает создание различных типов хранилищ:
        - PostgreSQL хранилище
        - JSON файловое хранилище
        - In-memory хранилище для тестов
        - Автоматический выбор хранилища по конфигурации
        """
        try:
            from src.storage.storage_factory import StorageFactory
    
            # Тестируем создание PostgreSQL хранилища
            with patch('psycopg2.connect', return_value=self.mocks['connection']):
>               pg_storage = StorageFactory.create_storage('postgresql')
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_complete_coverage.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
_______________ TestCompleteUIModuleCoverage.test_user_interface_complete_coverage _______________

self = <MagicMock name='print' id='139646071438928'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteUIModuleCoverage object at 0x7f01e4427bd0>
mock_print = <MagicMock name='print' id='139646071438928'>
mock_input = <MagicMock name='input' id='139646071435856'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_user_interface_complete_coverage(self, mock_print: Mock, mock_input: Mock) -> None:
        """
        Полное тестирование основного пользовательского интерфейса.
    
        Покрывает все сценарии взаимодействия:
        - Отображение главного меню
        - Навигация между разделами
        - Поиск вакансий с различными параметрами
        - Просмотр статистики и результатов
        - Обработка некорректного ввода
        """
        mock_input.return_value = '0'  # Выход из приложения
    
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            mock_storage = Mock()
            mock_db_manager = Mock()
            mock_db_manager.get_companies_and_vacancies_count.return_value = [
                {'company': 'Tech Corp', 'vacancies': 15}
            ]
    
            ui = UserInterface(mock_storage, mock_db_manager)
            assert ui is not None
    
            # Проверяем, что были вызовы print (отображение меню)
>           mock_print.assert_called()
E           AssertionError: Expected 'print' to have been called.

tests/test_final_complete_coverage.py:334: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestCompleteUtilityModuleCoverage.test_salary_comprehensive ___________________

self = <tests.test_final_complete_coverage.TestCompleteUtilityModuleCoverage object at 0x7f01e4434f90>

    def test_salary_comprehensive(self) -> None:
        """
        Полное тестирование класса Salary.
    
        Покрывает все аспекты работы с зарплатами:
        - Инициализация с различными параметрами
        - Валидация входных данных
        - Вычисление средних значений
        - Форматирование для отображения
        - Сравнение зарплатных предложений
        """
        try:
            from src.utils.salary import Salary
    
            # Тестируем полную зарплату
            salary_data = {'from': 100000, 'to': 200000, 'currency': 'RUR'}
            salary = Salary(salary_data)
            assert salary.salary_from == 100000
            assert salary.salary_to == 200000
            assert salary.currency == 'RUR'
    
            # Тестируем вычисление средней зарплаты
>           average = salary.get_average()
                      ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'Salary' object has no attribute 'get_average'

tests/test_final_complete_coverage.py:425: AttributeError
_____________ TestCompleteVacancyModelCoverage.test_vacancy_model_complete_coverage ______________

self = <tests.test_final_complete_coverage.TestCompleteVacancyModelCoverage object at 0x7f01e44357d0>

    def test_vacancy_model_complete_coverage(self) -> None:
        """
        Полное тестирование модели вакансии.
    
        Покрывает все аспекты вакансии:
        - Создание с полными и частичными данными
        - Валидация обязательных полей
        - Методы сравнения и сортировки
        - Сериализация в JSON и словари
        - Вычисляемые свойства и методы
        """
        try:
            from src.vacancies.models import Vacancy, Employer
    
            # Создаем полную вакансию
            employer = Employer("Test Company", "123")
            vacancy = Vacancy(
                title="Senior Python Developer",
                employer=employer,
                url="https://example.com/vacancy/12345"
            )
    
            assert vacancy is not None
            assert vacancy.title == "Senior Python Developer"
            assert vacancy.employer.name == "Test Company"
    
            # Тестируем валидацию
>           assert vacancy.is_valid() is True
                   ^^^^^^^^^^^^^^^^
E           AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_final_complete_coverage.py:474: AttributeError
______________ TestCompleteConfigurationCoverage.test_app_config_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteConfigurationCoverage object at 0x7f01e4436650>

    def test_app_config_complete_coverage(self) -> None:
        """
        Полное тестирование общей конфигурации приложения.
    
        Покрывает основные настройки:
        - Выбор типа хранилища по умолчанию
        - Настройки логирования
        - Конфигурация кэширования
        - Параметры производительности
        - Режимы работы (debug/production)
        """
        try:
            from src.config.app_config import AppConfig
    
            config = AppConfig()
            assert config is not None
    
            # Тестируем основные настройки
            assert hasattr(config, 'default_storage_type')
            storage_type = config.default_storage_type
>           assert storage_type in ['postgresql', 'json', 'memory']
E           AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']

tests/test_final_complete_coverage.py:543: AssertionError
_______________ TestMainApplicationInterface.test_main_application_interface_init ________________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f01e4474e90>

    def test_main_application_interface_init(self):
        """Тест инициализации главного интерфейса приложения"""
>       interface = MainApplicationInterface()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_main_application_interface.py:49: TypeError
__________________________ TestDBManager.test_db_manager_initialization __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e439e8d0>
mock_connect = <MagicMock name='connect' id='139646085575760'>

    @patch('psycopg2.connect')
    def test_db_manager_initialization(self, mock_connect):
        """Тестирование инициализации менеджера БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        assert self.db_manager is not None
>       assert hasattr(self.db_manager, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.db_manager.DBManager object at 0x7f01e350e350>, 'config')
E        +    where <src.storage.db_manager.DBManager object at 0x7f01e350e350> = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e439e8d0>.db_manager

tests/test_storage_modules_comprehensive.py:106: AssertionError
______________________ TestDBManager.test_get_companies_and_vacancies_count ______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e439ee90>
mock_connect = <MagicMock name='connect' id='139646085413840'>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect):
        """Тестирование получения количества компаний и вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 10),
            ('Company B', 15),
            ('Company C', 5)
        ]
        mock_connect.return_value = mock_conn
    
        # Мокаем проверку подключения
        with patch.object(self.db_manager, 'check_connection', return_value=True):
            result = self.db_manager.get_companies_and_vacancies_count()
    
>       assert isinstance(result, list)
E       AssertionError: assert False
E        +  where False = isinstance(<MagicMock name='mock.__enter__().cursor().__enter__().fetchall()' id='139646067729168'>, list)

tests/test_storage_modules_comprehensive.py:132: AssertionError
______________________________ TestDBManager.test_get_all_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e439f510>
mock_connect = <MagicMock name='connect' id='139646085507408'>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тестирование получения всех вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 100000, 'https://test.com/1'),
            ('Company B', 'Java Developer', 120000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        with patch.object(self.db_manager, 'check_connection', return_value=True):
            result = self.db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:158: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646068437776'>, исправляем...
_______________________________ TestDBManager.test_get_avg_salary ________________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e439fbd0>
mock_connect = <MagicMock name='connect' id='139646074654032'>

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тестирование получения средней зарплаты"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (125000.0,)
        mock_connect.return_value = mock_conn
    
        with patch.object(self.db_manager, 'check_connection', return_value=True):
            result = self.db_manager.get_avg_salary()
    
        assert isinstance(result, float)
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_storage_modules_comprehensive.py:180: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646074487056'>, исправляем...
______________________ TestDBManager.test_get_vacancies_with_higher_salary _______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e43a4290>
mock_connect = <MagicMock name='connect' id='139646074977296'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тестирование получения вакансий с зарплатой выше средней"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Senior Python Developer', 150000, 'https://test.com/1'),
            ('Company B', 'Lead Java Developer', 180000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        with patch.object(self.db_manager, 'check_connection', return_value=True):
            result = self.db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:205: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646067833936'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646084856848'>, исправляем...
_________________________ TestDBManager.test_get_vacancies_with_keyword __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e43a4910>
mock_connect = <MagicMock name='connect' id='139646067722640'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect):
        """Тестирование поиска вакансий по ключевому слову"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 120000, 'https://test.com/1')
        ]
        mock_connect.return_value = mock_conn
    
        with patch.object(self.db_manager, 'check_connection', return_value=True):
            result = self.db_manager.get_vacancies_with_keyword("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:229: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139646075221136'>, исправляем...
____________________ TestDBManager.test_db_manager_connection_error_handling _____________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f01e43a4f90>
mock_connect = <MagicMock name='connect' id='139646074858128'>

    @patch('psycopg2.connect')
    def test_db_manager_connection_error_handling(self, mock_connect):
        """Тестирование обработки ошибок подключения"""
        mock_connect.side_effect = Exception("Connection failed")
    
        # Методы должны обрабатывать ошибки подключения
        with patch.object(self.db_manager, 'check_connection', side_effect=Exception("Connection check failed")):
>           result = self.db_manager.get_companies_and_vacancies_count()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/db_manager.py:307: in get_companies_and_vacancies_count
    if not self.check_connection():
           ^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='check_connection' id='139646088065936'>, args = (), kwargs = {}
effect = Exception('Connection check failed')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Connection check failed

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
_____________________________ TestPostgresSaver.test_save_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestPostgresSaver object at 0x7f01e43a5f10>
mock_connect = <MagicMock name='connect' id='139646075041424'>

    @patch('psycopg2.connect')
    def test_save_vacancies(self, mock_connect):
        """Тестирование сохранения вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        vacancies = [create_mock_vacancy() for _ in range(3)]
    
        self.postgres_saver.save_vacancies(vacancies)
    
        # Проверяем, что курсор был использован для выполнения запросов
>       assert mock_cursor.execute.called
E       AssertionError: assert False
E        +  where False = <Mock name='connect().cursor().execute' id='139646067941072'>.called
E        +    where <Mock name='connect().cursor().execute' id='139646067941072'> = <Mock name='connect().cursor()' id='139646075824784'>.execute

tests/test_storage_modules_comprehensive.py:288: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139646067634384'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139646088161808'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139646088153424'>
_________________________ TestStorageFactory.test_create_invalid_storage _________________________

self = <tests.test_storage_modules_comprehensive.TestStorageFactory object at 0x7f01e43a8210>

    def test_create_invalid_storage(self):
        """Тестирование создания несуществующего типа хранилища"""
>       storage = StorageFactory.create_storage("invalid_type")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'invalid_type'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: invalid_type

src/storage/storage_factory.py:20: ValueError
_________________ TestDatabaseConnection.test_database_connection_establishment __________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f01e43a9110>
mock_connect = <MagicMock name='connect' id='139646074849680'>

    @patch('psycopg2.connect')
    def test_database_connection_establishment(self, mock_connect):
        """Тестирование установки подключения к БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        connection = self.db_connection.get_connection()
    
        if connection:
>           assert connection == mock_conn
E           AssertionError: assert <MagicMock name='mock.connect()' id='139646085577232'> == <Mock name='connect()' id='139646074863504'>

tests/test_storage_modules_comprehensive.py:390: AssertionError
_________________ TestDatabaseConnection.test_database_connection_error_handling _________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f01e43a9e90>

    def test_database_connection_error_handling(self):
        """Тестирование обработки ошибок подключения"""
        with patch('psycopg2.connect', side_effect=Exception("Connection failed")):
            connection = self.db_connection.get_connection()
>           assert connection is None
E           AssertionError: assert <MagicMock name='mock.connect()' id='139646085577232'> is None

tests/test_storage_modules_comprehensive.py:406: AssertionError
__________________ TestVacancyRepository.test_vacancy_repository_initialization __________________

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f01e43a55d0>

    def test_vacancy_repository_initialization(self):
        """Тестирование инициализации репозитория вакансий"""
        assert self.vacancy_repository is not None
>       assert hasattr(self.vacancy_repository, 'db_manager')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e3511cd0>, 'db_manager')
E        +    where <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e3511cd0> = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f01e43a55d0>.vacancy_repository

tests/test_storage_modules_comprehensive.py:424: AssertionError
___________________________ TestVacancyRepository.test_delete_vacancy ____________________________

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e351a750>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:159: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f01e43aaa50>

    def test_delete_vacancy(self):
        """Тестирование удаления вакансии"""
        if hasattr(self.vacancy_repository, 'delete_vacancy'):
>           result = self.vacancy_repository.delete_vacancy("test_123")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e351a750>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
            with self._db_connection.get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute(
                        "DELETE FROM vacancies WHERE vacancy_id = %s",
                        (vacancy.vacancy_id,)
                    )
                    conn.commit()
    
                    if cursor.rowcount > 0:
                        logger.debug(f"Вакансия {vacancy.vacancy_id} успешно удалена")
                    else:
                        logger.warning(f"Вакансия {vacancy.vacancy_id} не найдена для удаления")
    
        except Exception as e:
>           logger.error(f"Ошибка удаления вакансии {vacancy.vacancy_id}: {e}")
                                                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/components/vacancy_repository.py:173: AttributeError
________________________ TestVacancyValidator.test_get_validation_errors _________________________

self = <tests.test_storage_modules_comprehensive.TestVacancyValidator object at 0x7f01e43b4bd0>

    def test_get_validation_errors(self):
        """Тестирование получения ошибок валидации"""
        vacancy = Mock()
        vacancy.vacancy_id = ""
        vacancy.title = ""
        vacancy.url = "invalid_url"
    
        if hasattr(self.validator, 'get_validation_errors'):
>           errors = self.validator.get_validation_errors(vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given

tests/test_storage_modules_comprehensive.py:526: TypeError
_________________ TestVacancyStorageService.test_storage_service_initialization __________________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f01e43b5490>

    def test_storage_service_initialization(self):
        """Тестирование инициализации сервиса хранения"""
        assert self.storage_service is not None
>       assert hasattr(self.storage_service, 'storage')
E       AssertionError: assert False
E        +  where False = hasattr(<tests.test_storage_modules_comprehensive.TestVacancyStorageService.setup_method.<locals>.TestVacancyStorageService object at 0x7f01e24dd050>, 'storage')
E        +    where <tests.test_storage_modules_comprehensive.TestVacancyStorageService.setup_method.<locals>.TestVacancyStorageService object at 0x7f01e24dd050> = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f01e43b5490>.storage_service

tests/test_storage_modules_comprehensive.py:554: AssertionError
_______________________ TestStorageIntegration.test_full_storage_workflow ________________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f01e43aaed0>
mock_connect = <MagicMock name='connect' id='139646074650768'>

    @patch('psycopg2.connect')
    def test_full_storage_workflow(self, mock_connect):
        """Тестирование полного рабочего процесса хранения"""
        mock_conn = Mock()
        mock_cursor = Mock()
    
        # Настраиваем context manager
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Создаем компоненты
>       with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:699: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2777010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________________ TestStorageIntegration.test_storage_error_recovery _______________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f01e43a6750>

    def test_storage_error_recovery(self):
        """Тестирование восстановления после ошибок хранения"""
        with patch('psycopg2.connect', side_effect=Exception("Database unavailable")):
>           with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:715: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2485c90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestStorageIntegration.test_storage_performance_simulation ___________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f01e43b8790>

    def test_storage_performance_simulation(self):
        """Симуляция тестирования производительности хранения"""
        # Создаем большое количество вакансий
        large_vacancy_list = [create_mock_vacancy() for _ in range(100)]
    
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
    
            # Настраиваем context manager
            mock_conn.__enter__ = Mock(return_value=mock_conn)
            mock_conn.__exit__ = Mock(return_value=None)
            mock_cursor.__enter__ = Mock(return_value=mock_cursor)
            mock_cursor.__exit__ = Mock(return_value=None)
    
            mock_conn.cursor.return_value = mock_cursor
            mock_connect.return_value = mock_conn
    
>           with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:747: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e350a510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestTypedDataProcessor.test_typed_data_processor_init ______________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f01e43dce90>

    def test_typed_data_processor_init(self):
        """Тест инициализации процессора типизированных данных"""
>       processor = TypedDataProcessor()
                    ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:48: TypeError
______________________ TestUIHelpersIntegration.test_salary_input_workflow _______________________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpersIntegration object at 0x7f01e4180b50>
mock_print = <MagicMock name='print' id='139646085482576'>
mock_input = <MagicMock name='input' id='139646070434512'>

    @patch('builtins.input', side_effect=['100000 - 150000'])
    @patch('builtins.print')
    def test_salary_input_workflow(self, mock_print, mock_input):
        """Тестирование рабочего процесса ввода зарплаты"""
        if not SRC_AVAILABLE:
            pytest.skip("Source code not available")
    
        # Симулируем ввод диапазона зарплат
        salary_input = mock_input.return_value
        result = parse_salary_range(salary_input)
    
>       assert result == (100000, 150000)
E       assert None == (100000, 150000)

tests/test_ui_helpers_comprehensive.py:463: AssertionError
____________________ TestUIHelpersExtended.test_parse_search_query_mixed_case ____________________

self = <tests.test_ui_helpers_extended.TestUIHelpersExtended object at 0x7f01e4155f90>

    def test_parse_search_query_mixed_case(self):
        """Тестирование парсинга в смешанном регистре"""
        result = _parse_search_query("python and django")
>       assert result == {"keywords": ["python", "django"], "operator": "AND"}
E       AssertionError: assert {'keywords': ...rator': 'AND'} == {'keywords': ...rator': 'AND'}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'keywords': ['python and django']} != {'keywords': ['python', 'django']}
E         Use -v to get more diff

tests/test_ui_helpers_extended.py:275: AssertionError
_____________________ TestUserInterface.test_main_interface_startup_and_exit _____________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f01e4139090>
mock_input = <MagicMock name='input' id='139646075768400'>

    @patch('builtins.input', return_value='0')
    def test_main_interface_startup_and_exit(self, mock_input):
        """Тестирование запуска и выхода из главного интерфейса"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2bd8ed0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestUserInterface.test_main_interface_menu_navigation ______________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f01e4147b90>
mock_input = <MagicMock name='input' id='139646085083280'>

    @patch('builtins.input', side_effect=['1', '0'])
    def test_main_interface_menu_navigation(self, mock_input):
        """Тестирование навигации по меню главного интерфейса"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e34b9ed0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestUserInterface.test_cache_clearing_option __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f01e412f4d0>
mock_input = <MagicMock name='input' id='139646085256848'>

    @patch('builtins.input', side_effect=['8', '0'])
    def test_cache_clearing_option(self, mock_input):
        """Тестирование опции очистки кэша"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e34e7090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________________ TestUserInterface.test_db_manager_demo_option __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f01e412fc90>
mock_input = <MagicMock name='input' id='139646071629968'>

    @patch('builtins.input', side_effect=['10', '0'])
    def test_db_manager_demo_option(self, mock_input):
        """Тестирование опции демонстрации DBManager"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e27e7d50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________________ TestSourceSelector.test_get_user_source_choice _________________________

self = <tests.test_ui_interfaces_comprehensive.TestSourceSelector object at 0x7f01e412f010>
mock_input = <MagicMock name='input' id='139646085496016'>

    @patch('builtins.input', return_value='1')
    def test_get_user_source_choice(self, mock_input):
        """Тестирование получения выбора источника пользователем"""
        if hasattr(self.source_selector, 'get_user_source_choice'):
            choice = self.source_selector.get_user_source_choice()
    
            # Результат может быть списком источников или None
>           assert choice is None or isinstance(choice, list)
E           AssertionError: assert ({'hh.ru'} is None or False)
E            +  where False = isinstance({'hh.ru'}, list)

tests/test_ui_interfaces_comprehensive.py:149: AssertionError
-------------------------------------- Captured stdout call --------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Выбран источник: HH.ru
_________________________ TestUIPerformance.test_pagination_performance __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUIPerformance object at 0x7f01e42588d0>

    def test_pagination_performance(self):
        """Тестирование производительности пагинации"""
        large_dataset = list(range(10000))
    
        from src.utils.paginator import Paginator
>       paginator = Paginator(large_dataset, page_size=100)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_interfaces_comprehensive.py:580: TypeError
___________________ TestUINavigation.test_handle_navigation_choice_page_number ___________________

self = <tests.test_ui_navigation_comprehensive.TestUINavigation object at 0x7f01e42d3790>

    def test_handle_navigation_choice_page_number(self):
        """Тестирование прямого указания номера страницы"""
        result = self.ui_nav._handle_navigation_choice("3", 1, 5)
        assert result == 3
    
        # Некорректный номер страницы
>       result = self.ui_nav._handle_navigation_choice("10", 1, 5)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_navigation_comprehensive.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/ui_navigation.py:153: in _handle_navigation_choice
    input("Нажмите Enter для продолжения...")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f01e4d12b10>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
-------------------------------------- Captured stdout call --------------------------------------
Некорректный номер страницы. Доступно: 1-5
Нажмите Enter для продолжения...
__________________________ TestQuickPaginate.test_quick_paginate_basic ___________________________

self = <tests.test_ui_navigation_comprehensive.TestQuickPaginate object at 0x7f01e42d2350>
mock_print = <MagicMock name='print' id='139646069912656'>
mock_input = <MagicMock name='input' id='139646070146960'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_quick_paginate_basic(self, mock_print, mock_input):
        """Базовое тестирование quick_paginate"""
        mock_input.return_value = "q"
    
        items = ["item1", "item2", "item3"]
>       quick_paginate(items, self.test_formatter, "Quick Test", items_per_page=2)

tests/test_ui_navigation_comprehensive.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/ui_navigation.py:246: in quick_paginate
    navigator.paginate_display(items, formatter, header, show_numbers, custom_actions)
src/utils/ui_navigation.py:47: in paginate_display
    self._display_page(items, current_page, total_pages, formatter, header, show_numbers)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.ui_navigation.UINavigation object at 0x7f01e267e4d0>
items = ['item1', 'item2', 'item3'], current_page = 1, total_pages = 2
formatter = <bound method TestQuickPaginate.test_formatter of <tests.test_ui_navigation_comprehensive.TestQuickPaginate object at 0x7f01e42d2350>>
header = 'Quick Test', show_numbers = True

    def _display_page(
        self,
        items: List[Any],
        current_page: int,
        total_pages: int,
        formatter: Callable[[Any, Optional[int]], str],
        header: str,
        show_numbers: bool,
    ) -> None:
        """Отображение текущей страницы"""
        # Вычисление индексов для текущей страницы
        start_idx = (current_page - 1) * self.items_per_page
        end_idx = min(start_idx + self.items_per_page, len(items))
        current_items = items[start_idx:end_idx]
    
        print(f"\n\n{header}")
        print("=" * len(header))
    
        # Отображение элементов
        for i, item in enumerate(current_items, start_idx + 1):
            if show_numbers:
>               formatted_item = formatter(item, i)
                                 ^^^^^^^^^^^^^^^^^^
E               TypeError: TestQuickPaginate.test_formatter() takes 1 positional argument but 3 were given

src/utils/ui_navigation.py:92: TypeError
___________________ TestQuickPaginate.test_quick_paginate_with_custom_actions ____________________

self = <tests.test_ui_navigation_comprehensive.TestQuickPaginate object at 0x7f01e42d24d0>
mock_print = <MagicMock name='print' id='139646066707792'>
mock_input = <MagicMock name='input' id='139646066706576'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_quick_paginate_with_custom_actions(self, mock_print, mock_input):
        """Тестирование quick_paginate с пользовательскими действиями"""
        mock_input.side_effect = ["c", "q"]
    
        action_called = False
        def custom_action():
            nonlocal action_called
            action_called = True
    
        custom_actions = {"c": custom_action}
        items = ["item1", "item2", "item3"]
    
>       quick_paginate(
            items,
            self.test_formatter,
            "Quick Test",
            custom_actions=custom_actions
        )

tests/test_ui_navigation_comprehensive.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/ui_navigation.py:246: in quick_paginate
    navigator.paginate_display(items, formatter, header, show_numbers, custom_actions)
src/utils/ui_navigation.py:47: in paginate_display
    self._display_page(items, current_page, total_pages, formatter, header, show_numbers)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.ui_navigation.UINavigation object at 0x7f01e2335d50>
items = ['item1', 'item2', 'item3'], current_page = 1, total_pages = 1
formatter = <bound method TestQuickPaginate.test_formatter of <tests.test_ui_navigation_comprehensive.TestQuickPaginate object at 0x7f01e42d24d0>>
header = 'Quick Test', show_numbers = True

    def _display_page(
        self,
        items: List[Any],
        current_page: int,
        total_pages: int,
        formatter: Callable[[Any, Optional[int]], str],
        header: str,
        show_numbers: bool,
    ) -> None:
        """Отображение текущей страницы"""
        # Вычисление индексов для текущей страницы
        start_idx = (current_page - 1) * self.items_per_page
        end_idx = min(start_idx + self.items_per_page, len(items))
        current_items = items[start_idx:end_idx]
    
        print(f"\n\n{header}")
        print("=" * len(header))
    
        # Отображение элементов
        for i, item in enumerate(current_items, start_idx + 1):
            if show_numbers:
>               formatted_item = formatter(item, i)
                                 ^^^^^^^^^^^^^^^^^^
E               TypeError: TestQuickPaginate.test_formatter() takes 1 positional argument but 3 were given

src/utils/ui_navigation.py:92: TypeError
_______________ TestUINavigationExtended.test_paginate_display_invalid_page_number _______________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f01e42c5e90>
mock_print = <MagicMock name='print' id='139646066233808'>
mock_input = <MagicMock name='input' id='139646066244048'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_invalid_page_number(self, mock_print, mock_input):
        """Тестирование некорректного номера страницы"""
        mock_input.side_effect = ["10", "q"]  # Страница 10 не существует
    
        def formatter(item, number):
            return f"{number}: {item}"
    
>       self.navigator.paginate_display(self.test_items, formatter, "Invalid Page Test")

tests/test_ui_navigation_extended.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/ui_navigation.py:58: in paginate_display
    choice = input("\nВыберите действие: ").strip().lower()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='139646066244048'>, args = ('\nВыберите действие: ',)
kwargs = {}, effect = <list_iterator object at 0x7f01e36493c0>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
_________________ TestUINavigationExtended.test_paginate_display_custom_actions __________________

self = <Mock id='139646071430416'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f01e42c6910>
mock_print = <MagicMock name='print' id='139646071423824'>
mock_input = <MagicMock name='input' id='139646071432720'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
>       mock_action.assert_called_once()
E       AssertionError: Expected 'mock' to have been called once. Called 0 times.

tests/test_ui_navigation_extended.py:139: AssertionError
_______________ TestUINavigationExtended.test_paginate_display_custom_action_error _______________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f01e42c4f50>
mock_print = <MagicMock name='print' id='139646075748752'>
mock_input = <MagicMock name='input' id='139646075758352'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_action_error(self, mock_print, mock_input):
        """Тестирование ошибки в кастомном действии"""
        def error_action():
            raise ValueError("Test error")
    
        custom_actions = {"e": error_action}
        mock_input.side_effect = ["e", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Error Test",
            custom_actions=custom_actions
        )
    
        calls = [call.args[0] for call in mock_print.call_args_list]
        output = " ".join(calls)
>       assert "Ошибка при выполнении действия" in output
E       AssertionError: assert 'Ошибка при выполнении действия' in '\n\nError Test ========== 1: Item 0 2: Item 1 3: Item 2 4: Item 3 5: Item 4 \n==================== Навигация: Страница 1 из 1 Показано элементов: 1-5 из 5 --------------------'

tests/test_ui_navigation_extended.py:163: AssertionError
_________________________ TestUserInterfaceComplete.test_start_interface _________________________

self = <tests.test_user_interface_complete.TestUserInterfaceComplete object at 0x7f01e41a9ed0>
mock_print = <MagicMock name='print' id='139646074966672'>
mock_input = <MagicMock name='input' id='139646075347344'>

    @patch('builtins.input', return_value='0')
    @patch('builtins.print')
    def test_start_interface(self, mock_print, mock_input):
        """Тест запуска интерфейса"""
>       with patch.object(self.user_interface, 'show_main_menu', return_value=None):

tests/test_user_interface_complete.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2b14ad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7f01e24867d0> does not have the attribute 'show_main_menu'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________________ TestUserInterfaceComplete.test_display_vacancies ________________________

self = <tests.test_user_interface_complete.TestUserInterfaceComplete object at 0x7f01e41bcc10>
mock_print = <MagicMock name='print' id='139646074185232'>

    @patch('builtins.print')
    def test_display_vacancies(self, mock_print):
        """Тест отображения вакансий"""
        from src.vacancies.models import Vacancy
    
        sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Test description",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Test Company",
                url="https://test.com/1"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_user_interface_complete.py:98: TypeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________________ TestUserInterfaceComponents.test_search_handler _________________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f01e422b1d0>
mock_print = <MagicMock name='print' id='139646069921744'>
mock_input = <MagicMock name='input' id='139646069928272'>

    @patch('builtins.input', side_effect=['1', 'Python', '7'])
    @patch('builtins.print')
    def test_search_handler(self, mock_print, mock_input):
        """Тестирование обработчика поиска вакансий"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Настраиваем мок для возврата тестовых данных
        ui.unified_api.search_vacancies_from_all_sources = Mock(return_value=[
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ])
    
        try:
            ui.search_handler.search_vacancies()
    
            # Проверяем, что API был вызван
>           assert ui.unified_api.search_vacancies_from_all_sources.called
E           AssertionError: assert False
E            +  where False = <Mock id='139646066209232'>.called
E            +    where <Mock id='139646066209232'> = <src.api_modules.unified_api.UnifiedAPI object at 0x7f01e241d1d0>.search_vacancies_from_all_sources
E            +      where <src.api_modules.unified_api.UnifiedAPI object at 0x7f01e241d1d0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f01e241f5d0>.unified_api

tests/test_user_interface_comprehensive.py:80: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f01e422b1d0>
mock_print = <MagicMock name='print' id='139646069921744'>
mock_input = <MagicMock name='input' id='139646069928272'>

    @patch('builtins.input', side_effect=['1', 'Python', '7'])
    @patch('builtins.print')
    def test_search_handler(self, mock_print, mock_input):
        """Тестирование обработчика поиска вакансий"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Настраиваем мок для возврата тестовых данных
        ui.unified_api.search_vacancies_from_all_sources = Mock(return_value=[
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ])
    
        try:
            ui.search_handler.search_vacancies()
    
            # Проверяем, что API был вызван
            assert ui.unified_api.search_vacancies_from_all_sources.called
    
        except Exception as e:
>           pytest.fail(f"search handler should not raise exceptions: {e}")
E           Failed: search handler should not raise exceptions: assert False
E            +  where False = <Mock id='139646066209232'>.called
E            +    where <Mock id='139646066209232'> = <src.api_modules.unified_api.UnifiedAPI object at 0x7f01e241d1d0>.search_vacancies_from_all_sources
E            +      where <src.api_modules.unified_api.UnifiedAPI object at 0x7f01e241d1d0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f01e241f5d0>.unified_api

tests/test_user_interface_comprehensive.py:83: Failed
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 397.75page/s, vacancies=3]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 4206.92page/s, vacancies=0]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 1497.97page/s, vacancies=17]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 4928.68page/s, vacancies=0]
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:218 check_vacancies_exist_batch вернул неожиданный тип: <class 'unittest.mock.Mock'>
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:70 Ошибка поиска вакансий:
______________________ TestUserInterfaceComponents.test_unified_api_methods ______________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f01e422ba50>

    def test_unified_api_methods(self):
        """Тестирование методов унифицированного API"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Проверяем методы UnifiedAPI
>       assert hasattr(ui.unified_api, 'search_vacancies_from_all_sources')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.unified_api.UnifiedAPI object at 0x7f01e27e53d0>, 'search_vacancies_from_all_sources')
E        +    where <src.api_modules.unified_api.UnifiedAPI object at 0x7f01e27e53d0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f01e27e7410>.unified_api

tests/test_user_interface_comprehensive.py:183: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________________ TestMainApplicationFlow.test_main_application_exit _______________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f01e424a410>
mock_input = <MagicMock name='input' id='139646069183696'>

    @patch('builtins.input', return_value='0')
    def test_main_application_exit(self, mock_input):
        """Тестирование выхода из приложения"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e25933d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestMainApplicationFlow.test_main_application_search_workflow __________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f01e424a790>
mock_input = <MagicMock name='input' id='139646067924112'>

    @patch('builtins.input', side_effect=['1', '1', 'Python', '7', '0'])
    def test_main_application_search_workflow(self, mock_input):
        """Тестирование рабочего процесса поиска в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e245c610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestMainApplicationFlow.test_main_application_display_workflow _________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f01e424ab10>
mock_input = <MagicMock name='input' id='139646066616848'>

    @patch('builtins.input', side_effect=['2', '0'])
    def test_main_application_display_workflow(self, mock_input):
        """Тестирование рабочего процесса отображения в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e231fd90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestMainApplicationFlow.test_main_application_demo_workflow ___________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f01e424aed0>
mock_input = <MagicMock name='input' id='139646074661648'>

    @patch('builtins.input', side_effect=['10', '0'])
    def test_main_application_demo_workflow(self, mock_input):
        """Тестирование рабочего процесса демонстрации в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2ac8710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestMainApplicationFlow.test_main_application_invalid_choice __________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f01e424b250>
mock_input = <MagicMock name='input' id='139646072451728'>

    @patch('builtins.input', side_effect=['999', '0'])
    def test_main_application_invalid_choice(self, mock_input):
        """Тестирование обработки некорректного выбора в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e28af950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestErrorHandling.test_create_instances_error_handling _____________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e424b990>

    def test_create_instances_error_handling(self):
        """Тестирование обработки ошибок при создании экземпляров"""
>       with patch('src.user_interface.PostgresSaver', side_effect=Exception("Database error")):

tests/test_user_interface_comprehensive.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2432a50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'PostgresSaver'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestErrorHandling.test_search_error_handling __________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e424bf90>

    def test_search_error_handling(self):
        """Тестирование обработки ошибок поиска"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # API возвращает ошибку
        mock_unified_api.search_vacancies.side_effect = Exception("API Error")
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            try:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:348: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e424bf90>

    def test_search_error_handling(self):
        """Тестирование обработки ошибок поиска"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # API возвращает ошибку
        mock_unified_api.search_vacancies.side_effect = Exception("API Error")
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            try:
                search_and_save_vacancies(mock_unified_api, mock_storage)
                # Функция должна обработать ошибку
            except Exception as e:
>               pytest.fail(f"search function should handle API errors: {e}")
E               Failed: search function should handle API errors: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:351: Failed
_________________________ TestErrorHandling.test_storage_error_handling __________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e42505d0>

    def test_storage_error_handling(self):
        """Тестирование обработки ошибок хранения"""
        mock_storage = Mock()
        mock_storage.get_vacancies.side_effect = Exception("Storage Error")
    
        try:
>           display_all_vacancies(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:359: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e42505d0>

    def test_storage_error_handling(self):
        """Тестирование обработки ошибок хранения"""
        mock_storage = Mock()
        mock_storage.get_vacancies.side_effect = Exception("Storage Error")
    
        try:
            display_all_vacancies(mock_storage)
            # Функция должна обработать ошибку
        except Exception as e:
>           pytest.fail(f"display function should handle storage errors: {e}")
E           Failed: display function should handle storage errors: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:362: Failed
________________________ TestErrorHandling.test_db_manager_error_handling ________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e4250c10>

    def test_db_manager_error_handling(self):
        """Тестирование обработки ошибок DB Manager"""
        mock_db_manager = Mock()
        mock_db_manager.get_companies_and_vacancies_count.side_effect = Exception("DB Error")
    
        try:
>           display_database_statistics(mock_db_manager)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'display_database_statistics' is not defined

tests/test_user_interface_comprehensive.py:370: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f01e4250c10>

    def test_db_manager_error_handling(self):
        """Тестирование обработки ошибок DB Manager"""
        mock_db_manager = Mock()
        mock_db_manager.get_companies_and_vacancies_count.side_effect = Exception("DB Error")
    
        try:
            display_database_statistics(mock_db_manager)
            # Функция должна обработать ошибку
        except Exception as e:
>           pytest.fail(f"statistics function should handle DB errors: {e}")
E           Failed: statistics function should handle DB errors: name 'display_database_statistics' is not defined

tests/test_user_interface_comprehensive.py:373: Failed
______________________ TestInputValidation.test_empty_search_query_handling ______________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e4251410>
mock_input = <MagicMock name='input' id='139646074971024'>

    @patch('builtins.input', side_effect=['', 'Python'])
    def test_empty_search_query_handling(self, mock_input):
        """Тестирование обработки пустого поискового запроса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        with patch('builtins.print'):
            try:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:387: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e4251410>
mock_input = <MagicMock name='input' id='139646074971024'>

    @patch('builtins.input', side_effect=['', 'Python'])
    def test_empty_search_query_handling(self, mock_input):
        """Тестирование обработки пустого поискового запроса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        with patch('builtins.print'):
            try:
                search_and_save_vacancies(mock_unified_api, mock_storage)
            except Exception as e:
>               pytest.fail(f"Should handle empty search query: {e}")
E               Failed: Should handle empty search query: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:389: Failed
_____________________ TestInputValidation.test_invalid_salary_input_handling _____________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e42519d0>
mock_input = <MagicMock name='input' id='139646074970256'>

    @patch('builtins.input', side_effect=['invalid_number', '100000'])
    def test_invalid_salary_input_handling(self, mock_input):
        """Тестирование обработки некорректного ввода зарплаты"""
        mock_storage = Mock()
        mock_storage.get_vacancies.return_value = []
    
        try:
>           filter_vacancies_by_salary(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:398: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e42519d0>
mock_input = <MagicMock name='input' id='139646074970256'>

    @patch('builtins.input', side_effect=['invalid_number', '100000'])
    def test_invalid_salary_input_handling(self, mock_input):
        """Тестирование обработки некорректного ввода зарплаты"""
        mock_storage = Mock()
        mock_storage.get_vacancies.return_value = []
    
        try:
            filter_vacancies_by_salary(mock_storage)
        except Exception as e:
>           pytest.fail(f"Should handle invalid salary input: {e}")
E           Failed: Should handle invalid salary input: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:400: Failed
__________________ TestInputValidation.test_invalid_confirmation_input_handling __________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e4251f90>
mock_input = <MagicMock name='input' id='139646070158800'>

    @patch('builtins.input', side_effect=['maybe', 'y'])
    def test_invalid_confirmation_input_handling(self, mock_input):
        """Тестирование обработки некорректного подтверждения"""
        mock_storage = Mock()
    
        try:
>           clear_vacancy_data(mock_storage)
            ^^^^^^^^^^^^^^^^^^
E           NameError: name 'clear_vacancy_data' is not defined

tests/test_user_interface_comprehensive.py:408: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f01e4251f90>
mock_input = <MagicMock name='input' id='139646070158800'>

    @patch('builtins.input', side_effect=['maybe', 'y'])
    def test_invalid_confirmation_input_handling(self, mock_input):
        """Тестирование обработки некорректного подтверждения"""
        mock_storage = Mock()
    
        try:
            clear_vacancy_data(mock_storage)
        except Exception as e:
>           pytest.fail(f"Should handle invalid confirmation input: {e}")
E           Failed: Should handle invalid confirmation input: name 'clear_vacancy_data' is not defined

tests/test_user_interface_comprehensive.py:410: Failed
____________________________ TestDataFlow.test_search_to_storage_flow ____________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f01e42527d0>

    def test_search_to_storage_flow(self):
        """Тестирование потока данных от поиска к хранению"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем данные для потока
        test_vacancies = [
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ]
        mock_unified_api.search_vacancies.return_value = test_vacancies
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
>           search_and_save_vacancies(mock_unified_api, mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:429: NameError
___________________________ TestDataFlow.test_storage_to_display_flow ____________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f01e4252dd0>

    def test_storage_to_display_flow(self):
        """Тестирование потока данных от хранения к отображению"""
        mock_storage = Mock()
    
        # Настраиваем данные в хранилище
        stored_vacancies = [
            ('Company A', 'Python Developer', 100000, 'https://test1.com'),
            ('Company B', 'Java Developer', 120000, 'https://test2.com')
        ]
        mock_storage.get_vacancies.return_value = stored_vacancies
    
>       display_all_vacancies(mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:450: NameError
_______________________________ TestDataFlow.test_filter_data_flow _______________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f01e42533d0>

    def test_filter_data_flow(self):
        """Тестирование потока данных при фильтрации"""
        mock_storage = Mock()
    
        # Данные с разными зарплатами для фильтрации
        test_vacancies = [
            ('Company A', 'Senior Developer', 150000, 'https://test1.com'),
            ('Company B', 'Junior Developer', 80000, 'https://test2.com'),
            ('Company C', 'Lead Developer', 200000, 'https://test3.com')
        ]
        mock_storage.get_vacancies.return_value = test_vacancies
    
        with patch('builtins.input', return_value='100000'):
>           filter_vacancies_by_salary(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:468: NameError
_____________ TestUserInterfaceIntegration.test_complete_search_and_display_workflow _____________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f01e4253b90>
mock_input = <MagicMock name='input' id='139646074639440'>

    @patch('builtins.input', side_effect=['1', '1', 'Python', '7', '2', '0'])
    def test_complete_search_and_display_workflow(self, mock_input):
        """Тестирование полного рабочего процесса поиска и отображения"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2572e10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterfaceIntegration.test_interface_performance_with_large_dataset ___________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f01e425c1d0>

    def test_interface_performance_with_large_dataset(self):
        """Тестирование производительности интерфейса с большим объемом данных"""
        mock_storage = Mock()
    
        # Создаем большой набор данных
        large_dataset = [
            (f'Company {i}', f'Job {i}', 100000 + i * 1000, f'https://test{i}.com')
            for i in range(1000)
        ]
        mock_storage.get_vacancies.return_value = large_dataset
    
        import time
        start_time = time.time()
    
>       display_all_vacancies(mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:522: NameError
________________ TestUserInterfaceIntegration.test_concurrent_operations_handling ________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f01e425c7d0>

    def test_concurrent_operations_handling(self):
        """Тестирование обработки одновременных операций"""
        # Симулируем одновременные операции с разными компонентами
        mock_unified_api = Mock()
        mock_storage = Mock()
        mock_db_manager = Mock()
    
        # Операции не должны конфликтовать
>       search_and_save_vacancies(mock_unified_api, mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:537: NameError
__________________ TestUserInterfaceAccessibility.test_menu_display_formatting ___________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceAccessibility object at 0x7f01e425d050>

    def test_menu_display_formatting(self):
        """Тестирование форматирования отображения меню"""
        with patch('builtins.print') as mock_print:
>           display_main_menu()
            ^^^^^^^^^^^^^^^^^
E           NameError: name 'display_main_menu' is not defined

tests/test_user_interface_comprehensive.py:550: NameError
____________________ TestUserInterfaceAccessibility.test_progress_indication _____________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceAccessibility object at 0x7f01e425dc50>

    def test_progress_indication(self):
        """Тестирование индикации прогресса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Симулируем долгую операцию
        mock_unified_api.search_vacancies.return_value = [
            {'id': str(i), 'name': f'Job {i}', 'url': f'https://test{i}.com'}
            for i in range(100)
        ]
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            with patch('builtins.print') as mock_print:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:581: NameError
__________________ TestVacancyDisplayHandler.test_vacancy_display_handler_init ___________________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f01e4278b10>

    def test_vacancy_display_handler_init(self):
        """Тест инициализации обработчика отображения вакансий"""
>       handler = VacancyDisplayHandler()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_vacancy_display_handler.py:42: TypeError
_____________________________ TestVacancy.test_vacancy_html_cleaning _____________________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancy object at 0x7f01e429dc90>

    def test_vacancy_html_cleaning(self):
        """Тестирование очистки HTML в тексте вакансии"""
        html_description = "<p>Test <b>description</b> with <a href='#'>HTML</a></p>"
        vacancy = Vacancy(
            title="Test",
            url="https://test.com",
            description=html_description,
            requirements="<ul><li>Python</li></ul>",
            responsibilities="<div>Development</div>"
        )
    
        # HTML теги должны быть удалены
>       assert "<p>" not in vacancy.description
E       AssertionError: assert '<p>' not in '<p>Test <b>...HTML</a></p>'
E         
E         '<p>' is contained here:
E           <p>Test <b>description</b> with <a href='#'>HTML</a></p>
E         ? +++

tests/test_vacancy_modules_comprehensive.py:417: AssertionError
___________________________ TestHHParser.test_hh_parser_salary_parsing ___________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f01e429fe10>

    def test_hh_parser_salary_parsing(self):
        """Тестирование парсинга зарплаты в HH"""
        hh_data = create_hh_vacancy_data()
        vacancy = self.parser.parse_vacancy(hh_data)
    
>       assert vacancy.salary is not None
               ^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'salary'

tests/test_vacancy_modules_comprehensive.py:601: AttributeError
__________________________ TestHHParser.test_hh_parser_employer_parsing __________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f01e4004410>

    def test_hh_parser_employer_parsing(self):
        """Тестирование парсинга работодателя в HH"""
        hh_data = create_hh_vacancy_data()
        vacancy = self.parser.parse_vacancy(hh_data)
    
>       assert isinstance(vacancy.employer, Employer)
                          ^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'employer'

tests/test_vacancy_modules_comprehensive.py:609: AttributeError
___________________________ TestHHParser.test_hh_parser_missing_fields ___________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f01e4005010>

    def test_hh_parser_missing_fields(self):
        """Тестирование обработки отсутствующих полей"""
        minimal_data = {
            "id": "123",
            "name": "Test Job",
            "alternate_url": "https://hh.ru/vacancy/123"
        }
    
        vacancy = self.parser.parse_vacancy(minimal_data)
    
        if vacancy is not None:
>           assert isinstance(vacancy, Vacancy)
E           AssertionError: assert False
E            +  where False = isinstance({'area': '', 'employer': '', 'employment': '', 'experience': '', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:638: AssertionError
_____________________ TestSuperJobParser.test_sj_parser_parse_single_vacancy _____________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f01e4005f10>

    def test_sj_parser_parse_single_vacancy(self):
        """Тестирование парсинга одной вакансии SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy, Vacancy)
E       AssertionError: assert False
E        +  where False = isinstance({'area': 'Москва', 'description': 'Разработка и поддержка веб-приложений', 'employer': 'IT Компания', 'employment': 'Полная занятость', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:660: AssertionError
________________________ TestSuperJobParser.test_sj_parser_salary_parsing ________________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f01e4006b50>

    def test_sj_parser_salary_parsing(self):
        """Тестирование парсинга зарплаты в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert vacancy.salary is not None
               ^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'salary'

tests/test_vacancy_modules_comprehensive.py:685: AttributeError
_______________________ TestSuperJobParser.test_sj_parser_employer_parsing _______________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f01e4007150>

    def test_sj_parser_employer_parsing(self):
        """Тестирование парсинга работодателя в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy.employer, Employer)
                          ^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'employer'

tests/test_vacancy_modules_comprehensive.py:693: AttributeError
______________________ TestSuperJobParser.test_sj_parser_timestamp_handling ______________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f01e4007750>

    def test_sj_parser_timestamp_handling(self):
        """Тестирование обработки timestamp в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy.published_at, datetime)
                          ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'published_at'

tests/test_vacancy_modules_comprehensive.py:701: AttributeError
___________________ TestVacancyModelsIntegration.test_full_parsing_workflow_hh ___________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f01e400c590>

    def test_full_parsing_workflow_hh(self):
        """Тестирование полного рабочего процесса парсинга HH"""
        hh_data = create_hh_vacancy_data()
        parser = HHParser()
    
        # Парсим вакансию
        vacancy = parser.parse_vacancy(hh_data)
    
>       assert isinstance(vacancy, Vacancy)
E       AssertionError: assert False
E        +  where False = isinstance({'area': 'Москва', 'employer': 'Яндекс', 'employment': 'Полная занятость', 'experience': 'От 1 года до 3 лет', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:725: AssertionError
___________________ TestVacancyModelsIntegration.test_full_parsing_workflow_sj ___________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f01e400cb90>

    def test_full_parsing_workflow_sj(self):
        """Тестирование полного рабочего процесса парсинга SuperJob"""
        sj_data = create_sj_vacancy_data()
>       parser = SJParser()
                 ^^^^^^^^
E       NameError: name 'SJParser' is not defined

tests/test_vacancy_modules_comprehensive.py:737: NameError
__________________ TestVacancyModelsIntegration.test_cross_format_compatibility __________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f01e400d190>

    def test_cross_format_compatibility(self):
        """Тестирование совместимости между форматами"""
        # Создаем вакансию из HH формата
        hh_data = create_hh_vacancy_data()
        hh_parser = HHParser()
        hh_vacancy = hh_parser.parse_vacancy(hh_data)
    
        # Создаем вакансию из SJ формата
        sj_data = create_sj_vacancy_data()
>       sj_parser = SJParser()
                    ^^^^^^^^
E       NameError: name 'SJParser' is not defined

tests/test_vacancy_modules_comprehensive.py:760: NameError
_________________ TestVacancyOperationsCoordinatorComplete.test_coordinator_init _________________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f01e4047a50>

    def test_coordinator_init(self):
        """Тест инициализации координатора операций с вакансиями"""
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_vacancy_operations_coordinator_complete.py:49: TypeError
____________________________ TestVacancyRepository.test_save_vacancy _____________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4084b90>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646072279184'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_save_vacancy(self, mock_db_connection):
        """Тест сохранения вакансии"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
        vacancy = Mock()
        vacancy.vacancy_id = "test_123"
        vacancy.title = "Test Vacancy"
    
>       with patch.object(repo, 'save_vacancy') as mock_save:

tests/test_vacancy_repository.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2a59b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e2a59e50> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancyRepository.test_get_vacancy_by_id __________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4085210>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646067562960'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_vacancy_by_id(self, mock_db_connection):
        """Тест получения вакансии по ID"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (
            "123", "Python Developer", "Test description",
            100000, 150000, "RUR", "Test Company", "https://test.com/vacancy/123"
        )
    
>       vacancy = repo.get_vacancy_by_id("123")
                  ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_vacancy_by_id'

tests/test_vacancy_repository.py:74: AttributeError
__________________________ TestVacancyRepository.test_get_all_vacancies __________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e40858d0>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646071009232'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_all_vacancies(self, mock_db_connection):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test description",
             100000, 150000, "RUR", "Test Company", "https://test.com/vacancy/123")
        ]
    
>       vacancies = repo.get_all_vacancies()
                    ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_all_vacancies'

tests/test_vacancy_repository.py:92: AttributeError
___________________________ TestVacancyRepository.test_update_vacancy ____________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e406ccd0>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646070028624'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_update_vacancy(self, mock_db_connection):
        """Тест обновления вакансии"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
>       with patch.object(repo, 'update_vacancy') as mock_update:

tests/test_vacancy_repository.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e265d6d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e265ded0> does not have the attribute 'update_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestVacancyRepository.test_find_vacancies_by_criteria ______________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4084650>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646075347216'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_find_vacancies_by_criteria(self, mock_db_connection):
        """Тест поиска вакансий по критериям"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = []
    
        criteria = {"salary_from": 100000, "company_name": "Test Company"}
>       vacancies = repo.find_vacancies_by_criteria(criteria)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'find_vacancies_by_criteria'

tests/test_vacancy_repository.py:134: AttributeError
___________________________ TestVacancyRepository.test_count_vacancies ___________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4085e90>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646069059728'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_count_vacancies(self, mock_db_connection):
        """Тест подсчета количества вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (10,)
    
>       count = repo.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count_vacancies'

tests/test_vacancy_repository.py:149: AttributeError
________________________ TestVacancyRepository.test_batch_save_vacancies _________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4086210>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646098142032'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_batch_save_vacancies(self, mock_db_connection):
        """Тест пакетного сохранения вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
        vacancies = [self.sample_vacancy]
    
>       with patch.object(repo, 'batch_save_vacancies') as mock_batch_save:

tests/test_vacancy_repository.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f01e2b168d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f01e2b15f90> does not have the attribute 'batch_save_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancyRepository.test_get_vacancies_by_salary_range ____________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f01e4086550>
mock_db_connection = <MagicMock name='DatabaseConnection' id='139646069912592'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_vacancies_by_salary_range(self, mock_db_connection):
        """Тест получения вакансий по диапазону зарплат"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = []
    
>       vacancies = repo.get_vacancies_by_salary_range(100000, 200000)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_vacancies_by_salary_range'

tests/test_vacancy_repository.py:179: AttributeError
___________________ TestVacancySearchHandlerComplete.test_search_handler_init ____________________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f01e4093a10>

    def test_search_handler_init(self):
        """Тест инициализации обработчика поиска вакансий"""
>       handler = VacancySearchHandler()
                  ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_vacancy_search_handler_complete.py:51: TypeError
________________________ TestVacancyValidator.test_get_validation_errors _________________________

self = <tests.test_vacancy_validator.TestVacancyValidator object at 0x7f01e40c6e90>

    def test_get_validation_errors(self):
        """Тест получения ошибок валидации"""
        if hasattr(self.validator, 'get_validation_errors'):
>           errors = self.validator.get_validation_errors(self.invalid_vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given

tests/test_vacancy_validator.py:130: TypeError
==================================== short test summary info =====================================
FAILED tests/test_api_modules_comprehensive.py::TestHeadHunterAPI::test_hh_api_search_vacancies_success - assert 0 == 1
FAILED tests/test_api_modules_comprehensive.py::TestSuperJobAPI::test_sj_api_search_vacancies_success - assert 0 == 1
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_search_all_sources - AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_search_specific_source - AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_error_handling - AssertionError: Expected 'get_vacancies' to have been called once. Called 0 times.
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_connect - ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retrie...
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_error_handling - TypeError: expected exception must be a BaseException type, not 'MagicMock'
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_with_params - ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retrie...
FAILED tests/test_api_modules_comprehensive.py::TestAPIIntegration::test_full_search_workflow - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_comprehensive_final.py::TestSpecialModules::test_vacancy_storage_service_full_coverage - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
FAILED tests/test_config_modules_comprehensive.py::TestAPIConfig::test_api_config_initialization - AssertionError: assert False
FAILED tests/test_config_modules_comprehensive.py::TestAPIConfig::test_api_config_abstract_methods - AttributeError: 'APIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_urls - AssertionError: assert (False or False)
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_headers - AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_default_parameters - AttributeError: 'HHAPIConfig' object has no attribute 'get_default_parameters'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_enabled - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_disabled - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_default - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_urls - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_with_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_without_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_parameters - AttributeError: 'SJAPIConfig' object has no attribute 'get_default_parameters'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_salary_filter - AttributeError: 'SJAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestDatabaseConfig::test_db_config_initialization - AttributeError: 'DatabaseConfig' object has no attribute 'default_storage_type'
FAILED tests/test_config_modules_comprehensive.py::TestTargetCompanies::test_company_ids_extraction - AssertionError: assert False
FAILED tests/test_config_modules_comprehensive.py::TestConfigIntegration::test_environment_variables_propagation - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_success - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_db_connection_error - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_keyboard_interrupt - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestDBManagerComprehensive::test_check_connection_success - assert False is True
FAILED tests/test_core_modules_comprehensive.py::TestVacancyModels::test_vacancy_validation_valid - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_core_modules_comprehensive.py::TestVacancyModels::test_vacancy_validation_invalid_title - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_core_modules_comprehensive.py::TestAppConfigComprehensive::test_app_config_default_values - AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
FAILED tests/test_core_modules_comprehensive.py::TestStorageFactoryComprehensive::test_storage_factory_postgresql - ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql
FAILED tests/test_core_modules_comprehensive.py::TestStorageFactoryComprehensive::test_storage_factory_json - ValueError: Поддерживается только PostgreSQL хранилище, получен: json
FAILED tests/test_database_connection.py::TestDatabaseConnection::test_database_connection_init - AssertionError: assert False
FAILED tests/test_database_connection.py::TestDatabaseConnection::test_close_connection - TypeError: DatabaseConnection.close_connection() takes 1 positional argument but 2 were given
FAILED tests/test_final_complete_coverage.py::TestCompleteAPIModuleCoverage::test_headhunter_api_complete_coverage - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_final_complete_coverage.py::TestCompleteAPIModuleCoverage::test_superjob_api_complete_coverage - AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'
FAILED tests/test_final_complete_coverage.py::TestCompleteStorageModuleCoverage::test_db_manager_complete_coverage - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_final_complete_coverage.py::TestCompleteStorageModuleCoverage::test_storage_factory_complete_coverage - ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql
FAILED tests/test_final_complete_coverage.py::TestCompleteUIModuleCoverage::test_user_interface_complete_coverage - AssertionError: Expected 'print' to have been called.
FAILED tests/test_final_complete_coverage.py::TestCompleteUtilityModuleCoverage::test_salary_comprehensive - AttributeError: 'Salary' object has no attribute 'get_average'
FAILED tests/test_final_complete_coverage.py::TestCompleteVacancyModelCoverage::test_vacancy_model_complete_coverage - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_final_complete_coverage.py::TestCompleteConfigurationCoverage::test_app_config_complete_coverage - AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
FAILED tests/test_main_application_interface.py::TestMainApplicationInterface::test_main_application_interface_init - TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run...
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_db_manager_initialization - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_companies_and_vacancies_count - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_all_vacancies - assert 0 == 2
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_vacancies_with_higher_salary - assert 0 == 2
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_vacancies_with_keyword - assert 0 == 1
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_db_manager_connection_error_handling - Exception: Connection check failed
FAILED tests/test_storage_modules_comprehensive.py::TestPostgresSaver::test_save_vacancies - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestStorageFactory::test_create_invalid_storage - ValueError: Поддерживается только PostgreSQL хранилище, получен: invalid_type
FAILED tests/test_storage_modules_comprehensive.py::TestDatabaseConnection::test_database_connection_establishment - AssertionError: assert <MagicMock name='mock.connect()' id='139646085577232'> == <Mock name='...
FAILED tests/test_storage_modules_comprehensive.py::TestDatabaseConnection::test_database_connection_error_handling - AssertionError: assert <MagicMock name='mock.connect()' id='139646085577232'> is None
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyRepository::test_vacancy_repository_initialization - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyRepository::test_delete_vacancy - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyValidator::test_get_validation_errors - TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyStorageService::test_storage_service_initialization - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_full_storage_workflow - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_storage_error_recovery - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_storage_performance_simulation - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_typed_data_processor.py::TestTypedDataProcessor::test_typed_data_processor_init - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpersIntegration::test_salary_input_workflow - assert None == (100000, 150000)
FAILED tests/test_ui_helpers_extended.py::TestUIHelpersExtended::test_parse_search_query_mixed_case - AssertionError: assert {'keywords': ...rator': 'AND'} == {'keywords': ...rator': 'AND'}
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_main_interface_startup_and_exit - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_main_interface_menu_navigation - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_cache_clearing_option - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_db_manager_demo_option - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestSourceSelector::test_get_user_source_choice - AssertionError: assert ({'hh.ru'} is None or False)
FAILED tests/test_ui_interfaces_comprehensive.py::TestUIPerformance::test_pagination_performance - TypeError: Paginator() takes no arguments
FAILED tests/test_ui_navigation_comprehensive.py::TestUINavigation::test_handle_navigation_choice_page_number - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_ui_navigation_comprehensive.py::TestQuickPaginate::test_quick_paginate_basic - TypeError: TestQuickPaginate.test_formatter() takes 1 positional argument but 3 were given
FAILED tests/test_ui_navigation_comprehensive.py::TestQuickPaginate::test_quick_paginate_with_custom_actions - TypeError: TestQuickPaginate.test_formatter() takes 1 positional argument but 3 were given
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_invalid_page_number - StopIteration
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Expected 'mock' to have been called once. Called 0 times.
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_action_error - AssertionError: assert 'Ошибка при выполнении действия' in '\n\nError Test ========== 1: Item...
FAILED tests/test_user_interface_complete.py::TestUserInterfaceComplete::test_start_interface - AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7f01e24867d0> ...
FAILED tests/test_user_interface_complete.py::TestUserInterfaceComplete::test_display_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceComponents::test_search_handler - Failed: search handler should not raise exceptions: assert False
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceComponents::test_unified_api_methods - AssertionError: assert False
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_exit - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_search_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_display_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_