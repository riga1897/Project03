~/workspace$ pytest --tb=auto
====================================== test session starts =======================================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.14.1
collected 1151 items                                                                             

tests/test_abstract.py ........                                                            [  0%]
tests/test_abstract_db_manager.py ....                                                     [  1%]
tests/test_advanced_coverage_comprehensive.py ...................F..........               [  3%]
tests/test_api_config.py ....                                                              [  3%]
tests/test_api_modules.py .............................                                    [  6%]
tests/test_api_modules_comprehensive.py ..F.s..F........FF.F..FF.F..F                      [  9%]
tests/test_app_config.py .....                                                             [  9%]
tests/test_base_api.py ......                                                              [  9%]
tests/test_base_formatter.py ..........                                                    [ 10%]
tests/test_base_parser.py ......                                                           [ 11%]
tests/test_cache.py .......                                                                [ 11%]
tests/test_cached_api.py ...........                                                       [ 12%]
tests/test_comprehensive_final.py ....................F..                                  [ 14%]
tests/test_config_modules_comprehensive.py FF.FFFFFF..FFFFFFF........................F.F.  [ 18%]
tests/test_console_interface.py ......                                                     [ 19%]
tests/test_core_modules_comprehensive.py FFF.FF....FF.FFF.                                 [ 20%]
tests/test_data_normalizers_comprehensive.py ............................                  [ 23%]
tests/test_database_connection.py F..F....                                                 [ 24%]
tests/test_db_config.py .....                                                              [ 24%]
tests/test_db_manager.py .................                                                 [ 25%]
tests/test_decorators.py .......                                                           [ 26%]
tests/test_env_loader.py ................                                                  [ 27%]
tests/test_final_complete_coverage.py FFFFF..FF.F.                                         [ 29%]
tests/test_get_api.py ......                                                               [ 29%]
tests/test_hh_api.py .......                                                               [ 30%]
tests/test_hh_api_config.py .....                                                          [ 30%]
tests/test_hh_parser.py ........                                                           [ 31%]
tests/test_integration.py .............                                                    [ 32%]
tests/test_main_application_interface.py F..........                                       [ 33%]
tests/test_menu_manager.py ..........                                                      [ 34%]
tests/test_missing_components.py .........                                                 [ 35%]
tests/test_paginator.py ......                                                             [ 35%]
tests/test_salary_fixed.py ...........                                                     [ 36%]
tests/test_salary_utils.py ......................                                          [ 38%]
tests/test_search_utils.py ............................                                    [ 40%]
tests/test_sj_api.py ..............                                                        [ 42%]
tests/test_sj_api_config.py .....                                                          [ 42%]
tests/test_sj_parser.py ........                                                           [ 43%]
tests/test_source_manager.py .................                                             [ 44%]
tests/test_source_selector.py .................                                            [ 46%]
tests/test_storage_factory.py ........                                                     [ 46%]
tests/test_storage_modules_comprehensive.py ....FFFFFFF.F....F.F.FF.....F....FF..........F [ 50%]
FF                                                                                         [ 50%]
tests/test_target_companies.py .....                                                       [ 51%]
tests/test_typed_data_processor.py F.............                                          [ 52%]
tests/test_ui_config.py .......................                                            [ 54%]
tests/test_ui_helpers_comprehensive.py ............................F......FF..             [ 58%]
tests/test_ui_helpers_extended.py ..........................F.............                 [ 61%]
tests/test_ui_interfaces_comprehensive.py FF.FF...F............................F...        [ 65%]
tests/test_ui_navigation.py ......................                                         [ 66%]
tests/test_ui_navigation_comprehensive.py .................F.....FF...                     [ 69%]
tests/test_ui_navigation_extended.py ......FFF..........................                   [ 72%]
tests/test_unified_api.py .................                                                [ 73%]
tests/test_user_interface_complete.py .F.....F.........                                    [ 75%]
tests/test_user_interface_comprehensive.py ..F......F..FFFFFFFFFFFFFFFFFFF.F               [ 78%]
tests/test_utilities_comprehensive.py .................................                    [ 81%]
tests/test_vacancy_display_handler.py F..................                                  [ 82%]
tests/test_vacancy_formatter.py ........                                                   [ 83%]
tests/test_vacancy_modules_comprehensive.py .............................F..........FF.F.F [ 87%]
.FFF.FFF..                                                                                 [ 88%]
tests/test_vacancy_operations.py ......                                                    [ 88%]
tests/test_vacancy_operations_coordinator.py ...........................                   [ 91%]
tests/test_vacancy_operations_coordinator_complete.py F.....................               [ 93%]
tests/test_vacancy_processing_coordinator.py .............                                 [ 94%]
tests/test_vacancy_repository.py .FFFF.FFFF                                                [ 95%]
tests/test_vacancy_search_handler_complete.py F......................                      [ 97%]
tests/test_vacancy_stats.py ............                                                   [ 98%]
tests/test_vacancy_stats_fixed.py .........                                                [ 98%]
tests/test_vacancy_validator.py ..........F.                                               [100%]

============================================ FAILURES ============================================
__________________ TestUIComponentsComprehensive.test_paginator_initialization ___________________

self = <tests.test_advanced_coverage_comprehensive.TestUIComponentsComprehensive object at 0x7f4190aae790>

    def test_paginator_initialization(self):
        """Тестирование инициализации пагинатора"""
        try:
            from src.utils.paginator import Paginator
    
            # Проверяем, есть ли конструктор с аргументами
            import inspect
            sig = inspect.signature(Paginator.__init__)
            if len(sig.parameters) == 1:  # только self
                # Создаем простую реализацию для тестов
                class TestPaginator:
                    def __init__(self, items, page_size=10):
                        self.items = items
                        self.page_size = page_size
                        self.total_pages = len(items) // page_size + (1 if len(items) % page_size else 0)
    
                items = list(range(100))
                paginator = TestPaginator(items, page_size=10)
                assert paginator.items == items
                assert paginator.page_size == 10
                assert paginator.total_pages == 10
            else:
                # Попытаемся создать пагинатор без аргументов, если это возможно
                try:
                    paginator = Paginator()
                    assert paginator is not None
                except Exception:
                    # Если конструктор требует аргументы, создаем тестовую реализацию
                    class TestPaginator:
                        def __init__(self, items=None, page_size=10):
                            self.items = items or []
                            self.page_size = page_size
                            self.total_pages = len(self.items) // page_size + (1 if len(self.items) % page_size else 0)
    
                    items = list(range(100))
                    paginator = TestPaginator(items, page_size=10)
>               assert hasattr(paginator, 'items') or hasattr(paginator, '_items')
E               AssertionError: assert (False or False)
E                +  where False = hasattr(<src.utils.paginator.Paginator object at 0x7f41904a2290>, 'items')
E                +  and   False = hasattr(<src.utils.paginator.Paginator object at 0x7f41904a2290>, '_items')

tests/test_advanced_coverage_comprehensive.py:443: AssertionError
_____________________ TestHeadHunterAPI.test_hh_api_search_vacancies_success _____________________

self = <tests.test_api_modules_comprehensive.TestHeadHunterAPI object at 0x7f419070fad0>
mock_get = <MagicMock name='get' id='139919568475408'>

    @patch('requests.get')
    def test_hh_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска вакансий через HH API"""
        # Настраиваем мок ответа
        mock_response = Mock()
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Test Company", "id": "456"},
                    "salary": {"from": 100000, "to": 200000, "currency": "RUR"},
                    "snippet": {"requirement": "Python", "responsibility": "Development"}
                }
            ],
            "pages": 1,
            "per_page": 20,
            "page": 0,
            "found": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Выполняем поиск
        result = self.hh_api.get_vacancies("Python")
    
        # Проверяем результат
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:102: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.hh_api:hh_api.py:179 Ошибка получения вакансий: 'Mock' object does not support item assignment
______________________ TestSuperJobAPI.test_sj_api_search_vacancies_success ______________________

self = <tests.test_api_modules_comprehensive.TestSuperJobAPI object at 0x7f41907181d0>
mock_get = <MagicMock name='get' id='139919568529424'>

    @patch('requests.get')
    def test_sj_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска через SuperJob API"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 789,
                    "profession": "Python разработчик",
                    "link": "https://superjob.ru/vakansii/python-789.html",
                    "firm_name": "IT Company",
                    "payment_from": 120000,
                    "payment_to": 180000,
                    "currency": "rub",
                    "candidat": "Знание Python",
                    "work": "Разработка ПО"
                }
            ],
            "total": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        result = self.sj_api.get_vacancies("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:211: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.cached_api:cached_api.py:115 Ошибка кэша памяти: Object of type Mock is not JSON serializable. Переключаемся на файловый кэш
ERROR    src.api_modules.sj_api:sj_api.py:198 Failed to get vacancies: cannot access local variable 'filepath' where it is not associated with a value
_______________________ TestUnifiedAPI.test_unified_api_search_all_sources _______________________

self = <Mock name='mock.get_vacancies' id='139919568483472'>, args = ('Python',), kwargs = {}
msg = "Expected 'get_vacancies' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f4190ad0bd0>

    def test_unified_api_search_all_sources(self):
        """Тестирование поиска по всем источникам"""
        # Используем правильное имя метода
        if hasattr(self.unified_api, 'get_vacancies_from_sources'):
            result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh", "sj"])
        else:
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        assert isinstance(result, list)
        assert len(result) >= 0  # Может быть пустым из-за фильтрации
    
        # Проверяем, что все API были вызваны
>       self.mock_hh_api.get_vacancies.assert_called_once_with("Python")
E       AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

tests/test_api_modules_comprehensive.py:360: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 503.36page/s, vacancies=999]
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.cached_api:cached_api.py:164 Ошибка соединения с API sj: HTTP error 403: {"error":{"code":403,"message":"Ваш ключ приложения неверен","error":null}}
_____________________ TestUnifiedAPI.test_unified_api_search_specific_source _____________________

self = <Mock name='mock.get_vacancies' id='139919543227216'>, args = ('Python',), kwargs = {}
msg = "Expected 'get_vacancies' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f4190ad22d0>

    def test_unified_api_search_specific_source(self):
        """Тестирование поиска по конкретному источнику"""
        if hasattr(self.unified_api, 'get_vacancies_from_sources'):
            result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh"])
        else:
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        # Проверяем, что вызван только HH API
>       self.mock_hh_api.get_vacancies.assert_called_once_with("Python")
E       AssertionError: Expected 'get_vacancies' to be called once. Called 0 times.

tests/test_api_modules_comprehensive.py:371: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 437.20page/s, vacancies=999]
_________________________ TestUnifiedAPI.test_unified_api_error_handling _________________________

self = <Mock name='mock.get_vacancies' id='139919571018064'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f41906f4850>

    def test_unified_api_error_handling(self):
        """Тестирование обработки ошибок"""
        # Пропускаем тест, если метод не существует
        if not hasattr(self.unified_api, 'get_vacancies_from_sources'):
            pytest.skip("Method get_vacancies_from_sources not implemented")
    
        # Симулируем ошибку в одном из API
        self.mock_hh_api.get_vacancies.side_effect = Exception("HH API Error")
    
        # API должен продолжить работу с другими источниками
        result = self.unified_api.get_vacancies_from_sources(search_query="Python", sources=["hh", "sj"])
        assert isinstance(result, list)
    
        # SJ API должен быть вызван несмотря на ошибку в HH
>       self.mock_sj_api.get_vacancies.assert_called_once()
E       AssertionError: Expected 'get_vacancies' to have been called once. Called 0 times.

tests/test_api_modules_comprehensive.py:397: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 302.59page/s, vacancies=999]
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.cached_api:cached_api.py:164 Ошибка соединения с API sj: HTTP error 403: {"error":{"code":403,"message":"Ваш ключ приложения неверен","error":null}}
__________________________ TestAPIConnector.test_api_connector_connect ___________________________

self = <src.api_modules.get_api.APIConnector object at 0x7f418f934150>, url = 'https://test.api'
params = None, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
>               params={k: v for k, v in params.items() if v is not None},
                                         ^^^^^^^^^^^^
                headers=self.headers,
                timeout=self.config.timeout,
            )
E           AttributeError: 'NoneType' object has no attribute 'items'

src/api_modules/get_api.py:108: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f41906f5ed0>
mock_get = <MagicMock name='get' id='139919558403280'>

    @patch('requests.get')
    def test_api_connector_connect(self, mock_get):
        """Тестирование метода connect APIConnector"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"status": "ok"}
        mock_response.status_code = 200
        mock_get.return_value = mock_response
    
>       result = api_connector.connect("https://test.api")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f418f934150>, url = 'https://test.api'
params = None, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
            raise ConnectionError(f"Connection error: {str(e)}")
        except ValueError as e:
            raise ConnectionError(f"JSON decode error: {str(e)}")
        except Exception as e:
>           raise ConnectionError(f"Unexpected error: {str(e)}")
E           ConnectionError: Unexpected error: 'NoneType' object has no attribute 'items'

src/api_modules/get_api.py:138: ConnectionError
_______________________ TestAPIConnector.test_api_connector_error_handling _______________________

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f41906f6190>
mock_get = <MagicMock name='get' id='139919568529104'>

    @patch('requests.get')
    def test_api_connector_error_handling(self, mock_get):
        """Тестирование обработки ошибок APIConnector"""
        import requests.exceptions
        api_connector = APIConnector()
        mock_get.side_effect = requests.exceptions.ConnectionError("Network error")
    
>       with pytest.raises(requests.exceptions.ConnectionError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:635: in __init__
    self.expected_exceptions = tuple(
.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:636: in <genexpr>
    self._parse_exc(e, expected="a BaseException type")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RaisesExc' object has no attribute 'expected_exceptions'") raised in repr()] RaisesExc object at 0x7f418f7a8950>
exc = <MagicMock name='mock.exceptions.ConnectionError' id='139919556776592'>
expected = 'a BaseException type'

    def _parse_exc(
        self, exc: type[BaseExcT_1] | types.GenericAlias, expected: str
    ) -> type[BaseExcT_1]:
        if isinstance(exc, type) and issubclass(exc, BaseException):
            if not issubclass(exc, Exception):
                self.is_baseexception = True
            return exc
        # because RaisesGroup does not support variable number of exceptions there's
        # still a use for RaisesExc(ExceptionGroup[Exception]).
        origin_exc: type[BaseException] | None = get_origin(exc)
        if origin_exc and issubclass(origin_exc, BaseExceptionGroup):
            exc_type = get_args(exc)[0]
            if (
                issubclass(origin_exc, ExceptionGroup) and exc_type in (Exception, Any)
            ) or (
                issubclass(origin_exc, BaseExceptionGroup)
                and exc_type in (BaseException, Any)
            ):
                if not isinstance(exc, Exception):
                    self.is_baseexception = True
                return cast(type[BaseExcT_1], origin_exc)
            else:
                raise ValueError(
                    f"Only `ExceptionGroup[Exception]` or `BaseExceptionGroup[BaseExeption]` "
                    f"are accepted as generic types but got `{exc}`. "
                    f"As `raises` will catch all instances of the specified group regardless of the "
                    f"generic argument specific nested exceptions has to be checked "
                    f"with `RaisesGroup`."
                )
        # unclear if the Type/ValueError distinction is even helpful here
        msg = f"expected exception must be {expected}, not "
        if isinstance(exc, type):
            raise ValueError(msg + f"{exc.__name__!r}")
        if isinstance(exc, BaseException):
            raise TypeError(msg + f"an exception instance ({type(exc).__name__})")
>       raise TypeError(msg + repr(type(exc).__name__))
E       TypeError: expected exception must be a BaseException type, not 'MagicMock'

.pythonlibs/lib/python3.11/site-packages/_pytest/raises.py:472: TypeError
________________________ TestAPIConnector.test_api_connector_with_params _________________________

self = <urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/util/connection.py:60: in create_connection
    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'test.api', port = 443, family = <AddressFamily.AF_INET: 2>
type = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno -2] Name or service not known

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/socket.py:974: gaierror

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f418f7ce0d0>, method = 'GET'
url = '/?query=Python&page=1', body = None
headers = {'User-Agent': 'MyVacancyApp/1.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False
assert_same_host = False, timeout = Timeout(connect=15, read=15, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/', query='query=Python&page=1', fragment=None)
destination_scheme = None, conn = None, release_this_conn = True, http_tunnel_required = False
err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:488: in _make_request
    raise new_e
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:464: in _make_request
    self._validate_conn(conn)
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:1093: in _validate_conn
    conn.connect()
.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:753: in connect
    self.sock = sock = self._new_conn()
                       ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
>           raise NameResolutionError(self.host, self, e) from e
E           urllib3.exceptions.NameResolutionError: <urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:205: NameResolutionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x7f418f7ccb50>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET'
url = '/?query=Python&page=1', response = None
error = NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)")
_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f418f7ce0d0>
_stacktrace = <traceback object at 0x7f418f7ce100>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/urllib3/util/retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <src.api_modules.get_api.APIConnector object at 0x7f41902d1f50>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
>           response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )

src/api_modules/get_api.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7f418f7ccb50>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:677: ConnectionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f41906f6790>
mock_get = <MagicMock name='get' id='139919568481552'>

    @patch('requests.get')
    def test_api_connector_with_params(self, mock_get):
        """Тестирование APIConnector с параметрами"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"data": "test"}
        mock_response.status_code = 200
        mock_get.return_value = mock_response
    
        params = {"query": "Python", "page": 1}
>       result = api_connector.connect("https://test.api", params=params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:458: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f41902d1f50>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
>           raise ConnectionError(f"Connection error: {str(e)}")
E           ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f418f7ce1d0>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

src/api_modules/get_api.py:134: ConnectionError
__________________________ TestAPIIntegration.test_full_search_workflow __________________________

self = <tests.test_api_modules_comprehensive.TestAPIIntegration object at 0x7f41906f7fd0>
mock_get = <MagicMock name='get' id='139919574524624'>

    @patch('requests.get')
    def test_full_search_workflow(self, mock_get):
        """Тестирование полного рабочего процесса поиска"""
        # Настраиваем ответы для всех API
        hh_response = Mock()
        hh_response.json.return_value = {
            "items": [{"id": "hh_1", "name": "HH Vacancy"}],
            "pages": 1,
            "page": 0
        }
        hh_response.status_code = 200
        hh_response.raise_for_status.return_value = None
    
        sj_response = Mock()
        sj_response.json.return_value = {
            "objects": [{"id": 1, "profession": "SJ Vacancy"}],
            "total": 1
        }
        sj_response.status_code = 200
        sj_response.raise_for_status.return_value = None
    
        # Настраиваем mock_get для возврата разных ответов
        def get_response(url, **kwargs):
            if "hh.ru" in url:
                return hh_response
            elif "superjob.ru" in url:
                return sj_response
            return Mock()
    
        mock_get.side_effect = get_response
    
        # Тестируем полный workflow
        with patch('src.config.api_config.APIConfig') as mock_hh_config, \
             patch('src.config.sj_api_config.SJAPIConfig') as mock_sj_config:
    
            # Настраиваем конфигурации
            mock_hh_config.return_value.get_base_url.return_value = "https://api.hh.ru"
            mock_hh_config.return_value.get_search_url.return_value = "https://api.hh.ru/vacancies"
            mock_hh_config.return_value.get_headers.return_value = {}
            mock_hh_config.return_value.get_default_parameters.return_value = {}
            mock_hh_config.return_value.should_filter_by_salary.return_value = False
    
            mock_sj_config.return_value.get_base_url.return_value = "https://api.superjob.ru"
            mock_sj_config.return_value.get_search_url.return_value = "https://api.superjob.ru/2.0/vacancies/"
            mock_sj_config.return_value.get_headers.return_value = {}
            mock_sj_config.return_value.get_default_parameters.return_value = {}
            mock_sj_config.return_value.should_filter_by_salary.return_value = False
    
            unified_api = UnifiedAPI()
>           result = unified_api.get_vacancies("Python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_modules_comprehensive.py:579: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestSpecialModules.test_vacancy_storage_service_full_coverage __________________

self = <tests.test_comprehensive_final.TestSpecialModules object at 0x7f419097e750>
mock_connect = <MagicMock name='connect' id='139919558046864'>

    @patch('psycopg2.connect')
    def test_vacancy_storage_service_full_coverage(self, mock_connect):
        """Полное покрытие vacancy_storage_service"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.execute.return_value = None
        mock_cursor.fetchone.return_value = (1, 'Test Company', '123')
        mock_cursor.fetchall.return_value = [(1, 'vacancy1'), (2, 'vacancy2')]
        mock_cursor.rowcount = 5
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
>           storage = VacancyStorageService()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_comprehensive_final.py:770: TypeError
__________________________ TestAPIConfig.test_api_config_initialization __________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f419086e990>

    def test_api_config_initialization(self):
        """Тестирование инициализации базовой конфигурации API"""
        config = APIConfig()
        assert config is not None
>       assert hasattr(config, 'get_base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.api_config.APIConfig object at 0x7f418f9244d0>, 'get_base_url')

tests/test_config_modules_comprehensive.py:34: AssertionError
_________________________ TestAPIConfig.test_api_config_abstract_methods _________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f419086f1d0>

    def test_api_config_abstract_methods(self):
        """Тестирование абстрактных методов базовой конфигурации"""
        config = APIConfig()
    
        # Базовая конфигурация должна возвращать значения по умолчанию
>       base_url = config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:43: AttributeError
______________________________ TestHHAPIConfig.test_hh_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f419085a310>

    def test_hh_config_urls(self):
        """Тестирование URL конфигурации HH"""
>       base_url = self.config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:67: AttributeError
_____________________________ TestHHAPIConfig.test_hh_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f419085abd0>

    def test_hh_config_headers(self):
        """Тестирование заголовков HTTP для HH API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:81: AttributeError
_______________________ TestHHAPIConfig.test_hh_config_default_parameters ________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f419085b190>

    def test_hh_config_default_parameters(self):
        """Тестирование параметров по умолчанию для HH API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:90: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_enabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f419085b990>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_hh_config_salary_filter_enabled(self):
        """Тестирование фильтрации по зарплате когда включена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:102: AttributeError
_____________________ TestHHAPIConfig.test_hh_config_salary_filter_disabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f4190858090>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'false'})
    def test_hh_config_salary_filter_disabled(self):
        """Тестирование фильтрации по зарплате когда отключена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:109: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_default ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f4190859bd0>

    @patch.dict(os.environ, {}, clear=True)
    def test_hh_config_salary_filter_default(self):
        """Тестирование значения по умолчанию для фильтрации по зарплате"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:116: AttributeError
______________________________ TestSJAPIConfig.test_sj_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f4190859b90>

    def test_sj_config_urls(self):
        """Тестирование URL конфигурации SuperJob"""
>       base_url = self.config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:144: AttributeError
_____________________________ TestSJAPIConfig.test_sj_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f4190856a50>

    def test_sj_config_headers(self):
        """Тестирование заголовков HTTP для SuperJob API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:154: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_with_api_key ___________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f4190858fd0>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'test_api_key_123'})
    def test_sj_config_with_api_key(self):
        """Тестирование конфигурации с API ключом"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:165: AttributeError
_________________________ TestSJAPIConfig.test_sj_config_without_api_key _________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f419086f050>

    @patch.dict(os.environ, {}, clear=True)
    def test_sj_config_without_api_key(self):
        """Тестирование конфигурации без API ключа"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:174: AttributeError
___________________________ TestSJAPIConfig.test_sj_config_parameters ____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f4190857790>

    def test_sj_config_parameters(self):
        """Тестирование параметров SuperJob API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:181: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_salary_filter __________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f41908566d0>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_sj_config_salary_filter(self):
        """Тестирование фильтрации по зарплате в SuperJob"""
        config = SJAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:193: AttributeError
________________________ TestDatabaseConfig.test_db_config_initialization ________________________

self = <tests.test_config_modules_comprehensive.TestDatabaseConfig object at 0x7f4190857550>

    def test_db_config_initialization(self):
        """Тестирование инициализации конфигурации БД"""
        assert self.config is not None
        assert hasattr(self.config, 'default_config')
        # Исправленная проверка на допустимые типы хранилищ
>       assert self.config.default_storage_type in ["postgresql", "json", "memory", "postgres"]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'default_storage_type'

tests/test_config_modules_comprehensive.py:209: AttributeError
________________________ TestTargetCompanies.test_company_ids_extraction _________________________

self = <tests.test_config_modules_comprehensive.TestTargetCompanies object at 0x7f419083f650>

    def test_company_ids_extraction(self):
        """Тестирование извлечения ID компаний"""
        if hasattr(self.companies, 'get_all_ids'):
            all_ids = self.companies.get_all_ids()
>           assert isinstance(all_ids, list)
E           AssertionError: assert False
E            +  where False = isinstance({'1057', '1122', '1145', '1165', '12258', '1237', ...}, list)

tests/test_config_modules_comprehensive.py:504: AssertionError
__________________ TestConfigIntegration.test_environment_variables_propagation __________________

self = <tests.test_config_modules_comprehensive.TestConfigIntegration object at 0x7f419083f290>

    @patch.dict(os.environ, {
        'LOG_LEVEL': 'INFO',
        'CACHE_TTL': '7200',
        'FILTER_ONLY_WITH_SALARY': 'true',
        'DATABASE_URL': 'postgresql://test:test@localhost:5432/test'
    })
    def test_environment_variables_propagation(self):
        """Тестирование распространения переменных окружения между конфигурациями"""
        # Проверяем, что переменные окружения корректно используются
        app_config = AppConfig()
        db_config = DatabaseConfig()
        hh_config = HHAPIConfig()
    
        # Все конфигурации должны учитывать переменные окружения
        if hasattr(app_config, 'get_log_level'):
            assert app_config.get_log_level() == 'INFO'
    
        if hasattr(app_config, 'get_cache_ttl'):
            assert app_config.get_cache_ttl() == 7200
    
        db_config_values = db_config.get_config()
        assert db_config_values['host'] == 'localhost'
        assert db_config_values['database'] == 'test'
    
>       assert hh_config.should_filter_by_salary() is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:561: AttributeError
_______________________ TestUserInterfaceModule.test_main_function_success _______________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f4190803250>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f419080ab90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_db_connection_error _________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f4190801910>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f419080b810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_keyboard_interrupt __________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f41908011d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f41908082d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestDBManagerComprehensive.test_check_connection_success ____________________

self = <tests.test_core_modules_comprehensive.TestDBManagerComprehensive object at 0x7f41908024d0>

    def test_check_connection_success(self) -> None:
        """Тестирование успешной проверки подключения"""
        with patch.object(self.db_manager, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.cursor.return_value = mock_cursor
            mock_get_conn.return_value = mock_connection
    
            result = self.db_manager.check_connection()
    
>           assert result is True
E           assert False is True

tests/test_core_modules_comprehensive.py:195: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.storage.db_manager:db_manager.py:790 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
_____________________ TestDBManagerComprehensive.test_create_tables_success ______________________

self = <tests.test_core_modules_comprehensive.TestDBManagerComprehensive object at 0x7f4190800210>

    def test_create_tables_success(self) -> None:
        """Тестирование успешного создания таблиц"""
        with patch.object(self.db_manager, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.cursor.return_value = mock_cursor
            mock_get_conn.return_value = mock_connection
    
>           self.db_manager.create_tables()

tests/test_core_modules_comprehensive.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f418f881b90>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:82: TypeError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
________________________ TestVacancyModels.test_vacancy_validation_valid _________________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f419086c510>

    def test_vacancy_validation_valid(self) -> None:
        """Тестирование валидации корректной вакансии"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="Python Developer",
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is True
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:283: AttributeError
____________________ TestVacancyModels.test_vacancy_validation_invalid_title _____________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f4190896050>

    def test_vacancy_validation_invalid_title(self) -> None:
        """Тестирование валидации вакансии с некорректным названием"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="",  # Пустое название
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is False
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:294: AttributeError
___________________ TestAppConfigComprehensive.test_app_config_default_values ____________________

self = <tests.test_core_modules_comprehensive.TestAppConfigComprehensive object at 0x7f4190894c10>

    def test_app_config_default_values(self) -> None:
        """Тестирование значений по умолчанию"""
        config = AppConfig()
    
        # Проверяем, что есть тип хранилища по умолчанию
>       assert config.default_storage_type in ["postgresql", "json", "memory"]
E       AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
E        +  where 'postgres' = <src.config.app_config.AppConfig object at 0x7f418f9246d0>.default_storage_type

tests/test_core_modules_comprehensive.py:312: AssertionError
________________ TestStorageFactoryComprehensive.test_storage_factory_postgresql _________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f4190897e50>

    def test_storage_factory_postgresql(self) -> None:
        """Тестирование создания PostgreSQL хранилища"""
>       storage = StorageFactory.create_storage("postgresql")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
___________________ TestStorageFactoryComprehensive.test_storage_factory_json ____________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f41908a5250>

    def test_storage_factory_json(self) -> None:
        """Тестирование создания JSON хранилища"""
>       storage = StorageFactory.create_storage("json")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'json'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: json

src/storage/storage_factory.py:20: ValueError
______________________ TestDatabaseConnection.test_database_connection_init ______________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f41907440d0>
mock_connect = <MagicMock name='connect' id='139919558330384'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_database_connection_init(self, mock_connect):
        """Тест инициализации подключения к базе данных"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
    
        assert db_conn is not None
>       assert hasattr(db_conn, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.database_connection.DatabaseConnection object at 0x7f418ee3b3d0>, 'config')

tests/test_database_connection.py:38: AssertionError
__________________________ TestDatabaseConnection.test_close_connection __________________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f4190960790>
mock_connect = <MagicMock name='connect' id='139919568319248'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_close_connection(self, mock_connect):
        """Тест закрытия подключения"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
        connection = db_conn.get_connection()
>       db_conn.close_connection(connection)
E       TypeError: DatabaseConnection.close_connection() takes 1 positional argument but 2 were given

tests/test_database_connection.py:70: TypeError
______________ TestCompleteAPIModuleCoverage.test_headhunter_api_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f41909a7c50>
mock_get = <MagicMock name='get' id='139919557697360'>

    @patch('requests.get')
    def test_headhunter_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование HeadHunter API клиента.
    
        Покрывает все специфичные для HH.ru функции:
        - Поиск вакансий с различными параметрами
        - Получение детальной информации о вакансии
        - Обработка пагинации результатов
        - Работа с фильтрами по компаниям и регионам
        - Обработка rate limiting и ошибок API
        """
        mock_get.return_value = self.mocks['hh_response']
    
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            api = HeadHunterAPI()
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('python developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:159: AttributeError
_______________ TestCompleteAPIModuleCoverage.test_superjob_api_complete_coverage ________________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f41909a78d0>
mock_get = <MagicMock name='get' id='139919543592976'>

    @patch('requests.get')
    def test_superjob_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование SuperJob API клиента.
    
        Покрывает все специфичные для SuperJob.ru функции:
        - Аутентификация с API ключом
        - Поиск вакансий с различными критериями
        - Обработка специфичного формата данных SuperJob
        - Работа с профессиональными каталогами
        - Региональная фильтрация
        """
        # Настраиваем мок для SuperJob ответа
        sj_response = Mock()
        sj_response.json.return_value = {
            'objects': [
                {
                    'id': 456,
                    'profession': 'Java Developer',
                    'firm_name': 'Dev Company',
                    'payment_from': 120000,
                    'payment_to': 180000,
                    'currency': 'rub'
                }
            ],
            'total': 1
        }
        mock_get.return_value = sj_response
    
        try:
            from src.api_modules.sj_api import SuperJobAPI
    
            api = SuperJobAPI('test_api_key')
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('java developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:210: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestCompleteStorageModuleCoverage.test_db_manager_complete_coverage _______________

self = <Mock name='mock.connect().cursor().execute' id='139919557735888'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f4190958890>
mock_connect = <MagicMock name='connect' id='139919556779152'>

    @patch('psycopg2.connect')
    def test_db_manager_complete_coverage(self, mock_connect: Mock) -> None:
        """
        Полное тестирование менеджера базы данных.
    
        Покрывает все операции с PostgreSQL:
        - Создание подключения и проверка доступности
        - Создание таблиц и индексов
        - Операции CRUD для вакансий и компаний
        - Сложные запросы и агрегации
        - Транзакции и откаты
        """
        mock_connect.return_value = self.mocks['connection']
    
        try:
            from src.storage.db_manager import DBManager
    
            db = DBManager()
            assert db is not None
    
            # Тестируем проверку подключения
            is_connected = db.check_connection()
            assert isinstance(is_connected, bool)
    
            # Тестируем создание таблиц
            db.create_tables()
>           self.mocks['cursor'].execute.assert_called()
E           AssertionError: Expected 'execute' to have been called.

tests/test_final_complete_coverage.py:259: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919543641424'>, исправляем...
____________ TestCompleteStorageModuleCoverage.test_storage_factory_complete_coverage ____________

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f4190958e90>

    def test_storage_factory_complete_coverage(self) -> None:
        """
        Полное тестирование фабрики хранилищ.
    
        Покрывает создание различных типов хранилищ:
        - PostgreSQL хранилище
        - JSON файловое хранилище
        - In-memory хранилище для тестов
        - Автоматический выбор хранилища по конфигурации
        """
        try:
            from src.storage.storage_factory import StorageFactory
    
            # Тестируем создание PostgreSQL хранилища
            with patch('psycopg2.connect', return_value=self.mocks['connection']):
>               pg_storage = StorageFactory.create_storage('postgresql')
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_complete_coverage.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
_______________ TestCompleteUIModuleCoverage.test_user_interface_complete_coverage _______________

self = <MagicMock name='print' id='139919574519504'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteUIModuleCoverage object at 0x7f41909596d0>
mock_print = <MagicMock name='print' id='139919574519504'>
mock_input = <MagicMock name='input' id='139919558215568'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_user_interface_complete_coverage(self, mock_print: Mock, mock_input: Mock) -> None:
        """
        Полное тестирование основного пользовательского интерфейса.
    
        Покрывает все сценарии взаимодействия:
        - Отображение главного меню
        - Навигация между разделами
        - Поиск вакансий с различными параметрами
        - Просмотр статистики и результатов
        - Обработка некорректного ввода
        """
        mock_input.return_value = '0'  # Выход из приложения
    
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            mock_storage = Mock()
            mock_db_manager = Mock()
            mock_db_manager.get_companies_and_vacancies_count.return_value = [
                {'company': 'Tech Corp', 'vacancies': 15}
            ]
    
            ui = UserInterface(mock_storage, mock_db_manager)
            assert ui is not None
    
            # Проверяем, что были вызовы print (отображение меню)
>           mock_print.assert_called()
E           AssertionError: Expected 'print' to have been called.

tests/test_final_complete_coverage.py:334: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestCompleteUtilityModuleCoverage.test_salary_comprehensive ___________________

self = <tests.test_final_complete_coverage.TestCompleteUtilityModuleCoverage object at 0x7f4190959a90>

    def test_salary_comprehensive(self) -> None:
        """
        Полное тестирование класса Salary.
    
        Покрывает все аспекты работы с зарплатами:
        - Инициализация с различными параметрами
        - Валидация входных данных
        - Вычисление средних значений
        - Форматирование для отображения
        - Сравнение зарплатных предложений
        """
        try:
            from src.utils.salary import Salary
    
            # Тестируем полную зарплату
            salary_data = {'from': 100000, 'to': 200000, 'currency': 'RUR'}
            salary = Salary(salary_data)
            assert salary.salary_from == 100000
            assert salary.salary_to == 200000
            assert salary.currency == 'RUR'
    
            # Тестируем вычисление средней зарплаты
>           average = salary.get_average()
                      ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'Salary' object has no attribute 'get_average'

tests/test_final_complete_coverage.py:425: AttributeError
_____________ TestCompleteVacancyModelCoverage.test_vacancy_model_complete_coverage ______________

self = <tests.test_final_complete_coverage.TestCompleteVacancyModelCoverage object at 0x7f419095ab90>

    def test_vacancy_model_complete_coverage(self) -> None:
        """
        Полное тестирование модели вакансии.
    
        Покрывает все аспекты вакансии:
        - Создание с полными и частичными данными
        - Валидация обязательных полей
        - Методы сравнения и сортировки
        - Сериализация в JSON и словари
        - Вычисляемые свойства и методы
        """
        try:
            from src.vacancies.models import Vacancy, Employer
    
            # Создаем полную вакансию
            employer = Employer("Test Company", "123")
            vacancy = Vacancy(
                title="Senior Python Developer",
                employer=employer,
                url="https://example.com/vacancy/12345"
            )
    
            assert vacancy is not None
            assert vacancy.title == "Senior Python Developer"
            assert vacancy.employer.name == "Test Company"
    
            # Тестируем валидацию
>           assert vacancy.is_valid() is True
                   ^^^^^^^^^^^^^^^^
E           AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_final_complete_coverage.py:474: AttributeError
______________ TestCompleteConfigurationCoverage.test_app_config_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteConfigurationCoverage object at 0x7f419095b510>

    def test_app_config_complete_coverage(self) -> None:
        """
        Полное тестирование общей конфигурации приложения.
    
        Покрывает основные настройки:
        - Выбор типа хранилища по умолчанию
        - Настройки логирования
        - Конфигурация кэширования
        - Параметры производительности
        - Режимы работы (debug/production)
        """
        try:
            from src.config.app_config import AppConfig
    
            config = AppConfig()
            assert config is not None
    
            # Тестируем основные настройки
            assert hasattr(config, 'default_storage_type')
            storage_type = config.default_storage_type
>           assert storage_type in ['postgresql', 'json', 'memory']
E           AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']

tests/test_final_complete_coverage.py:543: AssertionError
_______________ TestMainApplicationInterface.test_main_application_interface_init ________________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f4190799690>

    def test_main_application_interface_init(self):
        """Тест инициализации главного интерфейса приложения"""
>       interface = MainApplicationInterface()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_main_application_interface.py:49: TypeError
__________________________ TestDBManager.test_db_manager_initialization __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fde50>
mock_connect = <MagicMock name='connect' id='139919547888592'>

    @patch('psycopg2.connect')
    def test_db_manager_initialization(self, mock_connect):
        """Тестирование инициализации менеджера БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        assert self.db_manager is not None
>       assert hasattr(self.db_manager, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.db_manager.DBManager object at 0x7f418ee5e890>, 'config')
E        +    where <src.storage.db_manager.DBManager object at 0x7f418ee5e890> = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fde50>.db_manager

tests/test_storage_modules_comprehensive.py:106: AssertionError
______________________ TestDBManager.test_get_companies_and_vacancies_count ______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fd690>
mock_connect = <MagicMock name='connect' id='139919543825488'>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect):
        """Тестирование получения количества компаний и вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 10),
            ('Company B', 15),
            ('Company C', 5)
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_storage_modules_comprehensive.py:124: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:308 Нет подключения к базе данных
______________________________ TestDBManager.test_get_all_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902ffa50>
mock_connect = <MagicMock name='connect' id='139919557308304'>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тестирование получения всех вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 100000, 'https://test.com/1'),
            ('Company B', 'Java Developer', 120000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:144: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919539332816'>, исправляем...
_______________________________ TestDBManager.test_get_avg_salary ________________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902ff510>
mock_connect = <MagicMock name='connect' id='139919543815504'>

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тестирование получения средней зарплаты"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (125000.0,)
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_avg_salary()
    
        assert isinstance(result, float)
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_storage_modules_comprehensive.py:158: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919557249808'>, исправляем...
______________________ TestDBManager.test_get_vacancies_with_higher_salary _______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fcc90>
mock_connect = <MagicMock name='connect' id='139919547530768'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тестирование получения вакансий с зарплатой выше средней"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Senior Python Developer', 150000, 'https://test.com/1'),
            ('Company B', 'Lead Java Developer', 180000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:175: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919557732624'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919547981648'>, исправляем...
_________________________ TestDBManager.test_get_vacancies_with_keyword __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fc1d0>
mock_connect = <MagicMock name='connect' id='139919547565648'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect):
        """Тестирование поиска вакансий по ключевому слову"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 120000, 'https://test.com/1')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_vacancies_with_keyword("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:191: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139919539550096'>, исправляем...
____________________ TestDBManager.test_db_manager_connection_error_handling _____________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f41902fcd10>
mock_connect = <MagicMock name='connect' id='139919543319312'>

    @patch('psycopg2.connect')
    def test_db_manager_connection_error_handling(self, mock_connect):
        """Тестирование обработки ошибок подключения"""
        mock_connect.side_effect = Exception("Connection failed")
    
        # Методы должны обрабатывать ошибки подключения
        result = self.db_manager.get_companies_and_vacancies_count()
>       assert result == []
E       AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
E         
E         Left contains 12 more items, first extra item: ('Яндекс', 0)
E         Use -v to get more diff

tests/test_storage_modules_comprehensive.py:200: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:308 Нет подключения к базе данных
_____________________________ TestPostgresSaver.test_save_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestPostgresSaver object at 0x7f41904e2450>
mock_connect = <MagicMock name='connect' id='139919546464272'>

    @patch('psycopg2.connect')
    def test_save_vacancies(self, mock_connect):
        """Тестирование сохранения вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        vacancies = [create_mock_vacancy() for _ in range(3)]
    
        self.postgres_saver.save_vacancies(vacancies)
    
        # Проверяем, что курсор был использован для выполнения запросов
>       assert mock_cursor.execute.called
E       AssertionError: assert False
E        +  where False = <Mock name='connect().cursor().execute' id='139919547594256'>.called
E        +    where <Mock name='connect().cursor().execute' id='139919547594256'> = <Mock name='connect().cursor()' id='139919546011216'>.execute

tests/test_storage_modules_comprehensive.py:242: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139919543773648'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139919543765520'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='139919543764624'>
_________________________ TestStorageFactory.test_create_invalid_storage _________________________

self = <tests.test_storage_modules_comprehensive.TestStorageFactory object at 0x7f41904e2f10>

    def test_create_invalid_storage(self):
        """Тестирование создания несуществующего типа хранилища"""
>       storage = StorageFactory.create_storage("invalid_type")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'invalid_type'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: invalid_type

src/storage/storage_factory.py:20: ValueError
_________________ TestDatabaseConnection.test_database_connection_establishment __________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f41904e3890>
mock_connect = <MagicMock name='connect' id='139919543320336'>

    @patch('psycopg2.connect')
    def test_database_connection_establishment(self, mock_connect):
        """Тестирование установки подключения к БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        connection = self.db_connection.get_connection()
    
        if connection:
>           assert connection == mock_conn
E           AssertionError: assert <MagicMock name='mock.connect()' id='139919546465808'> == <Mock name='connect()' id='139919543319312'>

tests/test_storage_modules_comprehensive.py:330: AssertionError
_________________ TestDatabaseConnection.test_database_connection_error_handling _________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f41904e01d0>

    def test_database_connection_error_handling(self):
        """Тестирование обработки ошибок подключения"""
        with patch('psycopg2.connect', side_effect=Exception("Connection failed")):
            connection = self.db_connection.get_connection()
>           assert connection is None
E           AssertionError: assert <MagicMock name='mock.connect()' id='139919546465808'> is None

tests/test_storage_modules_comprehensive.py:346: AssertionError
__________________ TestVacancyRepository.test_vacancy_repository_initialization __________________

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f41904e0bd0>

    def test_vacancy_repository_initialization(self):
        """Тестирование инициализации репозитория вакансий"""
        assert self.vacancy_repository is not None
>       assert hasattr(self.vacancy_repository, 'db_manager')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.vacancy_repository.VacancyRepository object at 0x7f418ed65010>, 'db_manager')
E        +    where <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f418ed65010> = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f41904e0bd0>.vacancy_repository

tests/test_storage_modules_comprehensive.py:364: AssertionError
___________________________ TestVacancyRepository.test_delete_vacancy ____________________________

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f418ef2e110>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:159: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f41904d7310>

    def test_delete_vacancy(self):
        """Тестирование удаления вакансии"""
        if hasattr(self.vacancy_repository, 'delete_vacancy'):
>           result = self.vacancy_repository.delete_vacancy("test_123")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f418ef2e110>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
            with self._db_connection.get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute(
                        "DELETE FROM vacancies WHERE vacancy_id = %s",
                        (vacancy.vacancy_id,)
                    )
                    conn.commit()
    
                    if cursor.rowcount > 0:
                        logger.debug(f"Вакансия {vacancy.vacancy_id} успешно удалена")
                    else:
                        logger.warning(f"Вакансия {vacancy.vacancy_id} не найдена для удаления")
    
        except Exception as e:
>           logger.error(f"Ошибка удаления вакансии {vacancy.vacancy_id}: {e}")
                                                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/components/vacancy_repository.py:173: AttributeError
________________________ TestVacancyValidator.test_get_validation_errors _________________________

self = <tests.test_storage_modules_comprehensive.TestVacancyValidator object at 0x7f41904be690>

    def test_get_validation_errors(self):
        """Тестирование получения ошибок валидации"""
        vacancy = Mock()
        vacancy.vacancy_id = ""
        vacancy.title = ""
        vacancy.url = "invalid_url"
    
        if hasattr(self.validator, 'get_validation_errors'):
>           errors = self.validator.get_validation_errors(vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given

tests/test_storage_modules_comprehensive.py:466: TypeError
_________________ TestVacancyStorageService.test_storage_service_initialization __________________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f41904d50d0>

    def test_storage_service_initialization(self):
        """Тестирование инициализации сервиса хранения"""
        assert self.storage_service is not None
>       assert hasattr(self.storage_service, 'storage')
E       AssertionError: assert False
E        +  where False = hasattr(<tests.test_storage_modules_comprehensive.TestVacancyStorageService.setup_method.<locals>.TestVacancyStorageService object at 0x7f41908970d0>, 'storage')
E        +    where <tests.test_storage_modules_comprehensive.TestVacancyStorageService.setup_method.<locals>.TestVacancyStorageService object at 0x7f41908970d0> = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f41904d50d0>.storage_service

tests/test_storage_modules_comprehensive.py:494: AssertionError
_______________________ TestStorageIntegration.test_full_storage_workflow ________________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f41904bd890>
mock_connect = <MagicMock name='connect' id='139919557968336'>

    @patch('psycopg2.connect')
    def test_full_storage_workflow(self, mock_connect):
        """Тестирование полного рабочего процесса хранения"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Создаем компоненты
>       with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:632: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f418e7cf710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________________ TestStorageIntegration.test_storage_error_recovery _______________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f41904bdc50>

    def test_storage_error_recovery(self):
        """Тестирование восстановления после ошибок хранения"""
        with patch('psycopg2.connect', side_effect=Exception("Database unavailable")):
>           with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:648: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
