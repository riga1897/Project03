~/workspace$ pytest
========================= test session starts =========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 765 items                                                   

tests/test_abstract.py ........                                 [  1%]
tests/test_abstract_db_manager.py ....                          [  1%]
tests/test_api_config.py ....                                   [  2%]
tests/test_api_modules.py .............................         [  5%]
tests/test_app_config.py .....                                  [  6%]
tests/test_base_api.py ......                                   [  7%]
tests/test_base_formatter.py ..........                         [  8%]
tests/test_base_parser.py ......                                [  9%]
tests/test_cache.py .......                                     [ 10%]
tests/test_cached_api.py ...........                            [ 11%]
tests/test_complete_ui_coverage.py ..............               [ 13%]
tests/test_comprehensive_coverage.py ........................   [ 16%]
tests/test_comprehensive_src_coverage.py ...................    [ 19%]
tests/test_console_interface.py ......                          [ 20%]
tests/test_consolidated_coverage.py FFFFFFFFF.FF.FF..FF.FFFFFF. [ 23%]
F.FF                                                            [ 24%]
tests/test_coverage_enhancement.py ......................       [ 26%]
tests/test_coverage_validation.py .FF.F.F                       [ 27%]
tests/test_data_normalizers_comprehensive.py .................. [ 30%]
..........                                                      [ 31%]
tests/test_db_config.py .....                                   [ 32%]
tests/test_db_manager.py .................                      [ 34%]
tests/test_decorators.py .......                                [ 35%]
tests/test_env_loader.py ................                       [ 37%]
tests/test_final_comprehensive_coverage.py FFFF.....FF..F...... [ 40%]
F.......                                                        [ 41%]
tests/test_full_src_coverage.py ...............                 [ 43%]
tests/test_get_api.py ......                                    [ 43%]
tests/test_hh_api.py .......                                    [ 44%]
tests/test_hh_api_config.py .....                               [ 45%]
tests/test_hh_parser.py ........                                [ 46%]
tests/test_integration.py .............                         [ 48%]
tests/test_menu_manager.py ..........                           [ 49%]
tests/test_missing_components.py .........                      [ 50%]
tests/test_optimized_coverage.py FFFFFFF.FFFF.FF...             [ 52%]
tests/test_paginator.py ......                                  [ 53%]
tests/test_postgres_saver.py .FFFFFFFFF.FF.                     [ 55%]
tests/test_salary_fixed.py ...........                          [ 56%]
tests/test_salary_utils.py ......................               [ 59%]
tests/test_search_utils.py ............................         [ 63%]
tests/test_sj_api.py ..............                             [ 65%]
tests/test_sj_api_config.py .....                               [ 66%]
tests/test_sj_parser.py ........                                [ 67%]
tests/test_source_manager.py .................                  [ 69%]
tests/test_stable_coverage.py .....F.....F....F....             [ 72%]
tests/test_storage_factory.py ........                          [ 73%]
tests/test_target_companies.py .....                            [ 73%]
tests/test_targeted_coverage.py .FF...F..                       [ 74%]
tests/test_ui_config.py .......................                 [ 77%]
tests/test_ui_helpers_comprehensive.py ....................FFFF [ 81%]
F                                                               [ 81%]
tests/test_ui_navigation.py ......................              [ 84%]
tests/test_unified_api.py .................                     [ 86%]
tests/test_user_interface.py FFFFFFFF                           [ 87%]
tests/test_vacancy_formatter.py ........                        [ 88%]
tests/test_vacancy_operations.py ......                         [ 89%]
tests/test_vacancy_operations_coordinator.py .................. [ 91%]
.........                                                       [ 92%]
tests/test_vacancy_operations_enhanced.py ............FFFFFFFFF [ 95%]
F                                                               [ 95%]
tests/test_vacancy_processing_coordinator.py .............      [ 97%]
tests/test_vacancy_stats.py ............                        [ 98%]
tests/test_vacancy_stats_fixed.py .........                     [100%]

============================== FAILURES ===============================
_________ TestConsolidatedCoverage.test_hh_api_functionality __________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978c7f50>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649832630352'>, 'env_loader': <Mock id='140649832633424'>, 'file_cache': <Mock id='140649832633680'>, ...}

    def test_hh_api_functionality(self, consolidated_mocks):
        """Тест HeadHunter API"""
>       with patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_consolidated_coverage.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______ TestConsolidatedCoverage.test_superjob_api_functionality _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cc390>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649822831056'>, 'env_loader': <Mock id='140649822840208'>, 'file_cache': <Mock id='140649822839952'>, ...}

    def test_superjob_api_functionality(self, consolidated_mocks):
        """Тест SuperJob API"""
>       with patch('src.api_modules.sj_api.requests.get') as mock_get:

tests/test_consolidated_coverage.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.sj_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.sj_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
_______ TestConsolidatedCoverage.test_unified_api_functionality _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cc950>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649834556304'>, 'env_loader': <Mock id='140649822832528'>, 'file_cache': <Mock id='140649822846608'>, ...}

    def test_unified_api_functionality(self, consolidated_mocks):
        """Тест UnifiedAPI"""
        with patch('src.api_modules.unified_api.HeadHunterAPI') as mock_hh, \
             patch('src.api_modules.unified_api.SuperJobAPI') as mock_sj:
    
            mock_hh_instance = Mock()
            mock_sj_instance = Mock()
            mock_hh.return_value = mock_hh_instance
            mock_sj.return_value = mock_sj_instance
    
            mock_hh_instance.get_vacancies.return_value = [consolidated_mocks['vacancy']]
            mock_sj_instance.get_vacancies.return_value = [consolidated_mocks['vacancy']]
    
            api = UnifiedAPI()
>           result = api.get_vacancies_from_sources("Python", ["hh", "sj"])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_consolidated_coverage.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/api_modules/unified_api.py:82: in get_vacancies_from_sources
    filtered_vacancies = self._filter_by_target_companies(all_vacancies)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/api_modules/unified_api.py:117: in _filter_by_target_companies
    source = vacancy_data.get("source", "").lower()
             ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock spec='Vacancy' id='140649822838416'>, name = 'get'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
>               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'get'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:653: AttributeError
_______ TestConsolidatedCoverage.test_db_manager_functionality ________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cd050>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...ct()' id='140649823340560'>, 'env_loader': <Mock id='140649823342672'>, 'file_cache': <Mock id='140649823351888'>, ...}

    def test_db_manager_functionality(self, consolidated_mocks):
        """Тест DBManager"""
        with patch('src.storage.db_manager.psycopg2.connect') as mock_connect:
            mock_connect.return_value = consolidated_mocks['db_connection']
    
            # Создание с правильными параметрами
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            db_manager = DBManager(db_config)
    
            # Тест создания таблиц
>           db_manager.create_tables()

tests/test_consolidated_coverage.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:82: in create_tables
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7feb96c22750>

    def _get_connection(self):
        """
        Создает подключение к базе данных
    
        Returns:
            connection: Подключение к БД (psycopg2 или простой адаптер)
    
        Raises:
            Exception: При ошибке подключения к БД
        """
        if not PSYCOPG2_AVAILABLE:
            # Возвращаем простой адаптер как "подключение"
            return get_db_adapter()
    
        try:
>           connection_params = self.db_config.get_connection_params()
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'get_connection_params'

src/storage/db_manager.py:64: AttributeError
-------------------------- Captured log call --------------------------
ERROR    src.storage.db_manager:db_manager.py:73 Ошибка подключения к базе данных: 'dict' object has no attribute 'get_connection_params'
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'dict' object has no attribute 'get_connection_params'
_____ TestConsolidatedCoverage.test_postgres_saver_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cd710>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...ct()' id='140649832755600'>, 'env_loader': <Mock id='140649832757584'>, 'file_cache': <Mock id='140649832755984'>, ...}
mock_vacancy = <Mock spec='Vacancy' id='140649832758288'>

    def test_postgres_saver_functionality(self, consolidated_mocks, mock_vacancy):
        """Тест PostgresSaver"""
        with patch('src.storage.postgres_saver.psycopg2.connect') as mock_connect:
            mock_connect.return_value = consolidated_mocks['db_connection']
    
            # Настройка курсора для возврата результатов
            cursor = consolidated_mocks['db_connection'].cursor()
            cursor.fetchall.return_value = [
                ("123", "Python Developer", "https://test.com/123", "hh",
                 '{"from": 100000, "to": 150000}', "Test Company", "Москва",
                 "От 1 года до 3 лет", "Полная занятость", "Полный день",
                 "Test description", "Python, Django", "Development tasks",
                 "2025-01-01T00:00:00+0300")
            ]
    
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            saver = PostgresSaver(db_config)
    
            # Тест сохранения вакансии
>           result = saver.save_vacancy(mock_vacancy)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_consolidated_coverage.py:206: AttributeError
_____ TestConsolidatedCoverage.test_user_interface_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cc050>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649833633936'>, 'env_loader': <Mock id='140649814358544'>, 'file_cache': <Mock id='140649814355024'>, ...}

    def test_user_interface_functionality(self, consolidated_mocks):
        """Тест пользовательского интерфейса"""
>       with patch('src.ui_interfaces.console_interface.input', return_value='1'), \
             patch('src.ui_interfaces.console_interface.print'), \
             patch.object(UserInterface, 'storage', consolidated_mocks['storage']):

tests/test_consolidated_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb979142d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.console_interface.UserInterface'> does not have the attribute 'storage'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestConsolidatedCoverage.test_vacancy_model_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cdc90>
mock_vacancy = <Mock spec='Vacancy' id='140649842441488'>

    def test_vacancy_model_functionality(self, mock_vacancy):
        """Тест модели Vacancy"""
        # Создание вакансии из словаря
        vacancy_data = {
            'id': '123',
            'name': 'Python Developer',
            'url': 'https://test.com/123',
            'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
            'employer': {'name': 'Test Company'},
            'area': {'name': 'Москва'},
            'experience': {'name': 'От 1 года до 3 лет'},
            'employment': {'name': 'Полная занятость'},
            'schedule': {'name': 'Полный день'},
            'snippet': {'requirement': 'Python, Django', 'responsibility': 'Development'},
            'published_at': '2025-01-01T00:00:00+0300'
        }
    
>       vacancy = Vacancy.from_dict(vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_consolidated_coverage.py:250: TypeError
_____ TestConsolidatedCoverage.test_utility_modules_functionality _____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978ce090>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649833772944'>, 'env_loader': <Mock id='140649833006160'>, 'file_cache': <Mock id='140649836203856'>, ...}

    def test_utility_modules_functionality(self, consolidated_mocks):
        """Тест утилитных модулей"""
        # Тест поисковых утилит
        try:
            from src.utils.search_utils import normalize_query, extract_keywords
    
            normalized = normalize_query("  Python   Developer  ")
            assert isinstance(normalized, str)
    
            keywords = extract_keywords("Python Django REST API")
            assert isinstance(keywords, list)
        except ImportError:
            pass
    
        # Тест операций с файлами
        try:
            from src.utils.file_handlers import FileOperations
    
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                test_data = {"test": "data"}
                json.dump(test_data, f)
                temp_path = f.name
    
            try:
                file_ops = FileOperations()
                result = file_ops.read_json(temp_path)
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_consolidated_coverage.py:282: AssertionError
-------------------------- Captured log call --------------------------
ERROR    src.utils.file_handlers:file_handlers.py:47 Failed to read /tmp/tmpsu7fka2m.json: 'str' object has no attribute 'exists'
____ TestConsolidatedCoverage.test_storage_services_functionality _____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978ce750>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649833641360'>, 'env_loader': <Mock id='140649832568592'>, 'file_cache': <Mock id='140649832567376'>, ...}

    def test_storage_services_functionality(self, consolidated_mocks):
        """Тест сервисов хранения"""
        # Тест репозитория вакансий
        try:
            from src.storage.components.vacancy_repository import VacancyRepository
    
>           with patch.object(VacancyRepository, 'db_connection', consolidated_mocks['db_connection']):

tests/test_consolidated_coverage.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb974edd10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.storage.components.vacancy_repository.VacancyRepository'> does not have the attribute 'db_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____ TestConsolidatedCoverage.test_config_modules_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cf3d0>

    def test_config_modules_functionality(self):
        """Тест модулей конфигурации"""
        # Тест конфигурации БД
        try:
            from src.config.db_config import DatabaseConfig
    
            config = DatabaseConfig()
>           db_params = config.get_db_params()
                        ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DatabaseConfig' object has no attribute 'get_db_params'

tests/test_consolidated_coverage.py:352: AttributeError
______ TestConsolidatedCoverage.test_ui_components_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cfa90>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649814857104'>, 'env_loader': <Mock id='140649814853264'>, 'file_cache': <Mock id='140649814852688'>, ...}

    def test_ui_components_functionality(self, consolidated_mocks):
        """Тест UI компонентов"""
        # Тест обработчика отображения вакансий
        try:
            from src.ui_interfaces.vacancy_display_handler import VacancyDisplayHandler
    
            with patch('builtins.print'):
                handler = VacancyDisplayHandler(consolidated_mocks['storage'])
>               handler.display_vacancies([consolidated_mocks['vacancy']])
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_consolidated_coverage.py:383: AttributeError
_______ TestConsolidatedCoverage.test_decorators_functionality ________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d4790>

    def test_decorators_functionality(self):
        """Тест декораторов"""
        try:
            from src.utils.decorators import simple_cache, time_execution
    
            # Тест простого кэша
            @simple_cache
            def test_func(x):
                return x * 2
    
            result1 = test_func(5)
            result2 = test_func(5)
>           assert result1 == result2 == 10
E           assert <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7feb97533100> == <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7feb975316c0>

tests/test_consolidated_coverage.py:440: AssertionError
___ TestConsolidatedCoverage.test_vacancy_operations_functionality ____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d4e50>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649832192272'>, 'env_loader': <Mock id='140649832201552'>, 'file_cache': <Mock id='140649832201488'>, ...}

    def test_vacancy_operations_functionality(self, consolidated_mocks):
        """Тест операций с вакансиями"""
        try:
            from src.utils.vacancy_operations import VacancyOperations
    
            vacancies = [consolidated_mocks['vacancy']]
    
            # Тест фильтрации по ключевому слову
>           filtered = VacancyOperations.filter_vacancies_by_keyword(vacancies, "Python")
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_keyword'

tests/test_consolidated_coverage.py:461: AttributeError
_______ TestConsolidatedCoverage.test_env_loader_functionality ________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d6110>

    def test_env_loader_functionality(self):
        """Тест загрузчика переменных окружения"""
        try:
            from src.utils.env_loader import EnvLoader
    
            with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:
                f.write("TEST_VAR=test_value\n")
                f.write("API_KEY=secret_key\n")
                env_path = f.name
    
            try:
>               loader = EnvLoader(env_path)
                         ^^^^^^^^^^^^^^^^^^^
E               TypeError: EnvLoader() takes no arguments

tests/test_consolidated_coverage.py:521: TypeError
______ TestConsolidatedCoverage.test_menu_manager_functionality _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d6710>

    def test_menu_manager_functionality(self):
        """Тест менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            with patch('builtins.input', return_value='1'), \
                 patch('builtins.print'):
    
                menu_items = [
                    ("Поиск вакансий", lambda: "search"),
                    ("Просмотр сохраненных", lambda: "view"),
                    ("Выход", lambda: "exit")
                ]
    
>               manager = MenuManager(menu_items)
                          ^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_consolidated_coverage.py:544: TypeError
________ TestConsolidatedCoverage.test_paginator_functionality ________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d7310>

    def test_paginator_functionality(self):
        """Тест пагинатора"""
        try:
            from src.utils.paginator import Paginator
    
            items = list(range(100))
>           paginator = Paginator(items, per_page=10)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Paginator() takes no arguments

tests/test_consolidated_coverage.py:576: TypeError
_ TestConsolidatedCoverage.test_main_application_interface_functionality _

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978d7a90>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649820391824'>, 'env_loader': <Mock id='140649820390224'>, 'file_cache': <Mock id='140649820393424'>, ...}

    def test_main_application_interface_functionality(self, consolidated_mocks):
        """Тест главного интерфейса приложения"""
        try:
            from src.interfaces.main_application_interface import ConsoleApplicationInterface
    
            with patch('builtins.input', return_value='q'), \
                 patch('builtins.print'):
    
                # Создание с необходимыми моками
>               interface = ConsoleApplicationInterface()
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_consolidated_coverage.py:599: TypeError
_____ TestConsolidatedCoverage.test_storage_factory_functionality _____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978dc250>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649820394064'>, 'env_loader': <Mock id='140649820399696'>, 'file_cache': <Mock id='140649820396496'>, ...}

    def test_storage_factory_functionality(self, consolidated_mocks):
        """Тест фабрики хранилища"""
        try:
            from src.storage.storage_factory import StorageFactory
    
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            with patch('src.storage.storage_factory.PostgresSaver') as mock_saver:
                mock_saver.return_value = consolidated_mocks['storage']
    
>               storage = StorageFactory.create_storage("postgres", db_config)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: StorageFactory.create_storage() takes from 0 to 1 positional arguments but 2 were given

tests/test_consolidated_coverage.py:632: TypeError
______ TestConsolidatedCoverage.test_main_user_interface_module _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978dca10>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649820405712'>, 'env_loader': <Mock id='140649820397264'>, 'file_cache': <Mock id='140649820397584'>, ...}

    def test_main_user_interface_module(self, consolidated_mocks):
        """Тест главного модуля пользовательского интерфейса"""
        try:
            import src.user_interface as ui_module
    
>           with patch('src.user_interface.DBManager') as mock_db_manager, \
                 patch('src.user_interface.UserInterface') as mock_ui, \
                 patch('builtins.input', return_value='q'), \
                 patch('builtins.print'):

tests/test_consolidated_coverage.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb96950a10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestConsolidatedCoverage.test_api_connector_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978dd190>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649836921360'>, 'env_loader': <Mock id='140649833889360'>, 'file_cache': <Mock id='140649833880528'>, ...}

    def test_api_connector_functionality(self, consolidated_mocks):
        """Тест API коннектора"""
        try:
            from src.api_modules.get_api import APIConnector
    
>           with patch('src.api_modules.get_api.HeadHunterAPI') as mock_hh, \
                 patch('src.api_modules.get_api.SuperJobAPI') as mock_sj:

tests/test_consolidated_coverage.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb9762c290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.get_api' from '/home/runner/workspace/tests/../src/api_modules/get_api.py'> does not have the attribute 'HeadHunterAPI'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____ TestConsolidatedCoverage.test_comprehensive_error_handling ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978dd910>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649832708624'>, 'env_loader': <Mock id='140649832705552'>, 'file_cache': <Mock id='140649832697872'>, ...}

    def test_comprehensive_error_handling(self, consolidated_mocks):
        """Тест обработки ошибок во всех модулях"""
        # Тест с ошибками подключения к БД
        with patch('src.storage.postgres_saver.psycopg2.connect', side_effect=Exception("Connection failed")):
            try:
                from src.storage.postgres_saver import PostgresSaver
    
                db_config = {'host': 'localhost', 'port': '5432', 'database': 'test', 'username': 'user', 'password': 'pass'}
>               saver = PostgresSaver(db_config)
                        ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_consolidated_coverage.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:54: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:80: in _ensure_database_exists
    connection = self._get_connection("postgres")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:61: in _get_connection
    connection = psycopg2.connect(
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='connect' id='140649832743120'>, args = ()
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': 'pass', ...}
effect = Exception('Connection failed')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Connection failed

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
_________ TestConsolidatedCoverage.test_integration_workflow __________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978cf190>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649832168656'>, 'env_loader': <Mock id='140649822555792'>, 'file_cache': <Mock id='140649822554960'>, ...}

    def test_integration_workflow(self, consolidated_mocks):
        """Интеграционный тест основного рабочего процесса"""
>       with patch('src.api_modules.hh_api.requests.get') as mock_get, \
             patch('src.storage.postgres_saver.psycopg2.connect') as mock_connect, \
             patch('builtins.input', return_value='q'), \
             patch('builtins.print'):

tests/test_consolidated_coverage.py:739: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____ TestConsolidatedCoverage.test_complete_service_layer_coverage ____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978dc750>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649819920528'>, 'env_loader': <Mock id='140649819920464'>, 'file_cache': <Mock id='140649819919312'>, ...}

    def test_complete_service_layer_coverage(self, consolidated_mocks):
        """Тест полного покрытия сервисного слоя"""
        try:
            # Мок для сервисов с правильными параметрами
            mock_storage = consolidated_mocks['storage']
    
            # Тест дедупликации
            from src.storage.services.deduplication_service import DeduplicationService
            dedup_service = DeduplicationService(mock_storage)
>           result = dedup_service.deduplicate_vacancies([consolidated_mocks['vacancy']])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_vacancies'

tests/test_consolidated_coverage.py:806: AttributeError
_______ TestConsolidatedCoverage.test_complete_application_flow _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7feb978ddd50>
mock_print = <MagicMock name='print' id='140649832131472'>
mock_input = <MagicMock name='input' id='140649832125776'>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140649832132240'>, 'env_loader': <Mock id='140649832132048'>, 'file_cache': <Mock id='140649832131728'>, ...}

    @patch('builtins.input', return_value='q')
    @patch('builtins.print')
    def test_complete_application_flow(self, mock_print, mock_input, consolidated_mocks):
        """Тест полного потока приложения"""
>       with patch('src.storage.db_manager.psycopg2.connect') as mock_connect, \
             patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_consolidated_coverage.py:831: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______ TestCoverageValidation.test_basic_functionality_coverage _______

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7feb97903a50>

    def test_basic_functionality_coverage(self):
        """Базовый тест функциональности для покрытия"""
        # Тест модели вакансии
        from src.vacancies.models import Vacancy
    
        vacancy_data = {
            'id': 'test_123',
            'name': 'Test Job',
            'url': 'https://test.com',
            'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
            'employer': {'name': 'Test Company'},
            'area': {'name': 'Test City'},
            'experience': {'name': 'Test Experience'},
            'employment': {'name': 'Test Employment'},
            'schedule': {'name': 'Test Schedule'},
            'snippet': {'requirement': 'Test req', 'responsibility': 'Test resp'},
            'published_at': '2025-01-01T00:00:00+0300'
        }
    
>       vacancy = Vacancy.from_dict(vacancy_data, 'test')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_coverage_validation.py:63: TypeError
_______ TestCoverageValidation.test_api_modules_basic_coverage ________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7feb97904090>

    def test_api_modules_basic_coverage(self):
        """Базовое покрытие API модулей"""
>       with patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_coverage_validation.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestCoverageValidation.test_ui_basic_coverage ____________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7feb978f8090>

    def test_ui_basic_coverage(self):
        """Базовое покрытие UI модулей"""
        with patch('builtins.input', return_value='q'), \
             patch('builtins.print'):
    
            from src.ui_interfaces.console_interface import UserInterface
    
            mock_storage = Mock()
            mock_api = Mock()
            mock_storage.get_vacancies.return_value = []
    
>           interface = UserInterface(storage=mock_storage, unified_api=mock_api)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: UserInterface.__init__() got an unexpected keyword argument 'unified_api'

tests/test_coverage_validation.py:109: TypeError
__________ TestCoverageValidation.test_config_basic_coverage __________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7feb97904890>

    def test_config_basic_coverage(self):
        """Базовое покрытие модулей конфигурации"""
        try:
            from src.config.db_config import DatabaseConfig
            config = DatabaseConfig()
            assert config is not None
        except ImportError:
            pass
    
        try:
            from src.config.target_companies import TargetCompanies
>           companies = TargetCompanies.get_target_companies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'TargetCompanies' has no attribute 'get_target_companies'

tests/test_coverage_validation.py:139: AttributeError
___ TestFinalComprehensiveCoverage.test_vacancy_model_functionality ___

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97952250>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_vacancy_model_functionality(self, standard_vacancy_data):
        """Тест модели вакансии"""
        # Тест создания вакансии (правильная сигнатура)
        vacancy = Vacancy.from_dict(standard_vacancy_data)
    
        assert vacancy.vacancy_id == '123456'
        assert vacancy.title == 'Python Developer'
        assert 'Python' in str(vacancy.requirements)
    
        # Тест методов вакансии
        vacancy_dict = vacancy.to_dict()
        assert isinstance(vacancy_dict, dict)
>       assert vacancy_dict['id'] == '123456'
               ^^^^^^^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_final_comprehensive_coverage.py:100: KeyError
____ TestFinalComprehensiveCoverage.test_api_modules_comprehensive ____

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97953a90>
consolidated_mocks = {'api_response': {'items': [{'id': '123', 'name': 'Python Developer', 'source': 'hh.ru'}]}, 'db_connection': <Mock id=...22815632'>, 'db_cursor': <Mock name='mock.cursor()' id='140649822816080'>, 'storage': <Mock id='140649822817104'>, ...}

    def test_api_modules_comprehensive(self, consolidated_mocks):
        """Комплексный тест всех API модулей"""
        # Тест HeadHunter API с правильным patch
        with patch('requests.get') as mock_get:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.json.return_value = consolidated_mocks['api_response']
            mock_response.status_code = 200
            mock_get.return_value = mock_response
    
            api = HeadHunterAPI()
            result = api.get_vacancies("Python")
    
            assert isinstance(result, list)
            mock_get.assert_called()
    
        # Тест SuperJob API
        with patch('requests.get') as mock_get:
            from src.api_modules.sj_api import SuperJobAPI
    
            mock_response = Mock()
            mock_response.json.return_value = {"objects": [{"id": "123", "profession": "Python Developer"}]}
            mock_response.status_code = 200
            mock_get.return_value = mock_response
    
            api = SuperJobAPI()
            result = api.get_vacancies("Python", per_page=10)
    
            assert isinstance(result, list)
    
        # Тест Unified API
        with patch('src.api_modules.unified_api.HeadHunterAPI') as mock_hh, \
             patch('src.api_modules.unified_api.SuperJobAPI') as mock_sj:
            from src.api_modules.unified_api import UnifiedAPI
    
            mock_hh_instance = Mock()
            mock_sj_instance = Mock()
            mock_hh.return_value = mock_hh_instance
            mock_sj.return_value = mock_sj_instance
    
            mock_hh_instance.get_vacancies.return_value = [consolidated_mocks['vacancy']]
            mock_sj_instance.get_vacancies.return_value = [consolidated_mocks['vacancy']]
    
            unified_api = UnifiedAPI()
>           result = unified_api.get_vacancies_from_sources("Python", ["hh", "sj"])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_comprehensive_coverage.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/api_modules/unified_api.py:82: in get_vacancies_from_sources
    filtered_vacancies = self._filter_by_target_companies(all_vacancies)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.api_modules.unified_api.UnifiedAPI object at 0x7feb9639a350>
all_vacancies = [<Mock id='140649822829840'>, <Mock id='140649822829840'>]

    def _filter_by_target_companies(self, all_vacancies: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Фильтрация вакансий по целевым компаниям через проверку ID работодателя
    
        Args:
            all_vacancies: Все полученные вакансии
    
        Returns:
            List[Dict]: Вакансии только от целевых компаний
        """
        if not all_vacancies:
            return []
    
        # Получаем ID целевых компаний
        from src.config.target_companies import TargetCompanies
        target_companies = TargetCompanies.get_all_companies()
        target_hh_ids = {str(comp.hh_id) for comp in target_companies if comp.hh_id}
        target_sj_ids = {str(comp.sj_id) for comp in target_companies if comp.sj_id}
    
        filtered_vacancies = []
    
        for vacancy_data in all_vacancies:
            employer_id = None
            source = vacancy_data.get("source", "").lower()
    
            # Извлекаем ID работодателя
>           if "employer" in vacancy_data and isinstance(vacancy_data["employer"], dict):
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: argument of type 'Mock' is not iterable

src/api_modules/unified_api.py:120: TypeError
------------------------ Captured stderr call -------------------------
Fetching pages:   5%|▌         | 1/20 [00:00<00:02,  6.36page/s, vacancFetching pages:   5%|▌         | 1/20 [00:00<00:02,  6.36page/s, vacancFetching pages:  10%|█         | 2/20 [00:00<00:02,  6.50page/s, vacancFetching pages:  10%|█         | 2/20 [00:00<00:02,  6.50page/s, vacancFetching pages:  15%|█▌        | 3/20 [00:00<00:02,  6.56page/s, vacancFetching pages:  15%|█▌        | 3/20 [00:00<00:02,  6.56page/s, vacancFetching pages:  20%|██        | 4/20 [00:00<00:02,  6.58page/s, vacancFetching pages:  20%|██        | 4/20 [00:00<00:02,  6.58page/s, vacancFetching pages:  25%|██▌       | 5/20 [00:00<00:02,  6.60page/s, vacancFetching pages:  25%|██▌       | 5/20 [00:00<00:02,  6.60page/s, vacancFetching pages:  30%|███       | 6/20 [00:00<00:02,  6.61page/s, vacancFetching pages:  30%|███       | 6/20 [00:01<00:02,  6.61page/s, vacancFetching pages:  35%|███▌      | 7/20 [00:01<00:01,  6.61page/s, vacancFetching pages:  35%|███▌      | 7/20 [00:01<00:01,  6.61page/s, vacancFetching pages:  40%|████      | 8/20 [00:01<00:01,  6.62page/s, vacancFetching pages:  40%|████      | 8/20 [00:01<00:01,  6.62page/s, vacancFetching pages:  45%|████▌     | 9/20 [00:01<00:01,  6.62page/s, vacancFetching pages:  45%|████▌     | 9/20 [00:01<00:01,  6.62page/s, vacancFetching pages:  50%|█████     | 10/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  50%|█████     | 10/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  55%|█████▌    | 11/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  55%|█████▌    | 11/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  60%|██████    | 12/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  60%|██████    | 12/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  65%|██████▌   | 13/20 [00:01<00:01,  6.62page/s, vacanFetching pages:  65%|██████▌   | 13/20 [00:02<00:01,  6.62page/s, vacanFetching pages:  70%|███████   | 14/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  70%|███████   | 14/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  75%|███████▌  | 15/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  75%|███████▌  | 15/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  80%|████████  | 16/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  80%|████████  | 16/20 [00:02<00:00,  6.62page/s, vacanFetching pages:  85%|████████▌ | 17/20 [00:02<00:00,  6.63page/s, vacanFetching pages:  85%|████████▌ | 17/20 [00:02<00:00,  6.63page/s, vacanFetching pages:  90%|█████████ | 18/20 [00:02<00:00,  6.63page/s, vacanFetching pages:  90%|█████████ | 18/20 [00:02<00:00,  6.63page/s, vacanFetching pages:  95%|█████████▌| 19/20 [00:02<00:00,  6.60page/s, vacanFetching pages:  95%|█████████▌| 19/20 [00:03<00:00,  6.60page/s, vacanFetching pages: 100%|██████████| 20/20 [00:03<00:00,  6.61page/s, vacanFetching pages: 100%|██████████| 20/20 [00:03<00:00,  6.61page/s, vacancies=0]
-------------------------- Captured log call --------------------------
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:335 Некорректная структура вакансии в позиции 0
WARNING  src.api_modules.cached_api:cached_api.py:157 Данные не прошли валидацию структуры, кэширование пропущено для hh
WARNING  src.api_modules.cached_api:cached_api.py:159 Данные неполные или повреждены, кэширование пропущено для sj
__ TestFinalComprehensiveCoverage.test_storage_modules_comprehensive __

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb979531d0>
consolidated_mocks = {'api_response': {'items': [{'id': '123', 'name': 'Python Developer'}]}, 'db_connection': <Mock id='140649814325904'>, 'db_cursor': <Mock name='mock.cursor()' id='140649814322384'>, 'storage': <Mock id='140649814323344'>, ...}

    def test_storage_modules_comprehensive(self, consolidated_mocks):
        """Комплексный тест модулей хранения"""
        # Тест DBManager с правильной конфигурацией
        with patch('src.storage.db_manager.psycopg2.connect', return_value=consolidated_mocks['db_connection']):
            from src.storage.db_manager import DBManager
            from src.config.db_config import DatabaseConfig
    
            # Создаем правильный конфиг
            db_config = DatabaseConfig()
    
            with patch.object(db_config, 'get_connection_params', return_value={
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'user': 'test_user',
                'password': 'test_pass'
            }):
                db_manager = DBManager(db_config)
>               db_manager.create_tables()

tests/test_final_comprehensive_coverage.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7feb9635c990>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:82: TypeError
-------------------------- Captured log call --------------------------
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
___ TestFinalComprehensiveCoverage.test_ui_interfaces_comprehensive ___

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97951a50>
consolidated_mocks = {'api_response': {'items': [{'id': '123', 'name': 'Python Developer'}]}, 'db_connection': <Mock id='140649822829648'>, 'db_cursor': <Mock name='mock.cursor()' id='140649822814992'>, 'storage': <Mock id='140649814322000'>, ...}

    def test_ui_interfaces_comprehensive(self, consolidated_mocks):
        """Комплексный тест UI интерфейсов"""
        with patch('builtins.input', return_value='q'), \
             patch('builtins.print'):
    
            from src.ui_interfaces.console_interface import UserInterface
    
            # Правильная инициализация без лишних параметров
            interface = UserInterface(storage=consolidated_mocks['storage'])
    
            # Тест основных методов
>           interface.show_vacancies([consolidated_mocks['vacancy']])
            ^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UserInterface' object has no attribute 'show_vacancies'

tests/test_final_comprehensive_coverage.py:217: AttributeError
____ TestFinalComprehensiveCoverage.test_env_loader_functionality _____

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97902610>

    def test_env_loader_functionality(self):
        """Тест загрузчика переменных окружения"""
        try:
            from src.utils.env_loader import EnvLoader
    
            # Создание временного .env файла
            with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:
                f.write("DATABASE_HOST=localhost\n")
                f.write("DATABASE_PORT=5432\n")
                f.write("API_KEY=test_key\n")
                env_path = f.name
    
            try:
                # Проверяем сигнатуру конструктора
                import inspect
                sig = inspect.signature(EnvLoader.__init__)
    
                if len(sig.parameters) > 1:  # Есть параметры кроме self
>                   loader = EnvLoader(env_path)
                             ^^^^^^^^^^^^^^^^^^^
E                   TypeError: EnvLoader() takes no arguments

tests/test_final_comprehensive_coverage.py:426: TypeError
__ TestFinalComprehensiveCoverage.test_utility_classes_functionality __

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97902010>

    def test_utility_classes_functionality(self):
        """Тест утилитных классов с правильной инициализацией"""
        # Тест пагинатора
        try:
            from src.utils.paginator import Paginator
    
            # Проверяем сигнатуру конструктора
            import inspect
            sig = inspect.signature(Paginator.__init__)
    
            if len(sig.parameters) > 1:  # Принимает параметры
                items = list(range(50))
>               paginator = Paginator(items, per_page=10)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Paginator() takes no arguments

tests/test_final_comprehensive_coverage.py:453: TypeError
___ TestFinalComprehensiveCoverage.test_comprehensive_api_coverage ____

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb97900cd0>
consolidated_mocks = {'api_response': {'items': [{'id': '123', 'name': 'Python Developer'}]}, 'db_connection': <Mock id='140649817595536'>, 'db_cursor': <Mock name='mock.cursor()' id='140649817600784'>, 'storage': <Mock id='140649817591888'>, ...}

    def test_comprehensive_api_coverage(self, consolidated_mocks):
        """Комплексное покрытие API модулей"""
        # Тест базового API
        try:
            from src.api_modules.base_api import BaseAPI
    
            # Проверяем что это абстрактный класс
            assert BaseAPI is not None
    
        except ImportError:
            pass
    
        # Тест кэшированного API
        try:
            from src.api_modules.cached_api import CachedAPI
    
            # Создаем конкретную реализацию для тестирования
            class TestCachedAPI(CachedAPI):
                def get_vacancies(self, query, **kwargs):
                    return []
    
                def _fetch_vacancies(self, query, **kwargs):
                    return []
    
            with tempfile.TemporaryDirectory() as temp_dir:
>               api = TestCachedAPI(cache_dir=temp_dir)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Can't instantiate abstract class TestCachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies_page

tests/test_final_comprehensive_coverage.py:588: TypeError
_ TestFinalComprehensiveCoverage.test_ui_helpers_with_correct_vacancy_structure _

self = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage object at 0x7feb978c51d0>

    def test_ui_helpers_with_correct_vacancy_structure(self):
        """Тест UI помощников с правильной структурой вакансий"""
        try:
            from src.utils import ui_helpers
    
            # Создание правильной структуры вакансии
            class TestVacancy:
                def __init__(self, title, salary_from=None, salary_to=None):
                    self.title = title
                    self.name = title  # Альтернативное поле
                    self.salary = Mock()
                    self.salary.salary_from = salary_from
                    self.salary.salary_to = salary_to
                    self.employer = Mock()
                    self.employer.name = "Test Company"
                    self.url = "https://test.com"
                    self.description = f"Description for {title}"
                    self.requirements = f"Requirements for {title}"
    
            vacancies = [
                TestVacancy("Python Developer", 100000, 150000),
                TestVacancy("Java Developer", 120000, 180000),
                TestVacancy("No Salary Job")
            ]
    
            # Тест фильтрации
            if hasattr(ui_helpers, 'filter_vacancies_by_keyword'):
>               result = ui_helpers.filter_vacancies_by_keyword(vacancies, "Python")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_comprehensive_coverage.py:846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:144: in filter_vacancies_by_keyword
    full_text = _build_searchable_text(vacancy)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancy = <tests.test_final_comprehensive_coverage.TestFinalComprehensiveCoverage.test_ui_helpers_with_correct_vacancy_structure.<locals>.TestVacancy object at 0x7feb96a40f10>

    def _build_searchable_text(vacancy: Vacancy) -> str:
        """
        Формирует единую строку поиска из всех текстовых полей вакансии
    
        Args:
            vacancy: Объект вакансии
    
        Returns:
            str: Объединенный текст для поиска в нижнем регистре
        """
        searchable_text = []
    
        # Проверяем названия
        if vacancy.title:
            searchable_text.append(str(vacancy.title))
    
        # Проверяем описание
        if vacancy.description:
            searchable_text.append(str(vacancy.description))
    
        # Проверяем требования
        if vacancy.requirements:
            searchable_text.append(str(vacancy.requirements))
    
        # Проверяем обязанности
>       if vacancy.responsibilities:
           ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TestVacancy' object has no attribute 'responsibilities'

src/utils/ui_helpers.py:214: AttributeError
____ TestOptimizedCoverage.test_vacancy_model_creation_and_methods ____

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e11d0>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_vacancy_model_creation_and_methods(self, standard_vacancy_data):
        """Тест создания и методов модели вакансии"""
        # Создание из словаря
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:67: TypeError
________ TestOptimizedCoverage.test_api_modules_comprehensive _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e1550>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_api_modules_comprehensive(self, standard_vacancy_data):
        """Комплексный тест API модулей"""
        # Тест HeadHunter API
>       with patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_optimized_coverage.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______ TestOptimizedCoverage.test_storage_modules_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e18d0>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140649832631952'>, <Mock name='mock.cursor()' id='140649832633296'>)

    def test_storage_modules_comprehensive(self, standard_vacancy_data, mock_db_setup):
        """Комплексный тест модулей хранения"""
        connection, cursor = mock_db_setup
    
        # Тест DBManager
        with patch('src.storage.db_manager.psycopg2.connect', return_value=connection):
            from src.storage.db_manager import DBManager
    
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            db_manager = DBManager(db_config)
>           db_manager.create_tables()

tests/test_optimized_coverage.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:82: in create_tables
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7feb974fc690>

    def _get_connection(self):
        """
        Создает подключение к базе данных
    
        Returns:
            connection: Подключение к БД (psycopg2 или простой адаптер)
    
        Raises:
            Exception: При ошибке подключения к БД
        """
        if not PSYCOPG2_AVAILABLE:
            # Возвращаем простой адаптер как "подключение"
            return get_db_adapter()
    
        try:
>           connection_params = self.db_config.get_connection_params()
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'get_connection_params'

src/storage/db_manager.py:64: AttributeError
-------------------------- Captured log call --------------------------
ERROR    src.storage.db_manager:db_manager.py:73 Ошибка подключения к базе данных: 'dict' object has no attribute 'get_connection_params'
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'dict' object has no attribute 'get_connection_params'
_______ TestOptimizedCoverage.test_ui_interfaces_comprehensive ________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e1d90>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140649821412624'>, <Mock name='mock.cursor()' id='140649821412944'>)

    def test_ui_interfaces_comprehensive(self, standard_vacancy_data, mock_db_setup):
        """Комплексный тест UI интерфейсов"""
        connection, cursor = mock_db_setup
    
        with patch('builtins.input', return_value='1'), \
             patch('builtins.print'), \
             patch('src.storage.postgres_saver.psycopg2.connect', return_value=connection):
    
            from src.ui_interfaces.console_interface import UserInterface
            from src.storage.postgres_saver import PostgresSaver
            from src.api_modules.unified_api import UnifiedAPI
    
            # Создание компонентов
            db_config = {'host': 'localhost', 'port': '5432', 'database': 'test', 'username': 'user', 'password': 'pass'}
            storage = PostgresSaver(db_config)
            unified_api = UnifiedAPI()
    
>           interface = UserInterface(storage=storage, unified_api=unified_api)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: UserInterface.__init__() got an unexpected keyword argument 'unified_api'

tests/test_optimized_coverage.py:191: TypeError
______ TestOptimizedCoverage.test_utility_modules_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e2450>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_utility_modules_comprehensive(self, standard_vacancy_data):
        """Комплексный тест утилитных модулей"""
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:202: TypeError
________ TestOptimizedCoverage.test_file_operations_and_cache _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e2a50>

    def test_file_operations_and_cache(self):
        """Тест файловых операций и кэширования"""
        # Тест файловых операций
        try:
            from src.utils.file_handlers import FileOperations
    
            # Создание временного файла
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                test_data = {"test": "data", "numbers": [1, 2, 3]}
                json.dump(test_data, f)
                temp_path = f.name
    
            try:
                file_ops = FileOperations()
    
                # Тест чтения
                result = file_ops.read_json(temp_path)
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_optimized_coverage.py:265: AssertionError
-------------------------- Captured log call --------------------------
ERROR    src.utils.file_handlers:file_handlers.py:47 Failed to read /tmp/tmpi71n550x.json: 'str' object has no attribute 'exists'
__________ TestOptimizedCoverage.test_configuration_modules ___________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e3050>

    def test_configuration_modules(self):
        """Тест модулей конфигурации"""
        try:
            from src.config.db_config import DatabaseConfig
    
            config = DatabaseConfig()
>           db_params = config.get_db_params()
                        ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DatabaseConfig' object has no attribute 'get_db_params'

tests/test_optimized_coverage.py:300: AttributeError
_________ TestOptimizedCoverage.test_decorators_and_utilities _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977e3c90>

    def test_decorators_and_utilities(self):
        """Тест декораторов и вспомогательных утилит"""
        try:
            from src.utils.decorators import simple_cache, time_execution
    
            # Тест кэширующего декоратора
            call_count = 0
    
            @simple_cache
            def expensive_function(x):
                nonlocal call_count
                call_count += 1
                return x * 2
    
            result1 = expensive_function(5)
            result2 = expensive_function(5)
    
>           assert result1 == result2 == 10
E           assert <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7feb96c304a0> == <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7feb96c307c0>

tests/test_optimized_coverage.py:357: AssertionError
_________ TestOptimizedCoverage.test_env_loader_comprehensive _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977f4290>

    def test_env_loader_comprehensive(self):
        """Комплексный тест загрузчика переменных окружения"""
        try:
            from src.utils.env_loader import EnvLoader
    
            # Создание временного .env файла
            with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:
                f.write("DATABASE_HOST=localhost\n")
                f.write("DATABASE_PORT=5432\n")
                f.write("API_KEY=test_key\n")
                f.write("DEBUG=True\n")
                env_path = f.name
    
            try:
>               loader = EnvLoader(env_path)
                         ^^^^^^^^^^^^^^^^^^^
E               TypeError: EnvLoader() takes no arguments

tests/test_optimized_coverage.py:385: TypeError
_______ TestOptimizedCoverage.test_error_handling_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977f48d0>
mock_db_setup = (<Mock id='140649875115792'>, <Mock name='mock.cursor()' id='140649875115344'>)

    def test_error_handling_comprehensive(self, mock_db_setup):
        """Комплексный тест обработки ошибок"""
        connection, cursor = mock_db_setup
    
        # Тест ошибок API
>       with patch('src.api_modules.hh_api.requests.get', side_effect=Exception("Network error")):

tests/test_optimized_coverage.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
_________ TestOptimizedCoverage.test_data_processing_modules __________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977f4f10>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_data_processing_modules(self, standard_vacancy_data):
        """Тест модулей обработки данных"""
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:432: TypeError
________ TestOptimizedCoverage.test_complete_integration_flow _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977f5b50>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140649820769616'>, <Mock name='mock.cursor()' id='140649820767824'>)

    def test_complete_integration_flow(self, standard_vacancy_data, mock_db_setup):
        """Полный интеграционный тест"""
        connection, cursor = mock_db_setup
    
>       with patch('src.api_modules.hh_api.requests.get') as mock_api_get, \
             patch('src.storage.postgres_saver.psycopg2.connect', return_value=connection), \
             patch('builtins.input', return_value='q'), \
             patch('builtins.print'):

tests/test_optimized_coverage.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
___________ TestOptimizedCoverage.test_remaining_utilities ____________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7feb977f6150>

    def test_remaining_utilities(self):
        """Тест оставшихся утилит"""
        # Тест пагинатора
        try:
            from src.utils.paginator import Paginator
    
            items = list(range(50))
>           paginator = Paginator(items, per_page=10)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Paginator() takes no arguments

tests/test_optimized_coverage.py:536: TypeError
________________ TestPostgresSaver.test_get_connection ________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97816250>
mock_connect = <MagicMock name='connect' id='140649817450000'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_connection(self, mock_connect):
        """Тест получения соединения с БД"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        connection = saver._get_connection()
>       assert connection == mock_connection
E       AssertionError: assert <MagicMock name='mock.connect()' id='140649817451600'> == <Mock name='connect()' id='140649817448848'>

tests/test_postgres_saver.py:157: AssertionError
_________________ TestPostgresSaver.test_save_vacancy _________________

self = <Mock name='connect().cursor().execute' id='140649817596496'>
args = ('INSERT INTO vacancies VALUES (%s, %s, %s)', ('123', 'Python Developer', 'hh.ru'))
kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb978165d0>
mock_connect = <MagicMock name='connect' id='140649817453392'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancy(self, mock_connect):
        """Тест сохранения вакансии"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Создаем мок вакансии, так как оригинальный класс Vacancy может быть не импортирован
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
    
>       mock_cursor.execute.assert_called_once_with(
            "INSERT INTO vacancies VALUES (%s, %s, %s)", (vacancy.vacancy_id, vacancy.title, vacancy.source)
        )
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:182: AssertionError
________________ TestPostgresSaver.test_save_vacancies ________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97816990>
mock_connect = <MagicMock name='connect' id='140649823256336'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancies(self, mock_connect):
        """Тест сохранения нескольких вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancies = [
            MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru"),
            MockVacancy(vacancy_id="124", title="Java Developer", source="superjob.ru"),
        ]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancies(vacancies)
    
>       assert mock_cursor.execute.call_count == len(vacancies)
E       AssertionError: assert 0 == 2
E        +  where 0 = <Mock name='connect().cursor().execute' id='140649817608400'>.call_count
E        +    where <Mock name='connect().cursor().execute' id='140649817608400'> = <Mock name='connect().cursor()' id='140649823247376'>.execute
E        +  and   2 = len([<tests.test_postgres_saver.TestPostgresSaver.test_save_vacancies.<locals>.MockVacancy object at 0x7feb96c0b810>, <tests.test_postgres_saver.TestPostgresSaver.test_save_vacancies.<locals>.MockVacancy object at 0x7feb96c0a710>])

tests/test_postgres_saver.py:212: AssertionError
________________ TestPostgresSaver.test_get_vacancies _________________

self = <Mock name='connect().cursor().execute' id='140649817850576'>
args = ('SELECT * FROM vacancies',), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97816e90>
mock_connect = <MagicMock name='connect' id='140649822693072'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_vacancies(self, mock_connect):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "hh.ru"),
            ("124", "Java Developer", "superjob.ru"),
        ]
        # Имитируем описание столбцов, чтобы psycopg2.fetchmany корректно работал
        mock_cursor.description = [("id",), ("title",), ("source",)]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
    
>       mock_cursor.execute.assert_called_once_with("SELECT * FROM vacancies")
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:236: AssertionError
_____________ TestPostgresSaver.test_get_vacancies_empty ______________

self = <Mock name='connect().cursor().execute' id='140649819647056'>
args = ('SELECT * FROM vacancies',), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97817450>
mock_connect = <MagicMock name='connect' id='140649819646352'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_vacancies_empty(self, mock_connect):
        """Тест получения всех вакансий, когда они отсутствуют"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        mock_cursor.fetchall.return_value = []
        mock_cursor.description = [("id",), ("title",), ("source",)]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
    
>       mock_cursor.execute.assert_called_once_with("SELECT * FROM vacancies")
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:257: AssertionError
_________ TestPostgresSaver.test_delete_vacancy_by_id_success _________

self = <Mock name='connect().cursor().execute' id='140649821296528'>
args = ('DELETE FROM vacancies WHERE id = %s', ('123',)), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97817a10>
mock_connect = <MagicMock name='connect' id='140649820204432'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_success(self, mock_connect):
        """Тест удаления вакансии по ID - успех"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
        mock_cursor.rowcount = 1
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.delete_vacancy_by_id("123")
    
>       mock_cursor.execute.assert_called_once_with("DELETE FROM vacancies WHERE id = %s", ("123",))
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:274: AssertionError
________ TestPostgresSaver.test_delete_vacancy_by_id_not_found ________

self = <Mock name='connect().cursor().execute' id='140649819752016'>
args = ('DELETE FROM vacancies WHERE id = %s', ('999',)), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97817fd0>
mock_connect = <MagicMock name='connect' id='140649819750608'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_not_found(self, mock_connect):
        """Тест удаления вакансии по ID - не найдено"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
        mock_cursor.rowcount = 0
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.delete_vacancy_by_id("999")
    
>       mock_cursor.execute.assert_called_once_with("DELETE FROM vacancies WHERE id = %s", ("999",))
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:292: AssertionError
________ TestPostgresSaver.test_connection_error_handling_save ________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb978185d0>
mock_connect = <MagicMock name='connect' id='140649818010384'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_connection_error_handling_save(self, mock_connect):
        """Тест обработки ошибок соединения при сохранении"""
        mock_connect.side_effect = psycopg2.Error("Connection failed")
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
>       assert result is False
E       assert True is False

tests/test_postgres_saver.py:312: AssertionError
________ TestPostgresSaver.test_connection_error_handling_get _________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97818c10>
mock_connect = <MagicMock name='connect' id='140649820933200'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_connection_error_handling_get(self, mock_connect):
        """Тест обработки ошибок соединения при получении"""
        mock_connect.side_effect = psycopg2.Error("Connection failed")
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
>       assert result == []
E       AssertionError: assert <MagicMock na...649822683984'> == []
E         
E         Use -v to get more diff

tests/test_postgres_saver.py:323: AssertionError
__________ TestPostgresSaver.test_cursor_error_handling_save __________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97819910>
mock_connect = <MagicMock name='connect' id='140649817583056'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_cursor_error_handling_save(self, mock_connect):
        """Тест обработки ошибок курсора при сохранении"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.execute.side_effect = psycopg2.Error("Cursor execute error")
        mock_connect.return_value = mock_connection
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
>       assert result is False
E       assert True is False

tests/test_postgres_saver.py:356: AssertionError
__________ TestPostgresSaver.test_cursor_error_handling_get ___________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7feb97819f90>
mock_connect = <MagicMock name='connect' id='140649835882064'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_cursor_error_handling_get(self, mock_connect):
        """Тест обработки ошибок курсора при получении"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.execute.side_effect = psycopg2.Error("Cursor execute error")
        mock_connect.return_value = mock_connection
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
>       assert result == []
E       AssertionError: assert <MagicMock na...649822683984'> == []
E         
E         Use -v to get more diff

tests/test_postgres_saver.py:371: AssertionError
____________ TestStableCoverage.test_user_interface_basic _____________

self = <tests.test_stable_coverage.TestStableCoverage object at 0x7feb976a23d0>
safe_mocks = {'api': <Mock id='140649821540816'>, 'connection': <Mock id='140649817868368'>, 'cursor': <Mock name='mock.cursor()' id='140649817868240'>, 'storage': <Mock id='140649817880464'>}

    def test_user_interface_basic(self, safe_mocks):
        """Базовый тест пользовательского интерфейса"""
        with patch('builtins.input', return_value='q'), \
             patch('builtins.print'):
    
            from src.ui_interfaces.console_interface import UserInterface
    
            interface = UserInterface(storage=safe_mocks['storage'])
>           interface.show_menu()
            ^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UserInterface' object has no attribute 'show_menu'

tests/test_stable_coverage.py:143: AttributeError
_______________ TestStableCoverage.test_env_loader_safe _______________

self = <tests.test_stable_coverage.TestStableCoverage object at 0x7feb976b0850>

    def test_env_loader_safe(self):
        """Безопасный тест загрузчика env"""
        try:
            from src.utils.env_loader import EnvLoader
    
            # Проверяем сигнатуру и создаем соответственно
            import inspect
            sig = inspect.signature(EnvLoader.__init__)
    
            if len(sig.parameters) > 1:
                with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:
                    f.write("TEST=value\n")
                    env_path = f.name
    
                try:
>                   loader = EnvLoader(env_path)
                             ^^^^^^^^^^^^^^^^^^^
E                   TypeError: EnvLoader() takes no arguments

tests/test_stable_coverage.py:255: TypeError
____________ TestStableCoverage.test_remaining_utils_safe _____________

self = <tests.test_stable_coverage.TestStableCoverage object at 0x7feb976b26d0>

    def test_remaining_utils_safe(self):
        """Безопасный тест оставшихся утилит"""
        # Тест менеджера меню
        try:
            from src.utils.menu_manager import MenuManager
    
            import inspect
            sig = inspect.signature(MenuManager.__init__)
    
            with patch('builtins.input', return_value='1'), \
                 patch('builtins.print'):
    
                if len(sig.parameters) > 1:
                    menu_items = [("Test", lambda: "test")]
                    manager = MenuManager(menu_items)
                else:
                    manager = MenuManager()
    
                assert manager is not None
    
        except ImportError:
            pass
    
        # Тест пагинатора
        try:
            from src.utils.paginator import Paginator
    
            import inspect
            sig = inspect.signature(Paginator.__init__)
    
            if len(sig.parameters) > 1:
                items = list(range(20))
>               paginator = Paginator(items, per_page=5)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Paginator() takes no arguments

tests/test_stable_coverage.py:388: TypeError
_ TestVacancyStorageService.test_vacancy_storage_service_all_methods __

self = <tests.test_targeted_coverage.TestVacancyStorageService object at 0x7feb976d2ed0>
mock_connect = <MagicMock name='connect' id='140649823139856'>

    @patch('psycopg2.connect')
    def test_vacancy_storage_service_all_methods(self, mock_connect):
        """Тестирование всех методов VacancyStorageService"""
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
    
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (1, 'Test Company', '123')
            mock_cursor.fetchall.return_value = [(1, 'vacancy1'), (2, 'vacancy2')]
            mock_cursor.rowcount = 5
            mock_conn.cursor.return_value = mock_cursor
            mock_connect.return_value = mock_conn
    
            # Инициализация сервиса
>           storage = VacancyStorageService()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_targeted_coverage.py:115: TypeError
_______ TestUserInterface.test_user_interface_complete_workflow _______

self = <tests.test_targeted_coverage.TestUserInterface object at 0x7feb976d3610>
mock_print = <MagicMock name='print' id='140649823140112'>
mock_input = <MagicMock name='input' id='140649820919696'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_user_interface_complete_workflow(self, mock_print, mock_input):
        """Полное тестирование пользовательского интерфейса"""
        try:
            from src.user_interface import UserInterface
    
            # Различные сценарии ввода пользователя
            mock_input.side_effect = [
                '1',  # Поиск вакансий
                'Python',  # Запрос
                '1',  # HH.ru
                '1',  # Москва
                '100000',  # Зарплата от
                '200000',  # Зарплата до
                '2',  # От 1 до 3 лет
                'y',  # Подтверждение
                '0'   # Выход
            ]
    
            ui = UserInterface()
            assert ui is not None
    
            # Тест инициализации
            if hasattr(ui, '__init__'):
                ui.__init__()
    
            # Тест основного меню
            if hasattr(ui, 'show_main_menu'):
                ui.show_main_menu()
    
            if hasattr(ui, 'display_menu'):
                ui.display_menu()
    
            # Тест обработки пользовательского ввода
            if hasattr(ui, 'get_user_input'):
                result = ui.get_user_input('Введите запрос: ')
                assert isinstance(result, (str, type(None)))
    
            if hasattr(ui, 'get_user_choice'):
                choice = ui.get_user_choice(['Опция 1', 'Опция 2', 'Опция 3'])
                assert isinstance(choice, (int, str, type(None)))
    
            # Тест поиска вакансий
            if hasattr(ui, 'handle_search'):
                ui.handle_search()
    
            if hasattr(ui, 'search_vacancies'):
                ui.search_vacancies()
    
            if hasattr(ui, 'get_search_parameters'):
                params = ui.get_search_parameters()
                assert isinstance(params, (dict, type(None)))
    
            # Тест отображения результатов
            if hasattr(ui, 'display_vacancies'):
                vacancies = [create_test_vacancy(), create_test_vacancy()]
                ui.display_vacancies(vacancies)
    
            if hasattr(ui, 'display_vacancy'):
                ui.display_vacancy(create_test_vacancy())
    
            if hasattr(ui, 'show_vacancy_details'):
                ui.show_vacancy_details(create_test_vacancy())
    
            # Тест пагинации
            if hasattr(ui, 'paginate_results'):
                vacancies = [create_test_vacancy() for _ in range(20)]
                ui.paginate_results(vacancies)
    
            if hasattr(ui, 'show_page'):
                ui.show_page([create_test_vacancy()], 1, 10)
    
            # Тест фильтрации и сортировки
            if hasattr(ui, 'handle_filtering'):
                ui.handle_filtering()
    
            if hasattr(ui, 'apply_filters'):
                filters = {'salary_from': 100000, 'area': 'Москва'}
                ui.apply_filters(filters)
    
            if hasattr(ui, 'handle_sorting'):
                ui.handle_sorting()
    
            # Тест сохранения результатов
            if hasattr(ui, 'save_results'):
                vacancies = [create_test_vacancy()]
                ui.save_results(vacancies)
    
            if hasattr(ui, 'export_to_file'):
                ui.export_to_file([create_test_vacancy()], 'results.json')
    
            # Тест статистики
            if hasattr(ui, 'show_statistics'):
                ui.show_statistics([create_test_vacancy()])
    
            if hasattr(ui, 'display_stats'):
                stats = {'total': 100, 'avg_salary': 150000}
                ui.display_stats(stats)
    
            # Тест настроек
            if hasattr(ui, 'show_settings'):
                ui.show_settings()
    
            if hasattr(ui, 'configure_settings'):
                ui.configure_settings()
    
            # Тест справки
            if hasattr(ui, 'show_help'):
                ui.show_help()
    
            if hasattr(ui, 'display_instructions'):
                ui.display_instructions()
    
            # Тест запуска приложения
            if hasattr(ui, 'start'):
                # Мокаем все зависимости для избежания бесконечного цикла
                with patch.object(ui, 'show_main_menu', return_value=None):
                    with patch.object(ui, 'handle_search', return_value=None):
                        ui.start()
    
            if hasattr(ui, 'run'):
>               with patch.object(ui, 'display_menu', return_value=None):

tests/test_targeted_coverage.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb969d0b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7feb969d3390> does not have the attribute 'display_menu'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestRemainingLowCoverageModules.test_vacancy_search_handler_methods _

self = <tests.test_targeted_coverage.TestRemainingLowCoverageModules object at 0x7feb976dd590>

    def test_vacancy_search_handler_methods(self):
        """Тестирование vacancy_search_handler.py - 16% покрытие"""
        try:
            from src.ui_interfaces.vacancy_search_handler import VacancySearchHandler
    
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_targeted_coverage.py:651: TypeError
________ TestUIHelpers.test_filter_vacancies_by_keyword_basic _________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7feb97712950>
sample_vacancies = [<Mock id='140649822056592'>, <Mock id='140649822427472'>, <Mock id='140649822428816'>, <Mock id='140649822428112'>]

    def test_filter_vacancies_by_keyword_basic(self, sample_vacancies):
        """Тест базовой фильтрации по ключевому слову"""
        # Создаем реальные вакансии вместо Mock
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Python Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Python', 'responsibility': 'Development'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
>       result = ui_helpers.filter_vacancies_by_keyword(real_vacancies, "Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:144: in filter_vacancies_by_keyword
    full_text = _build_searchable_text(vacancy)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancy = <tests.test_ui_helpers_comprehensive.Vacancy object at 0x7feb96739210>

    def _build_searchable_text(vacancy: Vacancy) -> str:
        """
        Формирует единую строку поиска из всех текстовых полей вакансии
    
        Args:
            vacancy: Объект вакансии
    
        Returns:
            str: Объединенный текст для поиска в нижнем регистре
        """
        searchable_text = []
    
        # Проверяем названия
>       if vacancy.title:
           ^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'title'

src/utils/ui_helpers.py:202: AttributeError
____________ TestUIHelpers.test_display_vacancy_info_basic ____________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7feb9770a110>

    def test_display_vacancy_info_basic(self):
        """Тест отображения информации о вакансии"""
        # Создаем реальную вакансию для более точного теста
        vacancy_data = {
            'id': 'test_1',
            'name': 'Test Developer',
            'url': 'http://test.com',
            'salary': {'from': 50000, 'to': 70000, 'currency': 'RUR'},
            'employer': {'name': 'Test Company'},
            'area': {'name': 'Санкт-Петербург'},
            'experience': {'name': 'От 1 года до 3 лет'},
            'employment': {'name': 'Полная занятость'},
            'schedule': {'name': 'Полный день'},
            'snippet': {'requirement': 'Good skills', 'responsibility': 'Coding'},
            'published_at': '2025-01-01T00:00:00+0300'
        }
        vacancy = Vacancy.from_dict(vacancy_data, 'hh')
    
        with patch('builtins.print') as mock_print:
            ui_helpers.display_vacancy_info(vacancy, 1)
    
        # Проверяем, что print был вызван с ожидаемым форматом
        # Примерные строки, которые должны быть напечатаны
        expected_calls = [
>           pytest.call("Вакансия № 1:"),
            ^^^^^^^^^^^
            pytest.call(f"Название: {vacancy.name}"),
            pytest.call(f"Компания: {vacancy.employer.name}"),
            pytest.call(f"Зарплата: от {vacancy.salary.salary_from} до {vacancy.salary.salary_to} RUR"),
            pytest.call(f"URL: {vacancy.url}")
        ]
E       AttributeError: module 'pytest' has no attribute 'call'

tests/test_ui_helpers_comprehensive.py:275: AttributeError
_______ TestUIHelpers.test_filter_vacancies_by_min_salary_basic _______

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7feb97706f90>
sample_vacancies = [<Mock id='140649817895888'>, <Mock id='140649817896016'>, <Mock id='140649817896848'>, <Mock id='140649817895632'>]

    def test_filter_vacancies_by_min_salary_basic(self, sample_vacancies):
        """Тест фильтрации по минимальной зарплате"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Python Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': {'from': 100000 + i * 30000, 'to': 150000 + i * 50000, 'currency': 'RUR'},
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Python', 'responsibility': 'Development'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
        min_salary_threshold = 120000
>       result = ui_helpers.filter_vacancies_by_min_salary(real_vacancies, min_salary_threshold)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:256: in filter_vacancies_by_min_salary
    return VacancyOperations.filter_vacancies_by_min_salary(vacancies, min_salary)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancies = [<tests.test_ui_helpers_comprehensive.Vacancy object at 0x7feb966ef190>, <tests.test_ui_helpers_comprehensive.Vacancy ...omprehensive.Vacancy object at 0x7feb966eef10>, <tests.test_ui_helpers_comprehensive.Vacancy object at 0x7feb966eef90>]
min_salary = 120000

    @staticmethod
    def filter_vacancies_by_min_salary(vacancies: List[Vacancy], min_salary: int) -> List[Vacancy]:
        """
        Фильтрация вакансий по минимальной зарплате
    
        Args:
            vacancies: Список вакансий для фильтрации
            min_salary: Минимальная зарплата
    
        Returns:
            List[Vacancy]: Список отфильтрованных вакансий
        """
        filtered_vacancies = []
    
        for vacancy in vacancies:
            # Пропускаем вакансии без зарплаты
            if not vacancy.salary:
                continue
    
            # Получаем значения зарплаты
>           salary_from = vacancy.salary.salary_from
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'salary_from'

src/utils/vacancy_operations.py:66: AttributeError
_________ TestUIHelpers.test_get_vacancies_with_salary_basic __________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7feb97712450>
sample_vacancies = [<Mock id='140649820464784'>, <Mock id='140649820465424'>, <Mock id='140649820458576'>, <Mock id='140649820456976'>]

    def test_get_vacancies_with_salary_basic(self, sample_vacancies):
        """Тест получения вакансий с зарплатой"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            salary_data = {'from': 100000 + i * 20000, 'to': 150000 + i * 30000, 'currency': 'RUR'} if i % 2 == 0 else None
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': salary_data,
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Skills', 'responsibility': 'Tasks'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
>       result = ui_helpers.get_vacancies_with_salary(real_vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:271: in get_vacancies_with_salary
    return VacancyOperations.get_vacancies_with_salary(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/vacancy_operations.py:24: in get_vacancies_with_salary
    return [v for v in vacancies if v.salary and (v.salary.salary_from or v.salary.salary_to)]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x7feb96371c00>

>   return [v for v in vacancies if v.salary and (v.salary.salary_from or v.salary.salary_to)]
                                                  ^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'salary_from'

src/utils/vacancy_operations.py:24: AttributeError
__________ TestUIHelpers.test_sort_vacancies_by_salary_basic __________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7feb97711710>
sample_vacancies = [<Mock id='140649817982544'>, <Mock id='140649817987600'>, <Mock id='140649817993232'>, <Mock id='140649817982736'>]

    def test_sort_vacancies_by_salary_basic(self, sample_vacancies):
        """Тест сортировки вакансий по зарплате"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            salary_data = {'from': 100000 + i * 30000, 'to': 150000 + i * 50000, 'currency': 'RUR'}
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': salary_data,
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Skills', 'responsibility': 'Tasks'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
        result = ui_helpers.sort_vacancies_by_salary(real_vacancies)
    
        assert isinstance(result, list)
        assert len(result) == 4
        # Проверяем, что зарплаты отсортированы по возрастанию
        # sample_vacancies[0] -> from: 100000
        # sample_vacancies[1] -> from: 130000
        # sample_vacancies[2] -> from: 160000
        # sample_vacancies[3] -> from: 190000
        expected_salaries = [100000, 130000, 160000, 190000]
>       actual_salaries = [v.salary.salary_from for v in result]
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x7feb9767ec50>

>   actual_salaries = [v.salary.salary_from for v in result]
                       ^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'salary_from'

tests/test_ui_helpers_comprehensive.py:381: AttributeError
_________________ TestUserInterface.test_main_success _________________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb9770b8d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb97558f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_db_connection_fails ___________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb977038d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb97559490>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_create_tables_fails ___________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97703590>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb975599d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestUserInterface.test_main_populate_companies_fails _________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97703210>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb97559f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterface.test_main_initialization_check_fails ________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97702ed0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb9755a450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_keyboard_interrupt ____________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97702b90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb9755abd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestUserInterface.test_main_database_error_handling _________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97702850>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb9755b3d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestUserInterface.test_main_general_error_handling __________

args = (<tests.test_user_interface.TestUserInterface object at 0x7feb97702350>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7feb977504d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_with_keyword _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975aa790>
mock_filter = <MagicMock name='filter_vacancies_by_keyword' id='140649820919312'>

    @patch('src.utils.vacancy_operations.filter_vacancies_by_keyword')
    def test_filter_vacancies_by_criteria_with_keyword(self, mock_filter):
        """Тест фильтрации вакансий по критериям с ключевым словом"""
        vacancies = [MockVacancy("Python Developer"), MockVacancy("Java Developer")]
        mock_filter.return_value = [vacancies[0]]
    
        criteria = {"keyword": "Python"}
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:207: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_with_min_salary _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975aaad0>

    def test_filter_vacancies_by_criteria_with_min_salary(self):
        """Тест фильтрации вакансий по критериям с минимальной зарплатой"""
        vacancies = [
            MockVacancy("High Salary Job", MockSalary(150000, 200000)),
            MockVacancy("Low Salary Job", MockSalary(50000, 80000))
        ]
    
        criteria = {"min_salary": 100000}
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:221: AttributeError
__ TestVacancyOperations.test_filter_vacancies_by_criteria_combined ___

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975aae10>

    def test_filter_vacancies_by_criteria_combined(self):
        """Тест фильтрации по комбинированным критериям"""
        vacancies = [
            MockVacancy("Python Developer", MockSalary(150000, 200000)),
            MockVacancy("Python Junior", MockSalary(50000, 80000)),
            MockVacancy("Java Developer", MockSalary(120000, 150000))
        ]
    
        with patch('src.utils.vacancy_operations.filter_vacancies_by_keyword') as mock_filter:
            # Мокаем чтобы вернуть только Python вакансии
            mock_filter.return_value = [vacancies[0], vacancies[1]]
    
            criteria = {"keyword": "Python", "min_salary": 100000}
>           result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:239: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_empty_criteria _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975ab2d0>

    def test_filter_vacancies_by_criteria_empty_criteria(self):
        """Тест фильтрации с пустыми критериями"""
        vacancies = [MockVacancy("Job 1"), MockVacancy("Job 2")]
    
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, {})
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:248: AttributeError
__ TestVacancyOperations.test_get_vacancies_statistics_comprehensive __

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975ab8d0>

    def test_get_vacancies_statistics_comprehensive(self):
        """Тест получения комплексной статистики по вакансиям"""
        vacancies = [
            MockVacancy("Python Developer", MockSalary(100000, 150000)),
            MockVacancy("Java Developer", MockSalary(80000, 120000)),
            MockVacancy("No Salary Job", None),
            MockVacancy("Frontend Developer", MockSalary(70000, 100000))
        ]
    
>       stats = VacancyOperations.get_vacancies_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:262: AttributeError
___ TestVacancyOperations.test_get_vacancies_statistics_empty_list ____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975abed0>

    def test_get_vacancies_statistics_empty_list(self):
        """Тест статистики для пустого списка"""
>       stats = VacancyOperations.get_vacancies_statistics([])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:272: AttributeError
___ TestVacancyOperations.test_get_vacancies_statistics_no_salaries ___

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975b0510>

    def test_get_vacancies_statistics_no_salaries(self):
        """Тест статистики когда нет зарплат"""
        vacancies = [
            MockVacancy("Job 1", None),
            MockVacancy("Job 2", MockSalary(None, None))
        ]
    
>       stats = VacancyOperations.get_vacancies_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:287: AttributeError
_______ TestVacancyOperations.test_deduplicate_vacancies_by_url _______

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975b0b10>

    def test_deduplicate_vacancies_by_url(self):
        """Тест дедупликации вакансий по URL"""
        vacancies = [
            MockVacancy("Job 1"),
            MockVacancy("Job 2"),
            MockVacancy("Job 1 Duplicate")
        ]
    
        # Устанавливаем одинаковые URL для дубликатов
        vacancies[0].url = "http://test.com/job1"
        vacancies[1].url = "http://test.com/job2"
        vacancies[2].url = "http://test.com/job1"  # Дубликат
    
>       result = VacancyOperations.deduplicate_vacancies(vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:308: AttributeError
_____ TestVacancyOperations.test_deduplicate_vacancies_empty_list _____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975b1110>

    def test_deduplicate_vacancies_empty_list(self):
        """Тест дедупликации пустого списка"""
>       result = VacancyOperations.deduplicate_vacancies([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:317: AttributeError
___ TestVacancyOperations.test_deduplicate_vacancies_no_duplicates ____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7feb975b1710>

    def test_deduplicate_vacancies_no_duplicates(self):
        """Тест дедупликации когда дубликатов нет"""
        vacancies = [
            MockVacancy("Job 1"),
            MockVacancy("Job 2"),
            MockVacancy("Job 3")
        ]
    
        # Устанавливаем уникальные URL
        for i, vacancy in enumerate(vacancies):
            vacancy.url = f"http://test.com/job{i+1}"
    
>       result = VacancyOperations.deduplicate_vacancies(vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:333: AttributeError
======================= short test summary info =======================
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_hh_api_functionality - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_superjob_api_functionality - AttributeError: module 'src.api_modules.sj_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_unified_api_functionality - AttributeError: Mock object has no attribute 'get'
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_db_manager_functionality - AttributeError: 'dict' object has no attribute 'get_connection_par...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_postgres_saver_functionality - AttributeError: 'PostgresSaver' object has no attribute 'save_vaca...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_user_interface_functionality - AttributeError: <class 'src.ui_interfaces.console_interface.UserIn...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_vacancy_model_functionality - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_utility_modules_functionality - assert False
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_storage_services_functionality - AttributeError: <class 'src.storage.components.vacancy_repository....
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_config_modules_functionality - AttributeError: 'DatabaseConfig' object has no attribute 'get_db_p...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_ui_components_functionality - AttributeError: 'VacancyDisplayHandler' object has no attribute 'd...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_decorators_functionality - assert <function simple_cache.<locals>.decorator.<locals>.wrapper ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_vacancy_operations_functionality - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_env_loader_functionality - TypeError: EnvLoader() takes no arguments
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_menu_manager_functionality - TypeError: MenuManager.__init__() takes 1 positional argument but ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_paginator_functionality - TypeError: Paginator() takes no arguments
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_main_application_interface_functionality - TypeError: MainApplicationInterface.__init__() missing 3 required ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_storage_factory_functionality - TypeError: StorageFactory.create_storage() takes from 0 to 1 posit...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_main_user_interface_module - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_api_connector_functionality - AttributeError: <module 'src.api_modules.get_api' from '/home/runn...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_comprehensive_error_handling - Exception: Connection failed
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_integration_workflow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_complete_service_layer_coverage - AttributeError: 'DeduplicationService' object has no attribute 'de...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_complete_application_flow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_basic_functionality_coverage - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_api_modules_basic_coverage - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_ui_basic_coverage - TypeError: UserInterface.__init__() got an unexpected keyword argu...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_config_basic_coverage - AttributeError: type object 'TargetCompanies' has no attribute 'ge...
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_vacancy_model_functionality - KeyError: 'id'
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_api_modules_comprehensive - TypeError: argument of type 'Mock' is not iterable
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_storage_modules_comprehensive - TypeError: 'Mock' object does not support the context manager prot...
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_ui_interfaces_comprehensive - AttributeError: 'UserInterface' object has no attribute 'show_vaca...
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_env_loader_functionality - TypeError: EnvLoader() takes no arguments
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_utility_classes_functionality - TypeError: Paginator() takes no arguments
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_comprehensive_api_coverage - TypeError: Can't instantiate abstract class TestCachedAPI with abs...
FAILED tests/test_final_comprehensive_coverage.py::TestFinalComprehensiveCoverage::test_ui_helpers_with_correct_vacancy_structure - AttributeError: 'TestVacancy' object has no attribute 'responsibil...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_vacancy_model_creation_and_methods - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_api_modules_comprehensive - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_storage_modules_comprehensive - AttributeError: 'dict' object has no attribute 'get_connection_par...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_ui_interfaces_comprehensive - TypeError: UserInterface.__init__() got an unexpected keyword argu...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_utility_modules_comprehensive - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_file_operations_and_cache - assert False
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_configuration_modules - AttributeError: 'DatabaseConfig' object has no attribute 'get_db_p...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_decorators_and_utilities - assert <function simple_cache.<locals>.decorator.<locals>.wrapper ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_env_loader_comprehensive - TypeError: EnvLoader() takes no arguments
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_error_handling_comprehensive - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_data_processing_modules - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_complete_integration_flow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_remaining_utilities - TypeError: Paginator() takes no arguments
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_connection - AssertionError: assert <MagicMock name='mock.connect()' id='140649...
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancy - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies - AssertionError: assert 0 == 2
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_empty - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_connection_error_handling_save - assert True is False
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_connection_error_handling_get - AssertionError: assert <MagicMock na...649822683984'> == []
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_cursor_error_handling_save - assert True is False
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_cursor_error_handling_get - AssertionError: assert <MagicMock na...649822683984'> == []
FAILED tests/test_stable_coverage.py::TestStableCoverage::test_user_interface_basic - AttributeError: 'UserInterface' object has no attribute 'show_menu'
FAILED tests/test_stable_coverage.py::TestStableCoverage::test_env_loader_safe - TypeError: EnvLoader() takes no arguments
FAILED tests/test_stable_coverage.py::TestStableCoverage::test_remaining_utils_safe - TypeError: Paginator() takes no arguments
FAILED tests/test_targeted_coverage.py::TestVacancyStorageService::test_vacancy_storage_service_all_methods - TypeError: Can't instantiate abstract class VacancyStorageService ...
FAILED tests/test_targeted_coverage.py::TestUserInterface::test_user_interface_complete_workflow - AttributeError: <src.ui_interfaces.console_interface.UserInterface...
FAILED tests/test_targeted_coverage.py::TestRemainingLowCoverageModules::test_vacancy_search_handler_methods - TypeError: VacancySearchHandler.__init__() missing 2 required posi...
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_filter_vacancies_by_keyword_basic - AttributeError: 'Vacancy' object has no attribute 'title'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_display_vacancy_info_basic - AttributeError: module 'pytest' has no attribute 'call'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_filter_vacancies_by_min_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_get_vacancies_with_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_sort_vacancies_by_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_user_interface.py::TestUserInterface::test_main_success - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_db_connection_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_create_tables_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_populate_companies_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_initialization_check_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_keyboard_interrupt - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_database_error_handling - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_general_error_handling - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_with_keyword - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_with_min_salary - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_combined - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_empty_criteria - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_comprehensive - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_empty_list - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_no_salaries - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_by_url - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_empty_list - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_no_duplicates - AttributeError: type object 'VacancyOperations' has no attribute '...
=================== 89 failed, 676 passed in 30.79s ===================
~/workspace$ 