~/workspace$ pytest --cov=src --cov-report=term-missing
============================== test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collecting ... 
collected 1915 items                                                            

tests/test_abstract.py ........                                           [  0%]
tests/test_abstract_db_manager.py ....                                    [  0%]
tests/test_abstract_filter_complete.py .........                          [  1%]
tests/test_api_complete.py ...................                            [  2%]
tests/test_api_config.py ....                                             [  2%]
tests/test_api_data_filter.py ......                                      [  2%]
tests/test_api_fixes.py .......                                           [  2%]
tests/test_api_infrastructure_final.py F...FF..FF.EEE......F.F            [  4%]
tests/test_api_modules.py ............................                    [  5%]
tests/test_api_modules_consolidated.py ....                               [  5%]
tests/test_api_modules_coverage.py ..F...F............                    [  6%]
tests/test_app_config.py .........                                        [  7%]
tests/test_base_api.py ...............                                    [  8%]
tests/test_base_formatter.py ..........                                   [  8%]
tests/test_base_formatter_complete.py ..............................      [ 10%]
tests/test_base_parser.py ......                                          [ 10%]
tests/test_cache.py ......................                                [ 11%]
tests/test_cached_api.py ....                                             [ 11%]
tests/test_cached_api_complete.py ................                        [ 12%]
tests/test_components_fixed.py ...                                        [ 12%]
tests/test_comprehensive_coverage_boost.py .............................. [ 14%]
.........                                                                 [ 14%]
tests/test_comprehensive_coverage_final.py ss...s.....sF.......F..        [ 16%]
tests/test_comprehensive_fixed.py .....                                   [ 16%]
tests/test_comprehensive_missing_coverage.py F.....FFFF.EEE.............. [ 17%]
.                                                                         [ 17%]
tests/test_config_consolidated.py .....                                   [ 18%]
tests/test_config_missing_coverage.py .....sssss.............ss...        [ 19%]
tests/test_config_modules_consolidated.py ......                          [ 19%]
tests/test_config_modules_coverage.py ...................FFF..........    [ 21%]
tests/test_console_interface.py ......                                    [ 21%]
tests/test_console_interface_coverage.py ..................               [ 22%]
tests/test_core_functionality_consolidated.py .....                       [ 23%]
tests/test_core_infrastructure_final.py ..F.......FF....F..FF..F..        [ 24%]
tests/test_core_modules_comprehensive.py ........                         [ 24%]
tests/test_data_normalizers_comprehensive.py ............................ [ 26%]
                                                                          [ 26%]
tests/test_database_connection.py ........                                [ 26%]
tests/test_db_config.py .....                                             [ 26%]
tests/test_db_manager.py .................                                [ 27%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                        [ 28%]
tests/test_decorators.py .......                                          [ 29%]
tests/test_description_parser.py ..........                               [ 29%]
tests/test_env_loader.py ................                                 [ 30%]
tests/test_filter_utils.py ......                                         [ 30%]
tests/test_final_coverage_fixes.py .FF...................                 [ 31%]
tests/test_formatters_coverage.py ...........................             [ 33%]
tests/test_get_api_complete.py ....................                       [ 34%]
tests/test_hh_api_complete.py .................                           [ 35%]
tests/test_hh_api_config.py .....                                         [ 35%]
tests/test_hh_parser.py ........                                          [ 35%]
tests/test_integration.py .............                                   [ 36%]
tests/test_interfaces.py .ss                                              [ 36%]
tests/test_interfaces_coverage.py ..F..F...s........                      [ 37%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F...... [ 39%]
FF                                                                        [ 39%]
tests/test_main_application_interface.py ...                              [ 39%]
tests/test_main_application_interface_complete.py ....................... [ 40%]
....................                                                      [ 41%]
tests/test_main_consolidated.py .........                                 [ 42%]
tests/test_menu_manager.py ..........                                     [ 42%]
tests/test_missing_components.py .........                                [ 43%]
tests/test_missing_coverage_components.py .FF......FFFFF.....F            [ 44%]
tests/test_missing_coverage_extended.py ............F.FFF...........F.... [ 45%]
................FFF...                                                    [ 47%]
tests/test_models_coverage.py ...........................                 [ 48%]
tests/test_models_fixed.py ...                                            [ 48%]
tests/test_paginator.py ......                                            [ 48%]
tests/test_parsers_complete.py ............                               [ 49%]
tests/test_parsers_coverage.py .............................              [ 51%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                  [ 52%]
tests/test_real_components_coverage.py ........EEFE......F.               [ 53%]
tests/test_repository_fixed.py ..                                         [ 53%]
tests/test_salary_fixed.py ...........                                    [ 53%]
tests/test_salary_utils.py ......................                         [ 54%]
tests/test_search_utils.py ............................                   [ 56%]
tests/test_search_utils_complete.py ..................................... [ 58%]
.........                                                                 [ 58%]
tests/test_services_consolidated.py ....                                  [ 59%]
tests/test_services_coverage.py ............................              [ 60%]
tests/test_services_storage_consolidated.py ..........                    [ 60%]
tests/test_simple_db_adapter.py .........                                 [ 61%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                          [ 62%]
tests/test_sj_api.py ..............                                       [ 62%]
tests/test_sj_api_complete.py .............F....                          [ 63%]
tests/test_sj_api_config.py .....                                         [ 64%]
tests/test_sj_parser.py ........                                          [ 64%]
tests/test_sj_parser_complete.py ..............                           [ 65%]
tests/test_source_manager.py .................                            [ 66%]
tests/test_source_selector.py .................                           [ 67%]
tests/test_storage_abstractions.py ........                               [ 67%]
tests/test_storage_abstractions_coverage.py ........                      [ 67%]
tests/test_storage_complete.py .............                              [ 68%]
tests/test_storage_components_complete.py ......F....FF...............F   [ 70%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF     [ 71%]
tests/test_storage_factory.py ........                                    [ 71%]
tests/test_storage_modules_consolidated.py ....                           [ 72%]
tests/test_target_companies.py .....                                      [ 72%]
tests/test_typed_data_processor.py ................                       [ 73%]
tests/test_ui_components_complete.py .................................... [ 75%]
..                                                                        [ 75%]
tests/test_ui_components_extended.py ..................                   [ 76%]
tests/test_ui_config.py .......................                           [ 77%]
tests/test_ui_helpers_comprehensive.py .................................. [ 79%]
.....                                                                     [ 79%]
tests/test_ui_helpers_extended.py ....................................... [ 81%]
.                                                                         [ 81%]
tests/test_ui_modules_consolidated.py .....                               [ 81%]
tests/test_ui_navigation.py ......................                        [ 82%]
tests/test_ui_navigation_complete.py ..s..                                [ 83%]
tests/test_ui_navigation_comprehensive.py ......                          [ 83%]
tests/test_ui_navigation_extended.py .......F...........................  [ 85%]
tests/test_unified_api.py ................F...F.                          [ 86%]
tests/test_unified_api_complete.py ......F......................          [ 87%]
tests/test_unified_api_fixed.py ...                                       [ 88%]
tests/test_user_interface.py ...............                              [ 88%]
tests/test_user_interface_consolidated.py F.F                             [ 89%]
tests/test_user_interface_coverage.py ssssssFEEEEE                        [ 89%]
tests/test_user_interface_fixed.py ...                                    [ 89%]
tests/test_utils_consolidated.py .....                                    [ 90%]
tests/test_utils_coverage.py ......s..s...ssssssss                        [ 91%]
tests/test_utils_ui_consolidated.py ......                                [ 91%]
tests/test_vacancy_abstractions.py .................                      [ 92%]
tests/test_vacancy_display_handler.py ...................                 [ 93%]
tests/test_vacancy_formatter.py ........                                  [ 93%]
tests/test_vacancy_models_complete.py ....                                [ 94%]
tests/test_vacancy_models_consolidated.py ....                            [ 94%]
tests/test_vacancy_operations.py ......                                   [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................  [ 95%]
tests/test_vacancy_operations_coordinator_complete.py ................... [ 96%]
...                                                                       [ 97%]
tests/test_vacancy_processing_coordinator.py .............                [ 97%]
tests/test_vacancy_repository.py .........                                [ 98%]
tests/test_vacancy_stats.py ............                                  [ 98%]
tests/test_vacancy_stats_fixed.py .........                               [ 99%]
tests/test_vacancy_validator.py ............                              [100%]

==================================== ERRORS =====================================
_________ ERROR at setup of TestCachedAPICore.test_cached_api_cache_hit _________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fee6ad02310>

    @pytest.fixture
    def cached_api(self):
        if not CACHED_API_AVAILABLE:
            return Mock()
>       return CachedAPI()
               ^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_infrastructure_final.py:270: TypeError
________ ERROR at setup of TestCachedAPICore.test_cached_api_cache_miss _________

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fee6ad02890>

    @pytest.fixture
    def cached_api(self):
        if not CACHED_API_AVAILABLE:
            return Mock()
>       return CachedAPI()
               ^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_infrastructure_final.py:270: TypeError
_____ ERROR at setup of TestCachedAPICore.test_cached_api_cache_expiration ______

self = <tests.test_api_infrastructure_final.TestCachedAPICore object at 0x7fee6ad00710>

    @pytest.fixture
    def cached_api(self):
        if not CACHED_API_AVAILABLE:
            return Mock()
>       return CachedAPI()
               ^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_api_infrastructure_final.py:270: TypeError
______ ERROR at setup of TestSimpleDBAdapterCoverage.test_query_execution _______

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6abbdc50>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
___ ERROR at setup of TestSimpleDBAdapterCoverage.test_connection_management ____

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6abbe290>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
____ ERROR at setup of TestSimpleDBAdapterCoverage.test_transaction_handling ____

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6abbe910>

    @pytest.fixture
    def db_adapter(self):
        """Фикстура для SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return Mock()
>       return SimpleDBAdapter("postgresql://test:test@localhost/test")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SimpleDBAdapter.__init__() takes 1 positional argument but 2 were given

tests/test_comprehensive_missing_coverage.py:308: TypeError
_____ ERROR at setup of TestFileCacheRealMethods.test_cache_key_generation ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fee6a7a3a90>
temp_cache_dir = '/tmp/tmp1qm6kimu'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
______ ERROR at setup of TestFileCacheRealMethods.test_save_and_load_cycle ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fee6a7a4150>
temp_cache_dir = '/tmp/tmp336v1vv0'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
____ ERROR at setup of TestFileCacheRealMethods.test_invalid_cache_handling _____

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fee6a7a2e90>
temp_cache_dir = '/tmp/tmpt9fv5q6_'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_startup_sequence _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a344b50>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_menu_display_functionality _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a345190>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_user_interaction_handling _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a345810>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_error_handling_in_interface _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a345e50>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
_ ERROR at setup of TestMainApplicationInterfaceCoverage.test_application_lifecycle _

self = <tests.test_user_interface_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a336790>

    @pytest.fixture
    def main_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            mock_interface = Mock()
            mock_interface.initialize = Mock()
            mock_interface.show_menu = Mock()
            mock_interface.handle_user_input = Mock(return_value=None)
            mock_interface.run = Mock()
            return mock_interface
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_user_interface_coverage.py:141: TypeError
=================================== FAILURES ====================================
____________ TestHeadHunterAPICore.test_hh_api_get_vacancies_success ____________

self = <MagicMock name='get' id='140661971333776'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7fee6acf5990>
mock_get = <MagicMock name='get' id='140661971333776'>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fee6ac90750>

    @patch('requests.get')
    def test_hh_api_get_vacancies_success(self, mock_get, hh_api):
        """Тест успешного получения вакансий от HH API"""
        if not HH_API_AVAILABLE:
            return
    
        # Мокируем успешный ответ
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Tech Corp"},
                    "salary": {"from": 100000, "to": 150000, "currency": "RUR"}
                }
            ],
            "found": 1,
            "pages": 1,
            "page": 0
        }
        mock_get.return_value = mock_response
    
        result = hh_api.get_vacancies("python")
    
        assert isinstance(result, list)
>       mock_get.assert_called()
E       AssertionError: Expected 'get' to have been called.

tests/test_api_infrastructure_final.py:91: AssertionError
----------------------------- Captured stderr call ------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 487.56page/s, vacancies=931]
_________________ TestHeadHunterAPICore.test_hh_api_pagination __________________

self = <tests.test_api_infrastructure_final.TestHeadHunterAPICore object at 0x7fee6acf7a10>
hh_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fee6acf6550>

    def test_hh_api_pagination(self, hh_api):
        """Тест пагинации"""
        if not HH_API_AVAILABLE:
            return
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "items": [],
                "found": 100,
                "pages": 5,
                "page": 0
            }
            mock_get.return_value = mock_response
    
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("python", page=2)
>               assert isinstance(result, dict)
E               AssertionError: assert False
E                +  where False = isinstance([{'accept_incomplete_resumes': False, 'accept_temporary': False, 'address': {'building': '3к2Б', 'city': 'Санкт-Петерб...тро Спортивная', 'city': 'Санкт-Петербург', 'description': None, 'id': '5687491', ...}, 'adv_context': None, ...}, ...], dict)

tests/test_api_infrastructure_final.py:149: AssertionError
_______________ TestSuperJobAPICore.test_sj_api_with_auth_header ________________

self = <tests.test_api_infrastructure_final.TestSuperJobAPICore object at 0x7fee6ad03d90>
mock_get = <MagicMock name='get' id='140661931233040'>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fee6871d050>

    @patch('requests.get')
    def test_sj_api_with_auth_header(self, mock_get, sj_api):
        """Тест SJ API с заголовком авторизации"""
        if not SJ_API_AVAILABLE:
            return
    
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 456,
                    "profession": "Python Developer",
                    "link": "https://superjob.ru/vacancy/456",
                    "firm_name": "SJ Corp",
                    "payment_from": 80000,
                    "payment_to": 120000,
                    "currency": "rub"
                }
            ],
            "total": 1
        }
        mock_get.return_value = mock_response
    
        result = sj_api.get_vacancies("python")
        assert isinstance(result, list)
    
        # Проверяем что использовался правильный заголовок
>       call_kwargs = mock_get.call_args[1]
                      ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/test_api_infrastructure_final.py:189: TypeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:163 SuperJob API ключ не настроен или используется тестовый ключ
________________ TestUnifiedAPICore.test_unified_api_aggregation ________________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7fee6ad03f90>
mock_sj = <MagicMock name='get_vacancies' id='140661940588496'>
mock_hh = <MagicMock name='get_vacancies' id='140661936421712'>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fee69009b10>

    @patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies')
    @patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies')
    def test_unified_api_aggregation(self, mock_sj, mock_hh, unified_api):
        """Тест агрегации данных от разных источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Мокируем ответы от разных API
        mock_hh.return_value = [{"id": "hh1", "source": "hh"}]
        mock_sj.return_value = [{"id": "sj1", "source": "sj"}]
    
>       result = unified_api.get_vacancies("python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:238: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICore.test_unified_api_error_resilience ______________

self = <tests.test_api_infrastructure_final.TestUnifiedAPICore object at 0x7fee6ad00ed0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fee6a2a21d0>

    def test_unified_api_error_resilience(self, unified_api):
        """Тест устойчивости к ошибкам отдельных API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', side_effect=Exception("HH Error")), \
             patch('src.api_modules.sj_api.SuperJobAPI.get_vacancies', return_value=[{"id": "sj1"}]):
    
>           result = unified_api.get_vacancies("python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:249: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________ TestAPIPerformanceCore.test_api_request_batching ________________

self = <tests.test_api_infrastructure_final.TestAPIPerformanceCore object at 0x7fee6adc0b10>

    def test_api_request_batching(self):
        """Тест батчинга запросов"""
        if UNIFIED_API_AVAILABLE:
            unified_api = UnifiedAPI()
    
            # Мокируем множественные запросы
            with patch('src.api_modules.hh_api.HeadHunterAPI.get_vacancies', return_value=[]) as mock_hh:
                queries = ["python", "java", "javascript"]
    
                if hasattr(unified_api, 'get_vacancies_batch'):
                    results = unified_api.get_vacancies_batch(queries)
                    assert isinstance(results, dict)
                else:
                    # Если батчинг не поддерживается, тестируем последовательные запросы
                    for query in queries:
>                       result = unified_api.get_vacancies(query)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E                       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:438: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestAPIIntegrationCore.test_full_api_pipeline _________________

self = <tests.test_api_infrastructure_final.TestAPIIntegrationCore object at 0x7fee6adc1d90>
mock_get = <MagicMock name='get' id='140661976167760'>

    @patch('requests.get')
    def test_full_api_pipeline(self, mock_get):
        """Тест полного пайплайна API"""
        if not (HH_API_AVAILABLE and UNIFIED_API_AVAILABLE):
            return
    
        # Мокируем весь пайплайн
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "test123",
                    "name": "Full Stack Developer",
                    "alternate_url": "https://hh.ru/vacancy/test123",
                    "employer": {"name": "Integration Corp"},
                    "salary": {"from": 120000, "to": 180000, "currency": "RUR"},
                    "snippet": {
                        "requirement": "Python, Django",
                        "responsibility": "Development"
                    },
                    "area": {"name": "Moscow"},
                    "published_at": "2025-01-20T10:30:00+0300"
                }
            ],
            "found": 1
        }
        mock_get.return_value = mock_response
    
        unified_api = UnifiedAPI()
>       vacancies = unified_api.get_vacancies("python")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_infrastructure_final.py:506: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________ TestUnifiedAPICoverage.test_search_with_filters ________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fee6accae90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fee68fc72d0>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
        with patch.object(unified_api.hh_api, 'get_vacancies') as mock_hh, \
             patch.object(unified_api.sj_api, 'get_vacancies') as mock_sj:
    
            mock_hh.return_value = []
            mock_sj.return_value = []
    
>           result = unified_api.search_with_filters(search_params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'search_with_filters'

tests/test_api_modules_coverage.py:89: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____________ TestUnifiedAPICoverage.test_error_handling_api_failures ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fee6acc8bd0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fee69153090>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:162: AttributeError
------------------------------ Captured log setup -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestStorageModules.test_postgres_saver_functionality ______________

self = <tests.test_comprehensive_coverage_final.TestStorageModules object at 0x7fee6ab87290>

    def test_postgres_saver_functionality(self):
        """Тест функциональности PostgreSQL сохранения"""
        if 'postgres_saver' not in MODULES_TO_TEST:
            pytest.skip("PostgresSaver not available")
    
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661947831440'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________ TestIntegrationCoverage.test_full_pipeline_coverage ______________

self = <tests.test_comprehensive_coverage_final.TestIntegrationCoverage object at 0x7fee6ab78790>

    def test_full_pipeline_coverage(self):
        """Тест полного пайплайна обработки данных"""
        # Создаем тестовые данные
        test_vacancy_data = {
            "id": "123456789",
            "name": "Senior Python Developer",
            "employer": {"name": "TechCorp"},
            "salary": {"from": 150000, "to": 200000, "currency": "RUR"},
            "area": {"name": "Москва"},
            "experience": {"name": "От 3 до 6 лет"},
            "description": "We are looking for a senior Python developer..."
        }
    
        # Тестируем цепочку: API -> Parser -> Model -> Storage
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка моков
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [test_vacancy_data]}
            mock_get.return_value = mock_response
    
            mock_conn = Mock()
            mock_cursor = Mock()
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_coverage_final.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661944184272'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success ______

self = <Mock name='mock.execute' id='140661945193360'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7fee6abb5650>
mock_connect = <MagicMock name='connect' id='140661939948880'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68f54fd0>
mock_connection = (<Mock name='connect()' id='140661940286736'>, <Mock id='140661940287376'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
_________ TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fee6abb7ad0>
mock_connect = <MagicMock name='connect' id='140661940269840'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee693c3550>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fee6a2e61a0>

    @patch('psycopg2.connect')
    def test_save_vacancies_single_vacancy(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения одной вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
            # Используем реальный объект Vacancy
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee693c3550>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee6a2e61a0>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestPostgresSaverCoverage.test_delete_vacancy_by_id_success __________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fee6abbc0d0>
mock_connect = <MagicMock name='connect' id='140661941851856'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f9fc10>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id_success(self, mock_connect, postgres_saver):
        """Тест успешного удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.rowcount = 1
    
            if hasattr(postgres_saver, 'delete_vacancy_by_id'):
>               result = postgres_saver.delete_vacancy_by_id('test123')
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f9fc10>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_______ TestPostgresSaverCoverage.test_error_handling_in_save_operations ________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f6f950>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee69155640>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
>           cursor = connection.cursor()
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'cursor'

src/storage/postgres_saver.py:352: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fee6abbc790>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f6f950>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fee69155640>

    def test_error_handling_in_save_operations(self, postgres_saver, mock_vacancy):
        """Тест обработки ошибок при сохранении"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch.object(postgres_saver, '_get_connection', return_value=None):
            # Тест с недоступным подключением
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f6f950>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee69155640>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
                if new_count > 5:
                    update_messages.append(f"... и еще {new_count - 5} новых вакансий")
                if updated_count > 5:
                    update_messages.append(f"... и еще {updated_count - 5} обновленных вакансий")
    
            connection.commit()
    
            total_input = len(vacancies)
    
            logger.info("Batch операция через временные таблицы:")
            logger.info(f"  Входящих вакансий: {total_input}")
            logger.info(f"  Добавлено в БД: {new_count}")
            logger.info(f"  Обновлено в БД: {updated_count}")
    
            # Дополнительная проверка количества записей в БД
            cursor.execute("SELECT COUNT(*) FROM vacancies")
            total_in_db = cursor.fetchone()[0]
            logger.info(f"  Итого записей в БД после операции: {total_in_db}")
    
            # Показываем сводку результатов
            logger.info(
                f"Результат: сохранено {new_count + updated_count} из {total_input} вакансий (новых: {new_count}, обновлено: {updated_count})"
            )
    
        except PsycopgError as e:
            logger.error(f"Ошибка при batch операции через временные таблицы: {e}")
            if not connection.closed:
                try:
                    connection.rollback()
                except Exception:
                    pass
            raise
        finally:
            if "cursor" in locals():
                cursor.close()
>           connection.close()
            ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'close'

src/storage/postgres_saver.py:638: AttributeError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fee6abbcdd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee691ea650>

    def test_batch_operations(self, postgres_saver):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        # Создаем набор тестовых вакансий
        test_vacancies = []
        for i in range(5):
            vacancy_data = {
                'vacancy_id': f'test{i}',
                'title': f'Job {i}',
                'url': f'https://test{i}.com',
                'description': f'Description {i}',
                'employer': {'name': f'Company {i}', 'employer_id': f'comp{i}'},
                'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
                'source': 'test'
            }
            test_vacancies.append(vacancy_data)
    
        # Мокаем соединение для пакетной операции
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            mock_conn.return_value = Mock()
>           result = postgres_saver.save_vacancies(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee691ea650>
vacancies = [{'description': 'Description 0', 'employer': {'employer_id': 'comp0', 'name': 'Company 0'}, 'salary': {'currency': 'R...d': 'comp4', 'name': 'Company 4'}, 'salary': {'currency': 'RUR', 'from': 100000, 'to': 150000}, 'source': 'test', ...}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________________ TestSJAPIConfigCoverage.test_get_api_key ____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fee6aa24b90>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
___________________ TestSJAPIConfigCoverage.test_get_base_url ___________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fee6aa251d0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_______________ TestSJAPIConfigCoverage.test_get_request_headers ________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fee6aa22fd0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
_______________ TestVacancyModelsCore.test_employer_functionality _______________

self = <tests.test_core_infrastructure_final.TestVacancyModelsCore object at 0x7fee6a821890>

    def test_employer_functionality(self):
        """Тест функциональности Employer"""
        if not VACANCY_MODELS_AVAILABLE:
            return
    
        employer = Employer(name="Tech Corp", employer_id="emp123")
        assert employer.name == "Tech Corp"
>       assert employer.employer_id == "emp123"
               ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'Employer' object has no attribute 'employer_id'

tests/test_core_infrastructure_final.py:105: AttributeError
_______ TestPostgresSaverCoreFixed.test_postgres_saver_with_real_vacancy ________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7fee6a810b10>
mock_connect = <MagicMock name='connect' id='140661938111824'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a2c76d0>
real_vacancy_object = <src.vacancies.models.Vacancy object at 0x7fee6931c530>

    @patch('psycopg2.connect')
    def test_postgres_saver_with_real_vacancy(self, mock_connect, postgres_saver, real_vacancy_object):
        """Тест сохранения реального объекта вакансии"""
        if not POSTGRES_SAVER_AVAILABLE or not VACANCY_MODELS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Тестируем с реальным объектом Vacancy
>           result = postgres_saver.save_vacancies([real_vacancy_object])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a2c76d0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee6931c530>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________ TestPostgresSaverCoreFixed.test_postgres_type_validation_fix __________

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7fee6a8102d0>
mock_connect = <MagicMock name='connect' id='140661939565776'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f996d0>

    @patch('psycopg2.connect')
    def test_postgres_type_validation_fix(self, mock_connect, postgres_saver):
        """Тест исправления валидации типов"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 0
        mock_connect.return_value = mock_conn
    
        # Тест с невалидными данными (словари вместо объектов Vacancy)
        invalid_data = [
            {"id": "1", "title": "Job 1", "company_name": "Company 1"},
            {"id": "2", "title": "Job 2", "company_name": "Company 2"}
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать невалидные типы
>           result = postgres_saver.save_vacancies(invalid_data)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68f996d0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestUtilsCoreFunctionality.test_menu_manager_functionality ___________

self = <tests.test_core_infrastructure_final.TestUtilsCoreFunctionality object at 0x7fee6a810950>

    def test_menu_manager_functionality(self):
        """Тест функциональности менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            menu_manager = MenuManager()
    
            if hasattr(menu_manager, 'display_menu'):
                with patch('builtins.print'):
                    menu_items = ['Option 1', 'Option 2', 'Exit']
>                   menu_manager.display_menu(menu_items)
E                   TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_core_infrastructure_final.py:428: TypeError
__________ TestCacheCoreFunctionality.test_file_cache_core_operations ___________

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7fee6aa03310>

    def test_file_cache_core_operations(self):
        """Тест основных операций файлового кэша"""
        try:
            from src.utils.cache import FileCache
    
            with tempfile.TemporaryDirectory() as temp_dir:
                cache = FileCache(cache_dir=temp_dir)
    
                test_data = {"test": "data", "items": [1, 2, 3]}
                test_params = {"query": "python", "page": 1}
    
                # Тест сохранения
                cache.save_response("test_source", test_params, test_data)
    
                # Тест загрузки
                loaded_data = cache.load_response("test_source", test_params)
    
                # Тест валидации
>               is_valid = cache.is_valid_response(test_data)
                           ^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'FileCache' object has no attribute 'is_valid_response'

tests/test_core_infrastructure_final.py:498: AttributeError
_____________ TestCacheCoreFunctionality.test_cache_error_handling ______________

self = PosixPath('/invalid/path'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           FileNotFoundError: [Errno 2] No such file or directory: '/invalid/path'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7fee6aa03110>

    def test_cache_error_handling(self):
        """Тест обработки ошибок кэша"""
        try:
            from src.utils.cache import FileCache
    
            # Тест с недоступной директорией
>           cache = FileCache(cache_dir="/invalid/path")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/cache.py:17: in __init__
    self._ensure_dir_exists()
src/utils/cache.py:21: in _ensure_dir_exists
    self.cache_dir.mkdir(parents=True, exist_ok=True)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1120: in mkdir
    self.parent.mkdir(parents=True, exist_ok=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PosixPath('/invalid'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           OSError: [Errno 30] Read-only file system: '/invalid'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: OSError
___________ TestEdgeCasesCoreFinal.test_none_and_empty_data_handling ____________

self = <tests.test_core_infrastructure_final.TestEdgeCasesCoreFinal object at 0x7fee6aa00ad0>

    def test_none_and_empty_data_handling(self):
        """Тест обработки None и пустых данных"""
        test_modules = [
            ('src.utils.data_normalizers', 'normalize_area_data'),
            ('src.utils.file_handlers', 'FileHandler'),
            ('src.utils.cache', 'FileCache')
        ]
    
        for module_name, class_or_func_name in test_modules:
            try:
                module = __import__(module_name, fromlist=[class_or_func_name])
>               target = getattr(module, class_or_func_name)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: module 'src.utils.file_handlers' has no attribute 'FileHandler'

tests/test_core_infrastructure_final.py:577: AttributeError
_______________ TestDBManagerCoverage.test_create_database_schema _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a9a3290>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee691df810>
mock_connection = (<Mock id='140661944720208'>, <Mock name='mock.cursor()' id='140661942503568'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
_________________ TestDBManagerCoverage.test_save_company_data __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a990990>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee691df650>
mock_connection = (<Mock id='140661944721168'>, <Mock name='mock.cursor()' id='140661944727504'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
_____________ TestDBManagerCoverage.test_save_vacancy_comprehensive _____________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a990810>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee69013590>
mock_connection = (<Mock id='140661940625040'>, <Mock name='mock.cursor()' id='140661940622544'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
________________ TestDBManagerCoverage.test_bulk_save_operations ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a992490>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68fe0a10>
mock_connection = (<Mock id='140661940433296'>, <Mock name='mock.cursor()' id='140661940426000'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
__________________ TestDBManagerCoverage.test_query_operations __________________

self = <Mock name='mock.cursor().execute' id='140661942143184'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a984e50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee6b1c63d0>
mock_connection = (<Mock id='140661936164432'>, <Mock name='mock.cursor()' id='140661936168912'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661944493584'>, исправляем...
________________ TestDBManagerCoverage.test_search_functionality ________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a987610>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee69153190>
mock_connection = (<Mock id='140661944336784'>, <Mock name='mock.cursor()' id='140661944337936'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
_________________ TestDBManagerCoverage.test_filter_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a986e50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee6b1c4150>
mock_connection = (<Mock id='140661941940240'>, <Mock name='mock.cursor()' id='140661941935504'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
_______________ TestDBManagerCoverage.test_aggregation_operations _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a986b50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee6922d6d0>
mock_connection = (<Mock id='140661941928080'>, <Mock name='mock.cursor()' id='140661941933712'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
_________________ TestDBManagerCoverage.test_update_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a987790>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee696f1290>
mock_connection = (<Mock id='140661967435280'>, <Mock name='mock.cursor()' id='140661967427088'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
_________________ TestDBManagerCoverage.test_delete_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a986750>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68feb110>
mock_connection = (<Mock id='140661940466320'>, <Mock name='mock.cursor()' id='140661940462992'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
_______________ TestDBManagerCoverage.test_transaction_management _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fee6a9847d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68fb4bd0>
mock_connection = (<Mock id='140661940252240'>, <Mock name='mock.cursor()' id='140661940245008'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
__________ TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ___________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fee6a934d90>
mock_connect = <MagicMock name='connect' id='140661944828880'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68fa65d0>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fee694cfd40>

    @patch('psycopg2.connect')
    def test_save_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения реальных объектов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68fa65d0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee694cfd40>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___________ TestPostgresSaverFinalFixes.test_vacancy_type_validation ____________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fee6a935cd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a2c0810>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a2c0810>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______ TestMainApplicationInterfaceCoverage.test_concrete_implementation _______

self = <tests.test_interfaces_coverage.TestMainApplicationInterfaceCoverage object at 0x7fee6a8d5a50>

    def test_concrete_implementation(self):
        """Тест конкретной реализации интерфейса"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        # Создаем конкретную реализацию
        class ConcreteInterface(MainApplicationInterface):
            def run_application(self):
                return "Running"
    
>       interface = ConcreteInterface()
                    ^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_interfaces_coverage.py:87: TypeError
_____ TestVacancyDisplayHandlerCoverage.test_display_handler_methods_exist ______

self = <tests.test_interfaces_coverage.TestVacancyDisplayHandlerCoverage object at 0x7fee6a8d7990>

    def test_display_handler_methods_exist(self):
        """Тест существования методов обработчика"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        mock_storage = Mock()
        try:
            handler = VacancyDisplayHandler(mock_storage)
        except TypeError:
            handler = VacancyDisplayHandler()
    
        # Проверяем наличие ожидаемых методов
        expected_methods = ['display_vacancies', 'display_vacancy_details', 'show_vacancies']
    
        existing_methods = [method for method in expected_methods if hasattr(handler, method)]
>       assert len(existing_methods) > 0, "Handler should have at least one display method"
E       AssertionError: Handler should have at least one display method
E       assert 0 > 0
E        +  where 0 = len([])

tests/test_interfaces_coverage.py:144: AssertionError
___________ TestDBManagerFixed.test_get_companies_and_vacancies_count ___________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a931f10>
mock_connect = <MagicMock name='connect' id='140661574615312'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee53303290>
mock_connection = (<Mock name='connect()' id='140661574612176'>, <Mock id='140661574612624'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
___________________ TestDBManagerFixed.test_get_all_vacancies ___________________

self = <Mock name='mock.execute' id='140661942436752'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a9315d0>
mock_connect = <MagicMock name='connect' id='140661940467920'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68febe10>
mock_connection = (<Mock name='connect()' id='140661940463824'>, <Mock id='140661940457552'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661939950736'>, исправляем...
____________________ TestDBManagerFixed.test_get_avg_salary _____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a932dd0>
mock_connect = <MagicMock name='connect' id='140661939965840'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68f71590>
mock_connection = (<Mock name='connect()' id='140661939963472'>, <Mock id='140661939974032'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661942559120'>, исправляем...
___________ TestDBManagerFixed.test_get_vacancies_with_higher_salary ____________

self = <Mock name='mock.execute' id='140661940249488'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a933550>
mock_connect = <MagicMock name='connect' id='140661940260496'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68fb90d0>
mock_connection = (<Mock name='connect()' id='140661940272464'>, <Mock id='140661940262416'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661960217680'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661942059216'>, исправляем...
______________ TestDBManagerFixed.test_get_vacancies_with_keyword _______________

self = <Mock name='mock.execute' id='140661818760976'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a9331d0>
mock_connect = <MagicMock name='connect' id='140661935623952'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68b4c850>
mock_connection = (<Mock name='connect()' id='140661935627856'>, <Mock id='140661935621136'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661944536080'>, исправляем...
__________________ TestDBManagerFixed.test_get_database_stats ___________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fee6a933f90>
mock_connect = <MagicMock name='connect' id='140661935761680'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee68b6e610>
mock_connection = (<Mock name='connect()' id='140661935751504'>, <Mock id='140661935759440'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661945294352'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_____ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects ______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fee6a8b7550>
mock_connect = <MagicMock name='connect' id='140661960233040'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6946e410>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fee6919fa00>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6946e410>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fee6919fa00>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______________ TestPostgresSaverFixed.test_delete_vacancy_by_id ________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fee6a8b6a50>
mock_connect = <MagicMock name='connect' id='140661942061776'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a932110>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a932110>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count ________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fee6a8b7c50>
mock_connect = <MagicMock name='connect' id='140661936020048'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68fc8a10>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
________________ TestSimpleDBAdapterFixed.test_get_all_vacancies ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fee6a8b4750>
mock_connect = <MagicMock name='connect' id='140661940039504'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68f80fd0>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
___________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword ____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fee6a8b5b10>
mock_connect = <MagicMock name='connect' id='140661939927248'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68f67790>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
______________ TestSimpleDBAdapterFixed.test_init_database_schema _______________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fee6a8b5090>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69421cd0>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee69420810>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69421cd0> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestAPIModulesFixed.test_hh_api_methods_coverage ________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fee6a8a77d0>
mock_get = <MagicMock name='get' id='140661942441296'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
____________ TestAPIModulesFixed.test_cached_api_basic_functionality ____________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fee6a8a5850>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
___________________ TestEdgeCasesFixed.test_db_empty_results ____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fee6a894a50>
mock_connect = <MagicMock name='connect' id='140661945556496'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661931235024'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140661941863760'>, исправляем...
_______________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _______________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fee6a8955d0>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
___________ TestAPIModulesIntegration.test_sj_api_basic_functionality ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7fee6a85a710>

    def test_sj_api_basic_functionality(self):
        """Тест базовой функциональности SuperJob API"""
        if not SJ_API_AVAILABLE:
            pytest.skip("SuperJobAPI not available")
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"objects": [], "total": 0}
            mock_get.return_value = mock_response
    
            sj_api = SuperJobAPI()
            assert sj_api is not None
    
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:86: AssertionError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
___________ TestAPIModulesIntegration.test_unified_api_filter_methods ___________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7fee6a859b50>

    def test_unified_api_filter_methods(self):
        """Тест методов фильтрации UnifiedAPI"""
        if not UNIFIED_API_AVAILABLE:
            pytest.skip("UnifiedAPI not available")
    
        api = UnifiedAPI()
        assert api is not None
    
        # Тест пустого списка
        if hasattr(api, '_filter_by_target_companies'):
            result = api._filter_by_target_companies([])
            assert result == []
    
        # Тест с данными
        test_vacancies = [
            {"employer": {"id": "123"}, "title": "Test Job"}
        ]
    
>       with patch.object(api, '_get_target_company_ids', return_value=[]):

tests/test_missing_coverage_components.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee6911fd50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7fee6911d090> does not have the attribute '_get_target_company_ids'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
------------------------------- Captured log call -------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________ TestDBManagerCoverage.test_get_companies_and_vacancies_count __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fee6a8e0310>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee6a2c5d90>

    def test_get_companies_and_vacancies_count(self, db_manager):
        """Тест получения количества компаний и вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = [("Company A", 10), ("Company B", 5)]
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661960242704'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_________________ TestDBManagerCoverage.test_get_all_vacancies __________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fee6a858c50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee69015410>

    def test_get_all_vacancies(self, db_manager):
        """Тест получения всех вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661940113616'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___________________ TestDBManagerCoverage.test_get_avg_salary ___________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fee6a8e1e90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee694f4a90>

    def test_get_avg_salary(self, db_manager):
        """Тест получения средней зарплаты"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (125000,)
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661966981904'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestDBManagerCoverage.test_get_vacancies_with_higher_salary __________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fee6a8e0e10>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee694bf190>

    def test_get_vacancies_with_higher_salary(self, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661945517968'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____________ TestDBManagerCoverage.test_get_vacancies_with_keyword _____________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7fee6a8e0cd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fee694fa090>

    def test_get_vacancies_with_keyword(self, db_manager):
        """Тест получения вакансий по ключевому слову"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661945769808'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestIntegrationScenarios.test_api_and_database_integration ___________

self = <tests.test_missing_coverage_components.TestIntegrationScenarios object at 0x7fee6a8f2cd0>

    def test_api_and_database_integration(self):
        """Тест интеграции API и базы данных"""
        if not (UNIFIED_API_AVAILABLE and DB_MANAGER_AVAILABLE):
            pytest.skip("Required modules not available")
    
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            # Настройка DB
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock name='mock.cursor()' id='140661939920336'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______________________ TestPaginatorCoverage.test_get_page ______________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fee6a864410>
paginator = <Mock id='140661576646736'>

    def test_get_page(self, paginator):
        """Тест получения страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'get_page'):
            page_data = paginator.get_page(0)
>           assert isinstance(page_data, list) or page_data is None
E           AssertionError: assert (False or <Mock name='mock.get_page()' id='140661576660240'> is None)
E            +  where False = isinstance(<Mock name='mock.get_page()' id='140661576660240'>, list)

tests/test_missing_coverage_extended.py:339: AssertionError
___________________ TestPaginatorCoverage.test_previous_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fee6a8650d0>
paginator = <Mock id='140661576649680'>

    def test_previous_page(self, paginator):
        """Тест перехода к предыдущей странице"""
        if not PAGINATOR_AVAILABLE:
            return
    
        # Сначала переходим на следующую страницу
        if hasattr(paginator, 'next_page'):
            paginator.next_page()
    
        if hasattr(paginator, 'previous_page'):
            initial_page = getattr(paginator, 'current_page', 2)
            result = paginator.previous_page()
            if result:
                new_page = getattr(paginator, 'current_page', 1)
>               assert new_page == initial_page - 1
E               assert 0 == (0 - 1)

tests/test_missing_coverage_extended.py:367: AssertionError
___________________ TestPaginatorCoverage.test_has_next_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fee6a865710>
paginator = <Mock id='140661945064976'>

    def test_has_next_page(self, paginator):
        """Тест проверки наличия следующей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_next_page'):
            result = paginator.has_next_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_next_page()' id='140661945062288'>, bool)

tests/test_missing_coverage_extended.py:376: AssertionError
_________________ TestPaginatorCoverage.test_has_previous_page __________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fee6a84e2d0>
paginator = <Mock id='140661945004240'>

    def test_has_previous_page(self, paginator):
        """Тест проверки наличия предыдущей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_previous_page'):
            result = paginator.has_previous_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_previous_page()' id='140661944993360'>, bool)

tests/test_missing_coverage_extended.py:385: AssertionError
________________ TestVacancyFormatterCoverage.test_format_salary ________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7fee6a861510>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7fee69422990>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:555: TypeError
_________ TestUIInterfacesCoverage.test_vacancy_display_handler_display _________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fee6a718590>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:836: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_search_handler_search __________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fee6a718bd0>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ____

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fee6a7191d0>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:859: TypeError
__________ TestPostgresSaverCoverage.test_database_connection_methods ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a780ad0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee69365890>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
______________ TestPostgresSaverCoverage.test_create_tables_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a781150>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee688d6110>
mock_connection = (<Mock id='140661933032848'>, <Mock name='mock.cursor()' id='140661933040208'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
______________ TestPostgresSaverCoverage.test_save_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a781810>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6944fd10>
mock_connection = (<Mock id='140661933039632'>, <Mock name='mock.cursor()' id='140661936023248'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
____________ TestPostgresSaverCoverage.test_save_multiple_vacancies _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a781e90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68fedf90>
mock_connection = (<Mock id='140661945765264'>, <Mock name='mock.cursor()' id='140661945777232'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140661574613264'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140661574613264'> = <Mock name='mock.cursor()' id='140661945777232'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
______________ TestPostgresSaverCoverage.test_get_vacancies_method ______________

self = <Mock name='mock.cursor().execute' id='140661940318352'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a782510>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6922df90>
mock_connection = (<Mock id='140661940111888'>, <Mock name='mock.cursor()' id='140661940122064'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
__________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a782b90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68fa7b10>
mock_connection = (<Mock id='140661940183312'>, <Mock name='mock.cursor()' id='140661940177424'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
_____________ TestPostgresSaverCoverage.test_filter_by_salary_range _____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a783210>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a87e290>
mock_connection = (<Mock id='140661938115728'>, <Mock name='mock.cursor()' id='140661938121616'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
______________ TestPostgresSaverCoverage.test_get_companies_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a783890>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee69570490>
mock_connection = (<Mock id='140661946253968'>, <Mock name='mock.cursor()' id='140661946254160'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_____________ TestPostgresSaverCoverage.test_delete_vacancy_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a783ed0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee69574710>
mock_connection = (<Mock id='140661946270352'>, <Mock name='mock.cursor()' id='140661946271248'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee69574710>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
_________________ TestPostgresSaverCoverage.test_clear_all_data _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a784590>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6887c850>
mock_connection = (<Mock id='140661932671312'>, <Mock name='mock.cursor()' id='140661932671376'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_____________ TestPostgresSaverCoverage.test_get_statistics_method ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a784c10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a8b4990>
mock_connection = (<Mock id='140661966466960'>, <Mock name='mock.cursor()' id='140661966468944'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
_________________ TestPostgresSaverCoverage.test_export_to_json _________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a785290>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6887d8d0>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
________________ TestPostgresSaverCoverage.test_import_from_json ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a785910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee6a72cc50>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
______________ TestPostgresSaverCoverage.test_transaction_rollback ______________

self = <Mock name='mock.rollback' id='140661940141264'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a76d290>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee69525850>
mock_connection = (<Mock id='140661964851152'>, <Mock name='mock.cursor()' id='140661964861648'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
________________ TestPostgresSaverCoverage.test_batch_operations ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fee6a784710>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee688605d0>
mock_connection = (<Mock id='140661932557456'>, <Mock name='mock.cursor()' id='140661932557392'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fee688605d0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
________________ TestFileCacheRealMethods.test_cache_expiration _________________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fee6a7a3c90>
temp_cache_dir = '/tmp/tmp73w6gsmu'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш с очень коротким TTL
>       cache = FileCache(cache_dir=temp_cache_dir, ttl_seconds=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:273: TypeError
________ TestIntegrationWithRealClasses.test_cache_with_api_integration _________

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7fee6a7a5590>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:424: KeyError
___________ TestSimpleDBAdapterCoverage.test_connect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a66ba10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee696498d0>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
__________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a66bd90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69682a90>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a678190>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee6965dfd0>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee6965c390>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee6965dfd0> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a678510>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee694fbc50>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee694fa090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee694fbc50> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a678a50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee682bdad0>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee682bee90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee682bdad0> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a679090>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee695b3610>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee695b28d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee695b3610> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a6796d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69548890>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee69548190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69548890> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a679d10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee691b1510>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee691b1750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee691b1510> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a67a310>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69310110>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee69311990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee69310110> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a67a950>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee688e6f10>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee688e4190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee688e6f10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_error_handling_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fee6a67af90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68ad7350>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee68ad6f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68ad7350> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSuperJobAPIComplete.test_deduplicate_vacancies _______________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7fee6a6a6590>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fee69575b90>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee69584590>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestPostgresSaver.test_save_vacancies_batch __________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7fee6a53ff10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fee68bf1890>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee68fb0c10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fee68bf1890> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_insert_vacancy ____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fee6a54a310>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee688ac350>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee688ac410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee688ac350> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestSimpleDBAdapter.test_get_vacancies _____________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fee6a54a990>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68bae4d0>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fee68bac250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fee68bae4d0> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestStorageIntegration.test_repository_with_validator_integration _______

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7fee6a558150>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mock id='140661932942992'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestVacancyStorageServiceCoverage.test_storage_service_initialization _____

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fee6a54b990>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
__________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ___________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fee6a559e50>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fee695d2990>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
__________ TestVacancyStorageServiceCoverage.test_search_functionality __________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fee6a55a910>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fee6944eb10>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
___________ TestVacancyStorageServiceCoverage.test_delete_operations ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fee6a55ac90>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fee68ff14d0>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fee6a55bb90>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fee691cd550>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_______ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field ________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fee6a570210>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fee68fbec10>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
___________ TestDeduplicationServiceCoverage.test_identify_duplicates ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fee6a570890>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fee69583990>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
___________ TestFilteringServiceCoverage.test_filter_by_salary_range ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fee6a571750>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fee69666ed0>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_keyword ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fee6a571d90>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fee688d6250>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
______________ TestFilteringServiceCoverage.test_filter_by_company ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fee6a572410>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fee6957e110>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
______________ TestFilteringServiceCoverage.test_complex_filtering ______________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fee6a572a50>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fee691cfe10>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
_______________ TestVacancyRepositoryCoverage.test_create_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fee6a573950>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee688acd90>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_____________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fee6a573f90>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee695817d0>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
_______________ TestVacancyRepositoryCoverage.test_update_vacancy _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fee6a580650>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee694e6250>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee694e6250>
vacancy = <Mock id='140661945686864'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140661945695056'>: 'Mock' object does not support the context manager protocol
_____________ TestVacancyRepositoryCoverage.test_get_all_vacancies ______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fee6a573750>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee69663cd0>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee69663cd0>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
------------------------------- Captured log call -------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
______________ TestVacancyRepositoryCoverage.test_count_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fee6a571510>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fee6a573a90>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fee6a581010>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fee68be3050>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_required_fields ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fee6a5813d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fee6963d390>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
_____________ TestVacancyValidatorCoverage.test_validate_data_types _____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fee6a581750>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 