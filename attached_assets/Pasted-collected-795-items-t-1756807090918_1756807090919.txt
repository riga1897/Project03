collected 795 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  1%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  3%]
tests/test_api_modules.py .............................                                  [  6%]
tests/test_app_config.py .....                                                           [  7%]
tests/test_base_api.py ......                                                            [  8%]
tests/test_base_formatter.py ..........                                                  [  9%]
tests/test_base_parser.py ......                                                         [ 10%]
tests/test_cache.py .......                                                              [ 10%]
tests/test_cache_manager.py ....................                                         [ 13%]
tests/test_cached_api.py ...........                                                     [ 14%]
tests/test_complete_module_coverage.py .F.............FF                                 [ 16%]
tests/test_comprehensive_coverage.py ........................                            [ 20%]
tests/test_console_interface.py ......                                                   [ 20%]
tests/test_db_config.py .....                                                            [ 21%]
tests/test_db_manager.py .................                                               [ 23%]
tests/test_db_manager_demo.py ..F.....F........                                          [ 25%]
tests/test_decorators.py .......                                                         [ 26%]
tests/test_env_loader.py ................                                                [ 28%]
tests/test_extended_coverage.py EEEEEEEEEEEE.................FF..                        [ 32%]
tests/test_file_handlers.py ............                                                 [ 34%]
tests/test_full_src_coverage.py ........F......                                          [ 36%]
tests/test_get_api.py ......                                                             [ 36%]
tests/test_hh_api.py .......                                                             [ 37%]
tests/test_hh_api_config.py .....                                                        [ 38%]
tests/test_hh_parser.py ........                                                         [ 39%]
tests/test_integration.py .............                                                  [ 41%]
tests/test_main_module.py .F..F.....FF.                                                  [ 42%]
tests/test_menu_manager.py ..........                                                    [ 43%]
tests/test_menu_system.py ....................                                           [ 46%]
tests/test_missing_components.py ..................F                                     [ 48%]
tests/test_paginator.py ......                                                           [ 49%]
tests/test_postgres_saver.py .......                                                     [ 50%]
tests/test_salary_fixed.py ...........                                                   [ 51%]
tests/test_salary_utils.py ......................                                        [ 54%]
tests/test_search_utils.py ............................                                  [ 58%]
tests/test_sj_api.py ..............                                                      [ 59%]
tests/test_sj_api_config.py .....                                                        [ 60%]
tests/test_sj_parser.py ........                                                         [ 61%]
tests/test_source_manager.py .................                                           [ 63%]
tests/test_source_selector.py ..................                                         [ 65%]
tests/test_storage_factory.py ........                                                   [ 66%]
tests/test_target_companies.py .....                                                     [ 67%]
tests/test_ui_config.py .......................                                          [ 70%]
tests/test_ui_helpers.py ...........                                                     [ 71%]
tests/test_ui_navigation.py ......................                                       [ 74%]
tests/test_unified_api.py .................                                              [ 76%]
tests/test_user_interface.py ......................                                      [ 79%]
tests/test_user_interface_comprehensive.py .....EE.........                              [ 81%]
tests/test_vacancy_display_handler.py ..............                                     [ 83%]
tests/test_vacancy_formatter.py ........                                                 [ 84%]
tests/test_vacancy_models.py .................................................           [ 90%]
tests/test_vacancy_operations.py ......                                                  [ 91%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 94%]
tests/test_vacancy_search_handler.py .......................                             [ 97%]
tests/test_vacancy_stats.py .E.FFFF.F.FF                                                 [ 98%]
tests/test_vacancy_stats_fixed.py E.F..F..                                               [100%]

============================================ ERRORS ============================================
______________ ERROR at setup of TestVacancyStatsExtended.test_salary_statistics _______________

self = <workspace.tests.test_extended_coverage.TestVacancyStatsExtended object at 0x7f27bf7beb10>

    @pytest.fixture
    def sample_vacancies_extended(self):
        """Расширенная фикстура для тестовых вакансий"""
        if EXTENDED_SRC_AVAILABLE:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            vacancies = []
            for i in range(5):
>               salary = Salary(amount_from=50000 + i*10000, amount_to=80000 + i*15000, currency="RUR")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'

tests/test_extended_coverage.py:116: TypeError
___________ ERROR at setup of TestVacancyStatsExtended.test_experience_distribution ____________

self = <workspace.tests.test_extended_coverage.TestVacancyStatsExtended object at 0x7f27bf7bdf10>

    @pytest.fixture
    def sample_vacancies_extended(self):
        """Расширенная фикстура для тестовых вакансий"""
        if EXTENDED_SRC_AVAILABLE:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            vacancies = []
            for i in range(5):
>               salary = Salary(amount_from=50000 + i*10000, amount_to=80000 + i*15000, currency="RUR")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'

tests/test_extended_coverage.py:116: TypeError
___________ ERROR at setup of TestVacancyStatsExtended.test_employment_distribution ____________

self = <workspace.tests.test_extended_coverage.TestVacancyStatsExtended object at 0x7f27bf7bebd0>

    @pytest.fixture
    def sample_vacancies_extended(self):
        """Расширенная фикстура для тестовых вакансий"""
        if EXTENDED_SRC_AVAILABLE:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            vacancies = []
            for i in range(5):
>               salary = Salary(amount_from=50000 + i*10000, amount_to=80000 + i*15000, currency="RUR")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'

tests/test_extended_coverage.py:116: TypeError
______________ ERROR at setup of TestVacancyStatsExtended.test_area_distribution _______________

self = <workspace.tests.test_extended_coverage.TestVacancyStatsExtended object at 0x7f27bf7bf390>

    @pytest.fixture
    def sample_vacancies_extended(self):
        """Расширенная фикстура для тестовых вакансий"""
        if EXTENDED_SRC_AVAILABLE:
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            vacancies = []
            for i in range(5):
>               salary = Salary(amount_from=50000 + i*10000, amount_to=80000 + i*15000, currency="RUR")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'

tests/test_extended_coverage.py:116: TypeError
_________________ ERROR at setup of TestMenuManagerExtended.test_add_menu_item _________________

self = <workspace.tests.test_extended_coverage.TestMenuManagerExtended object at 0x7f27bf7bc7d0>

    @pytest.fixture
    def menu_manager(self):
        """Фикстура менеджера меню"""
        if EXTENDED_SRC_AVAILABLE:
>           return MenuManager()
                   ^^^^^^^^^^^
E           NameError: name 'MenuManager' is not defined

tests/test_extended_coverage.py:207: NameError
________________ ERROR at setup of TestMenuManagerExtended.test_execute_action _________________

self = <workspace.tests.test_extended_coverage.TestMenuManagerExtended object at 0x7f27bf7bc9d0>

    @pytest.fixture
    def menu_manager(self):
        """Фикстура менеджера меню"""
        if EXTENDED_SRC_AVAILABLE:
>           return MenuManager()
                   ^^^^^^^^^^^
E           NameError: name 'MenuManager' is not defined

tests/test_extended_coverage.py:207: NameError
___________________ ERROR at setup of TestMenuManagerExtended.test_show_menu ___________________

self = <workspace.tests.test_extended_coverage.TestMenuManagerExtended object at 0x7f27bf7bd690>

    @pytest.fixture
    def menu_manager(self):
        """Фикстура менеджера меню"""
        if EXTENDED_SRC_AVAILABLE:
>           return MenuManager()
                   ^^^^^^^^^^^
E           NameError: name 'MenuManager' is not defined

tests/test_extended_coverage.py:207: NameError
__________________ ERROR at setup of TestMenuManagerExtended.test_clear_menu ___________________

self = <workspace.tests.test_extended_coverage.TestMenuManagerExtended object at 0x7f27bf7bc290>

    @pytest.fixture
    def menu_manager(self):
        """Фикстура менеджера меню"""
        if EXTENDED_SRC_AVAILABLE:
>           return MenuManager()
                   ^^^^^^^^^^^
E           NameError: name 'MenuManager' is not defined

tests/test_extended_coverage.py:207: NameError
_________________ ERROR at setup of TestUIHelpersExtended.test_format_currency _________________

self = <workspace.tests.test_extended_coverage.TestUIHelpersExtended object at 0x7f27bf7b6d10>

    @pytest.fixture
    def ui_helpers(self):
        """Фикстура UI помощников"""
        if EXTENDED_SRC_AVAILABLE:
>           return UIHelpers()
                   ^^^^^^^^^
E           NameError: name 'UIHelpers' is not defined

tests/test_extended_coverage.py:289: NameError
________________ ERROR at setup of TestUIHelpersExtended.test_format_experience ________________

self = <workspace.tests.test_extended_coverage.TestUIHelpersExtended object at 0x7f27bf7b71d0>

    @pytest.fixture
    def ui_helpers(self):
        """Фикстура UI помощников"""
        if EXTENDED_SRC_AVAILABLE:
>           return UIHelpers()
                   ^^^^^^^^^
E           NameError: name 'UIHelpers' is not defined

tests/test_extended_coverage.py:289: NameError
__________________ ERROR at setup of TestUIHelpersExtended.test_truncate_text __________________

self = <workspace.tests.test_extended_coverage.TestUIHelpersExtended object at 0x7f27bf7b4090>

    @pytest.fixture
    def ui_helpers(self):
        """Фикстура UI помощников"""
        if EXTENDED_SRC_AVAILABLE:
>           return UIHelpers()
                   ^^^^^^^^^
E           NameError: name 'UIHelpers' is not defined

tests/test_extended_coverage.py:289: NameError
___________________ ERROR at setup of TestUIHelpersExtended.test_format_date ___________________

self = <workspace.tests.test_extended_coverage.TestUIHelpersExtended object at 0x7f27bf7b5e10>

    @pytest.fixture
    def ui_helpers(self):
        """Фикстура UI помощников"""
        if EXTENDED_SRC_AVAILABLE:
>           return UIHelpers()
                   ^^^^^^^^^
E           NameError: name 'UIHelpers' is not defined

tests/test_extended_coverage.py:289: NameError
__________ ERROR at setup of TestUserInterfaceComprehensive.test_run_advanced_search ___________

self = <workspace.tests.test_user_interface_comprehensive.TestUserInterfaceComprehensive object at 0x7f27beb2fc10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """
        Создание тестовых вакансий
    
        Returns:
            List[Vacancy]: Список тестовых объектов вакансий
        """
        vacancies = []
    
        # Вакансия с полной информацией - используем правильный конструктор Salary
>       salary1 = Salary.from_range(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_user_interface_comprehensive.py:33: AttributeError
___________ ERROR at setup of TestUserInterfaceComprehensive.test_run_salary_filter ____________

self = <workspace.tests.test_user_interface_comprehensive.TestUserInterfaceComprehensive object at 0x7f27beb2ffd0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """
        Создание тестовых вакансий
    
        Returns:
            List[Vacancy]: Список тестовых объектов вакансий
        """
        vacancies = []
    
        # Вакансия с полной информацией - используем правильный конструктор Salary
>       salary1 = Salary.from_range(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_user_interface_comprehensive.py:33: AttributeError
_____________ ERROR at setup of TestVacancyStats.test_calculate_salary_statistics ______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be7006d0>
sample_vacancies = [{'description': 'Работа с Python и Django', 'employer': {'name': 'Яндекс'}, 'salary': {'currency': 'RUR', 'from': 100...ption': 'Работа с React и TypeScript', 'employer': {'name': 'Тинькофф'}, 'salary': None, 'source': 'superjob.ru', ...}]

    @pytest.fixture
    def vacancy_objects(self, sample_vacancies: List[Dict[str, Any]]) -> List[Vacancy]:
        """
        Создание объектов Vacancy из тестовых данных
    
        Args:
            sample_vacancies: Тестовые данные вакансий
    
        Returns:
            List[Vacancy]: Список объектов вакансий
        """
        vacancies = []
        for data in sample_vacancies:
            # Создаем объект Salary если есть данные - используем правильный конструктор
            salary = None
            if data.get('salary'):
                salary_data = data['salary']
>               salary = Salary.from_range(
                         ^^^^^^^^^^^^^^^^^
                    salary_data.get('from'),
                    salary_data.get('to'),
                    salary_data.get('currency', 'RUR')
                )
E               AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:89: AttributeError
____ ERROR at setup of TestVacancyStatsFixed.test_calculate_salary_statistics_with_salaries ____

self = <workspace.tests.test_vacancy_stats_fixed.TestVacancyStatsFixed object at 0x7f27be702450>

    @pytest.fixture
    def sample_vacancies_fixed(self) -> List[Vacancy]:
        """
        Создание тестовых вакансий с правильными конструкторами
    
        Returns:
            List[Vacancy]: Список тестовых вакансий
        """
        vacancies = []
    
        # Вакансия с зарплатой (используем правильный конструктор Salary)
        salary1 = Salary({"from": 100000, "to": 150000, "currency": "RUR"})
>       vacancy1 = Vacancy(
            title="Python Developer",
            vacancy_id="1",
            url="https://example.com/1",
            source="hh.ru",
            employer={"name": "Яндекс"},
            salary=salary1,
            description="Разработка на Python"
        )

tests/test_vacancy_stats_fixed.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f27bdadbf40>
salary_data = <src.utils.salary.Salary object at 0x7f27bdadb9a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
_________________ TestCompleteModuleCoverage.test_vacancy_model_comprehensive __________________

self = <workspace.tests.test_complete_module_coverage.TestCompleteModuleCoverage object at 0x7f27bf374990>

    def test_vacancy_model_comprehensive(self) -> None:
        """
        Тест комплексной функциональности модели Vacancy
        """
        # Создаем зарплату правильным способом
        salary_data = {"from": 100000, "to": 150000, "currency": "RUR"}
        salary = Salary(salary_data)
    
        # Создаем вакансию
>       vacancy = Vacancy(
            title="Senior Python Developer",
            vacancy_id="test123",
            url="https://hh.ru/vacancy/12345",
            source="hh.ru",
            employer={"name": "Яндекс", "id": "1740"},
            salary=salary,
            description="Разработка высоконагруженных систем",
            experience={"name": "От 3 до 6 лет"},
            employment={"name": "Полная занятость"},
            area={"name": "Москва"}
        )

tests/test_complete_module_coverage.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f27be74a920>
salary_data = <src.utils.salary.Salary object at 0x7f27be74a1a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ TestCompleteModuleCoverage.test_comprehensive_type_checking __________________

self = <workspace.tests.test_complete_module_coverage.TestCompleteModuleCoverage object at 0x7f27bf369490>

    def test_comprehensive_type_checking(self) -> None:
        """
        Тест комплексной проверки типов
        """
        # Тестируем типы основных объектов
    
        # Salary
        salary = Salary({"from": 100000, "currency": "RUR"})
        assert isinstance(salary, Salary)
    
        # Vacancy
        vacancy = Vacancy("Test", "1", "https://test.com", "test")
        assert isinstance(vacancy, Vacancy)
    
        # VacancyStats
        from src.utils.vacancy_stats import VacancyStats
        stats = VacancyStats()
        assert isinstance(stats, VacancyStats)
    
        # Проверяем что методы возвращают правильные типы
        vacancy_list = [vacancy]
>       result = stats.calculate_salary_statistics(vacancy_list)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_complete_module_coverage.py:521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bde47310>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f27befa1230>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
_____________ TestCompleteModuleCoverage.test_integration_with_mocked_dependencies _____________

self = <MagicMock name='AppConfig' id='139808684256784'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'AppConfig' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_complete_module_coverage.TestCompleteModuleCoverage object at 0x7f27bf36a090>

    def test_integration_with_mocked_dependencies(self) -> None:
        """
        Тест интеграции с замокированными зависимостями
        """
        # Мокаем все внешние зависимости
        with patch('src.storage.db_manager.DBManager') as mock_db:
            with patch('src.config.app_config.AppConfig') as mock_config:
                with patch('src.storage.storage_factory.StorageFactory') as mock_factory:
    
                    # Настройка моков
                    mock_db_instance = Mock()
                    mock_db_instance.check_connection.return_value = True
                    mock_db.return_value = mock_db_instance
    
                    mock_config_instance = Mock()
                    mock_config_instance.default_storage_type = "postgres"
                    mock_config.return_value = mock_config_instance
    
                    mock_storage = Mock()
                    mock_factory.create_storage.return_value = mock_storage
    
                    # Тестируем интеграцию
                    from src.user_interface import main
    
                    with patch('src.ui_interfaces.console_interface.UserInterface') as mock_ui:
                        mock_ui_instance = Mock()
                        mock_ui.return_value = mock_ui_instance
    
                        # Выполняем функцию
                        main()
    
                        # Проверяем что все компоненты были использованы
                        mock_db.assert_called()
>                       mock_config.assert_called()
E                       AssertionError: Expected 'AppConfig' to have been called.

tests/test_complete_module_coverage.py:557: AssertionError
------------------------------------- Captured stdout call -------------------------------------

Критическая ошибка: object of type 'Mock' has no len()
Обратитесь к разработчику для решения проблемы.
-------------------------------------- Captured log call ---------------------------------------
ERROR    src.user_interface:user_interface.py:67 Критическая ошибка: object of type 'Mock' has no len()
_____________________ TestDBManagerDemo.test_demo_methods_call_db_manager ______________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f27bf332e10>
mock_print = <MagicMock name='print' id='139808666309328'>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f27bde46150>

    @patch('builtins.print')
    def test_demo_methods_call_db_manager(self, mock_print, db_manager_demo):
        """Тест что демонстрация вызывает методы DB менеджера"""
        # Запускаем полную демонстрацию
        db_manager_demo.run_full_demo()
    
        # Проверяем что методы DBManager были вызваны
        db_manager = db_manager_demo.db_manager
    
        assert db_manager.get_target_companies_analysis.called
>       assert db_manager.get_companies_and_vacancies_count.called
E       AssertionError: assert False
E        +  where False = <Mock name='mock.get_companies_and_vacancies_count' id='139808666307088'>.called
E        +    where <Mock name='mock.get_companies_and_vacancies_count' id='139808666307088'> = <Mock id='139808666306192'>.get_companies_and_vacancies_count

tests/test_db_manager_demo.py:156: AssertionError
________________________ TestDBManagerDemo.test_demo_individual_methods ________________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f27bf317590>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f27be746310>

    def test_demo_individual_methods(self, db_manager_demo):
        """Тест отдельных методов демонстрации"""
        # Тестируем что можем вызвать приватные методы через публичный интерфейс
        with patch('builtins.print'):
            # Основной метод должен вызывать все подметоды
            db_manager_demo.run_full_demo()
    
        # Проверяем что все ключевые методы DBManager были вызваны
        db_manager = db_manager_demo.db_manager
    
        # Проверяем вызовы основных методов
        methods_to_check = [
            'get_companies_and_vacancies_count',
            'get_all_vacancies',
            'get_avg_salary',
            'get_vacancies_with_higher_salary',
            'get_vacancies_with_keyword'
        ]
    
        for method_name in methods_to_check:
            method = getattr(db_manager, method_name)
>           assert method.called, f"Метод {method_name} не был вызван"
E           AssertionError: Метод get_companies_and_vacancies_count не был вызван
E           assert False
E            +  where False = <Mock name='mock.get_companies_and_vacancies_count' id='139808716707600'>.called

tests/test_db_manager_demo.py:281: AssertionError
______________________ TestAdvancedCoverage.test_module_interoperability _______________________

self = <workspace.tests.test_extended_coverage.TestAdvancedCoverage object at 0x7f27bf75b590>

    def test_module_interoperability(self) -> None:
        """Тест взаимодействия между модулями"""
        if EXTENDED_SRC_AVAILABLE:
            try:
                # Тестируем взаимодействие между компонентами
                from src.vacancies.models import Vacancy
                from src.utils.salary import Salary
    
                # Создаем объекты и тестируем их взаимодействие
>               salary = Salary.from_range(100000, 150000, "RUR")
                         ^^^^^^^^^^^^^^^^^
E               AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_extended_coverage.py:813: AttributeError
_______________________ TestAdvancedCoverage.test_configuration_coverage _______________________

self = <workspace.tests.test_extended_coverage.TestAdvancedCoverage object at 0x7f27bf7a3c10>

    def test_configuration_coverage(self) -> None:
        """Тест покрытия конфигурационных модулей"""
        config_modules = [
            "src.config.app_config",
            "src.config.db_config",
            "src.config.ui_config",
            "src.config.target_companies"
        ]
    
        for module_name in config_modules:
            try:
                import importlib
                module = importlib.import_module(module_name)
    
                # Проверяем что модуль загружен
                assert module is not None
    
                # Получаем все публичные атрибуты
                public_attrs = [attr for attr in dir(module) if not attr.startswith('_')]
    
                # Проверяем каждый атрибут
                for attr_name in public_attrs:
                    attr = getattr(module, attr_name)
    
                    # Проверяем что атрибут имеет допустимый тип
>                   assert attr is None or isinstance(attr, (str, int, float, bool, list, dict, type, type(lambda: None)))
E                   AssertionError: assert (typing.Dict is None or False)
E                    +  where False = isinstance(typing.Dict, (<class 'str'>, <class 'int'>, <class 'float'>, <class 'bool'>, <class 'list'>, <class 'dict'>, ...))

tests/test_extended_coverage.py:859: AssertionError
_____________________ TestFullSrcCoverage.test_comprehensive_method_calls ______________________

self = <workspace.tests.test_full_src_coverage.TestFullSrcCoverage object at 0x7f27bf790d90>

    def test_comprehensive_method_calls(self) -> None:
        """Тест покрытия вызовов методов"""
        try:
            from src.utils.vacancy_stats import VacancyStats
            from src.vacancies.models import Vacancy
            from src.utils.salary import Salary
    
            # Создаем экземпляры
            stats = VacancyStats()
    
            # Используем правильный конструктор для Salary
>           salary = Salary.from_range(100000, 150000, "RUR")
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_full_src_coverage.py:266: AttributeError
__________________________ TestMainModule.test_main_module_execution ___________________________

self = <workspace.tests.test_main_module.TestMainModule object at 0x7f27bef1afd0>
mock_main = <MagicMock name='main' id='139808662834192'>

    @patch('src.user_interface.main')
    def test_main_module_execution(self, mock_main: Mock) -> None:
        """
        Тест выполнения главного модуля
    
        Args:
            mock_main: Мок функции main из user_interface
        """
        # Имитируем выполнение main модуля
>       main_module.main()
        ^^^^^^^^^^^^^^^^
E       AttributeError: module 'main' has no attribute 'main'

tests/test_main_module.py:41: AttributeError
______________________ TestUserInterface.test_main_function_success_flow _______________________

self = <Mock name='UserInterface().run' id='139808662805392'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'run' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_main_module.TestUserInterface object at 0x7f27bef181d0>
mock_ui = <MagicMock name='UserInterface' id='139808662800144'>
mock_storage_factory = <MagicMock name='StorageFactory' id='139808662814352'>
mock_app_config = <MagicMock name='AppConfig' id='139808666687056'>
mock_db_manager = <MagicMock name='DBManager' id='139808676003984'>

    @patch('src.storage.db_manager.DBManager')
    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.storage_factory.StorageFactory')
    @patch('src.ui_interfaces.console_interface.UserInterface')
    def test_main_function_success_flow(
        self,
        mock_ui: Mock,
        mock_storage_factory: Mock,
        mock_app_config: Mock,
        mock_db_manager: Mock
    ) -> None:
        """
        Тест успешного выполнения основной функции
    
        Args:
            mock_ui: Мок пользовательского интерфейса
            mock_storage_factory: Мок фабрики хранилища
            mock_app_config: Мок конфигурации приложения
            mock_db_manager: Мок менеджера базы данных
        """
        # Настройка моков
        mock_db_instance = Mock()
        mock_db_instance.check_connection.return_value = True
        mock_db_instance.get_companies_and_vacancies_count.return_value = [{"name": "Test", "vacancies_count": 10}]
        mock_db_manager.return_value = mock_db_instance
    
        mock_storage_instance = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage_instance
    
        mock_app_config_instance = Mock()
        mock_app_config_instance.default_storage_type = "postgres"
        mock_app_config.return_value = mock_app_config_instance
    
        mock_ui_instance = Mock()
        mock_ui.return_value = mock_ui_instance
    
        # Выполняем функцию
        main()
    
        # Проверяем вызовы
        mock_db_manager.assert_called_once()
        mock_db_instance.check_connection.assert_called_once()
        mock_db_instance.create_tables.assert_called_once()
        mock_db_instance.populate_companies_table.assert_called_once()
>       mock_ui_instance.run.assert_called_once()
E       AssertionError: Expected 'run' to have been called once. Called 0 times.

tests/test_main_module.py:117: AssertionError
------------------------------------- Captured stdout call -------------------------------------

Критическая ошибка: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808662803216'>" for connection option "port"

Обратитесь к разработчику для решения проблемы.
-------------------------------------- Captured log call ---------------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808662803216'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808662803216'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД <Mock name='AppConfig().get_db_config().get()' id='139808662803216'>: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808662803216'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных <Mock name='AppConfig().get_db_config().get()' id='139808662803216'> недоступна и не может быть создана
ERROR    src.user_interface:user_interface.py:67 Критическая ошибка: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808662803216'>" for connection option "port"
_________________ TestUserInterface.test_main_function_initialization_sequence _________________

self = <MagicMock name='StorageFactory.create_storage' id='139808663248656'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'create_storage' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_main_module.TestUserInterface object at 0x7f27bf3fc590>
mock_storage_factory = <MagicMock name='StorageFactory' id='139808676316240'>
mock_app_config = <MagicMock name='AppConfig' id='139808661912080'>
mock_db_manager = <MagicMock name='DBManager' id='139808663241808'>

    @patch('src.storage.db_manager.DBManager')
    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.storage_factory.StorageFactory')
    def test_main_function_initialization_sequence(
        self,
        mock_storage_factory: Mock,
        mock_app_config: Mock,
        mock_db_manager: Mock
    ) -> None:
        """
        Тест последовательности инициализации
    
        Args:
            mock_storage_factory: Мок фабрики хранилища
            mock_app_config: Мок конфигурации приложения
            mock_db_manager: Мок менеджера базы данных
        """
        # Настройка моков
        mock_db_instance = Mock()
        mock_db_instance.check_connection.return_value = True
        mock_db_instance.get_companies_and_vacancies_count.return_value = []
        mock_db_manager.return_value = mock_db_instance
    
        mock_storage_instance = Mock()
        mock_storage_factory.create_storage.return_value = mock_storage_instance
    
        mock_app_config_instance = Mock()
        mock_app_config_instance.default_storage_type = "postgres"
        mock_app_config.return_value = mock_app_config_instance
    
        with patch('src.ui_interfaces.console_interface.UserInterface') as mock_ui:
            mock_ui_instance = Mock()
            mock_ui.return_value = mock_ui_instance
    
            # Выполняем функцию
            main()
    
            # Проверяем последовательность вызовов
            mock_db_manager.assert_called_once()
            mock_app_config.assert_called_once()
>           mock_storage_factory.create_storage.assert_called_once()
E           AssertionError: Expected 'create_storage' to have been called once. Called 0 times.

tests/test_main_module.py:241: AssertionError
------------------------------------- Captured stdout call -------------------------------------

Критическая ошибка: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808676316368'>" for connection option "port"

Обратитесь к разработчику для решения проблемы.
-------------------------------------- Captured log call ---------------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808676316368'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808676316368'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД <Mock name='AppConfig().get_db_config().get()' id='139808676316368'>: invalid integer value "<Mock name='AppConfig().get_db_config().get()' id='139808676316368'>" for connection option "port"

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных <Mock name='AppConfig().get_db_config().get()' id='139808676316368'> недоступна и не может быть создана
__________________________ TestUserInterface.test_module_level_logger __________________________

self = <workspace.tests.test_main_module.TestUserInterface object at 0x7f27bf3fe950>

    def test_module_level_logger(self) -> None:
        """
        Тест логгера модульного уровня
    
        Проверяет что логгер создан корректно
        """
        import src.user_interface
        assert hasattr(src.user_interface, 'logger')
        logger = src.user_interface.logger
>       assert logger.name == 'src.user_interface'
E       AssertionError: assert <MagicMock name='getLogger().name' id='139808666720656'> == 'src.user_interface'
E        +  where <MagicMock name='getLogger().name' id='139808666720656'> = <MagicMock name='getLogger()' id='139808676328016'>.name

tests/test_main_module.py:253: AssertionError
______________ TestMissingComponentsIntegration.test_error_handling_in_components ______________

self = <workspace.tests.test_missing_components.TestMissingComponentsIntegration object at 0x7f27befde350>

    def test_error_handling_in_components(self) -> None:
        """
        Тест обработки ошибок в компонентах
        """
        menu_manager = MenuManager()
        ui_helpers = UIHelpers()
    
        # Тестируем обработку ошибочных данных
        def error_action():
            raise ValueError("Тестовая ошибка")
    
        menu_manager.add_menu_item("Ошибочное действие", error_action)
    
        # Выполнение не должно прерывать работу программы
        try:
            menu_manager.execute_action(1)
        except ValueError:
            pass  # Ошибка ожидаема
    
        # UI helpers должны корректно обрабатывать некорректные данные
>       result1 = ui_helpers.format_currency("invalid", "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_components.py:458: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <workspace.tests.test_missing_components.UIHelpers object at 0x7f27bda16190>
amount = 'invalid', currency = 'RUR'

    def format_currency(self, amount: Optional[float], currency: str = "RUR") -> str:
        """
        Форматирование валюты
    
        Args:
            amount: Сумма для форматирования
            currency: Код валюты
    
        Returns:
            str: Отформатированная строка с валютой
        """
        if amount is None:
            return "Не указано"
    
        currency_symbols = {
            "RUR": "₽",
            "USD": "$",
            "EUR": "€"
        }
    
        symbol = currency_symbols.get(currency, currency)
>       return f"{amount:,.0f} {symbol}"
               ^^^^^^^^^^^^^^^^^^^^^^^^^
E       ValueError: Unknown format code 'f' for object of type 'str'

tests/test_missing_components.py:99: ValueError
________________________ TestVacancyStats.test_vacancies_without_salary ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be701390>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdb95d50>

    def test_vacancies_without_salary(self, vacancy_stats: VacancyStats) -> None:
        """Тест обработки вакансий без зарплаты"""
        # Создаем вакансию без зарплаты
        vacancy_no_salary = Vacancy(
            title="Developer",
            vacancy_id="1",
            url="https://example.com/1",
            source="hh.ru",
            employer={"name": "Company1"},
            salary=None,
            description="Job description"
        )
    
        vacancies = [vacancy_no_salary]
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdb95d50>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f27bdbed4a0>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
________________________ TestVacancyStats.test_salary_range_calculation ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be7019d0>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27be767c50>

    def test_salary_range_calculation(self, vacancy_stats: VacancyStats) -> None:
        """Тест расчета диапазона зарплат"""
        # Создаем вакансию с диапазоном зарплат - используем правильный конструктор
>       salary = Salary.from_range(50000, 100000, "RUR")
                 ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:164: AttributeError
___________________________ TestVacancyStats.test_mixed_salary_types ___________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be702010>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdad65d0>

    def test_mixed_salary_types(self, vacancy_stats: VacancyStats) -> None:
        """Тест обработки различных типов зарплат"""
        vacancies = []
    
        # Вакансия с полным диапазоном - используем правильный конструктор
>       salary1 = Salary.from_range(80000, 120000, "RUR")
                  ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:189: AttributeError
______________ TestVacancyStats.test_salary_statistics_with_different_currencies _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be702650>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27be700dd0>

    def test_salary_statistics_with_different_currencies(self, vacancy_stats: VacancyStats) -> None:
        """Тест статистики с различными валютами"""
        vacancies = []
    
        # Вакансия в рублях - используем правильный конструктор
>       salary_rur = Salary.from_range(100000, 150000, "RUR")
                     ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:243: AttributeError
________________ TestVacancyStats.test_calculate_salary_statistics_performance _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be7032d0>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdafa6d0>

    def test_calculate_salary_statistics_performance(self, vacancy_stats: VacancyStats) -> None:
        """Тест производительности расчета статистики"""
        import time
    
        # Создаем большое количество вакансий - используем правильный конструктор
        large_vacancy_list = []
        for i in range(100):
>           salary = Salary.from_range(50000 + i * 1000, 100000 + i * 1000, "RUR")
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:283: AttributeError
_______________________ TestVacancyStats.test_salary_statistics_detailed _______________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be708090>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdac5cd0>

    def test_salary_statistics_detailed(self, vacancy_stats: VacancyStats) -> None:
        """Тест детальной статистики зарплат"""
        # Создаем вакансии с известными зарплатами для проверки расчетов
        vacancies = []
    
        # Вакансии с конкретными зарплатами
        salaries_data = [
            (100000, 150000),  # средняя: 125000
            (200000, 250000),  # средняя: 225000
            (80000, 120000),   # средняя: 100000
        ]
    
        for i, (min_sal, max_sal) in enumerate(salaries_data):
>           salary = Salary.from_range(min_sal, max_sal, "RUR")
                     ^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:333: AttributeError
______________________ TestVacancyStats.test_salary_statistics_formatting ______________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f27be708790>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdb54350>

    def test_salary_statistics_formatting(self, vacancy_stats: VacancyStats) -> None:
        """Тест форматирования результатов статистики"""
        # Создаем простую вакансию для тестирования
>       salary = Salary.from_range(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_range'

tests/test_vacancy_stats.py:358: AttributeError
______________ TestVacancyStatsFixed.test_calculate_salary_statistics_no_salaries ______________

self = <workspace.tests.test_vacancy_stats_fixed.TestVacancyStatsFixed object at 0x7f27be700c10>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdbdf810>

    def test_calculate_salary_statistics_no_salaries(self, vacancy_stats: VacancyStats) -> None:
        """
        Тест расчета статистики для вакансий без зарплат
    
        Args:
            vacancy_stats: Экземпляр класса статистики
        """
        # Создаем вакансии без зарплат
        vacancies = [
            Vacancy(
                title="Developer",
                vacancy_id="1",
                url="https://example.com/1",
                source="hh.ru",
                salary=None
            )
        ]
    
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats_fixed.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdbdf810>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f27bdbe76c0>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
_____________________ TestVacancyStatsFixed.test_vacancy_stats_performance _____________________

self = <workspace.tests.test_vacancy_stats_fixed.TestVacancyStatsFixed object at 0x7f27bebfbe10>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdb324d0>

    def test_vacancy_stats_performance(self, vacancy_stats: VacancyStats) -> None:
        """
        Тест производительности расчета статистики
    
        Args:
            vacancy_stats: Экземпляр класса статистики
        """
        import time
    
        # Создаем большое количество вакансий
        vacancies = []
        for i in range(100):
            vacancy = Vacancy(
                title=f"Developer {i}",
                vacancy_id=str(i),
                url=f"https://example.com/{i}",
                source="test",
                salary=None  # Без зарплаты для ускорения
            )
            vacancies.append(vacancy)
    
        start_time = time.time()
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats_fixed.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f27bdb324d0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f27be6124e0>, <src.vacancies.models.Vacancy object at 0x7f27be6118b0>, <sr... <src.vacancies.models.Vacancy object at 0x7f27be612410>, <src.vacancies.models.Vacancy object at 0x7f27be6121a0>, ...]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
=================================== short test summary info ====================================
FAILED tests/test_complete_module_coverage.py::TestCompleteModuleCoverage::test_vacancy_model_comprehensive - AttributeError: 'Salary' object has no attribute 'get'
FAILED tests/test_complete_module_coverage.py::TestCompleteModuleCoverage::test_comprehensive_type_checking - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_complete_module_coverage.py::TestCompleteModuleCoverage::test_integration_with_mocked_dependencies - AssertionError: Expected 'AppConfig' to have been called.
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_methods_call_db_manager - AssertionError: assert False
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_individual_methods - AssertionError: Метод get_companies_and_vacancies_count не был вызван
FAILED tests/test_extended_coverage.py::TestAdvancedCoverage::test_module_interoperability - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_extended_coverage.py::TestAdvancedCoverage::test_configuration_coverage - AssertionError: assert (typing.Dict is None or False)
FAILED tests/test_full_src_coverage.py::TestFullSrcCoverage::test_comprehensive_method_calls - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_main_module.py::TestMainModule::test_main_module_execution - AttributeError: module 'main' has no attribute 'main'
FAILED tests/test_main_module.py::TestUserInterface::test_main_function_success_flow - AssertionError: Expected 'run' to have been called once. Called 0 times.
FAILED tests/test_main_module.py::TestUserInterface::test_main_function_initialization_sequence - AssertionError: Expected 'create_storage' to have been called once. Called 0 times.
FAILED tests/test_main_module.py::TestUserInterface::test_module_level_logger - AssertionError: assert <MagicMock name='getLogger().name' id='139808666720656'> == 'src.use...
FAILED tests/test_missing_components.py::TestMissingComponentsIntegration::test_error_handling_in_components - ValueError: Unknown format code 'f' for object of type 'str'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_vacancies_without_salary - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_salary_range_calculation - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_mixed_salary_types - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_salary_statistics_with_different_currencies - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_calculate_salary_statistics_performance - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_salary_statistics_detailed - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_salary_statistics_formatting - AttributeError: type object 'Salary' has no attribute 'from_range'
FAILED tests/test_vacancy_stats_fixed.py::TestVacancyStatsFixed::test_calculate_salary_statistics_no_salaries - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_vacancy_stats_fixed.py::TestVacancyStatsFixed::test_vacancy_stats_performance - AttributeError: 'Salary' object has no attribute 'from_amount'
ERROR tests/test_extended_coverage.py::TestVacancyStatsExtended::test_salary_statistics - TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'
ERROR tests/test_extended_coverage.py::TestVacancyStatsExtended::test_experience_distribution - TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'
ERROR tests/test_extended_coverage.py::TestVacancyStatsExtended::test_employment_distribution - TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'
ERROR tests/test_extended_coverage.py::TestVacancyStatsExtended::test_area_distribution - TypeError: Salary.__init__() got an unexpected keyword argument 'amount_from'
ERROR tests/test_extended_coverage.py::TestMenuManagerExtended::test_add_menu_item - NameError: name 'MenuManager' is not defined
ERROR tests/test_extended_coverage.py::TestMenuManagerExtended::test_execute_action - NameError: name 'MenuManager' is not defined
ERROR tests/test_extended_coverage.py::TestMenuManagerExtended::test_show_menu - NameError: name 'MenuManager' is not defined
ERROR tests/test_extended_coverage.py::TestMenuManagerExtended::test_clear_menu - NameError: name 'MenuManager' is not defined
ERROR tests/test_extended_coverage.py::TestUIHelpersExtended::test_format_currency - NameError: name 'UIHelpers' is not defined
ERROR tests/test_extended_coverage.py::TestUIHelpersExtended::test_format_experience - NameError: name 'UIHelpers' is not defined
ERROR tests/test_extended_coverage.py::TestUIHelpersExtended::test_truncate_text - NameError: name 'UIHelpers' is not defined
ERROR tests/test_extended_coverage.py::TestUIHelpersExtended::test_format_date - NameError: name 'UIHelpers' is not defined
ERROR tests/test_user_interface_comprehensive.py::TestUserInterfaceComprehensive::test_run_advanced_search - AttributeError: type object 'Salary' has no attribute 'from_range'