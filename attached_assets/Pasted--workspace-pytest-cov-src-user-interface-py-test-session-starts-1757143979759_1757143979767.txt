~/workspace$ pytest --cov=src/user_interface.py
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1832 items                                                               

tests/test_abstract.py ........                                              [  0%]
tests/test_abstract_db_manager.py ....                                       [  0%]
tests/test_abstract_filter_complete.py .........                             [  1%]
tests/test_api_complete.py ...................                               [  2%]
tests/test_api_config.py ....                                                [  2%]
tests/test_api_data_filter.py ......                                         [  2%]
tests/test_api_fixes.py .......                                              [  3%]
tests/test_api_modules.py ............................                       [  4%]
tests/test_api_modules_consolidated.py ....                                  [  4%]
tests/test_api_modules_coverage.py .FF...F............                       [  5%]
tests/test_app_config.py .........                                           [  6%]
tests/test_base_api.py ...............                                       [  7%]
tests/test_base_formatter.py ..........                                      [  7%]
tests/test_base_formatter_complete.py ..............................         [  9%]
tests/test_base_parser.py ......                                             [  9%]
tests/test_cache.py ......................                                   [ 10%]
tests/test_cached_api.py ....                                                [ 11%]
tests/test_cached_api_complete.py ................                           [ 12%]
tests/test_components_fixed.py ...                                           [ 12%]
tests/test_comprehensive_fixed.py .....                                      [ 12%]
tests/test_comprehensive_missing_coverage.py F...E..FFFFF.F................. [ 14%]
.........                                                                    [ 14%]
tests/test_config_consolidated.py .....                                      [ 14%]
tests/test_config_missing_coverage.py .....sssss.............ss...           [ 16%]
tests/test_config_modules_consolidated.py ......                             [ 16%]
tests/test_config_modules_coverage.py ...................FFF..........       [ 18%]
tests/test_console_interface.py ......                                       [ 18%]
tests/test_console_interface_coverage.py ..................                  [ 19%]
tests/test_core_functionality_consolidated.py .....                          [ 20%]
tests/test_core_modules_comprehensive.py ........                            [ 20%]
tests/test_data_normalizers_comprehensive.py ............................    [ 22%]
tests/test_database_connection.py ........                                   [ 22%]
tests/test_db_config.py .....                                                [ 22%]
tests/test_db_manager.py .................                                   [ 23%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                           [ 24%]
tests/test_decorators.py .......                                             [ 24%]
tests/test_description_parser.py ..........                                  [ 25%]
tests/test_env_loader.py ................                                    [ 26%]
tests/test_filter_utils.py ......                                            [ 26%]
tests/test_final_coverage_fixes.py EEF...................                    [ 27%]
tests/test_formatters_coverage.py ...........................                [ 29%]
tests/test_get_api_complete.py ....................                          [ 30%]
tests/test_hh_api_complete.py .................                              [ 31%]
tests/test_hh_api_config.py .....                                            [ 31%]
tests/test_hh_parser.py ........                                             [ 32%]
tests/test_integration.py .............                                      [ 32%]
tests/test_interfaces.py .ss                                                 [ 32%]
tests/test_interfaces_coverage.py ................................           [ 34%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F......FF  [ 36%]
tests/test_main_application_interface.py ...                                 [ 36%]
tests/test_main_application_interface_complete.py .......................... [ 37%]
.................                                                            [ 38%]
tests/test_main_consolidated.py .........                                    [ 39%]
tests/test_menu_manager.py ..........                                        [ 39%]
tests/test_missing_components.py .........                                   [ 40%]
tests/test_missing_coverage_components.py ..............F..                  [ 41%]
tests/test_missing_coverage_extended.py ...........EEEEEE...........F....... [ 43%]
..............FFF...                                                         [ 44%]
tests/test_models_coverage.py ...........................                    [ 45%]
tests/test_models_fixed.py ...                                               [ 46%]
tests/test_paginator.py ......                                               [ 46%]
tests/test_parsers_complete.py ............                                  [ 47%]
tests/test_parsers_coverage.py .............................                 [ 48%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                     [ 49%]
tests/test_real_components_coverage.py ......EEEEFE......F.                  [ 50%]
tests/test_repository_fixed.py ..                                            [ 50%]
tests/test_salary_fixed.py ...........                                       [ 51%]
tests/test_salary_utils.py ......................                            [ 52%]
tests/test_search_utils.py ............................                      [ 54%]
tests/test_search_utils_complete.py ........................................ [ 56%]
......                                                                       [ 56%]
tests/test_services_consolidated.py ....                                     [ 56%]
tests/test_services_coverage.py .......FEEEE................                 [ 58%]
tests/test_services_storage_consolidated.py ..........                       [ 58%]
tests/test_simple_db_adapter.py .........                                    [ 59%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                             [ 60%]
tests/test_sj_api.py ..............                                          [ 61%]
tests/test_sj_api_complete.py .............F....                             [ 62%]
tests/test_sj_api_config.py .....                                            [ 62%]
tests/test_sj_parser.py ........                                             [ 62%]
tests/test_sj_parser_complete.py ..............                              [ 63%]
tests/test_source_manager.py .................                               [ 64%]
tests/test_source_selector.py .................                              [ 65%]
tests/test_storage_abstractions.py ........                                  [ 65%]
tests/test_storage_abstractions_coverage.py ......EE                         [ 66%]
tests/test_storage_complete.py .............                                 [ 66%]
tests/test_storage_components_complete.py ......F....FF...............F      [ 68%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF        [ 69%]
tests/test_storage_factory.py ........                                       [ 70%]
tests/test_storage_modules_consolidated.py ....                              [ 70%]
tests/test_target_companies.py .....                                         [ 70%]
tests/test_typed_data_processor.py ................                          [ 71%]
tests/test_ui_components_complete.py ......................................  [ 73%]
tests/test_ui_components_extended.py ..................                      [ 74%]
tests/test_ui_config.py .......................                              [ 76%]
tests/test_ui_helpers_comprehensive.py ..................................... [ 78%]
..                                                                           [ 78%]
tests/test_ui_helpers_extended.py ........................................   [ 80%]
tests/test_ui_modules_consolidated.py .....                                  [ 80%]
tests/test_ui_navigation.py ......................                           [ 81%]
tests/test_ui_navigation_complete.py ..s..                                   [ 82%]
tests/test_ui_navigation_comprehensive.py ......                             [ 82%]
tests/test_ui_navigation_extended.py .......F...........................     [ 84%]
tests/test_unified_api.py ................F...F.                             [ 85%]
tests/test_unified_api_complete.py ......F......................             [ 87%]
tests/test_unified_api_fixed.py ...                                          [ 87%]
tests/test_user_interface.py ...............                                 [ 88%]
tests/test_user_interface_consolidated.py F.F                                [ 88%]
tests/test_user_interface_coverage.py .........                              [ 88%]
tests/test_user_interface_fixed.py ...                                       [ 88%]
tests/test_utils_consolidated.py .....                                       [ 89%]
tests/test_utils_coverage.py .............................                   [ 90%]
tests/test_utils_ui_consolidated.py ......                                   [ 91%]
tests/test_vacancy_abstractions.py .................                         [ 92%]
tests/test_vacancy_display_handler.py ...................                    [ 93%]
tests/test_vacancy_formatter.py ........                                     [ 93%]
tests/test_vacancy_models_complete.py ....                                   [ 93%]
tests/test_vacancy_models_consolidated.py ....                               [ 93%]
tests/test_vacancy_operations.py ......                                      [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................     [ 95%]
tests/test_vacancy_operations_coordinator_complete.py ...................... [ 96%]
                                                                             [ 96%]
tests/test_vacancy_processing_coordinator.py .............                   [ 97%]
tests/test_vacancy_repository.py .........                                   [ 98%]
tests/test_vacancy_stats.py ............                                     [ 98%]
tests/test_vacancy_stats_fixed.py .........                                  [ 99%]
tests/test_vacancy_validator.py ............/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/coverage/inorout.py:521: CoverageWarning: Module src/user_interface.py was never imported. (module-not-imported)
  self.warn(f"Module {pkg} was never imported.", slug="module-not-imported")
/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/coverage/control.py:945: CoverageWarning: No data was collected. (no-data-collected)
  self._warn("No data was collected.", slug="no-data-collected")

WARNING: Failed to generate report: No data to report.

/home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/pytest_cov/plugin.py:358: CovReportWarning: Failed to generate report: No data to report.

  warnings.warn(CovReportWarning(message), stacklevel=1)
                                                                             [100%]

====================================== ERRORS ======================================
__ ERROR at setup of TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fd907823e50>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        from src.vacancies.models import Vacancy, Employer
        from src.utils.salary import Salary
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(from_amount=100000, to_amount=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'

tests/test_comprehensive_missing_coverage.py:164: TypeError
_ ERROR at setup of TestPostgresSaverFinalFixes.test_is_vacancy_exists_with_real_vacancy _

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fd90752c410>

    @pytest.fixture
    def mock_vacancy(self):
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return Mock()
    
        # Создаем реальный объект Vacancy
        employer = Employer(name="Test Company", employer_id="comp123")
        # Используем правильные параметры для Salary
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_final_coverage_fixes.py:80: TypeError
___ ERROR at setup of TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ___

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fd90752cf10>

    @pytest.fixture
    def mock_vacancy(self):
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return Mock()
    
        # Создаем реальный объект Vacancy
        employer = Employer(name="Test Company", employer_id="comp123")
        # Используем правильные параметры для Salary
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_final_coverage_fixes.py:80: TypeError
______ ERROR at setup of TestPaginatorCoverage.test_paginator_initialization _______

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073cd610>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_get_current_page ___________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073cdd50>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
______________ ERROR at setup of TestPaginatorCoverage.test_next_page ______________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073ce450>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_previous_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073ceb90>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_has_next_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073cf290>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_has_previous_page __________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7fd9073cf990>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
_ ERROR at setup of TestPostgresSaverRealInterface.test_is_vacancy_exists_with_vacancy_object _

self = <tests.test_real_components_coverage.TestPostgresSaverRealInterface object at 0x7fd907158190>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        if not MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            mock.salary = None
            return mock
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_real_components_coverage.py:161: TypeError
_ ERROR at setup of TestPostgresSaverRealInterface.test_delete_vacancy_with_vacancy_object _

self = <tests.test_real_components_coverage.TestPostgresSaverRealInterface object at 0x7fd907158910>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        if not MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            mock.salary = None
            return mock
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_real_components_coverage.py:161: TypeError
_______ ERROR at setup of TestFileCacheRealMethods.test_cache_key_generation _______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fd90714f810>
temp_cache_dir = '/tmp/tmpaoingrfc'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_______ ERROR at setup of TestFileCacheRealMethods.test_save_and_load_cycle ________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fd90714d6d0>
temp_cache_dir = '/tmp/tmp_obl079a'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
______ ERROR at setup of TestFileCacheRealMethods.test_invalid_cache_handling ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fd90714ccd0>
temp_cache_dir = '/tmp/tmp4axnr01w'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_remove_duplicates_by_url _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7fd9072cc5d0>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_remove_duplicates_by_title_company _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7fd9072cff50>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_____ ERROR at setup of TestDeduplicationServiceCoverage.test_find_duplicates ______

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7fd9072cc210>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_statistics _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7fd9072cc590>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_ ERROR at setup of TestVacancyModelIntegration.test_storage_with_real_vacancy_objects _

self = <tests.test_storage_abstractions_coverage.TestVacancyModelIntegration object at 0x7fd907112290>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для создания mock вакансии"""
        if not VACANCY_MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            return mock
    
        # Создаем реальную вакансию для тестов
        employer = Employer(name="Test Company", employer_id="comp123")
    
        # Создаем зарплату с правильными параметрами
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_storage_abstractions_coverage.py:266: TypeError
_ ERROR at setup of TestVacancyModelIntegration.test_db_manager_with_vacancy_filtering _

self = <tests.test_storage_abstractions_coverage.TestVacancyModelIntegration object at 0x7fd907112950>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для создания mock вакансии"""
        if not VACANCY_MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            return mock
    
        # Создаем реальную вакансию для тестов
        employer = Employer(name="Test Company", employer_id="comp123")
    
        # Создаем зарплату с правильными параметрами
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_storage_abstractions_coverage.py:266: TypeError
===================================== FAILURES =====================================
____________ TestUnifiedAPICoverage.test_get_vacancies_from_all_sources ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fd9078fba90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd906df3a10>

    def test_get_vacancies_from_all_sources(self, unified_api):
        """Тест получения вакансий из всех источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Настраиваем моки для возврата данных
>       unified_api.hh_api.get_vacancies.return_value = [
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            {'id': '1', 'title': 'Python Dev', 'source': 'hh'},
            {'id': '2', 'title': 'Java Dev', 'source': 'hh'}
        ]
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:57: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestUnifiedAPICoverage.test_search_with_filters __________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fd9079041d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd906e039d0>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
>       unified_api.hh_api.get_vacancies.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:80: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICoverage.test_error_handling_api_failures ______________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fd907905e10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd906e32b10>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:156: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success _______

self = <Mock name='mock.execute' id='140570081855888'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7fd907823090>
mock_connect = <MagicMock name='connect' id='140570099938448'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906dfb1d0>
mock_connection = (<Mock name='connect()' id='140570090172496'>, <Mock id='140570090164752'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_true _______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fd907828ed0>
mock_connect = <MagicMock name='connect' id='140570089855248'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905beb2d0>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_true(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (1,)
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('test123')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905beb2d0>
vacancy = 'test123'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_false ______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7fd907829490>
mock_connect = <MagicMock name='connect' id='140570089382480'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9063db610>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_false(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - не существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = None
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('nonexistent')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9063db610>
vacancy = 'nonexistent'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
_________________ TestSimpleDBAdapterCoverage.test_initialization __________________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907829dd0>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906dc1790>

    def test_initialization(self, db_adapter):
        """Тест инициализации SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        assert db_adapter is not None
>       assert hasattr(db_adapter, 'save_vacancies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906dc1790>, 'save_vacancies')

tests/test_comprehensive_missing_coverage.py:296: AssertionError
____________ TestSimpleDBAdapterCoverage.test_save_vacancies_empty_list ____________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7fd90782a490>
mock_run = <MagicMock name='run' id='140570081819536'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905caf190>

    @patch('subprocess.run')
    def test_save_vacancies_empty_list(self, mock_run, db_adapter):
        """Тест сохранения пустого списка вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       result = db_adapter.save_vacancies([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'

tests/test_comprehensive_missing_coverage.py:304: AttributeError
__________________ TestCacheCoverage.test_save_and_load_response ___________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7fd90782ae10>
cache = <src.utils.cache.FileCache object at 0x7fd906473610>

    def test_save_and_load_response(self, cache):
        """Тест сохранения и загрузки ответа"""
        if not CACHE_AVAILABLE:
            return
    
        data = {"items": [{"id": "1", "name": "Test"}], "found": 1}
        params = {"query": "python", "page": 0}
    
        # Сначала сохраняем данные
        cache.save_response("hh", params, data)
    
        # Затем загружаем
        loaded_data = cache.load_response("hh", params)
    
>       assert loaded_data is not None
E       assert None is not None

tests/test_comprehensive_missing_coverage.py:335: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmp4klp3mun/hh_706f9072b3b7694d22a2ab464b8a25aa.json'
____________________ TestCacheCoverage.test_clear_cache_method _____________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7fd90782bc90>
cache = <src.utils.cache.FileCache object at 0x7fd905be1150>

    def test_clear_cache_method(self, cache):
        """Тест очистки кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем несколько файлов кэша
        cache.save_response("hh", {"query": "test1"}, {"data": 1})
        cache.save_response("hh", {"query": "test2"}, {"data": 2})
    
        # Очищаем кэш
>       cache.clear_cache()
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'clear_cache'

tests/test_comprehensive_missing_coverage.py:357: AttributeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpd_a_dkg6/hh_0bb438ddfe366eb2b5cd8d8bf3fba2c3.json'
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpd_a_dkg6/hh_b1a5cf751caed3a23aae5e87e985cb3a.json'
_____________________ TestSJAPIConfigCoverage.test_get_api_key _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fd90769d9d0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
____________________ TestSJAPIConfigCoverage.test_get_base_url _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fd90769e010>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_________________ TestSJAPIConfigCoverage.test_get_request_headers _________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fd90769e690>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
________________ TestDBManagerCoverage.test_create_database_schema _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907550b50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd905ff4490>
mock_connection = (<Mock id='140570085244240'>, <Mock name='mock.cursor()' id='140570085230352'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
___________________ TestDBManagerCoverage.test_save_company_data ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd9075512d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd907929e50>
mock_connection = (<Mock id='140570099454800'>, <Mock name='mock.cursor()' id='140570099456656'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
______________ TestDBManagerCoverage.test_save_vacancy_comprehensive _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907551a50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd907804050>
mock_connection = (<Mock id='140570103445968'>, <Mock name='mock.cursor()' id='140570103437200'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
_________________ TestDBManagerCoverage.test_bulk_save_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd90773f990>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906431190>
mock_connection = (<Mock id='140570080046608'>, <Mock name='mock.cursor()' id='140570105042192'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
___________________ TestDBManagerCoverage.test_query_operations ____________________

self = <Mock name='mock.cursor().execute' id='140570081247376'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907551750>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906430e50>
mock_connection = (<Mock id='140570089699792'>, <Mock name='mock.cursor()' id='140570089692432'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570079997776'>, исправляем...
_________________ TestDBManagerCoverage.test_search_functionality __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907551d90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd9063e6450>
mock_connection = (<Mock id='140570089376144'>, <Mock name='mock.cursor()' id='140570089384272'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
___________________ TestDBManagerCoverage.test_filter_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd9075521d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd905f86dd0>
mock_connection = (<Mock id='140570109363024'>, <Mock name='mock.cursor()' id='140570109377040'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
________________ TestDBManagerCoverage.test_aggregation_operations _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd9075525d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906dcc0d0>
mock_connection = (<Mock id='140570099765392'>, <Mock name='mock.cursor()' id='140570099773200'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
___________________ TestDBManagerCoverage.test_update_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907552a10>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd90648c3d0>
mock_connection = (<Mock id='140570090066000'>, <Mock name='mock.cursor()' id='140570090062672'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
___________________ TestDBManagerCoverage.test_delete_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907552e50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd9076f7e10>
mock_connection = (<Mock id='140570109378320'>, <Mock name='mock.cursor()' id='140570109378000'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
________________ TestDBManagerCoverage.test_transaction_management _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fd907553450>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd905b7b2d0>
mock_connection = (<Mock id='140570080551504'>, <Mock name='mock.cursor()' id='140570080548688'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
_____________ TestPostgresSaverFinalFixes.test_vacancy_type_validation _____________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7fd90752d910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905c08b50>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905c08b50>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
____________ TestDBManagerFixed.test_get_companies_and_vacancies_count _____________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761fb10>
mock_connect = <MagicMock name='connect' id='140570085773136'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906075a50>
mock_connection = (<Mock name='connect()' id='140570085775376'>, <Mock id='140570085775248'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
____________________ TestDBManagerFixed.test_get_all_vacancies _____________________

self = <Mock name='mock.execute' id='140570085329360'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761de50>
mock_connect = <MagicMock name='connect' id='140570085781968'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd9060778d0>
mock_connection = (<Mock name='connect()' id='140570085783376'>, <Mock id='140570085776656'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570086124624'>, исправляем...
______________________ TestDBManagerFixed.test_get_avg_salary ______________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761d790>
mock_connect = <MagicMock name='connect' id='140570084867856'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd907bcdf10>
mock_connection = (<Mock name='connect()' id='140570084865808'>, <Mock id='140570084867408'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570106283728'>, исправляем...
_____________ TestDBManagerFixed.test_get_vacancies_with_higher_salary _____________

self = <Mock name='mock.execute' id='140570089727056'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761de90>
mock_connect = <MagicMock name='connect' id='140570115673040'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd907bcd810>
mock_connection = (<Mock name='connect()' id='140570080035472'>, <Mock id='140570080038928'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570099928720'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570089675856'>, исправляем...
________________ TestDBManagerFixed.test_get_vacancies_with_keyword ________________

self = <Mock name='mock.execute' id='140570086344336'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761e310>
mock_connect = <MagicMock name='connect' id='140570081778512'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd906e04990>
mock_connection = (<Mock name='connect()' id='140570100002448'>, <Mock id='140570099993232'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570085388944'>, исправляем...
____________________ TestDBManagerFixed.test_get_database_stats ____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fd90761e790>
mock_connect = <MagicMock name='connect' id='140570081749904'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fd905c9e2d0>
mock_connection = (<Mock name='connect()' id='140570081747728'>, <Mock id='140570081750160'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570080451408'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_______ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects _______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fd90761c750>
mock_connect = <MagicMock name='connect' id='140570085313872'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd907bcd210>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fd905fcb110>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd907bcd210>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fd905fcb110>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________________ TestPostgresSaverFixed.test_delete_vacancy_by_id _________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fd90746c050>
mock_connect = <MagicMock name='connect' id='140570085240720'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905feddd0>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905feddd0>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count __________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fd90746d350>
mock_connect = <MagicMock name='connect' id='140570081525328'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fe97d0>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
_________________ TestSimpleDBAdapterFixed.test_get_all_vacancies __________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fd90746da50>
mock_connect = <MagicMock name='connect' id='140570085334480'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906009d10>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
_____________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword _____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fd90746e210>
mock_connect = <MagicMock name='connect' id='140570080538192'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905b75690>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
________________ TestSimpleDBAdapterFixed.test_init_database_schema ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fd90746dfd0>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fe87d0>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905fee090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fe87d0> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIModulesFixed.test_hh_api_methods_coverage _________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fd9075d63d0>
mock_get = <MagicMock name='get' id='140570086219472'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
_____________ TestAPIModulesFixed.test_cached_api_basic_functionality ______________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fd9075d7410>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
_____________________ TestEdgeCasesFixed.test_db_empty_results _____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fd90734d5d0>
mock_connect = <MagicMock name='connect' id='140570085380624'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570082634448'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140570084597904'>, исправляем...
________________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fd90734d090>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
_______________ TestLowCoverageComponents.test_api_methods_coverage ________________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7fd907387b50>
mock_get = <MagicMock name='get' id='140570081449552'>

    @patch('requests.get')
    def test_api_methods_coverage(self, mock_get):
        """Тест покрытия методов API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
            from src.api_modules.sj_api import SuperJobAPI
    
            # Тестируем HeadHunter API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
                assert isinstance(result, (dict, list))
    
            # Тестируем SuperJob API
            sj_api = SuperJobAPI()
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:374: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestVacancyFormatterCoverage.test_format_salary __________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7fd9073d2e90>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7fd905cec690>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:537: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_display_handler_display ___________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fd9073e6590>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:824: TypeError
___________ TestUIInterfacesCoverage.test_vacancy_search_handler_search ____________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fd9073e6bd0>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:835: TypeError
_____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ______

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7fd9073e71d0>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____________ TestPostgresSaverCoverage.test_database_connection_methods ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90724b750>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905c4e410>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
_______________ TestPostgresSaverCoverage.test_create_tables_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90724bdd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd90602a290>
mock_connection = (<Mock id='140570085467344'>, <Mock name='mock.cursor()' id='140570085464464'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
________________ TestPostgresSaverCoverage.test_save_vacancy_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd9072584d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905c4fb50>
mock_connection = (<Mock id='140570085467664'>, <Mock name='mock.cursor()' id='140570085469776'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
______________ TestPostgresSaverCoverage.test_save_multiple_vacancies ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd907258b50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905b60d90>
mock_connection = (<Mock id='140570085460112'>, <Mock name='mock.cursor()' id='140570085469200'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140570089702096'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140570089702096'> = <Mock name='mock.cursor()' id='140570085469200'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
_______________ TestPostgresSaverCoverage.test_get_vacancies_method ________________

self = <Mock name='mock.cursor().execute' id='140570082504400'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd9072591d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd90607f810>
mock_connection = (<Mock id='140570085806736'>, <Mock name='mock.cursor()' id='140570085805584'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
____________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd907259850>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9060f3650>
mock_connection = (<Mock id='140570086292368'>, <Mock name='mock.cursor()' id='140570086291728'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
______________ TestPostgresSaverCoverage.test_filter_by_salary_range _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd907259ed0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905d01d90>
mock_connection = (<Mock id='140570082155728'>, <Mock name='mock.cursor()' id='140570082155472'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
_______________ TestPostgresSaverCoverage.test_get_companies_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725a550>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9061f7b50>
mock_connection = (<Mock id='140570087355600'>, <Mock name='mock.cursor()' id='140570087354640'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_______________ TestPostgresSaverCoverage.test_delete_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725ab90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905d0a610>
mock_connection = (<Mock id='140570082182608'>, <Mock name='mock.cursor()' id='140570082182736'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905d0a610>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
__________________ TestPostgresSaverCoverage.test_clear_all_data ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725b210>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905c7e110>
mock_connection = (<Mock id='140570107116432'>, <Mock name='mock.cursor()' id='140570107116624'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_______________ TestPostgresSaverCoverage.test_get_statistics_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725b890>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9060f9710>
mock_connection = (<Mock id='140570086325712'>, <Mock name='mock.cursor()' id='140570086317072'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
__________________ TestPostgresSaverCoverage.test_export_to_json ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725bf10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd90612ced0>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
_________________ TestPostgresSaverCoverage.test_import_from_json __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd9072545d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905cf7ad0>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
_______________ TestPostgresSaverCoverage.test_transaction_rollback ________________

self = <Mock name='mock.rollback' id='140570070725584'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725afd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905266c90>
mock_connection = (<Mock id='140570087275600'>, <Mock name='mock.cursor()' id='140570071033616'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
_________________ TestPostgresSaverCoverage.test_batch_operations __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fd90725a650>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9051e4510>
mock_connection = (<Mock id='140570070499472'>, <Mock name='mock.cursor()' id='140570070500112'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fd9051e4510>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
__________________ TestFileCacheRealMethods.test_cache_expiration __________________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7fd90714c950>
temp_cache_dir = '/tmp/tmpdbvmqk3n'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш с очень коротким TTL
>       cache = FileCache(cache_dir=temp_cache_dir, ttl_seconds=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:273: TypeError
__________ TestIntegrationWithRealClasses.test_cache_with_api_integration __________

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7fd90714e9d0>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:424: KeyError
____ TestDeduplicationServiceCoverage.test_deduplication_service_initialization ____

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7fd9072afa90>

    def test_deduplication_service_initialization(self):
        """Тест инициализации DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
>       service = DeduplicationService()
                  ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:190: TypeError
_____________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907184710>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd90648f590>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
___________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907184a90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905c5da50>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd9071850d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fb2050>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905fb2f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fb2050> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907185710>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906434ed0>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd9074e7290>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906434ed0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907185d50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905c4f1d0>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905c4d990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905c4f1d0> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907186390>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905ca5dd0>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905ca6410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905ca5dd0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd9071869d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906489750>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd906489110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906489750> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907187010>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906004d90>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd906007450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd906004d90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ________________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907187610>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905e706d0>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905e72110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905e706d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd907187c50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905c5b2d0>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905c41050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905c5b2d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fd9072d42d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fb0610>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905fb1650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905fb0610> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7fd90715f390>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fd905248190>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905b2cfd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7fd9070fd010>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fd905be0f50>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905dc3790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fd905be0f50> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fd9072dd390>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905d046d0>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd905d04690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd905d046d0> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fd9070c8e50>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd90526c310>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd90526c390>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd90526c310> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7fd9070fff90>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='140570080001168'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______ TestVacancyStorageServiceCoverage.test_storage_service_initialization _______

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fd9070b74d0>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
____________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fd9070b7810>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fd905dd2450>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
___________ TestVacancyStorageServiceCoverage.test_search_functionality ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fd9070da290>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fd9052b4290>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_____________ TestVacancyStorageServiceCoverage.test_delete_operations _____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fd9070da790>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fd9061559d0>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
__________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fd9070db4d0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fd905be1d90>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fd9070db950>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fd905beba90>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
____________ TestDeduplicationServiceCoverage.test_identify_duplicates _____________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fd9070d8050>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fd905d00c10>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_____________ TestFilteringServiceCoverage.test_filter_by_salary_range _____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fd9070d93d0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fd905be1210>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_keyword ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fd90709c150>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fd90761e150>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_company ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fd9070db210>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fd905f541d0>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
_______________ TestFilteringServiceCoverage.test_complex_filtering ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fd9070cafd0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fd905c76c90>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
________________ TestVacancyRepositoryCoverage.test_create_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fd90709cb10>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd9061f7e90>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_______________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fd90709cb50>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd905af34d0>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
________________ TestVacancyRepositoryCoverage.test_update_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fd90709ced0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd905db7350>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd905db7350>
vacancy = <Mock id='140570082887952'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140570082893776'>: 'Mock' object does not support the context manager protocol
_______________ TestVacancyRepositoryCoverage.test_get_all_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fd90709dcd0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd90648bf90>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd90648bf90>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
________________ TestVacancyRepositoryCoverage.test_count_vacancies ________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fd90709f5d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fd905be3350>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fd90709e210>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fd906154710>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_required_fields ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fd90708c1d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fd905e66250>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
______________ TestVacancyValidatorCoverage.test_validate_data_types _______________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fd90708c890>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fd905db61d0>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________ TestUINavigationExtended.test_paginate_display_custom_actions ___________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7fd906fa5150>
mock_print = <MagicMock name='print' id='140570087271824'>
mock_input = <MagicMock name='input' id='140570082808720'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='140570087272144'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
__________________ TestUnifiedAPI.test_filter_by_target_companies __________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fd906fd4b10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd90521ef10>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
___________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources ___________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fd906fd6710>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd905d14310>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
______________ TestUnifiedAPIComplete.test_filter_by_target_companies ______________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7fd906fe4e10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fd905b2c150>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestUserInterfaceConsolidated.test_main_interface_complete ____________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fd9070074d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fd907006550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterfaceConsolidated.test_interface_components_integration ________

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fd90700c0d0>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
================================== tests coverage ==================================
_________________ coverage: platform linux, python 3.11.13-final-0 _________________

============================= short test summary info ==============================
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_get_vacancies_from_all_sources - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_search_with_filters - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_error_handling_api_failures - AttributeError: 'method' object has no attribute 'side_effect'
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count_success - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_true - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_false - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_initialization - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_empty_list - AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_save_and_load_response - assert None is not None
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_clear_cache_method - AttributeError: 'FileCache' object has no attribute 'clear_cache'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_base_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_request_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_create_database_schema - AttributeError: 'DBManager' object has no attribute 'create_database_schema'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_company_data - AttributeError: 'DBManager' object has no attribute 'save_company'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_vacancy_comprehensive - AttributeError: 'DBManager' object has no attribute 'save_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_bulk_save_operations - AttributeError: 'DBManager' object has no attribute 'save_companies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_query_operations - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_search_functionality - AttributeError: 'DBManager' object has no attribute 'search_by_keyword'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_filter_operations - AttributeError: 'DBManager' object has no attribute 'filter_by_experience'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_aggregation_operations - AttributeError: 'DBManager' object has no attribute 'count_vacancies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_update_operations - AttributeError: 'DBManager' object has no attribute 'update_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_delete_operations - AttributeError: 'DBManager' object has no attribute 'delete_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_transaction_management - AttributeError: 'DBManager' object has no attribute 'begin_transaction'
FAILED tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_vacancy_type_validation - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_em...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_va...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_k...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_api_methods_coverage - assert False
FAILED tests/test_missing_coverage_extended.py::TestVacancyFormatterCoverage::test_format_salary - TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 ...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_display_handler_display - TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argum...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_search_handler_search - TypeError: VacancySearchHandler.__init__() missing 2 required positional argume...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_operations_coordinator_coordinate - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positiona...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_ke...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_cache_expiration - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'
FAILED tests/test_real_components_coverage.py::TestIntegrationWithRealClasses::test_cache_with_api_integration - KeyError: 'found'
FAILED tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_service_initialization - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have th...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fd905be0...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fd9...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstract...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_v...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_company'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filt...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_required_f...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCo...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_save_vacancies_single_vacancy - TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'
ERROR tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_is_vacancy_exists_with_real_vacancy - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_save_real_vacancy_objects - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_paginator_initialization - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_get_current_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_real_components_coverage.py::TestPostgresSaverRealInterface::test_is_vacancy_exists_with_vacancy_object - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_real_components_coverage.py::TestPostgresSaverRealInterface::test_delete_vacancy_with_vacancy_object - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_cache_key_generation - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_save_and_load_cycle - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'
ERROR tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_invalid_cache_handling - TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_url - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_title_company - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_find_duplicates - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_statistics - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_storage_abstractions_coverage.py::TestVacancyModelIntegration::test_storage_with_real_vacancy_objects - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_storage_abstractions_coverage.py::TestVacancyModelIntegration::test_db_manager_with_vacancy_filtering - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
============= 105 failed, 1697 passed, 10 skipped, 20 errors in 16.71s =============
~/workspace$ 