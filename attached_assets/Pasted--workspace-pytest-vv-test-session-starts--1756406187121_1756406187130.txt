~/workspace$ pytest -vv
============================= test session starts =============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 352 items                                                           

tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_hh_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_sj_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_keywords PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_location PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_experience PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_employment_type PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_company PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_complex_filter_chain PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_empty_filter_results PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_with_empty_data PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_invalid_data_structure PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_api_initialization PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_valid PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_invalid PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_page_success PASSED [  4%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_empty_response PASSED [  4%]
tests/test_api_modules.py::TestHeadHunterAPI::test_empty_response_structure PASSED [  4%]
tests/test_api_modules.py::TestSuperJobAPI::test_api_initialization_with_custom_key PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_valid PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_invalid PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_get_vacancies_page_with_source PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_empty_response_structure PASSED [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_full_range ERROR [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_from_only ERROR [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_to_only ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_none ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_empty_dict ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_rur ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_usd ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_eur ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_unknown ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_truncate ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_short ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_none ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_date_string ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_date_none ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_string ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_none ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_employment_type ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_schedule ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_dict ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_none ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_tags ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_none ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_number_thousands ERROR [ 13%]
tests/test_cache.py::TestFileCache::test_cache_initialization PASSED    [ 13%]
tests/test_cache.py::TestFileCache::test_generate_params_hash PASSED    [ 13%]
tests/test_cache.py::TestFileCache::test_generate_params_hash_different_params PASSED [ 13%]
tests/test_cache.py::TestFileCache::test_save_and_load_response FAILED  [ 14%]
tests/test_cache.py::TestFileCache::test_load_response_nonexistent PASSED [ 14%]
tests/test_cache.py::TestFileCache::test_clear_cache_source FAILED      [ 14%]
tests/test_cache.py::TestFileCache::test_clear_cache_all PASSED         [ 15%]
tests/test_cache.py::TestFileCache::test_cache_with_complex_params FAILED [ 15%]
tests/test_cache.py::TestFileCache::test_cache_file_corrupted PASSED    [ 15%]
tests/test_cache.py::TestFileCache::test_cache_unicode_support FAILED   [ 15%]
tests/test_config.py::TestAppConfig::test_default_initialization PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_get_storage_type PASSED       [ 16%]
tests/test_config.py::TestAppConfig::test_set_storage_type_valid PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_set_storage_type_invalid PASSED [ 17%]
tests/test_config.py::TestAppConfig::test_get_db_config PASSED          [ 17%]
tests/test_config.py::TestAppConfig::test_db_config_from_env PASSED     [ 17%]
tests/test_config.py::TestDatabaseConfig::test_default_initialization SKIPPED [ 17%]
tests/test_config.py::TestDatabaseConfig::test_initialization_with_env PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_get_connection_params PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_get_dsn PASSED           [ 18%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_success PASSED [ 19%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_failure PASSED [ 19%]
tests/test_config.py::TestHHAPIConfig::test_initialization SKIPPED      [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_headers PASSED          [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url PASSED    [ 20%]
tests/test_config.py::TestHHAPIConfig::test_get_employers_url PASSED    [ 20%]
tests/test_config.py::TestHHAPIConfig::test_get_areas_url PASSED        [ 20%]
tests/test_config.py::TestHHAPIConfig::test_get_request_params PASSED   [ 21%]
tests/test_config.py::TestSJAPIConfig::test_initialization PASSED       [ 21%]
tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key PASSED [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key PASSED [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key PASSED [ 22%]
tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url PASSED    [ 22%]
tests/test_config.py::TestSJAPIConfig::test_set_secret_key PASSED       [ 22%]
tests/test_config.py::TestSJAPIConfig::test_is_configured PASSED        [ 23%]
tests/test_config.py::TestSJAPIConfig::test_get_request_params PASSED   [ 23%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED [ 23%]
tests/test_db_manager.py::TestDBManager::test_get_connection_failure PASSED [ 23%]
tests/test_db_manager.py::TestDBManager::test_create_tables_success FAILED [ 24%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table FAILED [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count FAILED [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies FAILED  [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED     [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary FAILED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword FAILED [ 26%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 26%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats PASSED [ 26%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats_error PASSED [ 26%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success FAILED [ 27%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [ 27%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED [ 27%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_initialization PASSED [ 28%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_run_full_demo PASSED [ 28%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_get_db_manager_creation PASSED [ 28%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_display_database_stats PASSED [ 28%]
tests/test_decorators.py::TestDecorators::test_simple_cache_basic_functionality PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_ttl PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_simple_cache_max_size PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_kwargs PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_cache_clear_function PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_cache_info_function PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_env_variables PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_cache_with_complex_arguments FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_load_env_file_exists FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_load_env_file_not_exists FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_valid FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_with_quotes FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_invalid FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_comment FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_set_environment_variable FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable_with_default FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_load_environment_variables FAILED [ 34%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_success FAILED [ 34%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_missing FAILED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_json_data PASSED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_json_data PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_nonexistent_json_file PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_empty_json_file PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_invalid_json_file PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_creates_directory PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_atomic_write_on_error PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_cache_clearing_on_write PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_global_json_handler_instance PASSED [ 37%]
tests/test_file_handlers.py::TestJSONFileHandler::test_caching_behavior PASSED [ 37%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration PASSED [ 37%]
tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration PASSED [ 38%]
tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration PASSED [ 38%]
tests/test_integration.py::TestCacheIntegration::test_cached_api_integration PASSED [ 38%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow PASSED [ 38%]
tests/test_integration.py::TestFullWorkflowIntegration::test_error_handling_integration PASSED [ 39%]
tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration PASSED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_menu_manager_initialization PASSED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_valid FAILED [ 40%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_invalid_then_valid FAILED [ 40%]
tests/test_menu_manager.py::TestMenuManager::test_display_menu_items FAILED [ 40%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_exit FAILED [ 40%]
tests/test_paginator.py::TestPaginator::test_paginator_initialization FAILED [ 41%]
tests/test_paginator.py::TestPaginator::test_get_current_page_data FAILED [ 41%]
tests/test_paginator.py::TestPaginator::test_next_page FAILED           [ 41%]
tests/test_paginator.py::TestPaginator::test_next_page_at_end FAILED    [ 42%]
tests/test_paginator.py::TestPaginator::test_previous_page FAILED       [ 42%]
tests/test_paginator.py::TestPaginator::test_previous_page_at_start FAILED [ 42%]
tests/test_paginator.py::TestPaginator::test_go_to_page_valid FAILED    [ 42%]
tests/test_paginator.py::TestPaginator::test_go_to_page_invalid FAILED  [ 43%]
tests/test_paginator.py::TestPaginator::test_empty_data FAILED          [ 43%]
tests/test_paginator.py::TestPaginator::test_single_page_data FAILED    [ 43%]
tests/test_paginator.py::TestPaginator::test_page_info FAILED           [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_full_data PASSED [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_minimal_data PASSED [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_no_salary PASSED [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_company_data FAILED     [ 45%]
tests/test_parsers.py::TestHHParser::test_parse_companies_list FAILED   [ 45%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_full_data PASSED [ 45%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_minimal_data PASSED [ 46%]
tests/test_parsers.py::TestSuperJobParser::test_parse_companies_list FAILED [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_initialization ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_success ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_empty_list ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_database_error ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_all_vacancies ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_count ERROR [ 48%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success ERROR [ 48%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found ERROR [ 48%]
tests/test_postgres_saver.py::TestPostgresSaver::test_filter_vacancies_by_salary ERROR [ 48%]
tests/test_postgres_saver.py::TestPostgresSaver::test_search_vacancies_by_keyword ERROR [ 49%]
tests/test_salary.py::TestSalary::test_salary_initialization_with_range FAILED [ 49%]
tests/test_salary.py::TestSalary::test_salary_initialization_from_only FAILED [ 49%]
tests/test_salary.py::TestSalary::test_salary_initialization_to_only FAILED [ 50%]
tests/test_salary.py::TestSalary::test_salary_initialization_none_values FAILED [ 50%]
tests/test_salary.py::TestSalary::test_salary_from_dict_complete FAILED [ 50%]
tests/test_salary.py::TestSalary::test_salary_from_dict_partial FAILED  [ 50%]
tests/test_salary.py::TestSalary::test_salary_from_dict_none FAILED     [ 51%]
tests/test_salary.py::TestSalary::test_salary_from_dict_empty FAILED    [ 51%]
tests/test_salary.py::TestSalary::test_salary_to_dict FAILED            [ 51%]
tests/test_salary.py::TestSalary::test_salary_to_dict_partial FAILED    [ 51%]
tests/test_salary.py::TestSalary::test_salary_average_with_both_values FAILED [ 52%]
tests/test_salary.py::TestSalary::test_salary_average_from_only FAILED  [ 52%]
tests/test_salary.py::TestSalary::test_salary_average_to_only FAILED    [ 52%]
tests/test_salary.py::TestSalary::test_salary_average_none_values FAILED [ 53%]
tests/test_salary.py::TestSalary::test_salary_comparison_greater FAILED [ 53%]
tests/test_salary.py::TestSalary::test_salary_comparison_less FAILED    [ 53%]
tests/test_salary.py::TestSalary::test_salary_comparison_equal FAILED   [ 53%]
tests/test_salary.py::TestSalary::test_salary_comparison_with_none FAILED [ 54%]
tests/test_salary.py::TestSalary::test_salary_string_representation_full FAILED [ 54%]
tests/test_salary.py::TestSalary::test_salary_string_representation_from_only FAILED [ 54%]
tests/test_salary.py::TestSalary::test_salary_string_representation_none FAILED [ 55%]
tests/test_salary.py::TestSalary::test_salary_is_specified FAILED       [ 55%]
tests/test_salary.py::TestSalary::test_salary_currency_conversion FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_title_match FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_description_match FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_requirements_match FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_responsibilities_match FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_detailed_description_match FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_skills_match FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_case_insensitive FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_no_matches FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_relevance_scoring FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_true FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_false FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_title FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_requirements FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_responsibilities FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_description FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_detailed_description FAILED [ 60%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_skills FAILED [ 60%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_empty_list PASSED [ 60%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_empty_keyword FAILED [ 61%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_none_fields FAILED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_source_manager_initialization PASSED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_get_available_sources PASSED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_hh PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_sj PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_invalid PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_is_source_available_true PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_is_source_available_false PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_get_source_display_name PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_get_source_api_limits PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_hh PASSED [ 64%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_sj_valid PASSED [ 64%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_sj_invalid PASSED [ 64%]
tests/test_source_manager.py::TestSourceManager::test_get_source_priority PASSED [ 65%]
tests/test_source_manager.py::TestSourceManager::test_sort_sources_by_priority PASSED [ 65%]
tests/test_source_manager.py::TestSourceManager::test_get_source_features PASSED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_source_selector_initialization FAILED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_single FAILED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_all FAILED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_exit PASSED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_invalid_then_valid FAILED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_display_sources_info PASSED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_get_available_sources FAILED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_validate_source_choice FAILED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_get_source_name_by_choice FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_is_source_available FAILED [ 68%]
tests/test_source_selector.py::TestSourceSelector::test_display_source_menu FAILED [ 68%]
tests/test_storage.py::TestPostgresSaver::test_postgres_saver_initialization PASSED [ 69%]
tests/test_storage.py::TestPostgresSaver::test_get_connection PASSED    [ 69%]
tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data PASSED [ 69%]
tests/test_storage.py::TestPostgresSaver::test_ensure_database_exists PASSED [ 69%]
tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data PASSED [ 70%]
tests/test_storage.py::TestStorageFactory::test_get_storage_postgres PASSED [ 70%]
tests/test_storage.py::TestStorageFactory::test_get_storage_invalid_type PASSED [ 70%]
tests/test_storage.py::TestStorageFactory::test_get_storage_missing_config PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_valid PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_invalid_then_valid PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_non_numeric PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_title PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_description PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_case_insensitive PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_no_matches PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_both_values PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_min PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_max PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_single_value PASSED [ 74%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_invalid_format PASSED [ 74%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_empty_string PASSED [ 74%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_with_spaces PASSED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_empty_items FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_single_page FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_multiple_pages FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_next FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_previous FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_quit_immediately FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_invalid_input FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_custom_items_per_page FAILED [ 77%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_last_page_boundary FAILED [ 77%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_first_page_boundary FAILED [ 77%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_display_format FAILED [ 78%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_edge_case_zero_items_per_page FAILED [ 78%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_string_items FAILED [ 78%]
tests/test_unified_api.py::TestUnifiedAPI::test_initialization PASSED   [ 78%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_all_sources FAILED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_hh FAILED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_sj FAILED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_unknown PASSED [ 80%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_all_sources FAILED [ 80%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_source_hh PASSED [ 80%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_source_sj PASSED [ 80%]
tests/test_unified_api.py::TestUnifiedAPI::test_search_with_multiple_keywords PASSED [ 81%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_available_sources PASSED [ 81%]
tests/test_unified_api.py::TestUnifiedAPI::test_api_error_handling PASSED [ 81%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_handler_initialization PASSED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_empty PASSED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_with_data FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_empty FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_with_data FAILED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_found FAILED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_not_found PASSED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_empty_query ^C

=================================== ERRORS ====================================
______ ERROR at setup of TestBaseFormatter.test_format_salary_full_range ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e59d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_salary_from_only _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e6010>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_salary_to_only ________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e66d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_salary_none _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e6e10>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_salary_empty_dict ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e7510>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_rur _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e7c10>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_usd _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f8350>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_eur _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f8a50>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_currency_unknown _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f9150>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_text_truncate ________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f9810>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_text_short __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501e9690>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_text_none __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f8050>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_date_string _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f9c10>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_date_none __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501f9f90>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_experience_string ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fa310>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_experience_none _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fa6d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_employment_type _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fad10>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_schedule ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fb350>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_company_name _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fb990>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_company_name_dict ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f83501fbfd0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_company_name_none ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f834fd04650>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_clean_html_tags ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f834fd04c90>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_clean_html_none ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f834fd052d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_number_thousands _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f834fd05a10>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
___________ ERROR at setup of TestPostgresSaver.test_initialization ___________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f9038d0>
mock_db_manager = <Mock id='140201948508048'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f565a50>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_______ ERROR at setup of TestPostgresSaver.test_save_vacancies_success _______

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f903ed0>
mock_db_manager = <Mock id='140201944566800'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f1a6790>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_____ ERROR at setup of TestPostgresSaver.test_save_vacancies_empty_list ______

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f914590>
mock_db_manager = <Mock id='140201939845520'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834ed25290>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
___ ERROR at setup of TestPostgresSaver.test_save_vacancies_database_error ____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f914bd0>
mock_db_manager = <Mock id='140201944025936'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f1211d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_________ ERROR at setup of TestPostgresSaver.test_get_all_vacancies __________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f9151d0>
mock_db_manager = <Mock id='140201939838864'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834ed233d0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
________ ERROR at setup of TestPostgresSaver.test_get_vacancies_count _________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834fdf3c10>
mock_db_manager = <Mock id='140201944232144'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f152310>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
____ ERROR at setup of TestPostgresSaver.test_delete_vacancy_by_id_success ____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f914750>
mock_db_manager = <Mock id='140201944781136'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f1d8a50>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
___ ERROR at setup of TestPostgresSaver.test_delete_vacancy_by_id_not_found ___

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f9158d0>
mock_db_manager = <Mock id='140201943990928'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f118390>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_____ ERROR at setup of TestPostgresSaver.test_filter_vacancies_by_salary _____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f915d10>
mock_db_manager = <Mock id='140201948137936'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f50cd90>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
____ ERROR at setup of TestPostgresSaver.test_search_vacancies_by_keyword _____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f834f916090>
mock_db_manager = <Mock id='140201944248912'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f834f157bd0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
================================== FAILURES ===================================
__________________ TestFileCache.test_save_and_load_response __________________

self = <tests.test_cache.TestFileCache object at 0x7f834fd07b90>
file_cache = <src.utils.cache.FileCache object at 0x7f834f1a4690>

    def test_save_and_load_response(self, file_cache):
        """Тест сохранения и загрузки ответа"""
        source = 'hh'
        params = {'text': 'python', 'area': '1'}
        data = {'items': [{'name': 'Python Developer', 'id': '1'}], 'found': 1}
    
        # Сохраняем в кэш
        file_cache.save_response(source, params, data)
    
        # Получаем из кэша
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:87: AssertionError
____________________ TestFileCache.test_clear_cache_source ____________________

self = <tests.test_cache.TestFileCache object at 0x7f83501f9890>
file_cache = <src.utils.cache.FileCache object at 0x7f834f1dad10>

    def test_clear_cache_source(self, file_cache):
        """Тест очистки кэша определенного источника"""
        # Сохраняем кэш для HH
        hh_params = {'text': 'python', 'area': '1'}
        hh_data = {'items': []}
        file_cache.save_response('hh', hh_params, hh_data)
    
        # Сохраняем кэш для SJ
        sj_params = {'text': 'python', 'area': '1'}
        sj_data = {'items': []}
        file_cache.save_response('sj', sj_params, sj_data)
    
        # Очищаем только HH
        file_cache.clear('hh')
    
        # Проверяем, что HH очищен, а SJ остался
        assert file_cache.load_response('hh', hh_params) is None
>       assert file_cache.load_response('sj', sj_params) is not None
E       AssertionError: assert None is not None
E        +  where None = load_response('sj', {'text': 'python', 'area': '1'})
E        +    where load_response = <src.utils.cache.FileCache object at 0x7f834f1dad10>.load_response

tests/test_cache.py:117: AssertionError
________________ TestFileCache.test_cache_with_complex_params _________________

self = <tests.test_cache.TestFileCache object at 0x7f834fd11010>
file_cache = <src.utils.cache.FileCache object at 0x7f834f1a6650>

    def test_cache_with_complex_params(self, file_cache):
        """Тест кэширования со сложными параметрами"""
        source = 'hh'
        params = {
            'text': 'python developer',
            'area': ['1', '2'],  # список
            'salary': 100000,
            'experience': 'between1And3',
            'employment': 'full'
        }
        data = {'items': [], 'found': 0}
    
        # Сохраняем и получаем
        file_cache.save_response(source, params, data)
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:151: AssertionError
__________________ TestFileCache.test_cache_unicode_support ___________________

self = <tests.test_cache.TestFileCache object at 0x7f834fd116d0>
file_cache = <src.utils.cache.FileCache object at 0x7f83501ea2d0>

    def test_cache_unicode_support(self, file_cache):
        """Тест поддержки Unicode в кэше"""
        source = 'hh'
        params = {'text': 'разработчик python 🐍', 'area': 'Москва'}
        data = {
            'items': [
                {'name': 'Senior Python разработчик 👨‍💻', 'id': '1'}
            ],
            'found': 1
        }
    
        # Сохраняем и получаем
        file_cache.save_response(source, params, data)
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:185: AssertionError
__________________ TestDBManager.test_create_tables_success ___________________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd36a90>
mock_connect = <MagicMock name='connect' id='140201949045712'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f5e8050>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables_success(self, mock_connect, db_manager):
        """Тест успешного создания таблиц"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
>       db_manager.create_tables()

tests/test_db_manager.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f834f5e8050>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Создаем упрощенную таблицу компаний для целевых компаний
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS companies (
                            id SERIAL PRIMARY KEY,
                            name VARCHAR(255) NOT NULL UNIQUE,
                            hh_id VARCHAR(50),
                            sj_id VARCHAR(50)
                        );
                    """
                    )
                    logger.info("✓ Таблица companies создана/проверена")
    
                    # Создаем полную таблицу вакансий сразу с правильными типами
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS vacancies (
                            id SERIAL PRIMARY KEY,
                            vacancy_id VARCHAR(255) UNIQUE NOT NULL,
                            title TEXT NOT NULL,
                            url TEXT,
                            salary_from INTEGER,
                            salary_to INTEGER,
                            salary_currency VARCHAR(10),
                            description TEXT,
                            requirements TEXT,
                            responsibilities TEXT,
                            experience VARCHAR(100),
                            employment VARCHAR(100),
                            schedule VARCHAR(100),
                            area TEXT,
                            source VARCHAR(50),
                            published_at TIMESTAMP,
                            company_id INTEGER,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    """
                    )
    
                    # Проверяем и исправляем тип company_id если нужно
                    cursor.execute(
                        """
                        SELECT data_type
                        FROM information_schema.columns
                        WHERE table_name = 'vacancies' AND column_name = 'company_id'
                    """
                    )
    
                    result = cursor.fetchone()
>                   if result and result[0] not in ("integer", "bigint"):
                                  ^^^^^^^^^
E                   TypeError: 'Mock' object is not subscriptable

src/storage/db_manager.py:123: TypeError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_________________ TestDBManager.test_populate_companies_table _________________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd37150>
mock_connect = <MagicMock name='connect' id='140201948183696'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f514ad0>

    @patch('src.config.target_companies.TARGET_COMPANIES', [
        {"hh_id": "1", "name": "Test Company", "description": "Test Description"}
    ])
    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect, db_manager):
        """Тест заполнения таблицы компаний"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем пустую таблицу
        mock_cursor.fetchone.return_value = [0]
    
        db_manager.populate_companies_table()
    
        # Проверяем, что был выполнен INSERT запрос
        insert_calls = [call for call in mock_cursor.execute.call_args_list
                       if 'INSERT INTO companies' in str(call)]
>       assert len(insert_calls) >= 1
E       assert 0 >= 1
E        +  where 0 = len([])

tests/test_db_manager.py:95: AssertionError
____________ TestDBManager.test_get_companies_and_vacancies_count _____________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd377d0>
mock_connect = <MagicMock name='connect' id='140201943988368'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f1179d0>

    @patch('src.config.target_companies.TARGET_COMPANIES', [
        {"name": "Test Company 1"},
        {"name": "Test Company 2"}
    ])
    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager):
        """Тест получения количества вакансий по компаниям"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса
        mock_cursor.fetchall.return_value = [
            ("Test Company 1", 5),
            ("Test Company 2", 3)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
>       assert len(result) == 2
E       AssertionError: assert 12 == 2
E        +  where 12 = len([('\u042f\u043d\u0434\u0435\u043a\u0441', 0), ('\u0422\u0438\u043d\u044c\u043a\u043e\u0444\u0444', 0), ('\u0421\u0411\u0415\u0420', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ('\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u0438\u044f \u041a\u0430\u0441\u043f\u0435\u0440\u0441\u043a\u043e\u0433\u043e', 0), ('\u0410\u0432\u0438\u0442\u043e', 0), ('X5 Retail Group', 0), ('\u0420\u043e\u0441\u0442\u0435\u043b\u0435\u043a\u043e\u043c', 0), ('\u0410\u043b\u044c\u0444\u0430-\u0411\u0430\u043d\u043a', 0), ('JetBrains', 0)])

tests/test_db_manager.py:122: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
____________________ TestDBManager.test_get_all_vacancies _____________________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd37e50>
mock_connect = <MagicMock name='connect' id='140201948156624'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f510750>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса
        mock_cursor.fetchall.return_value = [
            {
                'title': 'Python Developer',
                'company_name': 'Test Company',
                'salary_info': '100000 - 150000 RUR',
                'url': 'https://test.com/vacancy/1',
                'vacancy_id': 'test_1',
                'employer': 'Test Company',
                'area': 'Moscow',
                'company_id': '1'
            }
        ]
    
        result = db_manager.get_all_vacancies()
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:155: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_____________ TestDBManager.test_get_vacancies_with_higher_salary _____________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd45210>
mock_connect = <MagicMock name='connect' id='140201944518544'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f19b250>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Мокаем get_avg_salary
        with patch.object(db_manager, 'get_avg_salary', return_value=100000.0):
            # Имитируем результат запроса - возвращаем список кортежей
            mock_cursor.fetchall.return_value = [
                ('Senior Python Developer', 'Test Company', '150000 - 200000 RUR',
                 'https://test.com/vacancy/2', 175000.0, 'test_2', 'Test Company')
            ]
    
            result = db_manager.get_vacancies_with_higher_salary()
    
>           assert len(result) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_db_manager.py:222: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
________________ TestDBManager.test_get_vacancies_with_keyword ________________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd45850>
mock_connect = <MagicMock name='connect' id='140201948538768'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f56fcd0>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager):
        """Тест поиска вакансий по ключевому слову"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса - возвращаем список кортежей
        mock_cursor.fetchall.return_value = [
            ('Python Developer', 'Test Company', '100000 - 150000 RUR',
             'https://test.com/vacancy/1', 'Python development position', 'test_1', 'Test Company')
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:246: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_________________ TestDBManager.test_check_connection_success _________________

self = <tests.test_db_manager.TestDBManager object at 0x7f834fd472d0>
mock_connect = <MagicMock name='connect' id='140201948602128'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f834f57e190>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect, db_manager):
        """Тест успешной проверки подключения"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:339: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
______________ TestDecorators.test_cache_with_complex_arguments _______________

self = <tests.test_decorators.TestDecorators object at 0x7f834fd61210>

    def test_cache_with_complex_arguments(self):
        """Тест кэширования с комплексными аргументами"""
        call_count = 0
    
        @simple_cache()
        def cached_function(data_list, data_dict):
            nonlocal call_count
            call_count += 1
            return sum(data_list) + sum(data_dict.values())
    
        # Первый вызов
>       result1 = cached_function([1, 2, 3], {'a': 4, 'b': 5})
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_decorators.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ([1, 2, 3], {'a': 4, 'b': 5}), kwargs = {}, actual_ttl = 3600
current_time = 1756406130.5200274
cache_key = (([1, 2, 3], {'a': 4, 'b': 5}), frozenset())

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # Получаем TTL из переменных окружения или используем переданное значение
        actual_ttl = ttl if ttl is not None else EnvLoader.get_env_var_int("CACHE_TTL", 3600)
        current_time = time.time()
    
        cache_key = (args, frozenset(kwargs.items()))
    
        # Проверяем существующий кэш
>       if cache_key in cache:
           ^^^^^^^^^^^^^^^^^^
E       TypeError: unhashable type: 'list'

src/utils/decorators.py:29: TypeError
___________________ TestEnvLoader.test_load_env_file_exists ___________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd624d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834ed96490>

    def test_load_env_file_exists(self, env_loader):
        """Тест загрузки существующего .env файла"""
        env_content = "TEST_KEY=test_value\nANOTHER_KEY=another_value"
    
        with patch('builtins.open', mock_open(read_data=env_content)):
            with patch('os.path.exists', return_value=True):
                result = env_loader.load_env_file('.env')
>               assert result is True
E               assert {} is True

tests/test_env_loader.py:27: AssertionError
_________________ TestEnvLoader.test_load_env_file_not_exists _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd62850>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f1a1590>

    def test_load_env_file_not_exists(self, env_loader):
        """Тест загрузки несуществующего .env файла"""
        with patch('os.path.exists', return_value=False):
            result = env_loader.load_env_file('.env')
>           assert result is False
E           assert {} is False

tests/test_env_loader.py:33: AssertionError
___________________ TestEnvLoader.test_parse_env_line_valid ___________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd62e90>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f182ad0>

    def test_parse_env_line_valid(self, env_loader):
        """Тест парсинга корректной строки переменной окружения"""
>       key, value = env_loader.parse_env_line("API_KEY=secret123")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:37: AttributeError
________________ TestEnvLoader.test_parse_env_line_with_quotes ________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd63510>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f13a090>

    def test_parse_env_line_with_quotes(self, env_loader):
        """Тест парсинга строки с кавычками"""
>       key, value = env_loader.parse_env_line('DB_URL="postgresql://localhost"')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:43: AttributeError
__________________ TestEnvLoader.test_parse_env_line_invalid __________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd63b50>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834ed26050>

    def test_parse_env_line_invalid(self, env_loader):
        """Тест парсинга некорректной строки"""
>       result = env_loader.parse_env_line("INVALID_LINE")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:49: AttributeError
__________________ TestEnvLoader.test_parse_env_line_comment __________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6c1d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834ed739d0>

    def test_parse_env_line_comment(self, env_loader):
        """Тест парсинга комментария"""
>       result = env_loader.parse_env_line("# This is a comment")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:54: AttributeError
_________________ TestEnvLoader.test_set_environment_variable _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6c810>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834fddcbd0>

    def test_set_environment_variable(self, env_loader):
        """Тест установки переменной окружения"""
>       env_loader.set_environment_variable("TEST_VAR", "test_value")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'set_environment_variable'

tests/test_env_loader.py:59: AttributeError
_________________ TestEnvLoader.test_get_environment_variable _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6ce50>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f57df10>

    def test_get_environment_variable(self, env_loader):
        """Тест получения переменной окружения"""
        os.environ["TEST_GET_VAR"] = "test_get_value"
    
>       value = env_loader.get_environment_variable("TEST_GET_VAR")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'

tests/test_env_loader.py:70: AttributeError
__________ TestEnvLoader.test_get_environment_variable_with_default ___________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6d490>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f545a10>

    def test_get_environment_variable_with_default(self, env_loader):
        """Тест получения переменной окружения с значением по умолчанию"""
>       value = env_loader.get_environment_variable("NON_EXISTENT_VAR", "default_value")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'

tests/test_env_loader.py:78: AttributeError
________________ TestEnvLoader.test_load_environment_variables ________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6dad0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834f17ebd0>

    @patch.dict(os.environ, {}, clear=True)
    def test_load_environment_variables(self, env_loader):
        """Тест загрузки всех переменных окружения"""
        variables = {
            "VAR1": "value1",
            "VAR2": "value2",
            "VAR3": "value3"
        }
    
>       env_loader.load_environment_variables(variables)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_environment_variables'

tests/test_env_loader.py:90: AttributeError
____________ TestEnvLoader.test_validate_required_env_vars_success ____________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6e1d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834ed97f10>

    def test_validate_required_env_vars_success(self, env_loader):
        """Тест валидации обязательных переменных - успешный случай"""
        required_vars = ["PATH"]  # PATH всегда должен существовать
    
>       missing = env_loader.validate_required_env_vars(required_vars)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'

tests/test_env_loader.py:99: AttributeError
____________ TestEnvLoader.test_validate_required_env_vars_missing ____________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f834fd6e8d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f834ed850d0>

    def test_validate_required_env_vars_missing(self, env_loader):
        """Тест валидации обязательных переменных - недостающие переменные"""
        required_vars = ["NON_EXISTENT_VAR1", "NON_EXISTENT_VAR2"]
    
>       missing = env_loader.validate_required_env_vars(required_vars)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'

tests/test_env_loader.py:106: AttributeError
_________________ TestMenuManager.test_get_user_choice_valid __________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f834fddf610>
mock_input = <MagicMock name='input' id='140201948349904'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f834f55a1d0>

    @patch('builtins.input', return_value='1')
    def test_get_user_choice_valid(self, mock_input, menu_manager):
        """Тест получения корректного выбора пользователя"""
        menu_items = ['Item 1', 'Item 2', 'Exit']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:28: AttributeError
___________ TestMenuManager.test_get_user_choice_invalid_then_valid ___________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f834fddfb50>
mock_print = <MagicMock name='print' id='140201939999696'>
mock_input = <MagicMock name='input' id='140201939999632'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f834ed49e50>

    @patch('builtins.input', side_effect=['invalid', '2'])
    @patch('builtins.print')
    def test_get_user_choice_invalid_then_valid(self, mock_print, mock_input, menu_manager):
        """Тест обработки некорректного, а затем корректного выбора"""
        menu_items = ['Item 1', 'Item 2']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:36: AttributeError
___________________ TestMenuManager.test_display_menu_items ___________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f834fde4210>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f834f50df10>

    def test_display_menu_items(self, menu_manager):
        """Тест отображения элементов меню"""
        menu_items = ['Search', 'View', 'Exit']
        with patch('builtins.print') as mock_print:
>           menu_manager.display_menu(menu_items)
E           TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:43: TypeError
__________________ TestMenuManager.test_get_user_choice_exit __________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f834fde47d0>
mock_input = <MagicMock name='input' id='140201944406032'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f834f17e590>

    @patch('builtins.input', return_value='0')
    def test_get_user_choice_exit(self, mock_input, menu_manager):
        """Тест выбора выхода из меню"""
        menu_items = ['Item 1', 'Exit']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:51: AttributeError
_________________ TestPaginator.test_paginator_initialization _________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde5bd0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_paginator_initialization(self, sample_data):
        """Тест инициализации пагинатора"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:20: TypeError
__________________ TestPaginator.test_get_current_page_data ___________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde6250>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_get_current_page_data(self, sample_data):
        """Тест получения данных текущей страницы"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:28: TypeError
________________________ TestPaginator.test_next_page _________________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde6950>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page(self, sample_data):
        """Тест перехода к следующей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:35: TypeError
_____________________ TestPaginator.test_next_page_at_end _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde7090>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page_at_end(self, sample_data):
        """Тест перехода к следующей странице на последней странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:43: TypeError
______________________ TestPaginator.test_previous_page _______________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde7790>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page(self, sample_data):
        """Тест перехода к предыдущей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:50: TypeError
__________________ TestPaginator.test_previous_page_at_start __________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fde7e90>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page_at_start(self, sample_data):
        """Тест перехода к предыдущей странице на первой странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:57: TypeError
_____________________ TestPaginator.test_go_to_page_valid _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fdf05d0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_valid(self, sample_data):
        """Тест перехода к корректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:63: TypeError
____________________ TestPaginator.test_go_to_page_invalid ____________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fdf0cd0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_invalid(self, sample_data):
        """Тест перехода к некорректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:69: TypeError
________________________ TestPaginator.test_empty_data ________________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fdf1390>

    def test_empty_data(self):
        """Тест пагинации с пустыми данными"""
>       paginator = Paginator([], page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:75: TypeError
_____________________ TestPaginator.test_single_page_data _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fdf1a10>

    def test_single_page_data(self):
        """Тест пагинации с данными на одну страницу"""
        data = [1, 2, 3]
>       paginator = Paginator(data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:83: TypeError
________________________ TestPaginator.test_page_info _________________________

self = <tests.test_paginator.TestPaginator object at 0x7f834fdf2110>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_page_info(self, sample_data):
        """Тест получения информации о странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:89: TypeError
____________________ TestHHParser.test_parse_company_data _____________________

self = <tests.test_parsers.TestHHParser object at 0x7f834fdf3d50>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f834f543510>

    def test_parse_company_data(self, hh_parser):
        """Тест парсинга данных компании"""
        company_data = {
            'id': '123',
            'name': 'TestCompany',
            'description': 'Test Description',
            'alternate_url': 'https://hh.ru/employer/123'
        }
    
>       result = hh_parser.parse_company(company_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_company'

tests/test_parsers.py:104: AttributeError
___________________ TestHHParser.test_parse_companies_list ____________________

self = <tests.test_parsers.TestHHParser object at 0x7f834f900210>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f834f566e50>

    def test_parse_companies_list(self, hh_parser):
        """Тест парсинга списка компаний"""
        companies_data = {
            'items': [
                {'id': '1', 'name': 'Company1'},
                {'id': '2', 'name': 'Company2'}
            ]
        }
    
>       result = hh_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_companies'

tests/test_parsers.py:119: AttributeError
________________ TestSuperJobParser.test_parse_companies_list _________________

self = <tests.test_parsers.TestSuperJobParser object at 0x7f834f901890>
sj_parser = <src.vacancies.parsers.sj_parser.SuperJobParser object at 0x7f834f5099d0>

    def test_parse_companies_list(self, sj_parser):
        """Тест парсинга списка компаний SJ"""
        companies_data = {
            'objects': [
                {'id': 101, 'title': 'SJ Company1'},
                {'id': 102, 'title': 'SJ Company2'}
            ]
        }
    
>       result = sj_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobParser' object has no attribute 'parse_companies'

tests/test_parsers.py:190: AttributeError
______________ TestSalary.test_salary_initialization_with_range _______________

self = <tests.test_salary.TestSalary object at 0x7f834f917110>

    def test_salary_initialization_with_range(self):
        """Тест инициализации зарплаты с диапазоном"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:15: TypeError
_______________ TestSalary.test_salary_initialization_from_only _______________

self = <tests.test_salary.TestSalary object at 0x7f834f917650>

    def test_salary_initialization_from_only(self):
        """Тест инициализации зарплаты только с минимумом"""
>       salary = Salary(80000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:22: TypeError
________________ TestSalary.test_salary_initialization_to_only ________________

self = <tests.test_salary.TestSalary object at 0x7f834f917c50>

    def test_salary_initialization_to_only(self):
        """Тест инициализации зарплаты только с максимумом"""
>       salary = Salary(salary_to=200000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:29: TypeError
______________ TestSalary.test_salary_initialization_none_values ______________

self = <tests.test_salary.TestSalary object at 0x7f834f9202d0>

    def test_salary_initialization_none_values(self):
        """Тест инициализации зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:36: TypeError
__________________ TestSalary.test_salary_from_dict_complete __________________

self = <tests.test_salary.TestSalary object at 0x7f834f9208d0>

    def test_salary_from_dict_complete(self):
        """Тест создания зарплаты из полного словаря"""
        salary_dict = {"from": 100000, "to": 150000, "currency": "RUR"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:44: AttributeError
__________________ TestSalary.test_salary_from_dict_partial ___________________

self = <tests.test_salary.TestSalary object at 0x7f834f920ed0>

    def test_salary_from_dict_partial(self):
        """Тест создания зарплаты из частичного словаря"""
        salary_dict = {"from": 80000, "currency": "USD"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:52: AttributeError
____________________ TestSalary.test_salary_from_dict_none ____________________

self = <tests.test_salary.TestSalary object at 0x7f834f9214d0>

    def test_salary_from_dict_none(self):
        """Тест создания зарплаты из None"""
>       salary = Salary.from_dict(None)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:59: AttributeError
___________________ TestSalary.test_salary_from_dict_empty ____________________

self = <tests.test_salary.TestSalary object at 0x7f834f921ad0>

    def test_salary_from_dict_empty(self):
        """Тест создания зарплаты из пустого словаря"""
>       salary = Salary.from_dict({})
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:66: AttributeError
_______________________ TestSalary.test_salary_to_dict ________________________

self = <tests.test_salary.TestSalary object at 0x7f834f9220d0>

    def test_salary_to_dict(self):
        """Тест преобразования зарплаты в словарь"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:73: TypeError
___________________ TestSalary.test_salary_to_dict_partial ____________________

self = <tests.test_salary.TestSalary object at 0x7f834f922690>

    def test_salary_to_dict_partial(self):
        """Тест преобразования частичной зарплаты в словарь"""
>       salary = Salary(80000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:81: TypeError
_______________ TestSalary.test_salary_average_with_both_values _______________

self = <tests.test_salary.TestSalary object at 0x7f834f922d10>

    def test_salary_average_with_both_values(self):
        """Тест расчета средней зарплаты при наличии обоих значений"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:89: TypeError
__________________ TestSalary.test_salary_average_from_only ___________________

self = <tests.test_salary.TestSalary object at 0x7f834f9233d0>

    def test_salary_average_from_only(self):
        """Тест расчета средней зарплаты при наличии только минимума"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:94: TypeError
___________________ TestSalary.test_salary_average_to_only ____________________

self = <tests.test_salary.TestSalary object at 0x7f834f923a90>

    def test_salary_average_to_only(self):
        """Тест расчета средней зарплаты при наличии только максимума"""
>       salary = Salary(salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:99: TypeError
_________________ TestSalary.test_salary_average_none_values __________________

self = <tests.test_salary.TestSalary object at 0x7f834f928190>

    def test_salary_average_none_values(self):
        """Тест расчета средней зарплаты при отсутствии значений"""
>       salary = Salary(None, None, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:104: TypeError
__________________ TestSalary.test_salary_comparison_greater __________________

self = <tests.test_salary.TestSalary object at 0x7f834f923790>

    def test_salary_comparison_greater(self):
        """Тест сравнения зарплат - больше"""
>       salary1 = Salary(150000, 200000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:109: TypeError
___________________ TestSalary.test_salary_comparison_less ____________________

self = <tests.test_salary.TestSalary object at 0x7f834f921e90>

    def test_salary_comparison_less(self):
        """Тест сравнения зарплат - меньше"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:115: TypeError
___________________ TestSalary.test_salary_comparison_equal ___________________

self = <tests.test_salary.TestSalary object at 0x7f834f9177d0>

    def test_salary_comparison_equal(self):
        """Тест сравнения зарплат - равно"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:121: TypeError
_________________ TestSalary.test_salary_comparison_with_none _________________

self = <tests.test_salary.TestSalary object at 0x7f834f928290>

    def test_salary_comparison_with_none(self):
        """Тест сравнения зарплат с None значениями"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:127: TypeError
______________ TestSalary.test_salary_string_representation_full ______________

self = <tests.test_salary.TestSalary object at 0x7f834f928690>

    def test_salary_string_representation_full(self):
        """Тест строкового представления полной зарплаты"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:135: TypeError
___________ TestSalary.test_salary_string_representation_from_only ____________

self = <tests.test_salary.TestSalary object at 0x7f834f9289d0>

    def test_salary_string_representation_from_only(self):
        """Тест строкового представления зарплаты только с минимумом"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:143: TypeError
______________ TestSalary.test_salary_string_representation_none ______________

self = <tests.test_salary.TestSalary object at 0x7f834f928d10>

    def test_salary_string_representation_none(self):
        """Тест строкового представления зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:150: TypeError
_____________________ TestSalary.test_salary_is_specified _____________________

self = <tests.test_salary.TestSalary object at 0x7f834f929210>

    def test_salary_is_specified(self):
        """Тест проверки указана ли зарплата"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:156: TypeError
_________________ TestSalary.test_salary_currency_conversion __________________

self = <tests.test_salary.TestSalary object at 0x7f834f929810>

    def test_salary_currency_conversion(self):
        """Тест конвертации валют (если поддерживается)"""
>       salary = Salary(1000, 2000, "USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:166: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_title_match _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92a990>

    def test_filter_vacancies_by_keyword_title_match(self):
        """Тест фильтрации по ключевому слову в заголовке"""
        vacancies = [
>           self.create_test_vacancy(title="Python Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Java Developer"),
            self.create_test_vacancy(title="Frontend Developer")
        ]

tests/test_search_utils.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92a990>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_description_match ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92af90>

    def test_filter_vacancies_by_keyword_description_match(self):
        """Тест фильтрации по ключевому слову в описании"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", description="Python programming required"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", description="Java programming required"),
            self.create_test_vacancy(title="Developer", description="Frontend development with React")
        ]

tests/test_search_utils.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92af90>
kwargs = {'description': 'Python programming required', 'title': 'Developer'}
defaults = {'benefits': None, 'description': 'Python programming required', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_requirements_match _____

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92b590>

    def test_filter_vacancies_by_keyword_requirements_match(self):
        """Тест фильтрации по ключевому слову в требованиях"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", requirements="Experience with Python"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", requirements="Experience with Java"),
        ]

tests/test_search_utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92b590>
kwargs = {'requirements': 'Experience with Python', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___ TestSearchUtils.test_filter_vacancies_by_keyword_responsibilities_match ___

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92bbd0>

    def test_filter_vacancies_by_keyword_responsibilities_match(self):
        """Тест фильтрации по ключевому слову в обязанностях"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", responsibilities="Develop Python applications"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", responsibilities="Develop Java applications"),
        ]

tests/test_search_utils.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92bbd0>
kwargs = {'responsibilities': 'Develop Python applications', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_ TestSearchUtils.test_filter_vacancies_by_keyword_detailed_description_match _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93c210>

    def test_filter_vacancies_by_keyword_detailed_description_match(self):
        """Тест фильтрации по ключевому слову в детальном описании"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", detailed_description="Work with Python and Django"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", detailed_description="Work with Java and Spring"),
        ]

tests/test_search_utils.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93c210>
kwargs = {'detailed_description': 'Work with Python and Django', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': 'Work with Python and Django', 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_skills_match ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93c810>

    def test_filter_vacancies_by_keyword_skills_match(self):
        """Тест фильтрации по ключевому слову в навыках"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", skills=[{"name": "Python"}, {"name": "Django"}]),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", skills=[{"name": "Java"}, {"name": "Spring"}]),
        ]

tests/test_search_utils.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93c810>
kwargs = {'skills': [{'name': 'Python'}, {'name': 'Django'}], 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
______ TestSearchUtils.test_filter_vacancies_by_keyword_case_insensitive ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93ce10>

    def test_filter_vacancies_by_keyword_case_insensitive(self):
        """Тест нечувствительности к регистру"""
        vacancies = [
>           self.create_test_vacancy(title="PYTHON DEVELOPER"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="python developer"),
            self.create_test_vacancy(title="Python Developer")
        ]

tests/test_search_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93ce10>
kwargs = {'title': 'PYTHON DEVELOPER'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_________ TestSearchUtils.test_filter_vacancies_by_keyword_no_matches _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93d410>

    def test_filter_vacancies_by_keyword_no_matches(self):
        """Тест фильтрации без совпадений"""
        vacancies = [
>           self.create_test_vacancy(title="Java Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="C++ Developer")
        ]

tests/test_search_utils.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93d410>
kwargs = {'title': 'Java Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_relevance_scoring ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93da10>

    def test_filter_vacancies_by_keyword_relevance_scoring(self):
        """Тест сортировки по релевантности"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", description="Python mentioned here"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Python Developer", description="Main Python role"),
            self.create_test_vacancy(title="Senior Python Developer", requirements="Python expertise required")
        ]

tests/test_search_utils.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93da10>
kwargs = {'description': 'Python mentioned here', 'title': 'Developer'}
defaults = {'benefits': None, 'description': 'Python mentioned here', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____________ TestSearchUtils.test_vacancy_contains_keyword_true ______________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93dfd0>

    def test_vacancy_contains_keyword_true(self):
        """Тест функции vacancy_contains_keyword с положительным результатом"""
>       vacancy = self.create_test_vacancy(title="Python Developer", description="Python programming")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93dfd0>
kwargs = {'description': 'Python programming', 'title': 'Python Developer'}
defaults = {'benefits': None, 'description': 'Python programming', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____________ TestSearchUtils.test_vacancy_contains_keyword_false _____________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93e610>

    def test_vacancy_contains_keyword_false(self):
        """Тест функции vacancy_contains_keyword с отрицательным результатом"""
>       vacancy = self.create_test_vacancy(title="Java Developer", description="Java programming")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93e610>
kwargs = {'description': 'Java programming', 'title': 'Java Developer'}
defaults = {'benefits': None, 'description': 'Java programming', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSearchUtils.test_vacancy_contains_keyword_in_title ____________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92b350>

    def test_vacancy_contains_keyword_in_title(self):
        """Тест поиска ключевого слова в заголовке"""
>       vacancy = self.create_test_vacancy(title="Python Developer")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f92b350>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_vacancy_contains_keyword_in_requirements ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f928410>

    def test_vacancy_contains_keyword_in_requirements(self):
        """Тест поиска ключевого слова в требованиях"""
>       vacancy = self.create_test_vacancy(requirements="Python experience required")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f928410>
kwargs = {'requirements': 'Python experience required'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
______ TestSearchUtils.test_vacancy_contains_keyword_in_responsibilities ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93e290>

    def test_vacancy_contains_keyword_in_responsibilities(self):
        """Тест поиска ключевого слова в обязанностях"""
>       vacancy = self.create_test_vacancy(responsibilities="Develop Python applications")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93e290>
kwargs = {'responsibilities': 'Develop Python applications'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_vacancy_contains_keyword_in_description _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93d810>

    def test_vacancy_contains_keyword_in_description(self):
        """Тест поиска ключевого слова в описании"""
>       vacancy = self.create_test_vacancy(description="Work with Python and frameworks")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93d810>
kwargs = {'description': 'Work with Python and frameworks'}
defaults = {'benefits': None, 'description': 'Work with Python and frameworks', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
____ TestSearchUtils.test_vacancy_contains_keyword_in_detailed_description ____

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93cbd0>

    def test_vacancy_contains_keyword_in_detailed_description(self):
        """Тест поиска ключевого слова в детальном описании"""
>       vacancy = self.create_test_vacancy(detailed_description="Python development role")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93cbd0>
kwargs = {'detailed_description': 'Python development role'}
defaults = {'benefits': None, 'description': None, 'detailed_description': 'Python development role', 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSearchUtils.test_vacancy_contains_keyword_in_skills ___________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93ed10>

    def test_vacancy_contains_keyword_in_skills(self):
        """Тест поиска ключевого слова в навыках"""
>       vacancy = self.create_test_vacancy(skills=[{"name": "Python"}, {"name": "Django"}])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93ed10>
kwargs = {'skills': [{'name': 'Python'}, {'name': 'Django'}]}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_______ TestSearchUtils.test_filter_vacancies_by_keyword_empty_keyword ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93f550>

    def test_filter_vacancies_by_keyword_empty_keyword(self):
        """Тест фильтрации с пустым ключевым словом"""
        vacancies = [
>           self.create_test_vacancy(title="Python Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Java Developer")
        ]

tests/test_search_utils.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93f550>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_none_fields _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93fb50>

    def test_filter_vacancies_by_keyword_none_fields(self):
        """Тест фильтрации вакансий с пустыми полями"""
>       vacancy = self.create_test_vacancy(
            title=None,
            description=None,
            requirements=None,
            responsibilities=None,
            detailed_description=None,
            skills=None
        )

tests/test_search_utils.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f834f93fb50>
kwargs = {'description': None, 'detailed_description': None, 'requirements': None, 'responsibilities': None, ...}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSourceSelector.test_source_selector_initialization ____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f94e650>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834e1be290>

    def test_source_selector_initialization(self, source_selector):
        """Тест инициализации SourceSelector"""
        assert source_selector is not None
>       assert hasattr(source_selector, 'available_sources')
E       AssertionError: assert False
E        +  where False = hasattr(<src.ui_interfaces.source_selector.SourceSelector object at 0x7f834e1be290>, 'available_sources')

tests/test_source_selector.py:22: AssertionError
____________ TestSourceSelector.test_get_user_source_choice_single ____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f94ec10>
mock_input = <MagicMock name='input' id='140201944698320'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834f1c4250>

    @patch('builtins.input', return_value='1')
    def test_get_user_source_choice_single(self, mock_input, source_selector):
        """Тест выбора одного источника"""
        with patch('builtins.print'):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:29: AssertionError
_____________ TestSourceSelector.test_get_user_source_choice_all ______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f94f1d0>
mock_input = <MagicMock name='input' id='140201927929680'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834e1c7410>

    @patch('builtins.input', return_value='3')
    def test_get_user_source_choice_all(self, mock_input, source_selector):
        """Тест выбора всех источников"""
        with patch('builtins.print'):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'superjob.ru', 'hh.ru'}, list)

tests/test_source_selector.py:37: AssertionError
______ TestSourceSelector.test_get_user_source_choice_invalid_then_valid ______

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f94fdd0>
mock_print = <MagicMock name='print' id='140201944830672'>
mock_input = <MagicMock name='input' id='140201940304784'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834f1e56d0>

    @patch('builtins.input', side_effect=['invalid', '1'])
    @patch('builtins.print')
    def test_get_user_source_choice_invalid_then_valid(self, mock_print, mock_input, source_selector):
        """Тест некорректного, затем корректного выбора"""
        sources = source_selector.get_user_source_choice()
>       assert isinstance(sources, list)
E       AssertionError: assert False
E        +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:51: AssertionError
________________ TestSourceSelector.test_get_available_sources ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f958b10>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834ed3e0d0>

    def test_get_available_sources(self, source_selector):
        """Тест получения доступных источников"""
>       sources = source_selector.get_available_sources()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_available_sources'

tests/test_source_selector.py:63: AttributeError
_______________ TestSourceSelector.test_validate_source_choice ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f959150>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834ed3d810>

    def test_validate_source_choice(self, source_selector):
        """Тест валидации выбора источника"""
>       assert source_selector.validate_source_choice("1") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'validate_source_choice'

tests/test_source_selector.py:70: AttributeError
______________ TestSourceSelector.test_get_source_name_by_choice ______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f959790>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834f541990>

    def test_get_source_name_by_choice(self, source_selector):
        """Тест получения имени источника по выбору"""
        # Предполагаем стандартную нумерацию
>       source_name = source_selector.get_source_name_by_choice("1")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_source_name_by_choice'

tests/test_source_selector.py:80: AttributeError
_________________ TestSourceSelector.test_is_source_available _________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f959d90>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834ed21990>

    def test_is_source_available(self, source_selector):
        """Тест проверки доступности источника"""
>       assert source_selector.is_source_available("hh.ru") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'is_source_available'

tests/test_source_selector.py:85: AttributeError
_________________ TestSourceSelector.test_display_source_menu _________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f834f95a350>
mock_print = <MagicMock name='print' id='140201940319440'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f834ed95a50>

    @patch('builtins.print')
    def test_display_source_menu(self, mock_print, source_selector):
        """Тест отображения меню источников"""
>       source_selector.display_source_menu()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'display_source_menu'

tests/test_source_selector.py:92: AttributeError
______________ TestUINavigation.test_quick_paginate_empty_items _______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f976e90>

    def test_quick_paginate_empty_items(self):
        """Тест пагинации с пустым списком элементов"""
        items = []
    
        with patch('builtins.input', return_value='q'):
>           result = quick_paginate(items, items_per_page=5)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:20: TypeError
______________ TestUINavigation.test_quick_paginate_single_page _______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f977210>

    def test_quick_paginate_single_page(self):
        """Тест пагинации с одной страницей"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=5)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:30: TypeError
_____________ TestUINavigation.test_quick_paginate_multiple_pages _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f977810>

    def test_quick_paginate_multiple_pages(self):
        """Тест пагинации с несколькими страницами"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6']
    
        with patch('builtins.input', side_effect=['n', 'q']):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=3)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:40: TypeError
____________ TestUINavigation.test_quick_paginate_navigation_next _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f977e50>

    def test_quick_paginate_navigation_next(self):
        """Тест навигации на следующую страницу"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6']
    
        with patch('builtins.input', side_effect=['n', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:50: TypeError
__________ TestUINavigation.test_quick_paginate_navigation_previous ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f984490>

    def test_quick_paginate_navigation_previous(self):
        """Тест навигации на предыдущую страницу"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['n', 'p', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:60: TypeError
____________ TestUINavigation.test_quick_paginate_quit_immediately ____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f984a90>

    def test_quick_paginate_quit_immediately(self):
        """Тест немедленного выхода из пагинации"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=2)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:70: TypeError
_____________ TestUINavigation.test_quick_paginate_invalid_input ______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f985090>

    def test_quick_paginate_invalid_input(self):
        """Тест обработки некорректного ввода"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['invalid', 'xyz', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:80: TypeError
_________ TestUINavigation.test_quick_paginate_custom_items_per_page __________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f985690>

    def test_quick_paginate_custom_items_per_page(self):
        """Тест пагинации с настраиваемым количеством элементов на странице"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=1)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:90: TypeError
___________ TestUINavigation.test_quick_paginate_last_page_boundary ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f985c90>

    def test_quick_paginate_last_page_boundary(self):
        """Тест навигации на границе последней страницы"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', side_effect=['n', 'n', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:100: TypeError
__________ TestUINavigation.test_quick_paginate_first_page_boundary ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f986250>

    def test_quick_paginate_first_page_boundary(self):
        """Тест навигации на границе первой страницы"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['p', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:110: TypeError
_____________ TestUINavigation.test_quick_paginate_display_format _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f986850>

    def test_quick_paginate_display_format(self):
        """Тест формата отображения элементов"""
        items = [
            {'title': 'Job 1', 'company': 'Company A'},
            {'title': 'Job 2', 'company': 'Company B'}
        ]
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=5)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:123: TypeError
_____ TestUINavigation.test_quick_paginate_edge_case_zero_items_per_page ______

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f986e50>

    def test_quick_paginate_edge_case_zero_items_per_page(self):
        """Тест граничного случая с нулевым количеством элементов на странице"""
        items = ['item1', 'item2']
    
        with patch('builtins.input', return_value='q'):
            # При items_per_page=0 или отрицательном значении должно использоваться значение по умолчанию
            try:
>               quick_paginate(items, items_per_page=0)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:134: TypeError
______________ TestUINavigation.test_quick_paginate_string_items ______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f834f987450>

    def test_quick_paginate_string_items(self):
        """Тест пагинации со строковыми элементами"""
        items = ["First item", "Second item", "Third item"]
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:145: TypeError
_____________ TestUnifiedAPI.test_get_vacancies_from_all_sources ______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f834f9775d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f834f534fd0>
mock_hh_api = <Mock id='140201948152720'>
mock_sj_api = <Mock id='140201948156240'>

    def test_get_vacancies_from_all_sources(self, unified_api, mock_hh_api, mock_sj_api):
        """Тест получения вакансий из всех источников"""
        result = unified_api.get_vacancies_from_sources("Python")
    
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_unified_api.py:54: AssertionError
---------------------------- Captured stdout call -----------------------------
Выполняется дедупликация и фильтрация по целевым компаниям...
Не найдено вакансий от целевых компаний
---------------------------- Captured stderr call -----------------------------
ERROR:src.api_modules.base_api:Ошибка при SQL-дедупликации с фильтрацией: 'Mock' object is not subscriptable
ERROR:src.api_modules.base_api:SQL-дедупликация обязательна. Fallback логика отключена.
------------------------------ Captured log call ------------------------------
ERROR    src.api_modules.base_api:base_api.py:311 Ошибка при SQL-дедупликации с фильтрацией: 'Mock' object is not subscriptable
ERROR    src.api_modules.base_api:base_api.py:313 SQL-дедупликация обязательна. Fallback логика отключена.
______________ TestUnifiedAPI.test_get_vacancies_from_source_hh _______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f834f98c650>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f834f52fad0>
mock_hh_api = <Mock id='140201944819920'>

    def test_get_vacancies_from_source_hh(self, unified_api, mock_hh_api):
        """Тест получения вакансий из HeadHunter"""
        result = unified_api.get_vacancies_from_source("hh", "Python")
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_unified_api.py:62: AssertionError
______________ TestUnifiedAPI.test_get_vacancies_from_source_sj _______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f834f98cf10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f834f118f90>
mock_sj_api = <Mock id='140201952414416'>

    def test_get_vacancies_from_source_sj(self, unified_api, mock_sj_api):
        """Тест получения вакансий из SuperJob"""
        result = unified_api.get_vacancies_from_source("sj", "Python")
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_unified_api.py:70: AssertionError
_____________ TestUnifiedAPI.test_get_companies_from_all_sources ______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f834f98d6d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f834e1cb190>
mock_hh_api = <Mock id='140201939816272'>
mock_sj_api = <Mock id='140201939812688'>

    def test_get_companies_from_all_sources(self, unified_api, mock_hh_api, mock_sj_api):
        """Тест получения компаний из всех источников"""
>       result = unified_api.get_companies_from_sources()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_companies_from_sources'

tests/test_unified_api.py:82: AttributeError
______ TestVacancyDisplayHandler.test_show_all_saved_vacancies_with_data ______

self = <MagicMock name='quick_paginate' id='140201927292560'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f834f9edc50>
mock_paginate = <MagicMock name='quick_paginate' id='140201927292560'>
display_handler = <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f834f166a10>
mock_storage = <Mock id='140201974099600'>
sample_vacancies = [<src.vacancies.models.Vacancy object at 0x7f834edd4fc0>, <src.vacancies.models.Vacancy object at 0x7f834edd4ef0>]

    @patch('src.utils.ui_navigation.quick_paginate')
    def test_show_all_saved_vacancies_with_data(self, mock_paginate, display_handler, mock_storage, sample_vacancies):
        """Тест отображения всех вакансий - с данными"""
        mock_storage.get_vacancies.return_value = sample_vacancies
    
        display_handler.show_all_saved_vacancies()
    
>       mock_paginate.assert_called_once()
E       AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.

tests/test_vacancy_display_handler.py:72: AssertionError
---------------------------- Captured stdout call -----------------------------

Сохраненных вакансий: 2


Сохраненные вакансии
====================
1.
ID: 1
Название: Python Developer
Компания: Не указана
Зарплата: от 100,000 до 150,000RUR
Опыт: Не указан
Занятость: Не указана
Источник: hh.ru
Ссылка: https://example.com/1
Описание вакансии: Описание отсутствует
2.
ID: 2
Название: Java Developer
Компания: Не указана
Зарплата: от 120,000 до 180,000RUR
Опыт: Не указан
Занятость: Не указана
Источник: superjob.ru
Ссылка: https://example.com/2
Описание вакансии: Описание отсутствует

====================
Навигация:
Страница 1 из 1
Показано элементов: 1-2 из 2
--------------------

Нажмите Enter для продолжения...Ошибка при загрузке вакансий: pytest: reading from stdin while output is captured!  Consider using `-s`.
---------------------------- Captured stderr call -----------------------------
ERROR:src.ui_interfaces.vacancy_display_handler:Ошибка при отображении сохраненных вакансий: pytest: reading from stdin while output is captured!  Consider using `-s`.
------------------------------ Captured log call ------------------------------
ERROR    src.ui_interfaces.vacancy_display_handler:vacancy_display_handler.py:49 Ошибка при отображении сохраненных вакансий: pytest: reading from stdin while output is captured!  Consider using `-s`.
______ TestVacancyDisplayHandler.test_show_top_vacancies_by_salary_empty ______

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f834f9ece50>
mock_print = <MagicMock name='print' id='140201927949072'>
display_handler = <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f834e1ca650>
mock_storage = <Mock id='140201927937040'>

    @patch('builtins.print')
    def test_show_top_vacancies_by_salary_empty(self, mock_print, display_handler, mock_storage):
        """Тест отображения топ вакансий по зарплате - пустой список"""
        mock_storage.get_top_vacancies_by_salary.return_value = []
    
>       display_handler.show_top_vacancies_by_salary()

tests/test_vacancy_display_handler.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_display_handler.py:54: in show_top_vacancies_by_salary
    n = get_positive_integer("\nВведите количество вакансий для отображения: ")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:43: in get_positive_integer
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7f83511b34d0>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
---------------------------- Captured stdout call -----------------------------

Введите количество вакансий для отображения: 
____ TestVacancyDisplayHandler.test_show_top_vacancies_by_salary_with_data ____

self = <MagicMock name='quick_paginate' id='140201943950672'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f834f9eda90>
mock_paginate = <MagicMock name='quick_paginate' id='140201943950672'>
mock_input = <MagicMock name='input' id='140201948413520'>
display_handler = <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f834f10ffd0>
mock_storage = <Mock id='140201943947472'>
sample_vacancies = [<src.vacancies.models.Vacancy object at 0x7f834e1668f0>, <src.vacancies.models.Vacancy object at 0x7f834e166a90>]

    @patch('builtins.input', return_value='10')
    @patch('src.utils.ui_navigation.quick_paginate')
    def test_show_top_vacancies_by_salary_with_data(self, mock_paginate, mock_input, display_handler, mock_storage, sample_vacancies):
        """Тест отображения топ вакансий по зарплате - с данными"""
        mock_storage.get_top_vacancies_by_salary.return_value = sample_vacancies
    
        display_handler.show_top_vacancies_by_salary()
    
>       mock_paginate.assert_called_once()
E       AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.

tests/test_vacancy_display_handler.py:93: AssertionError
---------------------------- Captured stdout call -----------------------------
Нет сохраненных вакансий.
___ TestVacancyDisplayHandler.test_search_saved_vacancies_by_keyword_found ____

self = <MagicMock name='filter_vacancies_by_keyword' id='140201940247568'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'filter_vacancies_by_keyword' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f834f9ede90>
mock_paginate = <MagicMock name='quick_paginate' id='140201948373328'>
mock_input = <MagicMock name='input' id='140201948381136'>
display_handler = <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f834ed23c10>
mock_storage = <Mock id='140201939829200'>
sample_vacancies = [<src.vacancies.models.Vacancy object at 0x7f834f5a57e0>, <src.vacancies.models.Vacancy object at 0x7f834f5a41f0>]

    @patch('builtins.input', return_value='python')
    @patch('src.utils.ui_navigation.quick_paginate')
    def test_search_saved_vacancies_by_keyword_found(self, mock_paginate, mock_input, display_handler, mock_storage, sample_vacancies):
        """Тест поиска сохраненных вакансий по ключевому слову - найдены"""
        mock_storage.get_vacancies.return_value = sample_vacancies
    
        with patch('src.utils.ui_helpers.filter_vacancies_by_keyword') as mock_filter:
            mock_filter.return_value = [sample_vacancies[0]]  # Возвращаем Python вакансию
    
            display_handler.search_saved_vacancies_by_keyword()
    
>           mock_filter.assert_called_once()
E           AssertionError: Expected 'filter_vacancies_by_keyword' to have been called once. Called 0 times.

tests/test_vacancy_display_handler.py:106: AssertionError
---------------------------- Captured stdout call -----------------------------

Найдено 1 сохраненных вакансий с ключевым словом 'python':


Вакансии с ключевым словом 'python'
===================================
1.
ID: 1
Название: Python Developer
Компания: Не указана
Зарплата: от 100,000 до 150,000RUR
Опыт: Не указан
Занятость: Не указана
Источник: hh.ru
Ссылка: https://example.com/1
Описание вакансии: Описание отсутствует

====================
Навигация:
Страница 1 из 1
Показано элементов: 1-1 из 1
--------------------
=========================== short test summary info ===========================
FAILED tests/test_cache.py::TestFileCache::test_save_and_load_response - assert None is not None
FAILED tests/test_cache.py::TestFileCache::test_clear_cache_source - AssertionError: assert None is not None
 +  where None = load_response('sj', {'text': 'python', 'area': '1'})
 +    where load_response = <src.utils.cache.FileCache object at 0x7f834f1dad10>.load_response
FAILED tests/test_cache.py::TestFileCache::test_cache_with_complex_params - assert None is not None
FAILED tests/test_cache.py::TestFileCache::test_cache_unicode_support - assert None is not None
FAILED tests/test_db_manager.py::TestDBManager::test_create_tables_success - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - assert 0 >= 1
 +  where 0 = len([])
FAILED tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 2
 +  where 12 = len([('\u042f\u043d\u0434\u0435\u043a\u0441', 0), ('\u0422\u0438\u043d\u044c\u043a\u043e\u0444\u0444', 0), ('\u0421\u0411\u0415\u0420', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ('\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u0438\u044f \u041a\u0430\u0441\u043f\u0435\u0440\u0441\u043a\u043e\u0433\u043e', 0), ('\u0410\u0432\u0438\u0442\u043e', 0), ('X5 Retail Group', 0), ('\u0420\u043e\u0441\u0442\u0435\u043b\u0435\u043a\u043e\u043c', 0), ('\u0410\u043b\u044c\u0444\u0430-\u0411\u0430\u043d\u043a', 0), ('JetBrains', 0)])
FAILED tests/test_db_manager.py::TestDBManager::test_get_all_vacancies - assert 0 == 1
 +  where 0 = len([])
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary - assert 0 == 1
 +  where 0 = len([])
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword - assert 0 == 1
 +  where 0 = len([])
FAILED tests/test_db_manager.py::TestDBManager::test_check_connection_success - assert False is True
FAILED tests/test_decorators.py::TestDecorators::test_cache_with_complex_arguments - TypeError: unhashable type: 'list'
FAILED tests/test_env_loader.py::TestEnvLoader::test_load_env_file_exists - assert {} is True
FAILED tests/test_env_loader.py::TestEnvLoader::test_load_env_file_not_exists - assert {} is False
FAILED tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_valid - AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'
FAILED tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_with_quotes - AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'
FAILED tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_invalid - AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'
FAILED tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_comment - AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'
FAILED tests/test_env_loader.py::TestEnvLoader::test_set_environment_variable - AttributeError: 'EnvLoader' object has no attribute 'set_environment_variable'
FAILED tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable - AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'
FAILED tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable_with_default - AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'
FAILED tests/test_env_loader.py::TestEnvLoader::test_load_environment_variables - AttributeError: 'EnvLoader' object has no attribute 'load_environment_variables'
FAILED tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_success - AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'
FAILED tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_missing - AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_valid - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_invalid_then_valid - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_menu_manager.py::TestMenuManager::test_display_menu_items - TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given
FAILED tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_exit - AttributeError: 'MenuManager' object has no attribute 'get_user_choice'
FAILED tests/test_paginator.py::TestPaginator::test_paginator_initialization - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_get_current_page_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_next_page - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_next_page_at_end - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_previous_page - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_previous_page_at_start - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_go_to_page_valid - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_go_to_page_invalid - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_empty_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_single_page_data - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_page_info - TypeError: Paginator() takes no arguments
FAILED tests/test_parsers.py::TestHHParser::test_parse_company_data - AttributeError: 'HHParser' object has no attribute 'parse_company'
FAILED tests/test_parsers.py::TestHHParser::test_parse_companies_list - AttributeError: 'HHParser' object has no attribute 'parse_companies'
FAILED tests/test_parsers.py::TestSuperJobParser::test_parse_companies_list - AttributeError: 'SuperJobParser' object has no attribute 'parse_companies'
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_with_range - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_to_only - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'
FAILED tests/test_salary.py::TestSalary::test_salary_initialization_none_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_complete - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_partial - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_none - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_from_dict_empty - AttributeError: type object 'Salary' has no attribute 'from_dict'
FAILED tests/test_salary.py::TestSalary::test_salary_to_dict - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_to_dict_partial - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_average_with_both_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_average_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_average_to_only - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'
FAILED tests/test_salary.py::TestSalary::test_salary_average_none_values - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_greater - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_less - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_equal - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_comparison_with_none - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_full - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_from_only - TypeError: Salary.__init__() got an unexpected keyword argument 'currency'
FAILED tests/test_salary.py::TestSalary::test_salary_string_representation_none - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_is_specified - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_salary.py::TestSalary::test_salary_currency_conversion - TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_title_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_description_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_requirements_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_responsibilities_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_detailed_description_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_skills_match - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_case_insensitive - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_no_matches - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_relevance_scoring - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_true - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_false - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_title - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_requirements - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_responsibilities - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_description - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_detailed_description - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_skills - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_empty_keyword - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_none_fields - TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'
FAILED tests/test_source_selector.py::TestSourceSelector::test_source_selector_initialization - AssertionError: assert False
 +  where False = hasattr(<src.ui_interfaces.source_selector.SourceSelector object at 0x7f834e1be290>, 'available_sources')
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_single - AssertionError: assert False
 +  where False = isinstance({'hh.ru'}, list)
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_all - AssertionError: assert False
 +  where False = isinstance({'superjob.ru', 'hh.ru'}, list)
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_invalid_then_valid - AssertionError: assert False
 +  where False = isinstance({'hh.ru'}, list)
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_available_sources - AttributeError: 'SourceSelector' object has no attribute 'get_available_sources'
FAILED tests/test_source_selector.py::TestSourceSelector::test_validate_source_choice - AttributeError: 'SourceSelector' object has no attribute 'validate_source_choice'
FAILED tests/test_source_selector.py::TestSourceSelector::test_get_source_name_by_choice - AttributeError: 'SourceSelector' object has no attribute 'get_source_name_by_choice'
FAILED tests/test_source_selector.py::TestSourceSelector::test_is_source_available - AttributeError: 'SourceSelector' object has no attribute 'is_source_available'
FAILED tests/test_source_selector.py::TestSourceSelector::test_display_source_menu - AttributeError: 'SourceSelector' object has no attribute 'display_source_menu'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_empty_items - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_single_page - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_multiple_pages - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_next - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_previous - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_quit_immediately - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_invalid_input - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_custom_items_per_page - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_last_page_boundary - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_first_page_boundary - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_display_format - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_edge_case_zero_items_per_page - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_string_items - TypeError: quick_paginate() missing 1 required positional argument: 'formatter'
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_all_sources - assert 0 == 2
 +  where 0 = len([])
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_hh - assert 0 == 1
 +  where 0 = len([])
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_sj - assert 0 == 1
 +  where 0 = len([])
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_all_sources - AttributeError: 'UnifiedAPI' object has no attribute 'get_companies_from_sources'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_with_data - AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_empty - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_with_data - AssertionError: Expected 'quick_paginate' to have been called once. Called 0 times.
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_found - AssertionError: Expected 'filter_vacancies_by_keyword' to have been called once. Called 0 times.
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_full_range - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_from_only - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_to_only - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_empty_dict - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_rur - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_usd - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_eur - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_unknown - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_text_truncate - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_text_short - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_text_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_date_string - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_date_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_string - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_employment_type - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_schedule - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_dict - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_tags - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_none - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_base_formatter.py::TestBaseFormatter::test_format_number_thousands - TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_initialization - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_success - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_empty_list - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_database_error - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_get_all_vacancies - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_count - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_filter_vacancies_by_salary - TypeError: 'Mock' object is not subscriptable
ERROR tests/test_postgres_saver.py::TestPostgresSaver::test_search_vacancies_by_keyword - TypeError: 'Mock' object is not subscriptable
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1114: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
=========== 114 failed, 145 passed, 2 skipped, 34 errors in 11.99s ============
~/workspace$ 