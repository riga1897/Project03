~/workspace$ pytest --cov=src --cov-report=term-missing
=========================== test session starts ============================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 2644 items                                                       

tests/test_abstract.py ........                                      [  0%]
tests/test_abstract_classes_fixes.py .........                       [  0%]
tests/test_abstract_db_manager.py ....                               [  0%]
tests/test_abstract_filter_complete.py .........                     [  1%]
tests/test_advanced_integration_coverage.py .FF..F.FFFFFF.....FF.FF. [  2%]
......FF.F                                                           [  2%]
tests/test_api_complete.py ...................                       [  3%]
tests/test_api_components_coverage.py ...........                    [  3%]
tests/test_api_config.py ....                                        [  3%]
tests/test_api_data_filter.py ......                                 [  3%]
tests/test_api_fixes.py .......                                      [  4%]
tests/test_api_infrastructure_final.py .......................       [  5%]
tests/test_api_modules.py ............................               [  6%]
tests/test_api_modules_consolidated.py ....                          [  6%]
tests/test_api_modules_coverage.py ...................               [  6%]
tests/test_app_config.py .........                                   [  7%]
tests/test_base_api.py ...............                               [  7%]
tests/test_base_formatter.py ..........                              [  8%]
tests/test_base_formatter_complete.py .............................. [  9%]
                                                                     [  9%]
tests/test_base_parser.py ......                                     [  9%]
tests/test_cache.py ......................                           [ 10%]
tests/test_cached_api.py ....                                        [ 10%]
tests/test_cached_api_complete.py ................                   [ 11%]
tests/test_components_fixed.py ...                                   [ 11%]
tests/test_comprehensive_advanced_coverage.py ..........             [ 11%]
tests/test_comprehensive_coverage_boost.py ......................... [ 12%]
..............                                                       [ 13%]
tests/test_comprehensive_coverage_final.py .......................   [ 14%]
tests/test_comprehensive_fixed.py .....                              [ 14%]
tests/test_comprehensive_missing_coverage.py ....................... [ 15%]
......                                                               [ 15%]
tests/test_config_consolidated.py .....                              [ 15%]
tests/test_config_missing_coverage.py ............................   [ 16%]
tests/test_config_modules_consolidated.py ......                     [ 16%]
tests/test_config_modules_coverage.py .............................. [ 17%]
..                                                                   [ 18%]
tests/test_console_interface.py ......                               [ 18%]
tests/test_console_interface_coverage.py ..................          [ 18%]
tests/test_core_functionality_consolidated.py .....                  [ 19%]
tests/test_core_infrastructure_final.py ..F.......FF....F..FF..F..   [ 20%]
tests/test_core_infrastructure_final_fixed.py ...................... [ 20%]
....                                                                 [ 21%]
tests/test_core_modules_comprehensive.py ........                    [ 21%]
tests/test_critical_components_fixed.py ...............F......       [ 22%]
tests/test_critical_errors_fixed.py ...................F..           [ 23%]
tests/test_critical_missing_coverage.py ......F..................... [ 24%]
..                                                                   [ 24%]
tests/test_data_managers_coverage.py .............................   [ 25%]
tests/test_data_normalizers_comprehensive.py ....................... [ 26%]
.....                                                                [ 26%]
tests/test_data_processing_coverage.py .............                 [ 26%]
tests/test_database_connection.py ........                           [ 27%]
tests/test_database_storage_coverage.py ....F.FFFFFF......           [ 27%]
tests/test_db_config.py .....                                        [ 28%]
tests/test_db_manager.py .................                           [ 28%]
tests/test_db_manager_coverage_fixed.py F.FFFFFFFF.FF....F.F..       [ 29%]
tests/test_decorators.py .......                                     [ 29%]
tests/test_description_parser.py ..........                          [ 30%]
tests/test_env_loader.py ................                            [ 30%]
tests/test_file_operations_coverage.py ............                  [ 31%]
tests/test_filter_utils.py ......                                    [ 31%]
tests/test_final_comprehensive_coverage.py ...........               [ 31%]
tests/test_final_coverage_fixes.py .FF...................            [ 32%]
tests/test_final_critical_coverage.py ..FFF.............FF.          [ 33%]
tests/test_final_missing_coverage.py .............                   [ 33%]
tests/test_final_system_coverage.py ..................FFFF........FF [ 35%]
..F.                                                                 [ 35%]
tests/test_formatters_coverage.py ...........................        [ 36%]
tests/test_get_api_complete.py ....................                  [ 37%]
tests/test_hh_api_complete.py .................                      [ 37%]
tests/test_hh_api_config.py .....                                    [ 37%]
tests/test_hh_parser.py ........                                     [ 38%]
tests/test_hierarchy_abstractions_coverage.py ..............         [ 38%]
tests/test_integration.py .............                              [ 39%]
tests/test_interfaces.py .ss                                         [ 39%]
tests/test_interfaces_coverage.py ..F..F...s........                 [ 40%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F. [ 40%]
.....FF                                                              [ 41%]
tests/test_main_application_interface.py ...                         [ 41%]
tests/test_main_application_interface_complete.py .................. [ 42%]
.........................                                            [ 42%]
tests/test_main_consolidated.py .........                            [ 43%]
tests/test_menu_manager.py ..........                                [ 43%]
tests/test_missing_components.py .........                           [ 44%]
tests/test_missing_coverage_components.py .FF......FFFFF.....F       [ 44%]
tests/test_missing_coverage_extended.py ............F.FFF........... [ 45%]
F....................FFF...                                          [ 46%]
tests/test_models_coverage.py ...........................            [ 47%]
tests/test_models_data_coverage.py ..............FF.FFFEEEEEE.FFF    [ 49%]
tests/test_models_fixed.py ...                                       [ 49%]
tests/test_monitoring_logging_coverage.py ...F.FFF.................. [ 50%]
...F..F....F..........FFF.F                                          [ 51%]
tests/test_paginator.py ......                                       [ 51%]
tests/test_parsers_complete.py ............                          [ 51%]
tests/test_parsers_coverage.py .............................         [ 52%]
tests/test_performance_optimization_coverage.py .........F..FF...... [ 53%]
.......F.............                                                [ 54%]
tests/test_persistence_components_coverage.py ...............        [ 55%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.             [ 55%]
tests/test_real_components_coverage.py .........FF.......F.          [ 56%]
tests/test_repository_fixed.py ..                                    [ 56%]
tests/test_salary_fixed.py ...........                               [ 56%]
tests/test_salary_utils.py ......................                    [ 57%]
tests/test_search_utils.py ............................              [ 58%]
tests/test_search_utils_complete.py ................................ [ 60%]
..............                                                       [ 60%]
tests/test_security_validation_coverage.py ........F................ [ 61%]
.....F......F..                                                      [ 62%]
tests/test_service_components_coverage.py E...EE.EE.EEE.EEEEEEE.FFFF [ 63%]
FFFFFF                                                               [ 63%]
tests/test_services_consolidated.py ....                             [ 63%]
tests/test_services_coverage.py ............................         [ 64%]
tests/test_services_storage_consolidated.py ..........               [ 64%]
tests/test_simple_db_adapter.py .........                            [ 65%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                     [ 65%]
tests/test_sj_api.py ..............                                  [ 66%]
tests/test_sj_api_complete.py .............F....                     [ 67%]
tests/test_sj_api_config.py .....                                    [ 67%]
tests/test_sj_parser.py ........                                     [ 67%]
tests/test_sj_parser_complete.py ..............                      [ 68%]
tests/test_skip_conditions_removal.py ............                   [ 68%]
tests/test_source_manager.py .................                       [ 69%]
tests/test_source_selector.py .................                      [ 69%]
tests/test_storage_abstractions.py ........                          [ 70%]
tests/test_storage_abstractions_coverage.py ........                 [ 70%]
tests/test_storage_complete.py .............                         [ 70%]
tests/test_storage_components_complete.py ......F....FF............. [ 71%]
..F                                                                  [ 71%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FF [ 72%]
F                                                                    [ 72%]
tests/test_storage_components_fixes.py ....F....F...............     [ 73%]
tests/test_storage_factory.py ........                               [ 74%]
tests/test_storage_modules_consolidated.py ....                      [ 74%]
tests/test_storage_services_complete_coverage.py ..FEEEEEEEEEEEEEEEE [ 75%]
EEEEE..                                                              [ 75%]
tests/test_target_companies.py .....                                 [ 75%]
tests/test_typed_data_processor.py ................                  [ 76%]
tests/test_ui_components_complete.py ............................... [ 77%]
.......                                                              [ 77%]
tests/test_ui_components_coverage.py .........................       [ 78%]
tests/test_ui_components_extended.py ..................              [ 79%]
tests/test_ui_components_missing_tests.py ..........FEEE...........F [ 80%]
EEE                                                                  [ 80%]
tests/test_ui_config.py .......................                      [ 81%]
tests/test_ui_helpers_comprehensive.py ............................. [ 82%]
..........                                                           [ 82%]
tests/test_ui_helpers_extended.py .................................. [ 83%]
......                                                               [ 84%]
tests/test_ui_modules_consolidated.py .....                          [ 84%]
tests/test_ui_navigation.py ......................                   [ 85%]
tests/test_ui_navigation_complete.py ..s..                           [ 85%]
tests/test_ui_navigation_comprehensive.py ......                     [ 85%]
tests/test_ui_navigation_extended.py .......F....................... [ 86%]
....                                                                 [ 86%]
tests/test_ultimate_coverage_boost.py F.......

================================== ERRORS ==================================
__ ERROR at setup of TestBaseJobAPICoverage.test_base_api_initialization ___

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a1990>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
____ ERROR at setup of TestBaseJobAPICoverage.test_get_vacancies_method ____

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a1fd0>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
__ ERROR at setup of TestBaseJobAPICoverage.test_validate_vacancy_method ___

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a2610>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
_____ ERROR at setup of TestBaseJobAPICoverage.test_clear_cache_method _____

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a2c90>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
__ ERROR at setup of TestBaseJobAPICoverage.test_base_api_with_parameters __

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a32d0>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
__ ERROR at setup of TestBaseJobAPICoverage.test_base_api_error_scenarios __

self = <tests.test_models_data_coverage.TestBaseJobAPICoverage object at 0x7f15d48a3910>

    @pytest.fixture
    def base_api(self):
        """Создание экземпляра BaseJobAPI"""
>       return BaseJobAPI()
               ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:335: TypeError
_ ERROR at setup of TestFilteringServiceCoverage.test_filtering_service_initialization _

self = <tests.test_service_components_coverage.TestFilteringServiceCoverage object at 0x7f15d4680210>

    @pytest.fixture
    def filtering_service(self):
        """Создание экземпляра FilteringService"""
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:74: TypeError
_ ERROR at setup of TestFilteringServiceCoverage.test_filtering_with_empty_data _

self = <tests.test_service_components_coverage.TestFilteringServiceCoverage object at 0x7f15d4681b50>

    @pytest.fixture
    def filtering_service(self):
        """Создание экземпляра FilteringService"""
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:74: TypeError
_ ERROR at setup of TestFilteringServiceCoverage.test_filtering_error_handling _

self = <tests.test_service_components_coverage.TestFilteringServiceCoverage object at 0x7f15d4682190>

    @pytest.fixture
    def filtering_service(self):
        """Создание экземпляра FilteringService"""
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:74: TypeError
_ ERROR at setup of TestFilteringServiceCoverage.test_filtering_performance _

self = <tests.test_service_components_coverage.TestFilteringServiceCoverage object at 0x7f15d4682e10>

    @pytest.fixture
    def filtering_service(self):
        """Создание экземпляра FilteringService"""
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:74: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_service_initialization _

self = <tests.test_service_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d4683850>

    @pytest.fixture
    def deduplication_service(self):
        """Создание экземпляра DeduplicationService"""
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:194: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_with_empty_data _

self = <tests.test_service_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d4688510>

    @pytest.fixture
    def deduplication_service(self):
        """Создание экземпляра DeduplicationService"""
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:194: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_performance _

self = <tests.test_service_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d4681910>

    @pytest.fixture
    def deduplication_service(self):
        """Создание экземпляра DeduplicationService"""
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:194: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_error_handling _

self = <tests.test_service_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d46882d0>

    @pytest.fixture
    def deduplication_service(self):
        """Создание экземпляра DeduplicationService"""
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:194: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_storage_service_initialization _

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d4689110>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_save_vacancies __

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d4689490>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
__ ERROR at setup of TestVacancyStorageServiceCoverage.test_get_vacancies __

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d4689910>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_process_and_save _

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d4689f90>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_storage_error_handling _

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d468a5d0>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_batch_storage_operations _

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d468ac10>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceCoverage.test_storage_with_invalid_data _

self = <tests.test_service_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d468b250>

    @pytest.fixture
    def storage_service(self):
        """Создание экземпляра VacancyStorageService"""
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:288: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_vacancy_storage_service_initialization _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d4448b90>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_save_vacancy_single _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d4449210>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_save_vacancies_batch _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d4449890>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_load_vacancy_by_id _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d4449f10>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_delete_vacancy_by_id _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d444a550>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_vacancy_exists_check _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d444ab90>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestVacancyStorageServiceComplete.test_error_handling_in_operations _

self = <tests.test_storage_services_complete_coverage.TestVacancyStorageServiceComplete object at 0x7f15d444b210>

    @pytest.fixture
    def vacancy_storage_service(self):
        """Фикстура для VacancyStorageService"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return Mock()
>       return VacancyStorageService()
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_services_complete_coverage.py:140: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplication_service_initialization _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d4437510>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplicate_by_id _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d4448fd0>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplicate_by_multiple_fields _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d444bc10>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplicate_empty_data _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d444bfd0>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplicate_single_item _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d444c390>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestDeduplicationServiceComplete.test_deduplication_strategy_configuration _

self = <tests.test_storage_services_complete_coverage.TestDeduplicationServiceComplete object at 0x7f15d444c7d0>

    @pytest.fixture
    def deduplication_service(self):
        """Фикстура для DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:266: TypeError
_ ERROR at setup of TestFilteringServiceComplete.test_filtering_service_initialization _

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444d0d0>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
_ ERROR at setup of TestFilteringServiceComplete.test_filter_by_salary_range _

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444d710>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
__ ERROR at setup of TestFilteringServiceComplete.test_filter_by_keywords __

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444dd50>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
__ ERROR at setup of TestFilteringServiceComplete.test_filter_by_company ___

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444e3d0>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
_ ERROR at setup of TestFilteringServiceComplete.test_filter_by_experience_level _

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444ea10>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
_ ERROR at setup of TestFilteringServiceComplete.test_combine_multiple_filters _

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444f050>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
__ ERROR at setup of TestFilteringServiceComplete.test_filter_validation ___

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444f690>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
_ ERROR at setup of TestFilteringServiceComplete.test_empty_data_filtering _

self = <tests.test_storage_services_complete_coverage.TestFilteringServiceComplete object at 0x7f15d444fcd0>

    @pytest.fixture
    def filtering_service(self):
        """Фикстура для FilteringService"""
        if not FILTERING_SERVICE_AVAILABLE:
            return Mock()
>       return FilteringService()
               ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_storage_services_complete_coverage.py:355: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_application_lifecycle _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f15d45045d0>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_main_application_flow _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f15d4504c10>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestMainApplicationInterfaceFixed.test_configuration_management _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f15d4505290>

    @pytest.fixture
    def main_app_interface(self):
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return Mock()
>       return MainApplicationInterface()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:296: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_with_different_datasets _

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f15d4504e10>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
_ ERROR at setup of TestPaginatorFixed.test_pagination_navigation_comprehensive _

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f15d44fca10>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
____ ERROR at setup of TestPaginatorFixed.test_paginator_configuration _____

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f15d44ff210>

    @pytest.fixture
    def paginator(self):
        if not PAGINATOR_AVAILABLE:
            return Mock()
>       return Paginator(page_size=10)
               ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:671: TypeError
================================= FAILURES =================================
_______ TestPostgresSaverAdvancedCoverage.test_save_vacancies_method _______

self = <tests.test_advanced_integration_coverage.TestPostgresSaverAdvancedCoverage object at 0x7f15d5111190>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d4082850>
mock_db_connection = (<Mock id='139731728826960'>, <Mock id='139731728826576'>)

    def test_save_vacancies_method(self, postgres_saver, mock_db_connection):
        """Тест метода сохранения вакансий"""
        mock_conn, mock_cursor = mock_db_connection
    
        test_vacancies = [
            {'id': 'pg1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': 'pg2', 'title': 'Java Developer', 'company': 'DevCorp'}
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_advanced_integration_coverage.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d4082850>
vacancies = [{'company': 'TechCorp', 'id': 'pg1', 'title': 'Python Developer'}, {'company': 'DevCorp', 'id': 'pg2', 'title': 'Java Developer'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
______ TestPostgresSaverAdvancedCoverage.test_batch_optimized_method _______

self = <tests.test_advanced_integration_coverage.TestPostgresSaverAdvancedCoverage object at 0x7f15d51117d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d40faf10>
mock_db_connection = (<Mock id='139731727129616'>, <Mock id='139731727129680'>)

    def test_batch_optimized_method(self, postgres_saver, mock_db_connection):
        """Тест оптимизированного batch метода"""
        mock_conn, mock_cursor = mock_db_connection
    
        batch_vacancies = [
            {'id': f'batch_{i}', 'title': f'Job {i}', 'company': f'Company {i}'}
            for i in range(10)
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.add_vacancy_batch_optimized(batch_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_advanced_integration_coverage.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d40faf10>
vacancies = [{'company': 'Company 0', 'id': 'batch_0', 'title': 'Job 0'}, {'company': 'Company 1', 'id': 'batch_1', 'title': 'Job ...ny': 'Company 4', 'id': 'batch_4', 'title': 'Job 4'}, {'company': 'Company 5', 'id': 'batch_5', 'title': 'Job 5'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__ TestPostgresSaverAdvancedCoverage.test_postgres_large_batch_operations __

self = <tests.test_advanced_integration_coverage.TestPostgresSaverAdvancedCoverage object at 0x7f15d5112c10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3f63250>
mock_db_connection = (<Mock id='139731733083344'>, <Mock id='139731733076432'>)

    def test_postgres_large_batch_operations(self, postgres_saver, mock_db_connection):
        """Тест обработки больших пакетов данных"""
        mock_conn, mock_cursor = mock_db_connection
    
        large_batch = [
            {'id': f'large_{i}', 'title': f'Large Job {i}'}
            for i in range(1000)
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies(large_batch)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_advanced_integration_coverage.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3f63250>
vacancies = [{'id': 'large_0', 'title': 'Large Job 0'}, {'id': 'large_1', 'title': 'Large Job 1'}, {'id': 'large_2', 'title': 'Lar...3', 'title': 'Large Job 3'}, {'id': 'large_4', 'title': 'Large Job 4'}, {'id': 'large_5', 'title': 'Large Job 5'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
__________ TestEnvLoaderAdvancedCoverage.test_env_loader_get_var ___________

self = <tests.test_advanced_integration_coverage.TestEnvLoaderAdvancedCoverage object at 0x7f15d5113b90>

    def test_env_loader_get_var(self):
        """Тест получения переменных окружения"""
        test_vars = [
            ('DATABASE_URL', 'postgresql://localhost/test'),
            ('API_KEY', 'test_key_123'),
            ('DEBUG', 'True'),
            ('NONEXISTENT_VAR', None)
        ]
    
        for var_name, expected in test_vars:
            with patch.dict(os.environ, {var_name: expected} if expected else {}, clear=False):
>               result = EnvLoader.get_var(var_name, 'default_value')
                         ^^^^^^^^^^^^^^^^^
E               AttributeError: type object 'EnvLoader' has no attribute 'get_var'

tests/test_advanced_integration_coverage.py:194: AttributeError
________ TestEnvLoaderAdvancedCoverage.test_env_loader_load_dotenv _________

self = <tests.test_advanced_integration_coverage.TestEnvLoaderAdvancedCoverage object at 0x7f15d5118250>

    def test_env_loader_load_dotenv(self):
        """Тест загрузки .env файла"""
>       with patch('dotenv.load_dotenv', return_value=True):

tests/test_advanced_integration_coverage.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'dotenv', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'dotenv'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_______ TestEnvLoaderAdvancedCoverage.test_env_loader_with_defaults ________

self = <tests.test_advanced_integration_coverage.TestEnvLoaderAdvancedCoverage object at 0x7f15d5118910>

    def test_env_loader_with_defaults(self):
        """Тест EnvLoader с значениями по умолчанию"""
        test_cases = [
            ('MISSING_VAR', 'default_value', 'default_value'),
            ('EMPTY_VAR', '', ''),
            ('NONE_VAR', None, None)
        ]
    
        for var_name, env_value, default in test_cases:
            env_dict = {var_name: env_value} if env_value is not None else {}
            with patch.dict(os.environ, env_dict, clear=False):
>               result = EnvLoader.get_var(var_name, default)
                         ^^^^^^^^^^^^^^^^^
E               AttributeError: type object 'EnvLoader' has no attribute 'get_var'

tests/test_advanced_integration_coverage.py:214: AttributeError
______ TestEnvLoaderAdvancedCoverage.test_env_loader_type_conversions ______

self = <tests.test_advanced_integration_coverage.TestEnvLoaderAdvancedCoverage object at 0x7f15d5119010>

    def test_env_loader_type_conversions(self):
        """Тест преобразования типов в EnvLoader"""
        type_cases = [
            ('INT_VAR', '123'),
            ('BOOL_VAR', 'True'),
            ('FLOAT_VAR', '3.14'),
            ('STRING_VAR', 'test_string')
        ]
    
        for var_name, value in type_cases:
            with patch.dict(os.environ, {var_name: value}):
>               result = EnvLoader.get_var(var_name)
                         ^^^^^^^^^^^^^^^^^
E               AttributeError: type object 'EnvLoader' has no attribute 'get_var'

tests/test_advanced_integration_coverage.py:228: AttributeError
_______ TestEnvLoaderAdvancedCoverage.test_env_loader_error_handling _______

self = <tests.test_advanced_integration_coverage.TestEnvLoaderAdvancedCoverage object at 0x7f15d5111c10>

    def test_env_loader_error_handling(self):
        """Тест обработки ошибок в EnvLoader"""
        # Тестируем с различными ошибочными сценариями
>       with patch('dotenv.load_dotenv', side_effect=Exception("Load error")):

tests/test_advanced_integration_coverage.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'dotenv', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'dotenv'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_______ TestFileHandlerAdvancedCoverage.test_file_handler_read_json ________

self = <tests.test_advanced_integration_coverage.TestFileHandlerAdvancedCoverage object at 0x7f15d5119410>

    def test_file_handler_read_json(self):
        """Тест чтения JSON файлов"""
        test_data = {'key': 'value', 'number': 123}
    
        with patch('builtins.open', mock_open(read_data=json.dumps(test_data))):
            with patch('json.load', return_value=test_data):
                result = FileHandler.read_json('test.json')
>               assert result == test_data
E               AssertionError: assert {} == {'key': 'valu...'number': 123}
E                 
E                 Right contains 2 more items:
E                 {'key': 'value', 'number': 123}
E                 Use -v to get more diff

tests/test_advanced_integration_coverage.py:251: AssertionError
______ TestVacancyStatsAdvancedCoverage.test_calculate_average_salary ______

self = <tests.test_advanced_integration_coverage.TestVacancyStatsAdvancedCoverage object at 0x7f15d511b1d0>
sample_vacancies_for_stats = [{'id': 'stat1', 'location': 'Москва', 'salary_from': 80000, 'salary_to': 120000}, {'id': 'stat2', 'location': 'СПб', ...alary_from': 60000, 'salary_to': 90000}, {'id': 'stat4', 'location': 'Казань', 'salary_from': None, 'salary_to': None}]

    def test_calculate_average_salary(self, sample_vacancies_for_stats):
        """Тест расчета средней зарплаты"""
>       avg_salary = VacancyStats.calculate_average_salary(sample_vacancies_for_stats)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'calculate_average_salary'

tests/test_advanced_integration_coverage.py:340: AttributeError
______ TestVacancyStatsAdvancedCoverage.test_get_salary_distribution _______

self = <tests.test_advanced_integration_coverage.TestVacancyStatsAdvancedCoverage object at 0x7f15d511b810>
sample_vacancies_for_stats = [{'id': 'stat1', 'location': 'Москва', 'salary_from': 80000, 'salary_to': 120000}, {'id': 'stat2', 'location': 'СПб', ...alary_from': 60000, 'salary_to': 90000}, {'id': 'stat4', 'location': 'Казань', 'salary_from': None, 'salary_to': None}]

    def test_get_salary_distribution(self, sample_vacancies_for_stats):
        """Тест получения распределения зарплат"""
>       distribution = VacancyStats.get_salary_distribution(sample_vacancies_for_stats)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_salary_distribution'

tests/test_advanced_integration_coverage.py:345: AttributeError
_____ TestVacancyStatsAdvancedCoverage.test_vacancy_stats_performance ______

self = <tests.test_advanced_integration_coverage.TestVacancyStatsAdvancedCoverage object at 0x7f15d5114490>

    def test_vacancy_stats_performance(self):
        """Тест производительности статистики"""
        large_vacancy_set = [
            {
                'id': f'perf_{i}',
                'salary_from': 50000 + (i * 1000),
                'salary_to': 80000 + (i * 1500),
                'location': f'City_{i % 10}'
            }
            for i in range(1000)
        ]
    
>       avg_salary = VacancyStats.calculate_average_salary(large_vacancy_set)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'calculate_average_salary'

tests/test_advanced_integration_coverage.py:379: AttributeError
____ TestVacancyStatsAdvancedCoverage.test_vacancy_stats_data_integrity ____

self = <tests.test_advanced_integration_coverage.TestVacancyStatsAdvancedCoverage object at 0x7f15d5114ad0>
sample_vacancies_for_stats = [{'id': 'stat1', 'location': 'Москва', 'salary_from': 80000, 'salary_to': 120000}, {'id': 'stat2', 'location': 'СПб', ...alary_from': 60000, 'salary_to': 90000}, {'id': 'stat4', 'location': 'Казань', 'salary_from': None, 'salary_to': None}]

    def test_vacancy_stats_data_integrity(self, sample_vacancies_for_stats):
        """Тест целостности данных в статистике"""
        # Тестируем что статистики не изменяют исходные данные
        original_data = sample_vacancies_for_stats.copy()
    
>       VacancyStats.calculate_average_salary(sample_vacancies_for_stats)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'calculate_average_salary'

tests/test_advanced_integration_coverage.py:390: AttributeError
________ TestCompleteSystemIntegration.test_complete_data_pipeline _________

self = <tests.test_advanced_integration_coverage.TestCompleteSystemIntegration object at 0x7f15d4f286d0>

    def test_complete_data_pipeline(self):
        """Тест полного конвейера обработки данных"""
        # Инициализация всех компонентов
        postgres_saver = PostgresSaver()
        env_loader = EnvLoader()
        file_handler = FileHandler()
        vacancy_stats = VacancyStats()
        hh_api = HHAPI()
    
        # Полный конвейер обработки данных
        with patch.dict(os.environ, {'API_KEY': 'test_key'}):
            with patch('builtins.open', mock_open()):
                with patch('json.load', return_value={}):
                    with patch('json.dump'):
                        # 1. Загружаем конфигурацию
>                       env_loader.load_dotenv()
                        ^^^^^^^^^^^^^^^^^^^^^^
E                       AttributeError: 'EnvLoader' object has no attribute 'load_dotenv'

tests/test_advanced_integration_coverage.py:512: AttributeError
___________ TestCompleteSystemIntegration.test_system_resilience ___________

self = <tests.test_advanced_integration_coverage.TestCompleteSystemIntegration object at 0x7f15d4f28d50>

    def test_system_resilience(self):
        """Тест устойчивости системы к ошибкам"""
        # Тестируем каскадные ошибки в системе
        postgres_saver = PostgresSaver()
        env_loader = EnvLoader()
        file_handler = FileHandler()
    
        # Сценарий с множественными ошибками
>       with patch.object(env_loader, 'load_dotenv', side_effect=Exception("Env error")):

tests/test_advanced_integration_coverage.py:545: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d40cefd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.utils.env_loader.EnvLoader object at 0x7f15d3f28e50> does not have the attribute 'load_dotenv'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__ TestCompleteSystemIntegration.test_data_consistency_across_components ___

self = <tests.test_advanced_integration_coverage.TestCompleteSystemIntegration object at 0x7f15d5116390>

    def test_data_consistency_across_components(self):
        """Тест консистентности данных между компонентами"""
        test_data = [
            {'id': 'cons1', 'title': 'Consistency Test 1', 'salary_from': 100000},
            {'id': 'cons2', 'title': 'Consistency Test 2', 'salary_from': 120000}
        ]
    
        postgres_saver = PostgresSaver()
        file_handler = FileHandler()
        vacancy_stats = VacancyStats()
    
        with patch('builtins.open', mock_open()):
            with patch('json.dump'):
                with patch('json.load', return_value=test_data):
                    with patch.object(postgres_saver, 'save_vacancies', return_value=[]):
                        # Сохраняем в файл
                        file_handler.write_json('consistency_test.json', test_data)
    
                        # Читаем из файла
                        file_data = file_handler.read_json('consistency_test.json')
    
                        # Рассчитываем статистику
>                       avg_salary = vacancy_stats.calculate_average_salary(file_data)
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                       AttributeError: 'VacancyStats' object has no attribute 'calculate_average_salary'

tests/test_advanced_integration_coverage.py:618: AttributeError
____________ TestVacancyModelsCore.test_employer_functionality _____________

self = <tests.test_core_infrastructure_final.TestVacancyModelsCore object at 0x7f15d4c6e950>

    def test_employer_functionality(self):
        """Тест функциональности Employer"""
        if not VACANCY_MODELS_AVAILABLE:
            return
    
        employer = Employer(name="Tech Corp", employer_id="emp123")
        assert employer.name == "Tech Corp"
>       assert employer.employer_id == "emp123"
               ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'Employer' object has no attribute 'employer_id'

tests/test_core_infrastructure_final.py:105: AttributeError
_____ TestPostgresSaverCoreFixed.test_postgres_saver_with_real_vacancy _____

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7f15d4c8f790>
mock_connect = <MagicMock name='connect' id='139731724594064'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3c9a610>
real_vacancy_object = <src.vacancies.models.Vacancy object at 0x7f15d3caec30>

    @patch('psycopg2.connect')
    def test_postgres_saver_with_real_vacancy(self, mock_connect, postgres_saver, real_vacancy_object):
        """Тест сохранения реального объекта вакансии"""
        if not POSTGRES_SAVER_AVAILABLE or not VACANCY_MODELS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Тестируем с реальным объектом Vacancy
>           result = postgres_saver.save_vacancies([real_vacancy_object])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3c9a610>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f15d3caec30>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_______ TestPostgresSaverCoreFixed.test_postgres_type_validation_fix _______

self = <tests.test_core_infrastructure_final.TestPostgresSaverCoreFixed object at 0x7f15d4c8fd50>
mock_connect = <MagicMock name='connect' id='139731724586256'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3b044d0>

    @patch('psycopg2.connect')
    def test_postgres_type_validation_fix(self, mock_connect, postgres_saver):
        """Тест исправления валидации типов"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 0
        mock_connect.return_value = mock_conn
    
        # Тест с невалидными данными (словари вместо объектов Vacancy)
        invalid_data = [
            {"id": "1", "title": "Job 1", "company_name": "Company 1"},
            {"id": "2", "title": "Job 2", "company_name": "Company 2"}
        ]
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать невалидные типы
>           result = postgres_saver.save_vacancies(invalid_data)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3b044d0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
________ TestUtilsCoreFunctionality.test_menu_manager_functionality ________

self = <tests.test_core_infrastructure_final.TestUtilsCoreFunctionality object at 0x7f15d4c960d0>

    def test_menu_manager_functionality(self):
        """Тест функциональности менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            menu_manager = MenuManager()
    
            if hasattr(menu_manager, 'display_menu'):
                with patch('builtins.print'):
                    menu_items = ['Option 1', 'Option 2', 'Exit']
>                   menu_manager.display_menu(menu_items)
E                   TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_core_infrastructure_final.py:428: TypeError
________ TestCacheCoreFunctionality.test_file_cache_core_operations ________

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7f15d4c974d0>

    def test_file_cache_core_operations(self):
        """Тест основных операций файлового кэша"""
        try:
            from src.utils.cache import FileCache
    
            with tempfile.TemporaryDirectory() as temp_dir:
                cache = FileCache(cache_dir=temp_dir)
    
                test_data = {"test": "data", "items": [1, 2, 3]}
                test_params = {"query": "python", "page": 1}
    
                # Тест сохранения
                cache.save_response("test_source", test_params, test_data)
    
                # Тест загрузки
                loaded_data = cache.load_response("test_source", test_params)
    
                # Тест валидации
>               is_valid = cache.is_valid_response(test_data)
                           ^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'FileCache' object has no attribute 'is_valid_response'

tests/test_core_infrastructure_final.py:498: AttributeError
___________ TestCacheCoreFunctionality.test_cache_error_handling ___________

self = PosixPath('/invalid/path'), mode = 511, parents = True
exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           FileNotFoundError: [Errno 2] No such file or directory: '/invalid/path'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_core_infrastructure_final.TestCacheCoreFunctionality object at 0x7f15d4c97ad0>

    def test_cache_error_handling(self):
        """Тест обработки ошибок кэша"""
        try:
            from src.utils.cache import FileCache
    
            # Тест с недоступной директорией
>           cache = FileCache(cache_dir="/invalid/path")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_infrastructure_final.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/cache.py:17: in __init__
    self._ensure_dir_exists()
src/utils/cache.py:21: in _ensure_dir_exists
    self.cache_dir.mkdir(parents=True, exist_ok=True)
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1120: in mkdir
    self.parent.mkdir(parents=True, exist_ok=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/invalid'), mode = 511, parents = True, exist_ok = True

    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
        """
        Create a new directory at this given path.
        """
        try:
>           os.mkdir(self, mode)
E           OSError: [Errno 30] Read-only file system: '/invalid'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pathlib.py:1116: OSError
_________ TestEdgeCasesCoreFinal.test_none_and_empty_data_handling _________

self = <tests.test_core_infrastructure_final.TestEdgeCasesCoreFinal object at 0x7f15d4c973d0>

    def test_none_and_empty_data_handling(self):
        """Тест обработки None и пустых данных"""
        test_modules = [
            ('src.utils.data_normalizers', 'normalize_area_data'),
            ('src.utils.file_handlers', 'FileHandler'),
            ('src.utils.cache', 'FileCache')
        ]
    
        for module_name, class_or_func_name in test_modules:
            try:
                module = __import__(module_name, fromlist=[class_or_func_name])
>               target = getattr(module, class_or_func_name)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: module 'src.utils.file_handlers' has no attribute 'FileHandler'

tests/test_core_infrastructure_final.py:577: AttributeError
________ TestIntegrationFixed.test_cache_integration_with_api_fixed ________

self = <tests.test_critical_components_fixed.TestIntegrationFixed object at 0x7f15d4cdfc90>

    def test_cache_integration_with_api_fixed(self):
        """Исправленный тест интеграции кэша с API"""
        if not (CACHE_AVAILABLE and HH_API_AVAILABLE):
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
            hh_api = HeadHunterAPI()
    
            # Проверяем базовую совместимость
            assert cache is not None
            assert hh_api is not None
    
            # Тестируем сохранение ответа API в кэш
            api_response = {"items": [], "found": 0}
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 0
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_critical_components_fixed.py:442: KeyError
___________ TestErrorHandlingFixes.test_attribute_error_handling ___________

self = <tests.test_critical_errors_fixed.TestErrorHandlingFixes object at 0x7f15d4cfb210>

    def test_attribute_error_handling(self):
        """Тест обработки ошибок атрибутов"""
    
        mock_obj = Mock()
    
        # Безопасная проверка атрибутов
        has_attr = hasattr(mock_obj, 'nonexistent_attr')
        assert isinstance(has_attr, bool)
    
        # Безопасное получение атрибута
        attr_value = getattr(mock_obj, 'nonexistent_attr', 'default')
>       assert attr_value == 'default'
E       AssertionError: assert <Mock name='mock.nonexistent_attr' id='139731725894864'> == 'default'

tests/test_critical_errors_fixed.py:494: AssertionError
_______ TestPostgresSaverCriticalCoverage.test_transaction_rollback ________

self = <tests.test_critical_missing_coverage.TestPostgresSaverCriticalCoverage object at 0x7f15d4d15fd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3f97490>
mock_connection = (<Mock id='139731727125968'>, <Mock id='139731727125008'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_cursor.execute.side_effect = Exception("Database error")
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            if hasattr(postgres_saver, 'save_vacancies'):
                test_vacancy = {'id': 'error_test', 'title': 'Error Job'}
>               result = postgres_saver.save_vacancies([test_vacancy])
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_critical_missing_coverage.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3f97490>
vacancies = [{'id': 'error_test', 'title': 'Error Job'}]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
___ TestDatabaseManagerImplementation.test_create_tables_implementation ____

self = <tests.test_database_storage_coverage.TestDatabaseManagerImplementation object at 0x7f15d4baea10>

    def test_create_tables_implementation(self):
        """Тест создания таблиц (реальный метод create_tables)"""
        try:
            from src.storage.db_manager import DBManager
    
            db_manager = DBManager()
    
            # Мокируем подключение и курсор
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.__enter__ = Mock(return_value=mock_connection)
            mock_connection.__exit__ = Mock(return_value=None)
            mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
            mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
    
            with patch.object(db_manager, '_get_connection', return_value=mock_connection):
    
>               db_manager.create_tables()

tests/test_database_storage_coverage.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f15d3b79950>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Создаем упрощенную таблицу компаний для целевых компаний
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS companies (
                            id SERIAL PRIMARY KEY,
                            name VARCHAR(255) NOT NULL UNIQUE,
                            hh_id VARCHAR(50),
                            sj_id VARCHAR(50)
                        );
                    """
                    )
                    logger.info("✓ Таблица companies создана/проверена")
    
                    # Создаем полную таблицу вакансий сразу с правильными типами
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS vacancies (
                            id SERIAL PRIMARY KEY,
                            vacancy_id VARCHAR(255) UNIQUE NOT NULL,
                            title TEXT NOT NULL,
                            url TEXT,
                            salary_from INTEGER,
                            salary_to INTEGER,
                            salary_currency VARCHAR(10),
                            description TEXT,
                            requirements TEXT,
                            responsibilities TEXT,
                            experience VARCHAR(100),
                            employment VARCHAR(100),
                            schedule VARCHAR(100),
                            area TEXT,
                            source VARCHAR(50),
                            published_at TIMESTAMP,
                            company_id INTEGER,
                            search_query TEXT,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    """
                    )
    
                    # Проверяем и исправляем тип company_id если нужно
                    cursor.execute(
                        """
                        SELECT data_type
                        FROM information_schema.columns
                        WHERE table_name = 'vacancies' AND column_name = 'company_id'
                    """
                    )
    
                    result = cursor.fetchone()
>                   if result and result[0] not in ("integer", "bigint"):
                                  ^^^^^^^^^
E                   TypeError: 'Mock' object is not subscriptable

src/storage/db_manager.py:203: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.db_manager:db_manager.py:277 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_ TestDatabaseManagerImplementation.test_get_all_vacancies_implementation __

self = <tests.test_database_storage_coverage.TestDatabaseManagerImplementation object at 0x7f15d4baf650>

    def test_get_all_vacancies_implementation(self):
        """Тест получения всех вакансий (реальный метод)"""
        try:
            from src.storage.db_manager import DBManager
    
            db_manager = DBManager()
    
            # Мокируем данные вакансий
            mock_vacancies = [
                ('1', 'Python Developer', 'Great company', 'Company A', '100000-150000 RUR', 'https://job1.com'),
                ('2', 'Java Developer', 'Another job', 'Company B', '120000-180000 RUR', 'https://job2.com')
            ]
    
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = mock_vacancies
>           mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_database_storage_coverage.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731723875024'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_ TestDatabaseManagerImplementation.test_get_vacancies_with_keyword_implementation _

self = <tests.test_database_storage_coverage.TestDatabaseManagerImplementation object at 0x7f15d4bafc50>

    def test_get_vacancies_with_keyword_implementation(self):
        """Тест поиска вакансий по ключевому слову (реальный метод)"""
        try:
            from src.storage.db_manager import DBManager
    
            db_manager = DBManager()
    
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_database_storage_coverage.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731740975888'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_ TestDatabaseManagerImplementation.test_get_companies_and_vacancies_count_implementation _

self = <tests.test_database_storage_coverage.TestDatabaseManagerImplementation object at 0x7f15d4bb0290>

    def test_get_companies_and_vacancies_count_implementation(self):
        """Тест получения статистики компаний (реальный метод)"""
        try:
            from src.storage.db_manager import DBManager
    
            db_manager = DBManager()
    
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = [('Company A', 5), ('Company B', 3)]
>           mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_database_storage_coverage.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731744066832'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___ TestDatabaseManagerImplementation.test_delete_vacancy_implementation ___

self = <tests.test_database_storage_coverage.TestDatabaseManagerImplementation object at 0x7f15d4bb0890>

    def test_delete_vacancy_implementation(self):
        """Тест удаления вакансии (реальный метод)"""
        try:
            from src.storage.db_manager import DBManager
    
            db_manager = DBManager()
    
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_cursor.rowcount = 1
>           mock_connection.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_database_storage_coverage.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731726167888'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_____ TestStorageServiceComponents.test_postgres_saver_implementation ______

self = <tests.test_database_storage_coverage.TestStorageServiceComponents object at 0x7f15d4bb1150>

    def test_postgres_saver_implementation(self):
        """Тест PostgresSaver"""
        try:
            from src.storage.postgres_saver import PostgresSaver
    
            # Мокируем DBManager
            mock_db_manager = Mock()
    
            # Создаем Mock сохранителя вместо импорта
            saver = Mock()
    
            if hasattr(saver, 'save_vacancies'):
                mock_db_manager.add_vacancy_batch_optimized.return_value = None
                saver.save_vacancies([])
    
            if hasattr(saver, 'get_saved_count'):
                    mock_db_manager.get_database_stats.return_value = {'total_vacancies': 100}
                    count = saver.get_saved_count()
>                   assert isinstance(count, (int, type(None)))
E                   AssertionError: assert False
E                    +  where False = isinstance(<Mock name='mock.get_saved_count()' id='139731726283536'>, (<class 'int'>, <class 'NoneType'>))

tests/test_database_storage_coverage.py:323: AssertionError
_ TestStorageServiceComponents.test_vacancy_storage_service_implementation _

self = <tests.test_database_storage_coverage.TestStorageServiceComponents object at 0x7f15d4bb1750>

    def test_vacancy_storage_service_implementation(self):
        """Тест VacancyStorageService"""
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
    
            # Мокируем зависимости
            mock_db_manager = Mock()
            mock_validator = Mock()
    
            # Создаем Mock сервиса вместо инстанцирования абстрактного класса
            service = Mock()
    
            if hasattr(service, 'store_vacancies'):
                mock_db_manager.add_vacancy_batch_optimized.return_value = None
                service.store_vacancies([])
    
            if hasattr(service, 'retrieve_vacancies'):
                    mock_db_manager.get_all_vacancies.return_value = []
                    vacancies = service.retrieve_vacancies()
>                   assert isinstance(vacancies, list)
E                   AssertionError: assert False
E                    +  where False = isinstance(<Mock name='mock.retrieve_vacancies()' id='139731725392656'>, list)

tests/test_database_storage_coverage.py:353: AssertionError
_____ TestDBManagerCoverageFixed.test_db_manager_initialization_fixed ______

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4be4750>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3aa1a50>

    def test_db_manager_initialization_fixed(self, db_manager):
        """Исправленный тест инициализации DBManager"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        assert db_manager is not None
        # Проверяем базовые атрибуты
>       assert hasattr(db_manager, 'database_name')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.db_manager.DBManager object at 0x7f15d3aa1a50>, 'database_name')

tests/test_db_manager_coverage_fixed.py:85: AssertionError
_______ TestDBManagerCoverageFixed.test_create_database_schema_fixed _______

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf4090>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3aa3e50>

    def test_create_database_schema_fixed(self, db_manager):
        """Исправленный тест создания схемы БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        # Используем реальный метод create_tables
        with patch.object(db_manager, '_get_connection', return_value=None):
>           db_manager.create_tables()

tests/test_db_manager_coverage_fixed.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f15d3aa3e50>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'NoneType' object does not support the context manager protocol

src/storage/db_manager.py:147: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.db_manager:db_manager.py:277 Ошибка при создании таблиц: 'NoneType' object does not support the context manager protocol
______ TestDBManagerCoverageFixed.test_populate_companies_table_fixed ______

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf4690>
mock_connect = <MagicMock name='connect' id='139731723794000'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d4b3f750>
mock_connection = (<MagicMock name='connect()' id='139731739604240'>, <MagicMock name='connect().cursor()' id='139731727421840'>)

    @patch('psycopg2.connect')
    def test_populate_companies_table_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест заполнения таблицы компаний"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
>           db_manager.populate_companies_table()

tests/test_db_manager_coverage_fixed.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f15d4b3f750>

    def populate_companies_table(self):
        """Заполняет таблицу companies целевыми компаниями"""
        try:
            # Используем контекстный менеджер для безопасной работы с подключением
            with self._get_connection() as connection:
                with connection.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Проверяем, существует ли таблица companies
                    cursor.execute(
                        """
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables
                            WHERE table_schema = 'public'
                            AND table_name = 'companies'
                        );
                    """
                    )
    
                    table_exists = cursor.fetchone()[0]
                    if not table_exists:
                        logger.warning("Таблица companies не существует. Таблицы должны быть созданы заранее.")
                        return
    
                    # Проверяем, есть ли уже данные в таблице
                    cursor.execute("SELECT COUNT(*) FROM companies")
                    companies_count = cursor.fetchone()[0]
    
>                   if companies_count > 0:
                       ^^^^^^^^^^^^^^^^^^^
E                   TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/db_manager.py:309: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.db_manager:db_manager.py:337 Ошибка при заполнении таблицы companies: '>' not supported between instances of 'MagicMock' and 'int'
_ TestDBManagerCoverageFixed.test_get_companies_and_vacancies_count_fixed __

self = <MagicMock name='connect().cursor().execute' id='139731727669008'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf4c90>
mock_connect = <MagicMock name='connect' id='139731721762640'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d4b3c350>
mock_connection = (<MagicMock name='connect()' id='139731733489360'>, <MagicMock name='connect().cursor()' id='139731733487888'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест получения компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('Tech Corp', 25),
            ('Data Corp', 15)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage_fixed.py:146: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
_________ TestDBManagerCoverageFixed.test_get_all_vacancies_fixed __________

self = <MagicMock name='connect().cursor().execute' id='139731728899856'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf52d0>
mock_connect = <MagicMock name='connect' id='139731726230032'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d195ba90>
mock_connection = (<MagicMock name='connect()' id='139731687278736'>, <MagicMock name='connect().cursor()' id='139731687278096'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = []
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage_fixed.py:162: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='connect().cursor().__enter__().fetchone().__getitem__()' id='139731727157712'>, исправляем...
__ TestDBManagerCoverageFixed.test_get_vacancies_with_higher_salary_fixed __

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf5910>
mock_connect = <MagicMock name='connect' id='139731740349264'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d415b590>
mock_connection = (<MagicMock name='connect()' id='139731743704976'>, <MagicMock name='connect().cursor()' id='139731743706000'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест получения вакансий с высокой зарплатой"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = []
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
>           result = db_manager.get_vacancies_with_higher_salary(100000)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: DBManager.get_vacancies_with_higher_salary() takes 1 positional argument but 2 were given

tests/test_db_manager_coverage_fixed.py:175: TypeError
_____ TestDBManagerCoverageFixed.test_get_vacancies_with_keyword_fixed _____

self = <MagicMock name='connect().cursor().execute' id='139731738917904'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf5f50>
mock_connect = <MagicMock name='connect' id='139731740373008'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d44c5f50>
mock_connection = (<MagicMock name='connect()' id='139731733487888'>, <MagicMock name='connect().cursor()' id='139731733490256'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = []
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_vacancies_with_keyword('python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage_fixed.py:197: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='connect().cursor().__enter__().fetchone().__getitem__()' id='139731726929488'>, исправляем...
___________ TestDBManagerCoverageFixed.test_get_avg_salary_fixed ___________

self = <MagicMock name='connect().cursor().execute' id='139731724245200'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf6590>
mock_connect = <MagicMock name='connect' id='139731687321424'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3ae85d0>
mock_connection = (<MagicMock name='connect()' id='139731722474192'>, <MagicMock name='connect().cursor()' id='139731722472528'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.5,)
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_avg_salary()
    
        assert isinstance(result, (float, int, type(None)))
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage_fixed.py:213: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='connect().cursor().__enter__().fetchone().__getitem__()' id='139731725161616'>, исправляем...
_________ TestDBManagerCoverageFixed.test_get_database_stats_fixed _________

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf6c10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d4baf8d0>

    def test_get_database_stats_fixed(self, db_manager):
        """Исправленный тест получения статистики БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        # Используем реальный метод без подключения
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
        assert 'total_companies' in result
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731723822928'>}

tests/test_db_manager_coverage_fixed.py:225: AssertionError
_______ TestDBManagerCoverageFixed.test_database_name_property_fixed _______

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf7810>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d42073d0>

    def test_database_name_property_fixed(self, db_manager):
        """Исправленный тест свойства имени БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        # Проверяем что database_name установлено
>       assert hasattr(db_manager, 'database_name')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.db_manager.DBManager object at 0x7f15d42073d0>, 'database_name')

tests/test_db_manager_coverage_fixed.py:246: AssertionError
________ TestDBManagerCoverageFixed.test_execute_query_method_fixed ________

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4bf7dd0>
mock_connect = <MagicMock name='connect' id='139731727135632'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d1929810>
mock_connection = (<MagicMock name='connect()' id='139731687092176'>, <MagicMock name='connect().cursor()' id='139731687082256'>)

    @patch('psycopg2.connect')
    def test_execute_query_method_fixed(self, mock_connect, db_manager, mock_connection):
        """Исправленный тест выполнения запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
    
        # Проверяем выполнение базового запроса
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            # Тестируем через реальный метод get_all_vacancies
            db_manager.get_all_vacancies()
    
        # Проверяем что SQL запрос был выполнен
>       assert mock_cursor.execute.called
E       AssertionError: assert False
E        +  where False = <MagicMock name='connect().cursor().execute' id='139731727132880'>.called
E        +    where <MagicMock name='connect().cursor().execute' id='139731727132880'> = <MagicMock name='connect().cursor()' id='139731687082256'>.execute

tests/test_db_manager_coverage_fixed.py:264: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='connect().cursor().__enter__().fetchone().__getitem__()' id='139731722657744'>, исправляем...
_________ TestDBManagerCoverageFixed.test_memory_management_fixed __________

self = <tests.test_db_manager_coverage_fixed.TestDBManagerCoverageFixed object at 0x7f15d4be4e50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3d78510>

    def test_memory_management_fixed(self, db_manager):
        """Исправленный тест управления памятью"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        # Проверяем что объект правильно управляет ресурсами
>       initial_state = db_manager.connection
                        ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'connection'

tests/test_db_manager_coverage_fixed.py:344: AttributeError
______ TestDBManagerEdgeCasesFixed.test_empty_database_handling_fixed ______

self = <tests.test_db_manager_coverage_fixed.TestDBManagerEdgeCasesFixed object at 0x7f15d4bf99d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3e656d0>

    def test_empty_database_handling_fixed(self, db_manager):
        """Исправленный тест работы с пустой БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        with patch.object(db_manager, '_get_connection') as mock_get_conn:
            mock_conn = MagicMock()
            mock_cursor = MagicMock()
            mock_conn.cursor.return_value = mock_cursor
            mock_cursor.fetchall.return_value = []
            mock_cursor.fetchone.return_value = None
            mock_get_conn.return_value = mock_conn
    
            # Тестируем все методы на пустой БД
            vacancies = db_manager.get_all_vacancies()
            companies = db_manager.get_companies_and_vacancies_count()
            avg_salary = db_manager.get_avg_salary()
    
            assert vacancies == []
>           assert companies == []
E           AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
E             
E             Left contains 12 more items, first extra item: ('Яндекс', 0)
E             Use -v to get more diff

tests/test_db_manager_coverage_fixed.py:416: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='_get_connection().__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731724689552'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='_get_connection().__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731724689552'>, исправляем...
________ TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f15d4a6df10>
mock_connect = <MagicMock name='connect' id='139731724933904'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3ae4b50>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f15d1873110>

    @patch('psycopg2.connect')
    def test_save_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения реальных объектов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_cursor.fetchall.return_value = []
        mock_cursor.rowcount = 1
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3ae4b50>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f15d1873110>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________ TestPostgresSaverFinalFixes.test_vacancy_type_validation _________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f15d4a6e550>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3fa9b10>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3fa9b10>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
______ TestPostgresSaverFixedCoverage.test_database_schema_operations ______

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7f15d4a85ad0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3aef610>
mock_connection_complete = (<Mock id='139731725066832'>, <Mock id='139731725060304'>)

    def test_database_schema_operations(self, postgres_saver, mock_connection_complete):
        """Полное покрытие операций со схемой БД"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3d61510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3aef610> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestPostgresSaverFixedCoverage.test_bulk_operations_complete _______

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7f15d4a85e90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3d09290>
mock_connection_complete = (<Mock id='139731723697744'>, <Mock id='139731723695376'>)

    def test_bulk_operations_complete(self, postgres_saver, mock_connection_complete):
        """Полное покрытие массовых операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
        test_companies = [
            {'company_id': 'comp1', 'name': 'Company 1', 'url': 'http://comp1.com'},
            {'company_id': 'comp2', 'name': 'Company 2', 'url': 'http://comp2.com'}
        ]
    
        test_vacancies = [
            {
                'vacancy_id': 'vac1',
                'title': 'Python Developer',
                'company_id': 'comp1',
                'salary_from': 100000,
                'salary_to': 150000,
                'currency': 'RUR',
                'description': 'Python development',
                'url': 'http://vacancy1.com',
                'published_at': datetime.now()
            }
        ]
    
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3c13710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3d09290> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___ TestPostgresSaverFixedCoverage.test_error_handling_and_transactions ____

self = <tests.test_final_critical_coverage.TestPostgresSaverFixedCoverage object at 0x7f15d4a863d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3c71a50>
mock_connection_complete = (<Mock id='139731687168208'>, <Mock id='139731687173392'>)

    def test_error_handling_and_transactions(self, postgres_saver, mock_connection_complete):
        """Полное покрытие обработки ошибок и транзакций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection_complete
    
        # Тест обработки ошибок подключения
        with patch('psycopg2.connect', side_effect=Exception("Database error")):
            if hasattr(postgres_saver, 'save_vacancies'):
                result = postgres_saver.save_vacancies([])
                assert isinstance(result, (int, list, type(None)))
    
        # Тест обработки ошибок выполнения
        mock_cursor.execute.side_effect = Exception("SQL error")
>       with patch.object(postgres_saver, 'get_connection', return_value=mock_conn):

tests/test_final_critical_coverage.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d400fa50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3c71a50> does not have the attribute 'get_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__ TestUnifiedAPIFixedCoverage.test_unified_api_error_resilience_complete __

self = <tests.test_final_critical_coverage.TestUnifiedAPIFixedCoverage object at 0x7f15d4a8eb90>
unified_api = <Mock spec='UnifiedAPI' id='139731687583824'>

    def test_unified_api_error_resilience_complete(self, unified_api):
        """Полное покрытие устойчивости к ошибкам"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Конфигурируем обработку ошибок
>       unified_api.handle_api_error.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_critical_coverage.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock spec='UnifiedAPI' id='139731687583824'>
name = 'handle_api_error'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
>               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'handle_api_error'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:653: AttributeError
_______ TestAppConfigFixedCoverage.test_app_config_loading_complete ________

self = <tests.test_final_critical_coverage.TestAppConfigFixedCoverage object at 0x7f15d4a87a90>
app_config = <Mock spec='AppConfig' id='139731727375568'>

    def test_app_config_loading_complete(self, app_config):
        """Полное покрытие загрузки конфигурации"""
        if not APP_CONFIG_AVAILABLE:
            return
    
        # Конфигурируем Mock для методов конфигурации
>       app_config.load_config.return_value = {}
        ^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_critical_coverage.py:677: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock spec='AppConfig' id='139731727375568'>, name = 'load_config'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
>               raise AttributeError("Mock object has no attribute %r" % name)
E               AttributeError: Mock object has no attribute 'load_config'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:653: AttributeError
____________ TestAppConfigComprehensive.test_get_setting_method ____________

self = <tests.test_final_system_coverage.TestAppConfigComprehensive object at 0x7f15d4ad6510>
app_config = <src.config.app_config.AppConfig object at 0x7f15d3111c90>

    def test_get_setting_method(self, app_config):
        """Тест метода получения настроек"""
        test_settings = [
            'database_url',
            'api_timeout',
            'cache_ttl',
            'debug_mode',
            'nonexistent_setting'
        ]
    
        for setting in test_settings:
>           value = app_config.get_setting(setting)
                    ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'AppConfig' object has no attribute 'get_setting'

tests/test_final_system_coverage.py:305: AttributeError
__________ TestAppConfigComprehensive.test_update_setting_method ___________

self = <tests.test_final_system_coverage.TestAppConfigComprehensive object at 0x7f15d4ad6b50>
app_config = <src.config.app_config.AppConfig object at 0x7f15d3fd4850>

    def test_update_setting_method(self, app_config):
        """Тест метода обновления настроек"""
        test_updates = [
            ('test_setting_1', 'test_value_1'),
            ('test_setting_2', 123),
            ('test_setting_3', True),
            ('test_setting_4', 3.14)
        ]
    
        for key, value in test_updates:
>           app_config.update_setting(key, value)
            ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'AppConfig' object has no attribute 'update_setting'

tests/test_final_system_coverage.py:318: AttributeError
__ TestAppConfigComprehensive.test_app_config_with_environment_variables ___

self = <tests.test_final_system_coverage.TestAppConfigComprehensive object at 0x7f15d4ad71d0>
app_config = <src.config.app_config.AppConfig object at 0x7f15d311cc10>

    def test_app_config_with_environment_variables(self, app_config):
        """Тест конфигурации с переменными окружения"""
        env_vars = {
            'APP_DEBUG': 'True',
            'APP_TIMEOUT': '30',
            'APP_CACHE_SIZE': '1000'
        }
    
        with patch.dict(os.environ, env_vars):
            # Тестируем получение настроек из окружения
            for var_name in env_vars:
                setting_name = var_name.lower().replace('app_', '')
>               value = app_config.get_setting(setting_name)
                        ^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'AppConfig' object has no attribute 'get_setting'

tests/test_final_system_coverage.py:334: AttributeError
________ TestAppConfigComprehensive.test_app_config_default_values _________

self = <tests.test_final_system_coverage.TestAppConfigComprehensive object at 0x7f15d4ad7810>
app_config = <src.config.app_config.AppConfig object at 0x7f15d31c3f10>

    def test_app_config_default_values(self, app_config):
        """Тест значений по умолчанию в конфигурации"""
        default_settings = [
            'page_size',
            'max_results',
            'timeout',
            'retry_count'
        ]
    
        for setting in default_settings:
>           value = app_config.get_setting(setting)
                    ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'AppConfig' object has no attribute 'get_setting'

tests/test_final_system_coverage.py:347: AttributeError
_______ TestFinalSystemIntegration.test_system_configuration_loading _______

self = <tests.test_final_system_coverage.TestFinalSystemIntegration object at 0x7f15d4ae21d0>

    def test_system_configuration_loading(self):
        """Тест загрузки конфигурации системы"""
        config_vars = {
            'DATABASE_URL': 'postgresql://localhost/test',
            'DEBUG': 'True',
            'LOG_LEVEL': 'INFO',
            'CACHE_TTL': '3600'
        }
    
        with patch.dict(os.environ, config_vars):
            app_config = AppConfig()
    
            # Тестируем загрузку конфигурации
            for key in ['database_url', 'debug', 'log_level', 'cache_ttl']:
>               value = app_config.get_setting(key)
                        ^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'AppConfig' object has no attribute 'get_setting'

tests/test_final_system_coverage.py:478: AttributeError
_________ TestFinalSystemIntegration.test_system_error_propagation _________

self = <tests.test_final_system_coverage.TestFinalSystemIntegration object at 0x7f15d4ae15d0>

    def test_system_error_propagation(self):
        """Тест распространения ошибок в системе"""
        # Создаем систему с ошибками в компонентах
        with patch.object(StorageFactory, 'get_default_storage', side_effect=Exception("Storage error")):
>           with patch.object(AppConfig, 'get_setting', side_effect=Exception("Config error")):

tests/test_final_system_coverage.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d31c93d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.config.app_config.AppConfig'> does not have the attribute 'get_setting'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestFinalSystemIntegration.test_system_state_consistency _________

self = <tests.test_final_system_coverage.TestFinalSystemIntegration object at 0x7f15d4ae2750>

    def test_system_state_consistency(self):
        """Тест консистентности состояния системы"""
        # Создаем систему и изменяем её состояние
        app_config = AppConfig()
        storage_interface = StorageInterface()
    
        # Изменяем конфигурацию
>       app_config.update_setting('test_mode', True)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'AppConfig' object has no attribute 'update_setting'

tests/test_final_system_coverage.py:563: AttributeError
____ TestMainApplicationInterfaceCoverage.test_concrete_implementation _____

self = <tests.test_interfaces_coverage.TestMainApplicationInterfaceCoverage object at 0x7f15d496e610>

    def test_concrete_implementation(self):
        """Тест конкретной реализации интерфейса"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            pytest.skip("MainApplicationInterface not available")
    
        # Создаем конкретную реализацию
        class ConcreteInterface(MainApplicationInterface):
            def run_application(self):
                return "Running"
    
>       interface = ConcreteInterface()
                    ^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_interfaces_coverage.py:87: TypeError
___ TestVacancyDisplayHandlerCoverage.test_display_handler_methods_exist ___

self = <tests.test_interfaces_coverage.TestVacancyDisplayHandlerCoverage object at 0x7f15d496ecd0>

    def test_display_handler_methods_exist(self):
        """Тест существования методов обработчика"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        mock_storage = Mock()
        try:
            handler = VacancyDisplayHandler(mock_storage)
        except TypeError:
            handler = VacancyDisplayHandler()
    
        # Проверяем наличие ожидаемых методов
        expected_methods = ['display_vacancies', 'display_vacancy_details', 'show_vacancies']
    
        existing_methods = [method for method in expected_methods if hasattr(handler, method)]
>       assert len(existing_methods) > 0, "Handler should have at least one display method"
E       AssertionError: Handler should have at least one display method
E       assert 0 > 0
E        +  where 0 = len([])

tests/test_interfaces_coverage.py:144: AssertionError
________ TestDBManagerFixed.test_get_companies_and_vacancies_count _________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499c090>
mock_connect = <MagicMock name='connect' id='139731268090384'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b8992bd0>
mock_connection = (<Mock name='connect()' id='139731268087312'>, <Mock id='139731268087760'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
________________ TestDBManagerFixed.test_get_all_vacancies _________________

self = <Mock name='mock.execute' id='139731268158096'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499c650>
mock_connect = <MagicMock name='connect' id='139731268138384'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b899fbd0>
mock_connection = (<Mock name='connect()' id='139731268140368'>, <Mock id='139731268140176'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731268470224'>, исправляем...
__________________ TestDBManagerFixed.test_get_avg_salary __________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499cc10>
mock_connect = <MagicMock name='connect' id='139731268176208'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b89a8410>
mock_connection = (<Mock name='connect()' id='139731268175504'>, <Mock id='139731268175568'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731266719504'>, исправляем...
_________ TestDBManagerFixed.test_get_vacancies_with_higher_salary _________

self = <Mock name='mock.execute' id='139731266587344'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499d210>
mock_connect = <MagicMock name='connect' id='139731268503184'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b8844b90>
mock_connection = (<Mock name='connect()' id='139731266716048'>, <Mock id='139731266717968'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731268381008'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731267173520'>, исправляем...
____________ TestDBManagerFixed.test_get_vacancies_with_keyword ____________

self = <Mock name='mock.execute' id='139731266777872'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499d7d0>
mock_connect = <MagicMock name='connect' id='139731268350096'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b89d39d0>
mock_connection = (<Mock name='connect()' id='139731268353104'>, <Mock id='139731268353168'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731267453648'>, исправляем...
________________ TestDBManagerFixed.test_get_database_stats ________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f15d499dd90>
mock_connect = <MagicMock name='connect' id='139731268347472'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b8800750>
mock_connection = (<Mock name='connect()' id='139731268352272'>, <Mock id='139731268352848'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731266773648'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
___ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects ___

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f15d499e690>
mock_connect = <MagicMock name='connect' id='139731740283664'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15b8836350>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f15b89bedd0>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15b8836350>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f15b89bedd0>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_____________ TestPostgresSaverFixed.test_delete_vacancy_by_id _____________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f15d499f210>
mock_connect = <MagicMock name='connect' id='139731723539920'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d16dbf50>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d16dbf50>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_____ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count ______

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f15d49a81d0>
mock_connect = <MagicMock name='connect' id='139731684827856'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d1702510>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
_____________ TestSimpleDBAdapterFixed.test_get_all_vacancies ______________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f15d49a8790>
mock_connect = <MagicMock name='connect' id='139731684825232'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d1702c90>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
_________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword _________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f15d49a8dd0>
mock_connect = <MagicMock name='connect' id='139731722846096'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3b43210>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
____________ TestSimpleDBAdapterFixed.test_init_database_schema ____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f15d49a9510>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3ab6a50>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3ab71d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3ab6a50> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestAPIModulesFixed.test_hh_api_methods_coverage _____________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f15d49aab50>
mock_get = <MagicMock name='get' id='139731687689104'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
_________ TestAPIModulesFixed.test_cached_api_basic_functionality __________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f15d49ab710>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
_________________ TestEdgeCasesFixed.test_db_empty_results _________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f15d49b27d0>
mock_connect = <MagicMock name='connect' id='139731712496080'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731727880976'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='139731684828624'>, исправляем...
____________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _____________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f15d49b2dd0>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
________ TestAPIModulesIntegration.test_sj_api_basic_functionality _________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7f15d4a0e190>

    def test_sj_api_basic_functionality(self):
        """Тест базовой функциональности SuperJob API"""
        if not SJ_API_AVAILABLE:
            pytest.skip("SuperJobAPI not available")
    
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"objects": [], "total": 0}
            mock_get.return_value = mock_response
    
            sj_api = SuperJobAPI()
            assert sj_api is not None
    
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:86: AssertionError
---------------------------- Captured log call -----------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
WARNING  src.api_modules.cached_api:cached_api.py:159 Данные неполные или повреждены, кэширование пропущено для sj
________ TestAPIModulesIntegration.test_unified_api_filter_methods _________

self = <tests.test_missing_coverage_components.TestAPIModulesIntegration object at 0x7f15d4a0e790>

    def test_unified_api_filter_methods(self):
        """Тест методов фильтрации UnifiedAPI"""
        if not UNIFIED_API_AVAILABLE:
            pytest.skip("UnifiedAPI not available")
    
        api = UnifiedAPI()
        assert api is not None
    
        # Тест пустого списка
        if hasattr(api, '_filter_by_target_companies'):
            result = api._filter_by_target_companies([])
            assert result == []
    
        # Тест с данными
        test_vacancies = [
            {"employer": {"id": "123"}, "title": "Test Job"}
        ]
    
>       with patch.object(api, '_get_target_company_ids', return_value=[]):

tests/test_missing_coverage_components.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3d20210>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7f15d3d21c10> does not have the attribute '_get_target_company_ids'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
---------------------------- Captured log call -----------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______ TestDBManagerCoverage.test_get_companies_and_vacancies_count _______

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f15d4a0d950>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d18e7110>

    def test_get_companies_and_vacancies_count(self, db_manager):
        """Тест получения количества компаний и вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = [("Company A", 10), ("Company B", 5)]
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731725405584'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_______________ TestDBManagerCoverage.test_get_all_vacancies _______________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f15d49f9510>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3ddba90>

    def test_get_all_vacancies(self, db_manager):
        """Тест получения всех вакансий"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731725550608'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
________________ TestDBManagerCoverage.test_get_avg_salary _________________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f15d4a21550>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d19c18d0>

    def test_get_avg_salary(self, db_manager):
        """Тест получения средней зарплаты"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (125000,)
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731687717264'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
_______ TestDBManagerCoverage.test_get_vacancies_with_higher_salary ________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f15d4a21910>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3fa9550>

    def test_get_vacancies_with_higher_salary(self, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731727454224'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__________ TestDBManagerCoverage.test_get_vacancies_with_keyword ___________

self = <tests.test_missing_coverage_components.TestDBManagerCoverage object at 0x7f15d4a21c90>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15b89d8210>

    def test_get_vacancies_with_keyword(self, db_manager):
        """Тест получения вакансий по ключевому слову"""
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731268373264'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
________ TestIntegrationScenarios.test_api_and_database_integration ________

self = <tests.test_missing_coverage_components.TestIntegrationScenarios object at 0x7f15d4a23ed0>

    def test_api_and_database_integration(self):
        """Тест интеграции API и базы данных"""
        if not (UNIFIED_API_AVAILABLE and DB_MANAGER_AVAILABLE):
            pytest.skip("Required modules not available")
    
        with patch('requests.get') as mock_get, \
             patch('psycopg2.connect') as mock_connect:
    
            # Настройка API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            # Настройка DB
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchall.return_value = []
>           mock_conn.cursor.return_value.__enter__.return_value = mock_cursor
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_missing_coverage_components.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.cursor()' id='139731712633488'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
___________________ TestPaginatorCoverage.test_get_page ____________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f15d484d810>
paginator = <Mock id='139731722393168'>

    def test_get_page(self, paginator):
        """Тест получения страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'get_page'):
            page_data = paginator.get_page(0)
>           assert isinstance(page_data, list) or page_data is None
E           AssertionError: assert (False or <Mock name='mock.get_page()' id='139731722393296'> is None)
E            +  where False = isinstance(<Mock name='mock.get_page()' id='139731722393296'>, list)

tests/test_missing_coverage_extended.py:339: AssertionError
_________________ TestPaginatorCoverage.test_previous_page _________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f15d484e4d0>
paginator = <Mock id='139731724262928'>

    def test_previous_page(self, paginator):
        """Тест перехода к предыдущей странице"""
        if not PAGINATOR_AVAILABLE:
            return
    
        # Сначала переходим на следующую страницу
        if hasattr(paginator, 'next_page'):
            paginator.next_page()
    
        if hasattr(paginator, 'previous_page'):
            initial_page = getattr(paginator, 'current_page', 2)
            result = paginator.previous_page()
            if result:
                new_page = getattr(paginator, 'current_page', 1)
>               assert new_page == initial_page - 1
E               assert 0 == (0 - 1)

tests/test_missing_coverage_extended.py:367: AssertionError
_________________ TestPaginatorCoverage.test_has_next_page _________________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f15d484a350>
paginator = <Mock id='139731727948240'>

    def test_has_next_page(self, paginator):
        """Тест проверки наличия следующей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_next_page'):
            result = paginator.has_next_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_next_page()' id='139731727955920'>, bool)

tests/test_missing_coverage_extended.py:376: AssertionError
_______________ TestPaginatorCoverage.test_has_previous_page _______________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f15d484e350>
paginator = <Mock id='139731722397584'>

    def test_has_previous_page(self, paginator):
        """Тест проверки наличия предыдущей страницы"""
        if not PAGINATOR_AVAILABLE:
            return
    
        if hasattr(paginator, 'has_previous_page'):
            result = paginator.has_previous_page()
>           assert isinstance(result, bool)
E           AssertionError: assert False
E            +  where False = isinstance(<Mock name='mock.has_previous_page()' id='139731722391696'>, bool)

tests/test_missing_coverage_extended.py:385: AssertionError
_____________ TestVacancyFormatterCoverage.test_format_salary ______________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7f15d4856b90>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7f15d3d7b9d0>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:555: TypeError
______ TestUIInterfacesCoverage.test_vacancy_display_handler_display _______

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f15d4865b10>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:836: TypeError
_______ TestUIInterfacesCoverage.test_vacancy_search_handler_search ________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f15d4866150>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
_ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate __

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f15d4866750>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:859: TypeError
_____________ TestDatabaseConfigCoverage.test_get_database_url _____________

self = <tests.test_models_data_coverage.TestDatabaseConfigCoverage object at 0x7f15d489af10>
db_config = <src.config.db_config.DatabaseConfig object at 0x7f15d4bdf410>

    def test_get_database_url(self, db_config):
        """Тест получения URL базы данных"""
>       url = db_config.get_database_url()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'get_database_url'

tests/test_models_data_coverage.py:259: AttributeError
___ TestDatabaseConfigCoverage.test_db_config_with_environment_variables ___

self = <tests.test_models_data_coverage.TestDatabaseConfigCoverage object at 0x7f15d489b590>
db_config = <src.config.db_config.DatabaseConfig object at 0x7f15d191b1d0>

    def test_db_config_with_environment_variables(self, db_config):
        """Тест конфигурации с переменными окружения"""
        test_env_vars = {
            'DATABASE_URL': 'postgresql://test:test@localhost/testdb',
            'DB_HOST': 'localhost',
            'DB_PORT': '5432',
            'DB_NAME': 'testdb',
            'DB_USER': 'testuser',
            'DB_PASSWORD': 'testpass'
        }
    
        with patch.dict(os.environ, test_env_vars):
            params = db_config.get_connection_params()
>           url = db_config.get_database_url()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DatabaseConfig' object has no attribute 'get_database_url'

tests/test_models_data_coverage.py:275: AttributeError
_________ TestUIConfigCoverage.test_ui_pagination_config_structure _________

self = <tests.test_models_data_coverage.TestUIConfigCoverage object at 0x7f15d48a0490>

    def test_ui_pagination_config_structure(self):
        """Тест структуры конфигурации пагинации UI"""
>       assert isinstance(ui_pagination_config, dict)
E       assert False
E        +  where False = isinstance(UIPaginationConfig(default_items_per_page=10, search_results_per_page=5, saved_vacancies_per_page=10, top_vacancies_per_page=10, max_items_per_page=50, min_items_per_page=1), dict)

tests/test_models_data_coverage.py:299: AssertionError
__________ TestUIConfigCoverage.test_ui_pagination_config_values ___________

self = <tests.test_models_data_coverage.TestUIConfigCoverage object at 0x7f15d48a0a90>

    def test_ui_pagination_config_values(self):
        """Тест значений конфигурации пагинации"""
        # Проверяем наличие ключевых настроек
        expected_keys = ['page_size', 'max_pages']
    
        for key in expected_keys:
>           if key in ui_pagination_config:
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: argument of type 'UIPaginationConfig' is not iterable

tests/test_models_data_coverage.py:307: TypeError
_____________ TestUIConfigCoverage.test_ui_config_modification _____________

self = <tests.test_models_data_coverage.TestUIConfigCoverage object at 0x7f15d48a1090>

    def test_ui_config_modification(self):
        """Тест модификации конфигурации UI"""
        # Создаем копию для безопасного тестирования
>       original_config = ui_pagination_config.copy()
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIPaginationConfig' object has no attribute 'copy'

tests/test_models_data_coverage.py:314: AttributeError
_________ TestModelIntegration.test_api_vacancy_model_integration __________

self = <tests.test_models_data_coverage.TestModelIntegration object at 0x7f15d48ac7d0>

    def test_api_vacancy_model_integration(self):
        """Тест интеграции API и модели вакансий"""
>       api = BaseJobAPI()
              ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:449: TypeError
____________ TestModelIntegration.test_config_model_integration ____________

self = <tests.test_models_data_coverage.TestModelIntegration object at 0x7f15d48acdd0>

    def test_config_model_integration(self):
        """Тест интеграции конфигурации и моделей"""
        db_config = DatabaseConfig()
    
        # Тестируем использование конфигурации с моделями
        connection_params = db_config.get_connection_params()
    
        # Создаем вакансии с учетом конфигурации
        test_vacancies = []
>       for i in range(ui_pagination_config.get('page_size', 10)):
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIPaginationConfig' object has no attribute 'get'

tests/test_models_data_coverage.py:477: AttributeError
____________ TestModelIntegration.test_complete_model_workflow _____________

self = <tests.test_models_data_coverage.TestModelIntegration object at 0x7f15d48ad410>

    def test_complete_model_workflow(self):
        """Тест полного рабочего процесса моделей"""
        # Инициализация всех компонентов
        db_config = DatabaseConfig()
>       api = BaseJobAPI()
              ^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseJobAPI with abstract methods _validate_vacancy, get_vacancies

tests/test_models_data_coverage.py:493: TypeError
_____________ TestSystemMonitorCoverage.test_get_system_stats ______________

self = <tests.test_monitoring_logging_coverage.TestSystemMonitorCoverage object at 0x7f15d48cdf90>
system_monitor = <tests.test_monitoring_logging_coverage.SystemMonitor object at 0x7f15d3cb5d50>

    def test_get_system_stats(self, system_monitor):
        """Тест получения системной статистики"""
>       with patch('psutil.cpu_percent', return_value=45.2):

tests/test_monitoring_logging_coverage.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_______ TestSystemMonitorCoverage.test_system_monitor_error_handling _______

self = <tests.test_monitoring_logging_coverage.TestSystemMonitorCoverage object at 0x7f15d48cf350>
system_monitor = <tests.test_monitoring_logging_coverage.SystemMonitor object at 0x7f15d199fd50>

    def test_system_monitor_error_handling(self, system_monitor):
        """Тест обработки ошибок в системном мониторе"""
        # Тестируем ошибки при получении статистики
>       with patch('psutil.cpu_percent', side_effect=Exception("CPU error")):

tests/test_monitoring_logging_coverage.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_______ TestSystemMonitorCoverage.test_system_monitor_resource_usage _______

self = <tests.test_monitoring_logging_coverage.TestSystemMonitorCoverage object at 0x7f15d48cf950>
system_monitor = <tests.test_monitoring_logging_coverage.SystemMonitor object at 0x7f15d3a3ac10>

    def test_system_monitor_resource_usage(self, system_monitor):
        """Тест мониторинга использования ресурсов"""
        resource_metrics = [
            ('cpu_percent', 'psutil.cpu_percent', 50.0),
            ('memory_percent', 'psutil.virtual_memory', Mock(percent=70.0)),
            ('disk_usage', 'psutil.disk_usage', Mock(percent=80.0))
        ]
    
        for metric_name, patch_target, return_value in resource_metrics:
>           with patch(patch_target, return_value=return_value):

tests/test_monitoring_logging_coverage.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
________ TestSystemMonitorCoverage.test_system_monitor_performance _________

self = <tests.test_monitoring_logging_coverage.TestSystemMonitorCoverage object at 0x7f15d48cff90>
system_monitor = <tests.test_monitoring_logging_coverage.SystemMonitor object at 0x7f15d19b3250>

    def test_system_monitor_performance(self, system_monitor):
        """Тест производительности системного монитора"""
        # Тестируем что мониторинг не замедляет систему
        start_time = time.time()
    
>       with patch('psutil.cpu_percent', return_value=30.0):

tests/test_monitoring_logging_coverage.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
___________ TestAuditLoggerCoverage.test_audit_logger_compliance ___________

self = <Mock name='getLogger().info' id='139731684649616'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'info' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_monitoring_logging_coverage.TestAuditLoggerCoverage object at 0x7f15d48e7090>

    def test_audit_logger_compliance(self):
        """Тест соответствия аудит логгера требованиям"""
        # Тестируем что все важные поля логируются
        required_fields = ['timestamp', 'action', 'user_id', 'details']
    
        with patch('logging.getLogger') as mock_logger:
            mock_logger.return_value.info = Mock()
            AuditLogger.log_user_action('test_action', 'test_user', {'test': 'data'})
    
            # Проверяем что лог был создан
>           mock_logger.return_value.info.assert_called()
E           AssertionError: Expected 'info' to have been called.

tests/test_monitoring_logging_coverage.py:432: AssertionError
______ TestMetricsCollectorCoverage.test_collect_performance_metrics _______

self = <tests.test_monitoring_logging_coverage.TestMetricsCollectorCoverage object at 0x7f15d48ec590>
metrics_collector = <tests.test_monitoring_logging_coverage.MetricsCollector object at 0x7f15b88be590>

    def test_collect_performance_metrics(self, metrics_collector):
        """Тест сбора метрик производительности"""
>       with patch('psutil.cpu_percent', return_value=45.5):

tests/test_monitoring_logging_coverage.py:464: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_________ TestMetricsCollectorCoverage.test_metrics_error_handling _________

self = <tests.test_monitoring_logging_coverage.TestMetricsCollectorCoverage object at 0x7f15d48ee510>
metrics_collector = <tests.test_monitoring_logging_coverage.MetricsCollector object at 0x7f15d40d0a10>

    def test_metrics_error_handling(self, metrics_collector):
        """Тест обработки ошибок в сборе метрик"""
        # Тестируем ошибки при сборе метрик
>       with patch('psutil.cpu_percent', side_effect=Exception("CPU monitoring error")):

tests/test_monitoring_logging_coverage.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
____ TestMonitoringLoggingIntegration.test_complete_monitoring_workflow ____

self = <tests.test_monitoring_logging_coverage.TestMonitoringLoggingIntegration object at 0x7f15d48ed150>

    def test_complete_monitoring_workflow(self):
        """Тест полного рабочего процесса мониторинга"""
        # Инициализация всех компонентов
        system_monitor = SystemMonitor()
        health_checker = HealthChecker()
        metrics_collector = MetricsCollector()
        alert_manager = AlertManager()
        logger = StructuredLogger('integration_test')
    
        # Полный workflow мониторинга
>       with patch('psutil.cpu_percent', return_value=85):

tests/test_monitoring_logging_coverage.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
______ TestMonitoringLoggingIntegration.test_monitoring_error_cascade ______

self = <tests.test_monitoring_logging_coverage.TestMonitoringLoggingIntegration object at 0x7f15d48ec850>

    def test_monitoring_error_cascade(self):
        """Тест каскада ошибок в мониторинге"""
        components = [
            SystemMonitor(),
            HealthChecker(),
            MetricsCollector(),
            AlertManager(),
            StructuredLogger('error_test')
        ]
    
        # Создаем каскад ошибок
        error_scenarios = [
            ('psutil.cpu_percent', Exception("CPU monitoring failed")),
            ('psycopg2.connect', Exception("Database unavailable")),
            ('smtplib.SMTP', Exception("Email server down"))
        ]
    
        for patch_target, error in error_scenarios:
>           with patch(patch_target, side_effect=error):

tests/test_monitoring_logging_coverage.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
___ TestMonitoringLoggingIntegration.test_monitoring_performance_impact ____

self = <tests.test_monitoring_logging_coverage.TestMonitoringLoggingIntegration object at 0x7f15d48dd0d0>

    def test_monitoring_performance_impact(self):
        """Тест влияния мониторинга на производительность"""
        # Тестируем что мониторинг не замедляет основную работу
        system_monitor = SystemMonitor()
        metrics_collector = MetricsCollector()
    
        # Измеряем производительность без мониторинга
        start_time = time.time()
        for _ in range(100):
            time.sleep(0.001)  # Эмуляция работы
        baseline_time = time.time() - start_time
    
        # Измеряем производительность с мониторингом
        start_time = time.time()
>       with patch('psutil.cpu_percent', return_value=50):

tests/test_monitoring_logging_coverage.py:762: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_ TestMonitoringLoggingIntegration.test_metrics_aggregation_and_reporting __

self = <tests.test_monitoring_logging_coverage.TestMonitoringLoggingIntegration object at 0x7f15d4a02110>

    def test_metrics_aggregation_and_reporting(self):
        """Тест агрегации и отчетности метрик"""
        metrics_collector = MetricsCollector()
    
        # Собираем метрики за период времени
        collected_metrics = []
    
>       with patch('psutil.cpu_percent', side_effect=[30, 40, 50, 60, 70]):

tests/test_monitoring_logging_coverage.py:797: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_____________ TestMemoryManagerCoverage.test_get_memory_usage ______________

self = <tests.test_performance_optimization_coverage.TestMemoryManagerCoverage object at 0x7f15d4752150>

    def test_get_memory_usage(self):
        """Тест получения использования памяти"""
>       with patch('psutil.Process') as mock_process:

tests/test_performance_optimization_coverage.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
______ TestMemoryManagerCoverage.test_memory_manager_error_scenarios _______

self = <tests.test_performance_optimization_coverage.TestMemoryManagerCoverage object at 0x7f15d4752f50>

    def test_memory_manager_error_scenarios(self):
        """Тест сценариев ошибок менеджера памяти"""
        # Тестируем ошибки при получении информации о памяти
>       with patch('psutil.Process', side_effect=Exception("Memory error")):

tests/test_performance_optimization_coverage.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
_______ TestMemoryManagerCoverage.test_memory_monitoring_continuous ________

self = <tests.test_performance_optimization_coverage.TestMemoryManagerCoverage object at 0x7f15d4753550>

    def test_memory_monitoring_continuous(self):
        """Тест непрерывного мониторинга памяти"""
        usage_history = []
    
        for i in range(10):
>           with patch('psutil.Process') as mock_process:

tests/test_performance_optimization_coverage.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:700: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'psutil', import_ = <function _gcd_import at 0x7f15d74f3d80>

>   ???
E   ModuleNotFoundError: No module named 'psutil'

<frozen importlib._bootstrap>:1140: ModuleNotFoundError
________ TestConnectionPoolCoverage.test_connection_pool_max_limit _________

self = <tests.test_performance_optimization_coverage.TestConnectionPoolCoverage object at 0x7f15d475d390>
connection_pool = <tests.test_performance_optimization_coverage.ConnectionPool object at 0x7f15d18592d0>

    def test_connection_pool_max_limit(self, connection_pool):
        """Тест ограничения максимального количества соединений"""
        connections = []
    
        # Пытаемся получить больше соединений чем максимум
        for i in range(10):
            try:
                with patch('psycopg2.connect', return_value=Mock()):
                    conn = connection_pool.get_connection()
                    if conn:
                        connections.append(conn)
            except:
                pass  # Превышение лимита
    
        # Количество не должно превышать максимум
>       assert len(connections) <= connection_pool.max_connections
E       AssertionError: assert 10 <= 5
E        +  where 10 = len([<Mock id='139731267463760'>, <Mock id='139731267456912'>, <Mock id='139731686231568'>, <Mock id='139731686235472'>, <Mock id='139731686240336'>, <Mock id='139731748801296'>, ...])
E        +  and   5 = <tests.test_performance_optimization_coverage.ConnectionPool object at 0x7f15d18592d0>.max_connections

tests/test_performance_optimization_coverage.py:391: AssertionError
________ TestPostgresSaverCoverage.test_database_connection_methods ________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4781d90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d191b550>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
___________ TestPostgresSaverCoverage.test_create_tables_method ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4782410>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d16bffd0>
mock_connection = (<Mock id='139731684542544'>, <Mock name='mock.cursor()' id='139731684545424'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
____________ TestPostgresSaverCoverage.test_save_vacancy_method ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4782ad0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d19180d0>
mock_connection = (<Mock id='139731737947280'>, <Mock name='mock.cursor()' id='139731737949072'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
__________ TestPostgresSaverCoverage.test_save_multiple_vacancies __________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4783150>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d318c7d0>
mock_connection = (<Mock id='139731712668304'>, <Mock name='mock.cursor()' id='139731712670416'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='139731712290896'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='139731712290896'> = <Mock name='mock.cursor()' id='139731712670416'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
___________ TestPostgresSaverCoverage.test_get_vacancies_method ____________

self = <Mock name='mock.cursor().execute' id='139731725558672'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d47837d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d4f71dd0>
mock_connection = (<Mock id='139731712286416'>, <Mock name='mock.cursor()' id='139731712286544'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4783e50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d4020550>
mock_connection = (<Mock id='139731727953744'>, <Mock name='mock.cursor()' id='139731727954640'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
__________ TestPostgresSaverCoverage.test_filter_by_salary_range ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4783950>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d4215ed0>
mock_connection = (<Mock id='139731730003728'>, <Mock name='mock.cursor()' id='139731730000336'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
___________ TestPostgresSaverCoverage.test_get_companies_method ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d4782c50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3bee590>
mock_connection = (<Mock id='139731723544720'>, <Mock name='mock.cursor()' id='139731723545360'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
___________ TestPostgresSaverCoverage.test_delete_vacancy_method ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d477a790>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3b13450>
mock_connection = (<Mock id='139731722641296'>, <Mock name='mock.cursor()' id='139731722642704'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3b13450>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
______________ TestPostgresSaverCoverage.test_clear_all_data _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d475e9d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d31410d0>
mock_connection = (<Mock id='139731712358736'>, <Mock name='mock.cursor()' id='139731712350864'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
___________ TestPostgresSaverCoverage.test_get_statistics_method ___________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d478c510>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d3c2bd50>
mock_connection = (<Mock id='139731723784016'>, <Mock name='mock.cursor()' id='139731723791312'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
______________ TestPostgresSaverCoverage.test_export_to_json _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d478c950>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d5549b10>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
_____________ TestPostgresSaverCoverage.test_import_from_json ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d478cd10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d31e1410>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
___________ TestPostgresSaverCoverage.test_transaction_rollback ____________

self = <Mock name='mock.rollback' id='139731267039952'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d478d910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15b88aff10>
mock_connection = (<Mock id='139731267150608'>, <Mock name='mock.cursor()' id='139731267156432'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
_____________ TestPostgresSaverCoverage.test_batch_operations ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f15d478df90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d16c3310>
mock_connection = (<Mock id='139731684567440'>, <Mock name='mock.cursor()' id='139731684566928'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d16c3310>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
____________ TestFileCacheRealMethods.test_save_and_load_cycle _____________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f15d47a03d0>
cache = <src.utils.cache.FileCache object at 0x7f15d169e790>

    def test_save_and_load_cycle(self, cache):
        """Тест полного цикла сохранения и загрузки"""
        if not CACHE_AVAILABLE:
            return
    
        source = "test"
        params = {"query": "test"}
        data = {"items": [{"id": "1", "title": "Test"}]}
    
        # Сохраняем данные
        cache.save_response(source, params, data)
    
        # Загружаем данные
        loaded_data = cache.load_response(source, params)
    
        if loaded_data is not None:
>           assert loaded_data == data
E           AssertionError: assert {'data': {'it...75638.3705492} == {'items': [{'...le': 'Test'}]}
E             
E             Left contains 3 more items:
E             {'data': {'items': [{'id': '1', 'title': 'Test'}]},
E              'meta': {'params': {'query': '
E             
E             ...Full output truncated (5 lines hidden), use '-vv' to show

tests/test_real_components_coverage.py:266: AssertionError
______________ TestFileCacheRealMethods.test_cache_expiration ______________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f15d47a0a10>
temp_cache_dir = '/tmp/tmp_s9am_wh'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш для тестирования истечения срока действия
        cache = FileCache(cache_dir=temp_cache_dir)
    
        source = "test"
        params = {"query": "test"}
        data = {"test": "data"}
    
        cache.save_response(source, params, data)
    
        # Ждем истечения TTL
        import time
        time.sleep(0.2)
    
        result = cache.load_response(source, params)
        # Данные должны быть None из-за истечения TTL
>       assert result is None
E       AssertionError: assert {'data': {'test': 'data'}, 'meta': {'params': {'query': 'test'}}, 'timestamp': 1757175638.39085} is None

tests/test_real_components_coverage.py:288: AssertionError
______ TestIntegrationWithRealClasses.test_cache_with_api_integration ______

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7f15d47ac390>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:425: KeyError
________________ TestDataSanitizerCoverage.test_clean_html _________________

self = <tests.test_security_validation_coverage.TestDataSanitizerCoverage object at 0x7f15d4653d90>

    def test_clean_html(self):
        """Тест очистки HTML"""
        html_texts = [
            "<p>Параграф текста</p>",
            "<script>alert('danger')</script>Безопасный текст",
            "<b>Жирный</b> и <i>курсивный</i> текст",
            "Текст без HTML",
            "<div><span>Вложенные теги</span></div>"
        ]
    
        for html in html_texts:
            cleaned = DataSanitizer.clean_html(html)
            assert isinstance(cleaned, str)
            # HTML теги должны быть удалены
>           assert '<script>' not in cleaned
E           AssertionError: assert '<script>' not in '<script>ale...пасный текст'
E             
E             '<script>' is contained here:
E               <script>alert('danger')</script>Безопасный текст
E             ? ++++++++

tests/test_security_validation_coverage.py:243: AssertionError
________ TestBusinessRulesCoverage.test_business_rules_integration _________

self = <tests.test_security_validation_coverage.TestBusinessRulesCoverage object at 0x7f15d4663210>

    def test_business_rules_integration(self):
        """Тест интеграции всех бизнес-правил"""
        test_vacancy = {
            'salary_from': 120000,
            'salary_to': 180000,
            'experience': 'middle',
>           'published_at': datetime.now()
                            ^^^^^^^^
        }
E       NameError: name 'datetime' is not defined

tests/test_security_validation_coverage.py:590: NameError
_____ TestSecurityValidationIntegration.test_security_defense_in_depth _____

self = <tests.test_security_validation_coverage.TestSecurityValidationIntegration object at 0x7f15d466e0d0>

    def test_security_defense_in_depth(self):
        """Тест глубокой защиты"""
        malicious_input = "'; DROP TABLE users; --<script>alert('xss')</script>"
    
        # Многоуровневая защита
        # Уровень 1: Валидация ввода
        try:
            is_safe = InputValidator.validate_search_query(malicious_input)
        except:
            is_safe = False
    
        # Уровень 2: Санитизация
        sanitized = InputValidator.sanitize_input(malicious_input)
        cleaned = DataSanitizer.clean_html(sanitized)
        escaped = DataSanitizer.escape_sql(cleaned)
    
        # Уровень 3: Валидация схемы
        test_data = {'query': escaped}
        errors = SchemaValidator.get_validation_errors(test_data)
    
        assert isinstance(is_safe, bool)
        assert isinstance(sanitized, str)
        assert isinstance(cleaned, str)
        assert isinstance(escaped, str)
        assert isinstance(errors, list)
    
        # Вредоносный код должен быть нейтрализован
>       assert '<script>' not in escaped
E       assert '<script>' not in "'; DROP TAB...s')</script>"
E         
E         '<script>' is contained here:
E           '; DROP TABLE users; --<script>alert('xss')</script>
E         ?                        ++++++++

tests/test_security_validation_coverage.py:747: AssertionError
_ TestVacancyOperationsCoordinatorCoverage.test_search_and_save_operation __

self = <tests.test_service_components_coverage.TestVacancyOperationsCoordinatorCoverage object at 0x7f15d46903d0>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15b8816f50>

    def test_search_and_save_operation(self, coordinator):
        """Тест операции поиска и сохранения"""
        search_query = "Python developer"
    
>       with patch.object(coordinator, 'search_and_save', return_value=[]):

tests/test_service_components_coverage.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15b8815b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15b8816f50> does not have the attribute 'search_and_save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___ TestVacancyOperationsCoordinatorCoverage.test_coordinate_operations ____

self = <tests.test_service_components_coverage.TestVacancyOperationsCoordinatorCoverage object at 0x7f15d4690a50>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3118fd0>

    def test_coordinate_operations(self, coordinator):
        """Тест координации операций"""
        operations = ['search', 'filter', 'save']
    
>       with patch.object(coordinator, 'coordinate_operations', return_value=True):

tests/test_service_components_coverage.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3119690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3118fd0> does not have the attribute 'coordinate_operations'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyOperationsCoordinatorCoverage.test_coordinator_error_handling _

self = <tests.test_service_components_coverage.TestVacancyOperationsCoordinatorCoverage object at 0x7f15d4691110>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3edb210>

    def test_coordinator_error_handling(self, coordinator):
        """Тест обработки ошибок в координаторе"""
>       with patch.object(coordinator, 'search_and_save', side_effect=Exception("Coordinator error")):

tests/test_service_components_coverage.py:416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3edbbd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3edb210> does not have the attribute 'search_and_save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyOperationsCoordinatorCoverage.test_complex_workflow_coordination _

self = <tests.test_service_components_coverage.TestVacancyOperationsCoordinatorCoverage object at 0x7f15d4691790>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3e76bd0>

    def test_complex_workflow_coordination(self, coordinator):
        """Тест координации сложного рабочего процесса"""
        # Эмуляция полного цикла операций
        operations_sequence = [
            'initialize',
            'search_vacancies',
            'filter_results',
            'deduplicate',
            'save_to_storage',
            'generate_report'
        ]
    
        for operation in operations_sequence:
>           with patch.object(coordinator, 'coordinate_operations', return_value=True):

tests/test_service_components_coverage.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3e75610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15d3e76bd0> does not have the attribute 'coordinate_operations'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__ TestVacancyOperationsCoordinatorCoverage.test_coordinator_performance ___

self = <tests.test_service_components_coverage.TestVacancyOperationsCoordinatorCoverage object at 0x7f15d4691e10>
coordinator = <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15b88c4610>

    def test_coordinator_performance(self, coordinator):
        """Тест производительности координатора"""
        large_operation_set = [f'operation_{i}' for i in range(100)]
    
>       with patch.object(coordinator, 'coordinate_operations', return_value=True):

tests/test_service_components_coverage.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15b88c6790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.VacancyOperationsCoordinator object at 0x7f15b88c4610> does not have the attribute 'coordinate_operations'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____ TestServiceIntegration.test_filtering_deduplication_integration ______

self = <tests.test_service_components_coverage.TestServiceIntegration object at 0x7f15d4692650>

    def test_filtering_deduplication_integration(self):
        """Тест интеграции фильтрации и дедупликации"""
>       filtering_service = FilteringService()
                            ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:454: TypeError
_______ TestServiceIntegration.test_storage_coordinator_integration ________

self = <tests.test_service_components_coverage.TestServiceIntegration object at 0x7f15d4692c50>

    def test_storage_coordinator_integration(self):
        """Тест интеграции хранения и координатора"""
>       storage_service = VacancyStorageService()
                          ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:477: TypeError
__________ TestServiceIntegration.test_complete_service_workflow ___________

self = <tests.test_service_components_coverage.TestServiceIntegration object at 0x7f15d4693250>

    def test_complete_service_workflow(self):
        """Тест полного рабочего процесса всех сервисов"""
        # Инициализация всех сервисов
>       filtering_service = FilteringService()
                            ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:498: TypeError
_________ TestServiceErrorRecovery.test_filtering_service_recovery _________

self = <tests.test_service_components_coverage.TestServiceErrorRecovery object at 0x7f15d4693a50>

    def test_filtering_service_recovery(self):
        """Тест восстановления сервиса фильтрации после ошибок"""
>       filtering_service = FilteringService()
                            ^^^^^^^^^^^^^^^^^^
E       TypeError: FilteringService.__init__() missing 1 required positional argument: 'strategy'

tests/test_service_components_coverage.py:532: TypeError
__________ TestServiceErrorRecovery.test_storage_service_recovery __________

self = <tests.test_service_components_coverage.TestServiceErrorRecovery object at 0x7f15d4698110>

    def test_storage_service_recovery(self):
        """Тест восстановления сервиса хранения после ошибок"""
>       storage_service = VacancyStorageService()
                          ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_service_components_coverage.py:556: TypeError
_________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46de950>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3bd3dd0>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
_______ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46def90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3f2e9d0>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_________ TestSimpleDBAdapterCoverage.test_execute_query_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46d31d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d4a2ee90>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d4a2ea10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d4a2ee90> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46dee10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3ac4690>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3dab150>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3ac4690> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage _______

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46df550>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3b07a10>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3b06bd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3b07a10> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage __________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46df8d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3b59890>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3b5be90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3b59890> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46dfc50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d19c2f90>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d19c2c10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d19c2f90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46dffd0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3fa2110>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3fa2bd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3fa2110> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46f0350>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d1960710>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d19613d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d1960710> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46f0950>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15b8851550>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15b88513d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15b8851550> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f15d46f0f90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d19b0a90>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3ae4d10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d19b0a90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSuperJobAPIComplete.test_deduplicate_vacancies ____________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f15d4719250>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f15d3e3d2d0>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3118ad0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestPostgresSaver.test_save_vacancies_batch ________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f15d45c3450>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15d1928550>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d1929750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f15d1928550> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestSimpleDBAdapter.test_insert_vacancy __________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f15d45c5250>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15b88c0850>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15b88c0890>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15b88c0850> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestSimpleDBAdapter.test_get_vacancies __________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f15d45c58d0>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3024410>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f15d3026950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f15d3024410> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____ TestStorageIntegration.test_repository_with_validator_integration _____

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f15d45d2cd0>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='139731267318480'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
__ TestVacancyStorageServiceCoverage.test_storage_service_initialization ___

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d45ecdd0>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d45ed410>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f15b88b4f10>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
_______ TestVacancyStorageServiceCoverage.test_search_functionality ________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d45ee710>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f15d3aa3d50>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_________ TestVacancyStorageServiceCoverage.test_delete_operations _________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f15d45eed50>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f15d46832d0>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
______ TestDeduplicationServiceCoverage.test_remove_duplicates_basic _______

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d45efc50>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f15d3e36110>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_____ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _____

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d45f82d0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f15d3e6ee90>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
________ TestDeduplicationServiceCoverage.test_identify_duplicates _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f15d45f8950>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f15d31af650>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_________ TestFilteringServiceCoverage.test_filter_by_salary_range _________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f15d45f8c50>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f15d3ac9f10>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
___________ TestFilteringServiceCoverage.test_filter_by_keyword ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f15d45f9050>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f15d1955850>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
___________ TestFilteringServiceCoverage.test_filter_by_company ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f15d45f9410>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f15d7015210>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
___________ TestFilteringServiceCoverage.test_complex_filtering ____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f15d45f9790>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f15d167fd10>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
____________ TestVacancyRepositoryCoverage.test_create_vacancy _____________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f15d45fa1d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d3b887d0>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
___________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id ___________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f15d45fa810>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d3e34d50>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
____________ TestVacancyRepositoryCoverage.test_update_vacancy _____________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f15d45fae90>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d1955650>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d1955650>
vacancy = <Mock id='139731687275920'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='139731687270992'>: 'Mock' object does not support the context manager protocol
___________ TestVacancyRepositoryCoverage.test_get_all_vacancies ___________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f15d45fbb10>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d3f00550>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d3f00550>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
____________ TestVacancyRepositoryCoverage.test_count_vacancies ____________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f15d45fc190>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f15d31ae610>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f15d45fd710>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f15d3e369d0>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
________ TestVacancyValidatorCoverage.test_validate_required_fields ________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f15d45fdd90>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f15d3d37590>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
__________ TestVacancyValidatorCoverage.test_validate_data_types ___________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f15d45fe3d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f15d19e4510>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
_______________ TestDBManagerFixed.test_database_operations ________________

self = <tests.test_storage_components_fixes.TestDBManagerFixed object at 0x7f15d45f8f10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f15d3e6ed90>
mock_db_connection = (<Mock id='139731726123792'>, <Mock id='139731726123408'>)

    def test_database_operations(self, db_manager, mock_db_connection):
        """Тест операций с базой данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_db_connection
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            # Тестируем различные операции
            operations = ['create_tables', 'drop_tables', 'clear_data']
    
            for operation in operations:
                if hasattr(db_manager, operation):
>                   result = getattr(db_manager, operation)()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f15d3e6ed90>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:147: TypeError
---------------------------- Captured log call -----------------------------
ERROR    src.storage.db_manager:db_manager.py:277 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
______________ TestPostgresSaverFixed.test_delete_operations _______________

self = <tests.test_storage_components_fixes.TestPostgresSaverFixed object at 0x7f15d4609fd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f15b8970890>
mock_connection = (<Mock id='139731684565200'>, <Mock id='139731684567568'>)

    def test_delete_operations(self, postgres_saver, mock_connection):
        """Тест операций удаления"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            delete_methods = ['delete_vacancy_by_id', 'delete_all_vacancies', 'clear_companies']
    
            for method_name in delete_methods:
                if hasattr(postgres_saver, method_name):
                    if method_name == 'delete_vacancy_by_id':
>                       result = getattr(postgres_saver, method_name)('test_id')
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_fixes.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f15b8970890>
vacancy_id = 'test_id'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_ TestAbstractFilterServiceComplete.test_abstract_filter_service_interface _

self = <tests.test_storage_services_complete_coverage.TestAbstractFilterServiceComplete object at 0x7f15d44481d0>

    def test_abstract_filter_service_interface(self):
        """Тест интерфейса AbstractFilterService"""
        if not ABSTRACT_FILTER_SERVICE_AVAILABLE:
            return
    
        # Проверяем что это абстрактный класс
        assert hasattr(AbstractFilterService, '__abstractmethods__')
    
        # Создаем конкретную реализацию
        class ConcreteFilterService(AbstractFilterService):
            def apply_filter(self, data: List[Any], criteria: Dict[str, Any]) -> List[Any]:
                return [item for item in data if item.get('active', True)]
    
            def validate_criteria(self, criteria: Dict[str, Any]) -> bool:
                return isinstance(criteria, dict)
    
>       filter_service = ConcreteFilterService()
                         ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class ConcreteFilterService with abstract methods filter_by_company_ids, get_target_company_stats

tests/test_storage_services_complete_coverage.py:115: TypeError
_ TestMainApplicationInterfaceFixed.test_main_app_interface_initialization _

self = <tests.test_ui_components_missing_tests.TestMainApplicationInterfaceFixed object at 0x7f15d44fff50>

    def test_main_app_interface_initialization(self):
        """Тест инициализации главного интерфейса приложения"""
        if not MAIN_APP_INTERFACE_AVAILABLE:
            return
    
>       mai = MainApplicationInterface()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MainApplicationInterface with abstract method run_application

tests/test_ui_components_missing_tests.py:303: TypeError
_____________ TestPaginatorFixed.test_paginator_initialization _____________

self = <tests.test_ui_components_missing_tests.TestPaginatorFixed object at 0x7f15d4505d10>

    def test_paginator_initialization(self):
        """Тест инициализации пагинатора"""
        if not PAGINATOR_AVAILABLE:
            return
    
>       pag = Paginator(page_size=10)
              ^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_components_missing_tests.py:678: TypeError
______ TestUINavigationExtended.test_paginate_display_custom_actions _______

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f15d43dce90>
mock_print = <MagicMock name='print' id='139731723270864'>
mock_input = <MagicMock name='input' id='139731684470096'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='139731723268432'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
_____ TestCacheUltimateCompleteCoverage.test_cache_complete_lifecycle ______

self = <tests.test_ultimate_coverage_boost.TestCacheUltimateCompleteCoverage object at 0x7f15d44006d0>
file_cache = <src.utils.cache.FileCache object at 0x7f15b8ddc290>

    def test_cache_complete_lifecycle(self, file_cache):
        """Полный жизненный цикл кэша без пропусков"""
        if CACHE_AVAILABLE:
            # Тест сохранения
            source = "test_api"
            params = {"query": "python", "page": 0}
            data = {"items": [{"id": "1", "title": "Python Developer"}]}
    
            file_cache.save_response(source, params, data)
    
            # Тест загрузки
            loaded = file_cache.load_response(source, params)
            if loaded is not None:
>               assert loaded == data
E               AssertionError: assert {'data': {'it...75647.1171036} == {'items': [{'... Developer'}]}
E                 
E                 Left contains 3 more items:
E                 {'data': {'items': [{'id': '1', 'title': 'Python Developer'}]},
E                  'meta': {'params': {'page': ...
E                 
E                 ...Full output truncated (5 lines hidden), use '-vv' to show

tests/test_ultimate_coverage_boost.py:102: AssertionError
========================= short test summary info ==========================
FAILED tests/test_advanced_integration_coverage.py::TestPostgresSaverAdvancedCoverage::test_save_vacancies_method - TypeError: 'Mock' object is not iterable
FAILED tests/test_advanced_integration_coverage.py::TestPostgresSaverAdvancedCoverage::test_batch_optimized_method - TypeError: 'Mock' object is not iterable
FAILED tests/test_advanced_integration_coverage.py::TestPostgresSaverAdvancedCoverage::test_postgres_large_batch_operations - TypeError: 'Mock' object is not iterable
FAILED tests/test_advanced_integration_coverage.py::TestEnvLoaderAdvancedCoverage::test_env_loader_get_var - AttributeError: type object 'EnvLoader' has no attribute 'get_var'
FAILED tests/test_advanced_integration_coverage.py::TestEnvLoaderAdvancedCoverage::test_env_loader_load_dotenv - ModuleNotFoundError: No module named 'dotenv'
FAILED tests/test_advanced_integration_coverage.py::TestEnvLoaderAdvancedCoverage::test_env_loader_with_defaults - AttributeError: type object 'EnvLoader' has no attribute 'get_var'
FAILED tests/test_advanced_integration_coverage.py::TestEnvLoaderAdvancedCoverage::test_env_loader_type_conversions - AttributeError: type object 'EnvLoader' has no attribute 'get_var'
FAILED tests/test_advanced_integration_coverage.py::TestEnvLoaderAdvancedCoverage::test_env_loader_error_handling - ModuleNotFoundError: No module named 'dotenv'
FAILED tests/test_advanced_integration_coverage.py::TestFileHandlerAdvancedCoverage::test_file_handler_read_json - AssertionError: assert {} == {'key': 'valu...'number': 123}
FAILED tests/test_advanced_integration_coverage.py::TestVacancyStatsAdvancedCoverage::test_calculate_average_salary - AttributeError: type object 'VacancyStats' has no attribute 'calculate_...
FAILED tests/test_advanced_integration_coverage.py::TestVacancyStatsAdvancedCoverage::test_get_salary_distribution - AttributeError: type object 'VacancyStats' has no attribute 'get_salary...
FAILED tests/test_advanced_integration_coverage.py::TestVacancyStatsAdvancedCoverage::test_vacancy_stats_performance - AttributeError: type object 'VacancyStats' has no attribute 'calculate_...
FAILED tests/test_advanced_integration_coverage.py::TestVacancyStatsAdvancedCoverage::test_vacancy_stats_data_integrity - AttributeError: type object 'VacancyStats' has no attribute 'calculate_...
FAILED tests/test_advanced_integration_coverage.py::TestCompleteSystemIntegration::test_complete_data_pipeline - AttributeError: 'EnvLoader' object has no attribute 'load_dotenv'
FAILED tests/test_advanced_integration_coverage.py::TestCompleteSystemIntegration::test_system_resilience - AttributeError: <src.utils.env_loader.EnvLoader object at 0x7f15d3f28e5...
FAILED tests/test_advanced_integration_coverage.py::TestCompleteSystemIntegration::test_data_consistency_across_components - AttributeError: 'VacancyStats' object has no attribute 'calculate_avera...
FAILED tests/test_core_infrastructure_final.py::TestVacancyModelsCore::test_employer_functionality - AttributeError: 'Employer' object has no attribute 'employer_id'
FAILED tests/test_core_infrastructure_final.py::TestPostgresSaverCoreFixed::test_postgres_saver_with_real_vacancy - TypeError: 'Mock' object is not iterable
FAILED tests/test_core_infrastructure_final.py::TestPostgresSaverCoreFixed::test_postgres_type_validation_fix - TypeError: 'Mock' object is not iterable
FAILED tests/test_core_infrastructure_final.py::TestUtilsCoreFunctionality::test_menu_manager_functionality - TypeError: MenuManager.display_menu() takes 1 positional argument but 2...
FAILED tests/test_core_infrastructure_final.py::TestCacheCoreFunctionality::test_file_cache_core_operations - AttributeError: 'FileCache' object has no attribute 'is_valid_response'
FAILED tests/test_core_infrastructure_final.py::TestCacheCoreFunctionality::test_cache_error_handling - OSError: [Errno 30] Read-only file system: '/invalid'
FAILED tests/test_core_infrastructure_final.py::TestEdgeCasesCoreFinal::test_none_and_empty_data_handling - AttributeError: module 'src.utils.file_handlers' has no attribute 'File...
FAILED tests/test_critical_components_fixed.py::TestIntegrationFixed::test_cache_integration_with_api_fixed - KeyError: 'found'
FAILED tests/test_critical_errors_fixed.py::TestErrorHandlingFixes::test_attribute_error_handling - AssertionError: assert <Mock name='mock.nonexistent_attr' id='139731725...
FAILED tests/test_critical_missing_coverage.py::TestPostgresSaverCriticalCoverage::test_transaction_rollback - TypeError: 'Mock' object is not iterable
FAILED tests/test_database_storage_coverage.py::TestDatabaseManagerImplementation::test_create_tables_implementation - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_database_storage_coverage.py::TestDatabaseManagerImplementation::test_get_all_vacancies_implementation - AttributeError: __enter__
FAILED tests/test_database_storage_coverage.py::TestDatabaseManagerImplementation::test_get_vacancies_with_keyword_implementation - AttributeError: __enter__
FAILED tests/test_database_storage_coverage.py::TestDatabaseManagerImplementation::test_get_companies_and_vacancies_count_implementation - AttributeError: __enter__
FAILED tests/test_database_storage_coverage.py::TestDatabaseManagerImplementation::test_delete_vacancy_implementation - AttributeError: __enter__
FAILED tests/test_database_storage_coverage.py::TestStorageServiceComponents::test_postgres_saver_implementation - AssertionError: assert False
FAILED tests/test_database_storage_coverage.py::TestStorageServiceComponents::test_vacancy_storage_service_implementation - AssertionError: assert False
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_db_manager_initialization_fixed - AssertionError: assert False
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_create_database_schema_fixed - TypeError: 'NoneType' object does not support the context manager protocol
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_populate_companies_table_fixed - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_companies_and_vacancies_count_fixed - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_all_vacancies_fixed - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_vacancies_with_higher_salary_fixed - TypeError: DBManager.get_vacancies_with_higher_salary() takes 1 positio...
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_vacancies_with_keyword_fixed - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_avg_salary_fixed - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_get_database_stats_fixed - AssertionError: assert 'total_vacancies' in {'salary_distribution': [],...
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_database_name_property_fixed - AssertionError: assert False
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_execute_query_method_fixed - AssertionError: assert False
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerCoverageFixed::test_memory_management_fixed - AttributeError: 'DBManager' object has no attribute 'connection'
FAILED tests/test_db_manager_coverage_fixed.py::TestDBManagerEdgeCasesFixed::test_empty_database_handling_fixed - AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
FAILED tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_save_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_final_coverage_fixes.py::TestPostgresSaverFinalFixes::test_vacancy_type_validation - TypeError: 'Mock' object is not iterable
FAILED tests/test_final_critical_coverage.py::TestPostgresSaverFixedCoverage::test_database_schema_operations - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7...
FAILED tests/test_final_critical_coverage.py::TestPostgresSaverFixedCoverage::test_bulk_operations_complete - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7...
FAILED tests/test_final_critical_coverage.py::TestPostgresSaverFixedCoverage::test_error_handling_and_transactions - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7...
FAILED tests/test_final_critical_coverage.py::TestUnifiedAPIFixedCoverage::test_unified_api_error_resilience_complete - AttributeError: Mock object has no attribute 'handle_api_error'
FAILED tests/test_final_critical_coverage.py::TestAppConfigFixedCoverage::test_app_config_loading_complete - AttributeError: Mock object has no attribute 'load_config'
FAILED tests/test_final_system_coverage.py::TestAppConfigComprehensive::test_get_setting_method - AttributeError: 'AppConfig' object has no attribute 'get_setting'
FAILED tests/test_final_system_coverage.py::TestAppConfigComprehensive::test_update_setting_method - AttributeError: 'AppConfig' object has no attribute 'update_setting'
FAILED tests/test_final_system_coverage.py::TestAppConfigComprehensive::test_app_config_with_environment_variables - AttributeError: 'AppConfig' object has no attribute 'get_setting'
FAILED tests/test_final_system_coverage.py::TestAppConfigComprehensive::test_app_config_default_values - AttributeError: 'AppConfig' object has no attribute 'get_setting'
FAILED tests/test_final_system_coverage.py::TestFinalSystemIntegration::test_system_configuration_loading - AttributeError: 'AppConfig' object has no attribute 'get_setting'
FAILED tests/test_final_system_coverage.py::TestFinalSystemIntegration::test_system_error_propagation - AttributeError: <class 'src.config.app_config.AppConfig'> does not have...
FAILED tests/test_final_system_coverage.py::TestFinalSystemIntegration::test_system_state_consistency - AttributeError: 'AppConfig' object has no attribute 'update_setting'
FAILED tests/test_interfaces_coverage.py::TestMainApplicationInterfaceCoverage::test_concrete_implementation - TypeError: MainApplicationInterface.__init__() missing 3 required posit...
FAILED tests/test_interfaces_coverage.py::TestVacancyDisplayHandlerCoverage::test_display_handler_methods_exist - AssertionError: Handler should have at least one display method
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 t...
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 t...
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 t...
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [],...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companie...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vaca...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancie...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract met...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestAPIModulesIntegration::test_sj_api_basic_functionality - assert False
FAILED tests/test_missing_coverage_components.py::TestAPIModulesIntegration::test_unified_api_filter_methods - AttributeError: <src.api_modules.unified_api.UnifiedAPI object at 0x7f1...
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_all_vacancies - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_avg_salary - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_vacancies_with_higher_salary - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestDBManagerCoverage::test_get_vacancies_with_keyword - AttributeError: __enter__
FAILED tests/test_missing_coverage_components.py::TestIntegrationScenarios::test_api_and_database_integration - AttributeError: __enter__
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_get_page - AssertionError: assert (False or <Mock name='mock.get_page()' id='13973...
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_previous_page - assert 0 == (0 - 1)
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_next_page - AssertionError: assert False
FAILED tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_previous_page - AssertionError: assert False
FAILED tests/test_missing_coverage_extended.py::TestVacancyFormatterCoverage::test_format_salary - TypeError: VacancyFormatter.format_salary() takes 2 positional argument...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_display_handler_display - TypeError: VacancyDisplayHandler.__init__() missing 1 required position...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_search_handler_search - TypeError: VacancySearchHandler.__init__() missing 2 required positiona...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_operations_coordinator_coordinate - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required p...
FAILED tests/test_models_data_coverage.py::TestDatabaseConfigCoverage::test_get_database_url - AttributeError: 'DatabaseConfig' object has no attribute 'get_database_...
FAILED tests/test_models_data_coverage.py::TestDatabaseConfigCoverage::test_db_config_with_environment_variables - AttributeError: 'DatabaseConfig' object has no attribute 'get_database_...
FAILED tests/test_models_data_coverage.py::TestUIConfigCoverage::test_ui_pagination_config_structure - assert False
FAILED tests/test_models_data_coverage.py::TestUIConfigCoverage::test_ui_pagination_config_values - TypeError: argument of type 'UIPaginationConfig' is not iterable
FAILED tests/test_models_data_coverage.py::TestUIConfigCoverage::test_ui_config_modification - AttributeError: 'UIPaginationConfig' object has no attribute 'copy'
FAILED tests/test_models_data_coverage.py::TestModelIntegration::test_api_vacancy_model_integration - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
FAILED tests/test_models_data_coverage.py::TestModelIntegration::test_config_model_integration - AttributeError: 'UIPaginationConfig' object has no attribute 'get'
FAILED tests/test_models_data_coverage.py::TestModelIntegration::test_complete_model_workflow - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
FAILED tests/test_monitoring_logging_coverage.py::TestSystemMonitorCoverage::test_get_system_stats - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestSystemMonitorCoverage::test_system_monitor_error_handling - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestSystemMonitorCoverage::test_system_monitor_resource_usage - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestSystemMonitorCoverage::test_system_monitor_performance - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestAuditLoggerCoverage::test_audit_logger_compliance - AssertionError: Expected 'info' to have been called.
FAILED tests/test_monitoring_logging_coverage.py::TestMetricsCollectorCoverage::test_collect_performance_metrics - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestMetricsCollectorCoverage::test_metrics_error_handling - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestMonitoringLoggingIntegration::test_complete_monitoring_workflow - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestMonitoringLoggingIntegration::test_monitoring_error_cascade - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestMonitoringLoggingIntegration::test_monitoring_performance_impact - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_monitoring_logging_coverage.py::TestMonitoringLoggingIntegration::test_metrics_aggregation_and_reporting - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_performance_optimization_coverage.py::TestMemoryManagerCoverage::test_get_memory_usage - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_performance_optimization_coverage.py::TestMemoryManagerCoverage::test_memory_manager_error_scenarios - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_performance_optimization_coverage.py::TestMemoryManagerCoverage::test_memory_monitoring_continuous - ModuleNotFoundError: No module named 'psutil'
FAILED tests/test_performance_optimization_coverage.py::TestConnectionPoolCoverage::test_connection_pool_max_limit - AssertionError: assert 10 <= 5
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacanci...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_sala...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_save_and_load_cycle - AssertionError: assert {'data': {'it...75638.3705492} == {'items': [{'....
FAILED tests/test_real_components_coverage.py::TestFileCacheRealMethods::test_cache_expiration - AssertionError: assert {'data': {'test': 'data'}, 'meta': {'params': {'...
FAILED tests/test_real_components_coverage.py::TestIntegrationWithRealClasses::test_cache_with_api_integration - KeyError: 'found'
FAILED tests/test_security_validation_coverage.py::TestDataSanitizerCoverage::test_clean_html - AssertionError: assert '<script>' not in '<script>ale...пасный текст'
FAILED tests/test_security_validation_coverage.py::TestBusinessRulesCoverage::test_business_rules_integration - NameError: name 'datetime' is not defined
FAILED tests/test_security_validation_coverage.py::TestSecurityValidationIntegration::test_security_defense_in_depth - assert '<script>' not in "'; DROP TAB...s')</script>"
FAILED tests/test_service_components_coverage.py::TestVacancyOperationsCoordinatorCoverage::test_search_and_save_operation - AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.Vacan...
FAILED tests/test_service_components_coverage.py::TestVacancyOperationsCoordinatorCoverage::test_coordinate_operations - AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.Vacan...
FAILED tests/test_service_components_coverage.py::TestVacancyOperationsCoordinatorCoverage::test_coordinator_error_handling - AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.Vacan...
FAILED tests/test_service_components_coverage.py::TestVacancyOperationsCoordinatorCoverage::test_complex_workflow_coordination - AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.Vacan...
FAILED tests/test_service_components_coverage.py::TestVacancyOperationsCoordinatorCoverage::test_coordinator_performance - AttributeError: <src.ui_interfaces.vacancy_operations_coordinator.Vacan...
FAILED tests/test_service_components_coverage.py::TestServiceIntegration::test_filtering_deduplication_integration - TypeError: FilteringService.__init__() missing 1 required positional ar...
FAILED tests/test_service_components_coverage.py::TestServiceIntegration::test_storage_coordinator_integration - TypeError: Can't instantiate abstract class VacancyStorageService with ...
FAILED tests/test_service_components_coverage.py::TestServiceIntegration::test_complete_service_workflow - TypeError: FilteringService.__init__() missing 1 required positional ar...
FAILED tests/test_service_components_coverage.py::TestServiceErrorRecovery::test_filtering_service_recovery - TypeError: FilteringService.__init__() missing 1 required positional ar...
FAILED tests/test_service_components_coverage.py::TestServiceErrorRecovery::test_storage_service_recovery - TypeError: Can't instantiate abstract class VacancyStorageService with ...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object a...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with ...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'dedupli...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_du...
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_s...
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_k...
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_c...
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multi...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_re...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_da...
FAILED tests/test_storage_components_fixes.py::TestDBManagerFixed::test_database_operations - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_fixes.py::TestPostgresSaverFixed::test_delete_operations - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_storage_services_complete_coverage.py::TestAbstractFilterServiceComplete::test_abstract_filter_service_interface - TypeError: Can't instantiate abstract class ConcreteFilterService with ...
FAILED tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_main_app_interface_initialization - TypeError: Can't instantiate abstract class MainApplicationInterface wi...
FAILED tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_paginator_initialization - TypeError: Paginator() takes no arguments
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_ultimate_coverage_boost.py::TestCacheUltimateCompleteCoverage::test_cache_complete_lifecycle - AssertionError: assert {'data': {'it...75647.1171036} == {'items': [{'....
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_base_api_initialization - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_get_vacancies_method - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_validate_vacancy_method - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_clear_cache_method - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_base_api_with_parameters - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_models_data_coverage.py::TestBaseJobAPICoverage::test_base_api_error_scenarios - TypeError: Can't instantiate abstract class BaseJobAPI with abstract me...
ERROR tests/test_service_components_coverage.py::TestFilteringServiceCoverage::test_filtering_service_initialization - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_service_components_coverage.py::TestFilteringServiceCoverage::test_filtering_with_empty_data - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_service_components_coverage.py::TestFilteringServiceCoverage::test_filtering_error_handling - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_service_components_coverage.py::TestFilteringServiceCoverage::test_filtering_performance - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_service_components_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_service_initialization - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_service_components_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_with_empty_data - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_service_components_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_performance - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_service_components_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_error_handling - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancies - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_get_vacancies - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_process_and_save - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_error_handling - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_batch_storage_operations - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_service_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_with_invalid_data - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_vacancy_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_save_vacancy_single - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_save_vacancies_batch - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_load_vacancy_by_id - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_delete_vacancy_by_id - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_vacancy_exists_check - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestVacancyStorageServiceComplete::test_error_handling_in_operations - TypeError: Can't instantiate abstract class VacancyStorageService with ...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplication_service_initialization - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplicate_by_id - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplicate_by_multiple_fields - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplicate_empty_data - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplicate_single_item - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestDeduplicationServiceComplete::test_deduplication_strategy_configuration - TypeError: DeduplicationService.__init__() missing 1 required positiona...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filtering_service_initialization - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filter_by_salary_range - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filter_by_keywords - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filter_by_company - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filter_by_experience_level - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_combine_multiple_filters - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_filter_validation - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_storage_services_complete_coverage.py::TestFilteringServiceComplete::test_empty_data_filtering - TypeError: FilteringService.__init__() missing 1 required positional ar...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_application_lifecycle - TypeError: Can't instantiate abstract class MainApplicationInterface wi...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_main_application_flow - TypeError: Can't instantiate abstract class MainApplicationInterface wi...
ERROR tests/test_ui_components_missing_tests.py::TestMainApplicationInterfaceFixed::test_configuration_management - TypeError: Can't instantiate abstract class MainApplicationInterface wi...
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_pagination_with_different_datasets - TypeError: Paginator() takes no arguments
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_pagination_navigation_comprehensive - TypeError: Paginator() takes no arguments
ERROR tests/test_ui_components_missing_tests.py::TestPaginatorFixed::test_paginator_configuration - TypeError: Paginator() takes no arguments
!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
========= 190 failed, 2065 passed, 4 skipped, 48 errors in 34.92s ==========
~/workspace$ 