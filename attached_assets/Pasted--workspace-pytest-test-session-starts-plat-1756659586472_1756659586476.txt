~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 285 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py ....                                     [  5%]
tests/test_app_config.py ..F..                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 14%]
tests/test_cached_api.py ....F                                    [ 15%]
tests/test_db_manager.py F...FF.F                                 [ 18%]
tests/test_decorators.py .......                                  [ 21%]
tests/test_env_loader.py ............                             [ 25%]
tests/test_file_handlers.py ............                          [ 29%]
tests/test_get_api.py ......                                      [ 31%]
tests/test_hh_api.py ..F....                                      [ 34%]
tests/test_hh_api_config.py FFFF.                                 [ 35%]
tests/test_hh_parser.py .F..FFF.                                  [ 38%]
tests/test_menu_manager.py .....F....                             [ 42%]
tests/test_paginator.py ....FF                                    [ 44%]
tests/test_postgres_saver.py .......                              [ 46%]
tests/test_salary_utils.py .FF.................                   [ 53%]
tests/test_search_utils.py ......FFFF.                            [ 57%]
tests/test_sj_api.py FF.FFFF                                      [ 60%]
tests/test_sj_api_config.py FF.F.                                 [ 61%]
tests/test_sj_parser.py ........                                  [ 64%]
tests/test_storage_factory.py .F...F..                            [ 67%]
tests/test_target_companies.py FF.F.                              [ 69%]
tests/test_ui_config.py FF...                                     [ 70%]
tests/test_ui_helpers.py ...........                              [ 74%]
tests/test_unified_api.py .................                       [ 80%]
tests/test_user_interface.py .FF..F..                             [ 83%]
tests/test_vacancy_display_handler.py .FFFFFF                     [ 85%]
tests/test_vacancy_formatter.py ..F..F.                           [ 88%]
tests/test_vacancy_models.py ....FFFFFFFF                         [ 92%]
tests/test_vacancy_operations_coordinator.py FF.FFFF.             [ 95%]
tests/test_vacancy_search_handler.py FFFFFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_________________ TestAppConfig.test_app_config_logging _________________

self = <workspace.tests.test_app_config.TestAppConfig object at 0x7fda2af732d0>

    def test_app_config_logging(self):
        """Тест конфигурации логирования"""
        config = AppConfig()
>       assert hasattr(config, 'setup_logging') or callable(getattr(config, 'setup_logging', None))
E       AssertionError: assert (False or False)
E        +  where False = hasattr(<src.config.app_config.AppConfig object at 0x7fda2af59210>, 'setup_logging')
E        +  and   False = callable(None)
E        +    where None = getattr(<src.config.app_config.AppConfig object at 0x7fda2af59210>, 'setup_logging', None)

tests/test_app_config.py:77: AssertionError
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <Mock name='FileCache().clear' id='140574979549968'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fda2af99550>
mock_file_cache = <MagicMock name='FileCache' id='140574979582544'>

    @patch('src.utils.cache.FileCache')
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
        api = TestCachedAPIImplementation()
        api.clear_cache("test")
    
        # Проверяем что метод clear был вызван
>       mock_cache_instance.clear.assert_called()
E       AssertionError: Expected 'clear' to have been called.

tests/test_cached_api.py:92: AssertionError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fda2afc1950>
mock_connect = <MagicMock name='connect' id='140574988046288'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:77: AssertionError
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fda2afc35d0>
mock_connect = <MagicMock name='connect' id='140574979463056'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor.fetch_data = [(125000.0,)]
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем check_connection и create_tables
        with patch.object(db_manager, 'check_connection', return_value=True):
            with patch.object(db_manager, 'create_tables'):
>               result = db_manager.get_avg_salary()
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fda29b7a290>

    def get_avg_salary(self) -> Optional[float]:
        """
        Получает среднюю зарплату по вакансиям
        Использует SQL-функцию AVG() для вычисления средней зарплаты
    
        Returns:
            Optional[float]: Средняя зарплата или None если данных нет
        """
        if not self._ensure_tables_exist():
            return None
    
        query = """
        -- Расчет средней зарплаты по всем вакансиям с использованием функции AVG()
        -- Учитывает различные варианты указания зарплаты и нормализует их к единому значению
        SELECT AVG(
            -- CASE для вычисления единого значения зарплаты из диапазона или отдельных значений
            CASE
                WHEN salary_from IS NOT NULL AND salary_to IS NOT NULL THEN
                    (salary_from + salary_to) / 2                     -- Среднее арифметическое диапазона
                WHEN salary_from IS NOT NULL THEN salary_from          -- Используем минимум, если нет максимума
                WHEN salary_to IS NOT NULL THEN salary_to              -- Используем максимум, если нет минимума
                ELSE NULL                                             -- Исключаем вакансии без зарплаты
            END
        ) as avg_salary                                               -- Применяем AVG() к нормализованным значениям
        FROM vacancies                                                -- Таблица вакансий
        -- Фильтрация: включаем только вакансии с указанной зарплатой
        WHERE (salary_from IS NOT NULL OR salary_to IS NOT NULL)      -- Есть хотя бы одно значение зарплаты
        AND salary_currency IN ('RUR', 'RUB', 'руб.', NULL)          -- Только российские рубли или без валюты
        """
    
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute(query)
                    result = cursor.fetchone()
>                   return float(result[0]) if result[0] is not None else None
                                               ^^^^^^^^^
E                   TypeError: 'NoneType' object is not subscriptable

src/storage/db_manager.py:518: TypeError
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fda2afcdf10>
mock_connect = <MagicMock name='connect' id='140574979574160'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor.fetch_data = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем check_connection и create_tables
        with patch.object(db_manager, 'check_connection', return_value=True):
            with patch.object(db_manager, 'create_tables'):
>               result = db_manager.get_vacancies_with_higher_salary()
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_db_manager.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:536: in get_vacancies_with_higher_salary
    avg_salary = self.get_avg_salary()
                 ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fda29ba5c10>

    def get_avg_salary(self) -> Optional[float]:
        """
        Получает среднюю зарплату по вакансиям
        Использует SQL-функцию AVG() для вычисления средней зарплаты
    
        Returns:
            Optional[float]: Средняя зарплата или None если данных нет
        """
        if not self._ensure_tables_exist():
            return None
    
        query = """
        -- Расчет средней зарплаты по всем вакансиям с использованием функции AVG()
        -- Учитывает различные варианты указания зарплаты и нормализует их к единому значению
        SELECT AVG(
            -- CASE для вычисления единого значения зарплаты из диапазона или отдельных значений
            CASE
                WHEN salary_from IS NOT NULL AND salary_to IS NOT NULL THEN
                    (salary_from + salary_to) / 2                     -- Среднее арифметическое диапазона
                WHEN salary_from IS NOT NULL THEN salary_from          -- Используем минимум, если нет максимума
                WHEN salary_to IS NOT NULL THEN salary_to              -- Используем максимум, если нет минимума
                ELSE NULL                                             -- Исключаем вакансии без зарплаты
            END
        ) as avg_salary                                               -- Применяем AVG() к нормализованным значениям
        FROM vacancies                                                -- Таблица вакансий
        -- Фильтрация: включаем только вакансии с указанной зарплатой
        WHERE (salary_from IS NOT NULL OR salary_to IS NOT NULL)      -- Есть хотя бы одно значение зарплаты
        AND salary_currency IN ('RUR', 'RUB', 'руб.', NULL)          -- Только российские рубли или без валюты
        """
    
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute(query)
                    result = cursor.fetchone()
>                   return float(result[0]) if result[0] is not None else None
                                               ^^^^^^^^^
E                   TypeError: 'NoneType' object is not subscriptable

src/storage/db_manager.py:518: TypeError
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fda2afcea90>
mock_connect = <MagicMock name='connect' id='140574984043280'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем функцию получения целевых компаний
        test_companies = [
            {"id": "1", "name": "Test Company 1"},
            {"id": "2", "name": "Test Company 2"}
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_connection):
>           with patch('src.config.target_companies.get_target_companies', return_value=test_companies):

tests/test_db_manager.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fda28e14c10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.target_companies' from '/home/runner/workspace/tests/../src/config/target_companies.py'> does not have the attribute 'get_target_companies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestHeadHunterAPI.test_get_vacancies_success ______________

self = <workspace.tests.test_hh_api.TestHeadHunterAPI object at 0x7fda2a3a1e50>
mock_paginator = <MagicMock name='Paginator' id='140574965722960'>
mock_api_config = <MagicMock name='APIConfig' id='140574979680336'>
mock_cache = <MagicMock name='FileCache' id='140574979543312'>
mock_connector = <MagicMock name='APIConnector' id='140574965509648'>

    @patch('src.api_modules.hh_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.hh_api.APIConfig')
    @patch('src.api_modules.hh_api.Paginator')
    def test_get_vacancies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения вакансий"""
        # Мок ответа API
        mock_response = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "employer": {"name": "Test Company"},
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "source": "hh.ru"
                }
            ],
            "found": 1,
            "pages": 1
        }
    
        # Настраиваем все моки
        mock_config_instance = Mock()
        mock_config_instance.hh_config.get_params.return_value = {"text": "python", "page": 0}
        mock_config_instance.get_pagination_params.return_value = {"max_pages": 20}
        mock_api_config.return_value = mock_config_instance
    
        api = HeadHunterAPI()
    
        # Мокаем метод подключения к API
        with patch.object(api, '_CachedAPI__connect_to_api', return_value=mock_response):
            result = api.get_vacancies("python")
    
>       assert isinstance(result, list)
E       AssertionError: assert False
E        +  where False = isinstance(<MagicMock name='Paginator().paginate()' id='140574966153616'>, list)

tests/test_hh_api.py:76: AssertionError
_____________ TestHHAPIConfig.test_hh_config_initialization _____________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7fda2a3a8890>

    def test_hh_config_initialization(self):
        """Тест инициализации HH API конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'BASE_URL')

tests/test_hh_api_config.py:11: AssertionError
__________________ TestHHAPIConfig.test_hh_config_urls __________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7fda2a3a1450>

    def test_hh_config_urls(self):
        """Тест URL конфигурации"""
        config = HHAPIConfig()
>       assert config.BASE_URL.startswith('https://api.hh.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'BASE_URL'

tests/test_hh_api_config.py:18: AttributeError
_______________ TestHHAPIConfig.test_hh_config_parameters _______________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7fda2a3a92d0>

    def test_hh_config_parameters(self):
        """Тест параметров конфигурации"""
        config = HHAPIConfig()
>       assert hasattr(config, 'DEFAULT_PER_PAGE')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'DEFAULT_PER_PAGE')

tests/test_hh_api_config.py:25: AssertionError
________________ TestHHAPIConfig.test_hh_config_timeout _________________

self = <workspace.tests.test_hh_api_config.TestHHAPIConfig object at 0x7fda2a3a9650>

    def test_hh_config_timeout(self):
        """Тест настроек таймаута"""
        config = HHAPIConfig()
>       assert hasattr(config, 'TIMEOUT')
E       AssertionError: assert False
E        +  where False = hasattr(HHAPIConfig(area=113, per_page=50, only_with_salary=False, period=15, custom_params={}), 'TIMEOUT')

tests/test_hh_api_config.py:33: AssertionError
__________________ TestHHParser.test_parse_hh_vacancy ___________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fda2a3abbd0>

    def test_parse_hh_vacancy(self):
        """Тест парсинга вакансии HH"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['id'] == '123456'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:31: KeyError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fda2a3b8e50>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {'items': [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies_list(data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_vacancies_list'

tests/test_hh_parser.py:55: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fda2a3b9510>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {'id': '123', 'name': 'Test Job'}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result['id'] == '123'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:63: KeyError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fda2a3b9bd0>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['company'] == 'Test Company'
               ^^^^^^^^^^^^^^^^^
E       KeyError: 'company'

tests/test_hh_parser.py:70: KeyError
_________________ TestMenuManager.test_menu_validation __________________

self = <workspace.tests.test_menu_manager.TestMenuManager object at 0x7fda2a3c9690>

    def test_menu_validation(self):
        """Тест валидации пунктов меню"""
        manager = MenuManager()
    
        # Проверяем что менеджер может работать
>       assert hasattr(manager, 'show_main_menu') or callable(manager)
E       AssertionError: assert (False or False)
E        +  where False = hasattr(<src.utils.menu_manager.MenuManager object at 0x7fda28e64290>, 'show_main_menu')
E        +  and   False = callable(<src.utils.menu_manager.MenuManager object at 0x7fda28e64290>)

tests/test_menu_manager.py:56: AssertionError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <MagicMock name='print' id='140574966407504'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fda2a3d6790>
mock_print = <MagicMock name='print' id='140574966407504'>
mock_input = <MagicMock name='input' id='140574966412496'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Используем правильные параметры
        quick_paginate(items, per_page=2)
    
        # Проверяем что print был вызван
>       mock_print.assert_called()
E       AssertionError: Expected 'print' to have been called.

tests/test_paginator.py:111: AssertionError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <MagicMock name='print' id='140574965853456'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fda2a3d6dd0>
mock_print = <MagicMock name='print' id='140574965853456'>
mock_input = <MagicMock name='input' id='140574965853328'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Используем правильные параметры
        quick_paginate(items, per_page=5)
    
        # Проверяем что print был вызван
>       mock_print.assert_called()
E       AssertionError: Expected 'print' to have been called.

tests/test_paginator.py:126: AssertionError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7fda2a3f5850>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
>       assert parse_salary_range("invalid") is None
E       AssertionError: assert (None, None) is None
E        +  where (None, None) = parse_salary_range('invalid')

tests/test_salary_utils.py:84: AssertionError
_________ TestSalaryUtils.test_parse_salary_range_reverse_order _________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7fda2a3f5e50>

    def test_parse_salary_range_reverse_order(self):
        """Тест парсинга диапазона в обратном порядке"""
        result = parse_salary_range("150000 - 100000")
        # Должно автоматически поменять местами
>       assert result == (100000, 150000)
E       assert (150000, 100000) == (100000, 150000)
E         
E         At index 0 diff: 150000 != 100000
E         Use -v to get more diff

tests/test_salary_utils.py:93: AssertionError
___________ TestAdvancedSearch.test_search_with_and_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7fda29f0a450>

    def test_search_with_and_operator(self):
        """Тест поиска с оператором AND"""
        vacancies = [
            Vacancy("123", "Python Django Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Python Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "Django Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_and(vacancies, ["python", "django"])
    
        # Должна найтись только первая вакансия
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_search_utils.py:76: AssertionError
____________ TestAdvancedSearch.test_search_with_or_operator ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7fda29f0a790>

    def test_search_with_or_operator(self):
        """Тест поиска с оператором OR"""
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
            Vacancy("125", "C++ Developer", "https://test3.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["python", "java"])
    
        # Должны найтись первые две вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:91: AssertionError
____________ TestAdvancedSearch.test_search_case_insensitive ____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7fda29f0ab10>

    def test_search_case_insensitive(self):
        """Тест поиска без учета регистра"""
        vacancies = [
            Vacancy("123", "PYTHON Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "python developer", "https://test2.com", "hh.ru")
        ]
    
        search = AdvancedSearch()
        result = search.search_with_or(vacancies, ["Python"])
    
        # Должны найтись обе вакансии
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_search_utils.py:104: AssertionError
_____________ TestAdvancedSearch.test_search_in_description _____________

self = <workspace.tests.test_search_utils.TestAdvancedSearch object at 0x7fda29f0b010>

    def test_search_in_description(self):
        """Тест поиска в описании вакансии"""
        vacancies = [
>           Vacancy("123", "Developer", "https://test.com", "hh.ru",
                   description="Work with Python and Django"),
            Vacancy("124", "Developer", "https://test2.com", "hh.ru",
                   description="Work with Java")
        ]
E       TypeError: Vacancy.__init__() got multiple values for argument 'description'

tests/test_search_utils.py:109: TypeError
______________ TestSuperJobAPI.test_sj_api_initialization _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f121d0>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJobAPI"""
        api = SuperJobAPI()
>       assert hasattr(api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fda28e89e90>, 'base_url')

tests/test_sj_api.py:16: AssertionError
_______________ TestSuperJobAPI.test_sj_api_with_api_key ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f127d0>

    def test_sj_api_with_api_key(self):
        """Тест инициализации с API ключом"""
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:21: TypeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f133d0>
mock_get = <MagicMock name='get' id='140574965982736'>

    @patch('requests.Session.get')
    def test_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "firm_name": "Test Company",
                    "payment_from": 100000,
                    "payment_to": 150000,
                    "town": {"title": "Москва"}
                }
            ],
            "total": 1
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:52: TypeError
____________ TestSuperJobAPI.test_get_vacancy_by_id_success _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f13990>
mock_get = <MagicMock name='get' id='140574979277008'>

    @patch('requests.Session.get')
    def test_get_vacancy_by_id_success(self, mock_get):
        """Тест успешного получения вакансии по ID"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "profession": "Python Developer",
            "firm_name": "Test Company"
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       api = SuperJobAPI(api_key="test_key")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: SuperJobAPI.__init__() got an unexpected keyword argument 'api_key'

tests/test_sj_api.py:70: TypeError
________________ TestSuperJobAPI.test_api_key_validation ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f13f90>

    def test_api_key_validation(self):
        """Тест валидации API ключа"""
        api = SuperJobAPI()
    
        # Проверяем обработку отсутствующего API ключа
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fda28eed210>, 'api_key')

tests/test_sj_api.py:81: AssertionError
_____________ TestSuperJobAPI.test_api_key_from_environment _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fda29f20550>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'env_test_key'})
    def test_api_key_from_environment(self):
        """Тест получения API ключа из переменной окружения"""
        api = SuperJobAPI()
        # API должен использовать ключ из окружения
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fda29b46310>, 'api_key')

tests/test_sj_api.py:88: AssertionError
_____________ TestSJAPIConfig.test_sj_config_initialization _____________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7fda29f0a9d0>

    def test_sj_config_initialization(self):
        """Тест инициализации SuperJob API конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'BASE_URL')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'BASE_URL')

tests/test_sj_api_config.py:11: AssertionError
__________________ TestSJAPIConfig.test_sj_config_urls __________________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7fda29f20350>

    def test_sj_config_urls(self):
        """Тест URL конфигурации"""
        config = SJAPIConfig()
>       assert config.BASE_URL.startswith('https://api.superjob.ru')
               ^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'BASE_URL'

tests/test_sj_api_config.py:17: AttributeError
_______________ TestSJAPIConfig.test_sj_config_parameters _______________

self = <workspace.tests.test_sj_api_config.TestSJAPIConfig object at 0x7fda29f213d0>

    def test_sj_config_parameters(self):
        """Тест параметров конфигурации"""
        config = SJAPIConfig()
>       assert hasattr(config, 'DEFAULT_COUNT')
E       AssertionError: assert False
E        +  where False = hasattr(SJAPIConfig(count=500, published=15, custom_params=None), 'DEFAULT_COUNT')

tests/test_sj_api_config.py:31: AssertionError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fda28eeca10>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=postgres"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fda29f2ba10>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140574966341200'>
mock_app_config = <MagicMock name='AppConfig' id='140574979359312'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_postgres_storage(self, mock_postgres_saver, mock_app_config):
        """Тест создания PostgreSQL хранилища с моками"""
        # Настраиваем моки
        mock_config_instance = Mock()
        mock_config_instance.get_db_config.return_value = {'host': 'localhost'}
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=Project03"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'Project03', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД Project03: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных Project03 недоступна и не может быть создана
_________ TestStorageFactory.test_create_storage_with_db_config _________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fda29b66a10>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=postgres'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fda29f38110>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140574979290640'>
mock_app_config = <MagicMock name='AppConfig' id='140574979288464'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_storage_with_db_config(self, mock_postgres_saver, mock_app_config):
        """Тест создания хранилища с конфигурацией БД"""
        # Настраиваем моки
        mock_config_instance = Mock()
        test_db_config = {
            'host': 'test_host',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
        mock_config_instance.get_db_config.return_value = test_db_config
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=test_db'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'test_db', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД test_db: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных test_db недоступна и не может быть создана
_______ TestTargetCompanies.test_target_companies_initialization ________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7fda29f39290>

    def test_target_companies_initialization(self):
        """Тест инициализации списка целевых компаний"""
        companies = TargetCompanies()
>       assert hasattr(companies, 'companies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.target_companies.TargetCompanies object at 0x7fda2b55f7d0>, 'companies')

tests/test_target_companies.py:44: AssertionError
________ TestTargetCompanies.test_get_target_companies_function _________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7fda29f39890>

    def test_get_target_companies_function(self):
        """Тест функции получения целевых компаний"""
        companies = get_target_companies()
>       assert isinstance(companies, (list, dict))
E       AssertionError: assert False
E        +  where False = isinstance(<src.config.target_companies.TargetCompanies object at 0x7fda29b79510>, (<class 'list'>, <class 'dict'>))

tests/test_target_companies.py:50: AssertionError
_____________ TestTargetCompanies.test_companies_not_empty ______________

self = <workspace.tests.test_target_companies.TestTargetCompanies object at 0x7fda29f3a4d0>

    def test_companies_not_empty(self):
        """Тест что список компаний не пустой"""
        companies = get_target_companies()
>       assert len(companies) > 0
               ^^^^^^^^^^^^^^
E       TypeError: object of type 'TargetCompanies' has no len()

tests/test_target_companies.py:67: TypeError
______________ TestUIConfig.test_ui_config_initialization _______________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7fda29f4c090>

    def test_ui_config_initialization(self):
        """Тест инициализации UI конфигурации"""
        config = UIConfig()
>       assert hasattr(config, 'PAGINATION_SIZE')
E       AssertionError: assert False
E        +  where False = hasattr(UIConfig(items_per_page=5, max_display_items=20), 'PAGINATION_SIZE')

tests/test_ui_config.py:10: AssertionError
________________ TestUIConfig.test_ui_config_pagination _________________

self = <workspace.tests.test_ui_config.TestUIConfig object at 0x7fda29f4cc10>

    def test_ui_config_pagination(self):
        """Тест настроек пагинации"""
        config = UIConfig()
>       assert config.PAGINATION_SIZE > 0
               ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UIConfig' object has no attribute 'PAGINATION_SIZE'

tests/test_ui_config.py:16: AttributeError
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <MagicMock name='_handle_choice' id='140574979409616'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_handle_choice' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fda29f997d0>
mock_stdout = <_io.StringIO object at 0x7fda29319090>
mock_input = <MagicMock name='input' id='140574966355152'>

    @patch('builtins.input', return_value='0')
    @patch('sys.stdout', new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
        with patch.object(ui, '_display_menu'):
            with patch.object(ui, '_handle_choice') as mock_handle:
                mock_handle.return_value = False
                ui.run()
>               mock_handle.assert_called()
E               AssertionError: Expected '_handle_choice' to have been called.

tests/test_user_interface.py:63: AssertionError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <MagicMock name='_search_vacancies' id='140574975005776'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_search_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fda29f99b90>
mock_input = <MagicMock name='input' id='140574979676560'>

    @patch('builtins.input', return_value='1')
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
        with patch.object(ui, '_search_vacancies') as mock_search:
            result = ui._handle_choice('1')
            if hasattr(ui, '_search_vacancies'):
>               mock_search.assert_called()
E               AssertionError: Expected '_search_vacancies' to have been called.

tests/test_user_interface.py:72: AssertionError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fda29f99250>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        with patch('builtins.input', side_effect=KeyboardInterrupt):
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

tests/test_user_interface.py:92: Failed
______ TestVacancyDisplayHandler.test_display_vacancies_empty_list ______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb5dd0>
mock_print = <MagicMock name='print' id='140574965847568'>

    @patch('builtins.print')
    def test_display_vacancies_empty_list(self, mock_print):
        """Тест отображения пустого списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       handler.display_vacancies([])
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:84: AttributeError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb6610>
mock_print = <MagicMock name='print' id='140574965789840'>

    @patch('builtins.print')
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru")
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:100: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb6ad0>
mock_paginate = <MagicMock name='quick_paginate' id='140574979457680'>

    @patch('src.ui_interfaces.vacancy_display_handler.quick_paginate')
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:115: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb7090>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:131: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb7950>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124",
            title="Junior Developer",
            url="https://test.com/vacancy/124",
            source="hh.ru",
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:153: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fda29fb7c10>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(
            id="125",
            title="Intern",
            url="https://test.com/vacancy/125",
            source="hh.ru",
            salary=salary
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:174: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fda29fbdf90>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fda28e8c3a0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fda29fbf1d0>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость"
        )

tests/test_vacancy_formatter.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fda29359a20>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
________________ TestVacancy.test_vacancy_initialization ________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd1a10>

    def test_vacancy_initialization(self):
        """Тест инициализации Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:78: TypeError
_________________ TestVacancy.test_vacancy_with_salary __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd2010>

    def test_vacancy_with_salary(self):
        """Тест вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            salary=str(salary), # Assuming salary is converted to string for the placeholder Vacancy
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:96: TypeError
________________ TestVacancy.test_vacancy_with_employer _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd2610>

    def test_vacancy_with_employer(self):
        """Тест вакансии с работодателем"""
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            description="Test description",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:109: TypeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd2c50>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:125: TypeError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd3290>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            vacancy_id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"],
            source="hh.ru"
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:180: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd38d0>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            vacancy_id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"],
            source="superjob.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:200: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29fd3ed0>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:219: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fda29f94510>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary),
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:242: TypeError
___ TestVacancyOperationsCoordinator.test_coordinator_initialization ____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29fed8d0>

    def test_coordinator_initialization(self):
        """Тест инициализации VacancyOperationsCoordinator"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
>       assert coordinator.api == mock_api
               ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyOperationsCoordinator' object has no attribute 'api'

tests/test_vacancy_operations_coordinator.py:21: AttributeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29fede90>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='140574965816080'>

    @patch('src.ui_interfaces.vacancy_search_handler.VacancySearchHandler')
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7fda2b77f910>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29feea50>
mock_print = <MagicMock name='print' id='140574965939792'>
mock_input = <MagicMock name='input' id='140575006498768'>

    @patch('builtins.input', return_value='5')
    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, mock_input):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
>       from src.vacancies.models import Vacancy, VacancySalary
E       ImportError: cannot import name 'VacancySalary' from 'src.vacancies.models' (/home/runner/workspace/tests/../src/vacancies/models.py)

tests/test_vacancy_operations_coordinator.py:62: ImportError
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29fef010>
mock_print = <MagicMock name='print' id='140574979422928'>
mock_input = <MagicMock name='input' id='140574965663632'>

    @patch('builtins.input', return_value='Python')
    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, mock_input):
        """Тест поиска сохраненных вакансий по ключевому слову"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:86: NameError
_____ TestVacancyOperationsCoordinator.test_handle_delete_vacancies _____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29fef5d0>
mock_input = <MagicMock name='input' id='140574979279120'>

    @patch('builtins.input', return_value='Python')
    def test_handle_delete_vacancies(self, mock_input):
        """Тест удаления вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:103: NameError
______ TestVacancyOperationsCoordinator.test_handle_cache_cleanup _______

self = <Mock name='mock.clear_cache' id='140575000807184'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear_cache' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fda29fefbd0>

    def test_handle_cache_cleanup(self):
        """Тест очистки кэша"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
        with patch('builtins.print'):
            coordinator.handle_cache_cleanup()
    
        # Проверяем, что очистка кэша была вызвана
>       mock_api.clear_cache.assert_called()
E       AssertionError: Expected 'clear_cache' to have been called.

tests/test_vacancy_operations_coordinator.py:126: AssertionError
------------------------- Captured stdout call --------------------------
Ваш выбор: 
--------------------------- Captured log call ---------------------------
ERROR    src.ui_interfaces.vacancy_operations_coordinator:vacancy_operations_coordinator.py:78 Ошибка при очистке кэша: pytest: reading from stdin while output is captured!  Consider using `-s`.
__ TestVacancySearchHandler.test_vacancy_search_handler_initialization __

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29fee210>

    def test_vacancy_search_handler_initialization(self):
        """Тест инициализации VacancySearchHandler"""
        mock_api = Mock()
        mock_storage = Mock()
    
        handler = VacancySearchHandler(mock_api, mock_storage)
    
>       assert handler.api == mock_api
               ^^^^^^^^^^^
E       AttributeError: 'VacancySearchHandler' object has no attribute 'api'

tests/test_vacancy_search_handler.py:22: AttributeError
__________ TestVacancySearchHandler.test_handle_search_success __________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29ffdfd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fda29ffca50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_empty_query ________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29ffe350>
mock_input = <MagicMock name='input' id='140574965979408'>

    @patch('builtins.input', return_value='')
    def test_handle_search_empty_query(self, mock_input):
        """Тест поиска с пустым запросом"""
        mock_api = Mock()
        mock_storage = Mock()
    
        handler = VacancySearchHandler(mock_api, mock_storage)
>       result = handler.handle_search()
                 ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySearchHandler' object has no attribute 'handle_search'

tests/test_vacancy_search_handler.py:52: AttributeError
________ TestVacancySearchHandler.test_handle_search_no_results _________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29ffe710>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fda29ffcf10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_with_saving ________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29ffea90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fda29ffd250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancySearchHandler.test_handle_search_cancelled_source_selection _

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fda29fff050>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fda29ffd450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
=========================== warnings summary ============================
tests/test_cached_api.py:14
  /home/runner/workspace/tests/test_cached_api.py:14: PytestCollectionWarning: cannot collect test class 'TestCachedAPIImplementation' because it has a __init__ constructor (from: tests/test_cached_api.py)
    class TestCachedAPIImplementation(CachedAPI):

tests/test_unified_api.py:57
  /home/runner/workspace/tests/test_unified_api.py:57: PytestCollectionWarning: cannot collect test class 'TestUnifiedAPI' because it has a __init__ constructor (from: tests/test_unified_api.py)
    class TestUnifiedAPI:

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== short test summary info ========================
FAILED tests/test_app_config.py::TestAppConfig::test_app_config_logging - AssertionError: assert (False or False)
FAILED tests/test_cached_api.py::TestCachedAPI::test_clear_cache_method - AssertionError: Expected 'clear' to have been called.
FAILED tests/test_db_manager.py::TestDBManager::test_check_connection_success - assert False is True
FAILED tests/test_db_manager.py::TestDBManager::test_get_avg_salary - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - AttributeError: <module 'src.config.target_companies' from '/home/ru...
FAILED tests/test_hh_api.py::TestHeadHunterAPI::test_get_vacancies_success - AssertionError: assert False
FAILED tests/test_hh_api_config.py::TestHHAPIConfig::test_hh_config_initialization - AssertionError: assert False
FAILED tests/test_hh_api_config.py::TestHHAPIConfig::test_hh_config_urls - AttributeError: 'HHAPIConfig' object has no attribute 'BASE_URL'
FAILED tests/test_hh_api_config.py::TestHHAPIConfig::test_hh_config_parameters - AssertionError: assert False
FAILED tests/test_hh_api_config.py::TestHHAPIConfig::test_hh_config_timeout - AssertionError: assert False
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancy - KeyError: 'id'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancies_list - AttributeError: 'HHParser' object has no attribute 'parse_vacancies_...
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancy_minimal_data - KeyError: 'id'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_employer_data - KeyError: 'company'
FAILED tests/test_menu_manager.py::TestMenuManager::test_menu_validation - AssertionError: assert (False or False)
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_quit - AssertionError: Expected 'print' to have been called.
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_navigation - AssertionError: Expected 'print' to have been called.
FAILED tests/test_salary_utils.py::TestSalaryUtils::test_parse_salary_range_invalid - AssertionError: assert (None, None) is None
FAILED tests/test_salary_utils.py::TestSalaryUtils::test_parse_salary_range_reverse_order - assert (150000, 100000) == (100000, 150000)
FAILED tests/test_search_utils.py::TestAdvancedSearch::test_search_with_and_operator - assert 0 == 1
FAILED tests/test_search_utils.py::TestAdvancedSearch::test_search_with_or_operator - assert 0 == 2
FAILED tests/test_search_utils.py::TestAdvancedSearch::test_search_case_insensitive - assert 0 == 2
FAILED tests/test_search_utils.py::TestAdvancedSearch::test_search_in_description - TypeError: Vacancy.__init__() got multiple values for argument 'desc...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_sj_api_initialization - AssertionError: assert False
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_sj_api_with_api_key - TypeError: SuperJobAPI.__init__() got an unexpected keyword argument...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancies_success - TypeError: SuperJobAPI.__init__() got an unexpected keyword argument...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancy_by_id_success - TypeError: SuperJobAPI.__init__() got an unexpected keyword argument...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_api_key_validation - AssertionError: assert False
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_api_key_from_environment - AssertionError: assert False
FAILED tests/test_sj_api_config.py::TestSJAPIConfig::test_sj_config_initialization - AssertionError: assert False
FAILED tests/test_sj_api_config.py::TestSJAPIConfig::test_sj_config_urls - AttributeError: 'SJAPIConfig' object has no attribute 'BASE_URL'
FAILED tests/test_sj_api_config.py::TestSJAPIConfig::test_sj_config_parameters - AssertionError: assert False
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_postgres_storage - psycopg2.OperationalError: connection to server at "localhost" (127....
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_storage_with_db_config - psycopg2.OperationalError: could not translate host name "test_host"...
FAILED tests/test_target_companies.py::TestTargetCompanies::test_target_companies_initialization - AssertionError: assert False
FAILED tests/test_target_companies.py::TestTargetCompanies::test_get_target_companies_function - AssertionError: assert False
FAILED tests/test_target_companies.py::TestTargetCompanies::test_companies_not_empty - TypeError: object of type 'TargetCompanies' has no len()
FAILED tests/test_ui_config.py::TestUIConfig::test_ui_config_initialization - AssertionError: assert False
FAILED tests/test_ui_config.py::TestUIConfig::test_ui_config_pagination - AttributeError: 'UIConfig' object has no attribute 'PAGINATION_SIZE'
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_run_exit - AssertionError: Expected '_handle_choice' to have been called.
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_handle_search - AssertionError: Expected '_search_vacancies' to have been called.
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_error_handling - Failed: DID NOT RAISE <class 'KeyboardInterrupt'>
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_empty_list - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_data - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_pagination - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_employer - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_salary - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_full - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_initialization - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_with_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_with_employer - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_str_representation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_hh - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_sj - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_to_dict - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_coordinator_initialization - AttributeError: 'VacancyOperationsCoordinator' object has no attribu...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_vacancy_search - OSError: pytest: reading from stdin while output is captured!  Consi...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_top_vacancies_by_salary - ImportError: cannot import name 'VacancySalary' from 'src.vacancies....
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_search_saved_by_keyword - NameError: name 'Vacancy' is not defined
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_delete_vacancies - NameError: name 'Vacancy' is not defined
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_cache_cleanup - AssertionError: Expected 'clear_cache' to have been called.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_vacancy_search_handler_initialization - AttributeError: 'VacancySearchHandler' object has no attribute 'api'
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_success - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_empty_query - AttributeError: 'VacancySearchHandler' object has no attribute 'hand...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_no_results - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_with_saving - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_cancelled_source_selection - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
============== 71 failed, 214 passed, 2 warnings in 2.64s ===============
~/workspace$ 