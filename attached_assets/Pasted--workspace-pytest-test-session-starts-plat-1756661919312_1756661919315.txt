~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 285 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py ....                                     [  5%]
tests/test_app_config.py .....                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 14%]
tests/test_cached_api.py ....F                                    [ 15%]
tests/test_db_manager.py FF..FF.F                                 [ 18%]
tests/test_decorators.py .......                                  [ 21%]
tests/test_env_loader.py ............                             [ 25%]
tests/test_file_handlers.py ............                          [ 29%]
tests/test_get_api.py ......                                      [ 31%]
tests/test_hh_api.py .......                                      [ 34%]
tests/test_hh_api_config.py .....                                 [ 35%]
tests/test_hh_parser.py ....FFF.                                  [ 38%]
tests/test_menu_manager.py ..........                             [ 42%]
tests/test_paginator.py ....FF                                    [ 44%]
tests/test_postgres_saver.py .......                              [ 46%]
tests/test_salary_utils.py .F..................                   [ 53%]
tests/test_search_utils.py ...........                            [ 57%]
tests/test_sj_api.py F..FFFF                                      [ 60%]
tests/test_sj_api_config.py .....                                 [ 61%]
tests/test_sj_parser.py ........                                  [ 64%]
tests/test_storage_factory.py .F...F..                            [ 67%]
tests/test_target_companies.py .....                              [ 69%]
tests/test_ui_config.py .....                                     [ 70%]
tests/test_ui_helpers.py ...........                              [ 74%]
tests/test_unified_api.py .................                       [ 80%]
tests/test_user_interface.py .FF..F..                             [ 83%]
tests/test_vacancy_display_handler.py .FFFFFF                     [ 85%]
tests/test_vacancy_formatter.py ..F..F.                           [ 88%]
tests/test_vacancy_models.py .......FFFFF                         [ 92%]
tests/test_vacancy_operations_coordinator.py FF.FFFF.             [ 95%]
tests/test_vacancy_search_handler.py FFFFFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <Mock name='FileCache().clear' id='140349829112272'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fa5befb17d0>
mock_file_cache = <MagicMock name='FileCache' id='140349829112784'>

    @patch('src.utils.cache.FileCache')
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
        api = TestCachedAPIImplementation()
    
        # Тестируем метод очистки кэша
        api.clear_cache("test")
    
        # Проверяем что метод clear был вызван
>       mock_cache_instance.clear.assert_called_once()
E       AssertionError: Expected 'clear' to have been called once. Called 0 times.

tests/test_cached_api.py:94: AssertionError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fa5befdd310>
mock_connect = <MagicMock name='connect' id='140349850645712'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем метод проверки соединения
        with patch.object(db_manager, '_get_connection', return_value=mock_connection):
            result = db_manager.check_connection()
>           assert result is True
E           assert False is True

tests/test_db_manager.py:78: AssertionError
___________________ TestDBManager.test_create_tables ____________________

self = <MagicMock name='connect' id='140349828939408'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'connect' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fa5befde410>
mock_connect = <MagicMock name='connect' id='140349828939408'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        # Мокаем метод обеспечения существования таблиц
        with patch.object(db_manager, '_ensure_tables_exist', return_value=True):
             with patch.object(db_manager, '_get_connection', return_value=mock_connection):
                db_manager.create_tables()
    
        # Проверяем что соединение было установлено
>       mock_connect.assert_called()
E       AssertionError: Expected 'connect' to have been called.

tests/test_db_manager.py:93: AssertionError
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fa5befc38d0>
mock_connect = <MagicMock name='connect' id='140349815676816'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = MockConnection()
        mock_cursor = Mock()
        mock_cursor.fetchone.return_value = (125000.0,)
    
        # Правильный мок для курсора как контекстного менеджера
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
>       mock_connection.cursor.return_value = mock_cursor_context
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_db_manager.py:145: AttributeError
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fa5befe9b10>
mock_connect = <MagicMock name='connect' id='140349824891984'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = MockConnection()
        mock_cursor = Mock()
        mock_cursor.fetchall.return_value = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
    
        # Правильный мок для курсора как контекстного менеджера
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
>       mock_connection.cursor.return_value = mock_cursor_context
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_db_manager.py:170: AttributeError
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fa5befea690>
mock_connect = <MagicMock name='connect' id='140349825156752'>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем функцию получения целевых компаний
        test_companies = [
            {"id": "1", "name": "Test Company 1"},
            {"id": "2", "name": "Test Company 2"}
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_connection):
            # Мокаем функцию получения целевых компаний
>           with patch('src.config.target_companies.get_target_companies_data', return_value=test_companies):

tests/test_db_manager.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fa5bdbda490>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.target_companies' from '/home/runner/workspace/tests/../src/config/target_companies.py'> does not have the attribute 'get_target_companies_data'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fa5be3b4e50>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {'items': [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies(data['items'])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_hh_parser.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/parsers/hh_parser.py:23: in parse_vacancies
    return [Vacancy.to_dict(vacancy) for vacancy in parsed_vacancies]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/parsers/hh_parser.py:23: in <listcomp>
    return [Vacancy.to_dict(vacancy) for vacancy in parsed_vacancies]
            ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.vacancies.models.Vacancy object at 0x7fa5bdbef860>

    def to_dict(self) -> Dict[str, Any]:
        """Преобразование вакансии в словарь"""
        result = {
            "vacancy_id": self.vacancy_id,
            "title": self.title,
            "url": self.url,
            "source": self.source,
            "area": self.area,
            "experience": self.experience,
            "employment": self.employment,
            "description": self.description,
            "published_at": self.published_at
        }
    
        if self.salary:
            result["salary"] = {
>               "from_amount": self.salary.from_amount,
                               ^^^^^^^^^^^^^^^^^^^^^^^
                "to_amount": self.salary.to_amount,
                "currency": self.salary.currency
            }
E           AttributeError: 'Salary' object has no attribute 'from_amount'

src/vacancies/models.py:364: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fa5be3b5510>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {'id': '123', 'name': 'Test Job'}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result['id'] == '123'
               ^^^^^^^^^^^^
E       KeyError: 'id'

tests/test_hh_parser.py:62: KeyError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fa5be3b5bd0>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result['employer']['name'] == 'Test Company'
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: string indices must be integers, not 'str'

tests/test_hh_parser.py:69: TypeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fa5be3d2850>
mock_print = <MagicMock name='print' id='140349825210128'>
mock_input = <MagicMock name='input' id='140349824581072'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Консолидированный мок для пагинации
        with patch('src.utils.paginator.Paginator') as mock_paginator_class:
            mock_paginator = Mock()
            mock_paginator_class.return_value = mock_paginator
    
            # Тестируем что пагинатор создается
            from src.utils.paginator import Paginator
            paginator = Paginator(items, per_page=2) # Changed to match the constructor
            assert paginator is not None
>           assert paginator.total == 3
E           AssertionError: assert <Mock name='Paginator().total' id='140349824574480'> == 3
E            +  where <Mock name='Paginator().total' id='140349824574480'> = <Mock name='Paginator()' id='140349824574160'>.total

tests/test_paginator.py:116: AssertionError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fa5be3d2ed0>
mock_print = <MagicMock name='print' id='140349824566352'>
mock_input = <MagicMock name='input' id='140349829652560'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Консолидированный мок для навигации
        with patch('src.utils.paginator.Paginator') as mock_paginator_class:
            mock_paginator = Mock()
            mock_paginator_class.return_value = mock_paginator
    
            # Тестируем навигацию пагинатора
            from src.utils.paginator import Paginator
            paginator = Paginator(items, per_page=5) # Changed to match the constructor
            assert paginator is not None
>           assert paginator.total == 20
E           AssertionError: assert <Mock name='Paginator().total' id='140349825132368'> == 20
E            +  where <Mock name='Paginator().total' id='140349825132368'> = <Mock name='Paginator()' id='140349825134416'>.total

tests/test_paginator.py:138: AssertionError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7fa5be3f1990>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
        result = parse_salary_range("invalid")
        assert result == (None, None)
>       assert parse_salary_range("") is None
E       AssertionError: assert (None, None) is None
E        +  where (None, None) = parse_salary_range('')

tests/test_salary_utils.py:86: AssertionError
______________ TestSuperJobAPI.test_sj_api_initialization _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fa5bdf84350>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJobAPI"""
        api = SuperJobAPI()
        assert api is not None
        assert hasattr(api, '__dict__')
>       assert api.base_url == "https://api.superjob.ru/2.0"
               ^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'base_url'

tests/test_sj_api.py:18: AttributeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <MagicMock name='get' id='140349824760848'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fa5bdf77150>
mock_get = <MagicMock name='get' id='140349824760848'>

    @patch('requests.Session.get')
    def test_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "firm_name": "Test Company",
                    "payment_from": 100000,
                    "payment_to": 150000,
                    "town": {"title": "Москва"}
                }
            ],
            "total": 1
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Мокаем загрузку переменных окружения
        with patch.dict(os.environ, {'SUPERJOB_API_KEY': 'test_key'}):
            api = SuperJobAPI()
            result = api.get_vacancies("Python")
    
            assert isinstance(result, list)
>           mock_get.assert_called()
E           AssertionError: Expected 'get' to have been called.

tests/test_sj_api.py:59: AssertionError
--------------------------- Captured log call ---------------------------
WARNING  root:cached_api.py:100 Ошибка кэша памяти: unhashable type: 'dict'. Переключаемся на файловый кэш
ERROR    src.api_modules.cached_api:cached_api.py:130 Ошибка соединения с API sj: HTTP error 403: {"error":{"code":403,"message":"Приложение с переданным ключом не найдено","error":null}}
____________ TestSuperJobAPI.test_get_vacancy_by_id_success _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fa5bdf93cd0>
mock_get = <MagicMock name='get' id='140349820442384'>

    @patch('requests.Session.get')
    def test_get_vacancy_by_id_success(self, mock_get):
        """Тест успешного получения вакансии по ID"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "profession": "Python Developer",
            "firm_name": "Test Company"
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Мокаем загрузку переменных окружения
        with patch.dict(os.environ, {'SUPERJOB_API_KEY': 'test_key'}):
            api = SuperJobAPI()
>           result = api.get_vacancy_by_id("123")
                     ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SuperJobAPI' object has no attribute 'get_vacancy_by_id'

tests/test_sj_api.py:76: AttributeError
________________ TestSuperJobAPI.test_api_key_validation ________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fa5bdf917d0>

    def test_api_key_validation(self):
        """Тест валидации API ключа"""
        api = SuperJobAPI()
    
        # Проверяем обработку отсутствующего API ключа
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fa5bdb2fdd0>, 'api_key')

tests/test_sj_api.py:86: AssertionError
_____________ TestSuperJobAPI.test_api_key_from_environment _____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fa5bdf76150>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'env_test_key'})
    def test_api_key_from_environment(self):
        """Тест получения API ключа из переменной окружения"""
        api = SuperJobAPI()
        # API должен использовать ключ из окружения
>       assert hasattr(api, 'api_key')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fa5bdb2be50>, 'api_key')

tests/test_sj_api.py:93: AssertionError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fa5bdb49f10>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=postgres"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fa5bdf65150>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140349815674128'>
mock_app_config = <MagicMock name='AppConfig' id='140349820442960'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_postgres_storage(self, mock_postgres_saver, mock_app_config):
        """Тест создания PostgreSQL хранилища с моками"""
        # Настраиваем моки
        mock_config_instance = Mock()
        mock_config_instance.get_db_config.return_value = {'host': 'localhost'}
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=Project03"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'Project03', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД Project03: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных Project03 недоступна и не может быть создана
_________ TestStorageFactory.test_create_storage_with_db_config _________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fa5bd79b0d0>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=postgres'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fa5be3e6f10>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140349825170320'>
mock_app_config = <MagicMock name='AppConfig' id='140349825158160'>

    @patch('src.config.app_config.AppConfig')
    @patch('src.storage.postgres_saver.PostgresSaver')
    def test_create_storage_with_db_config(self, mock_postgres_saver, mock_app_config):
        """Тест создания хранилища с конфигурацией БД"""
        # Настраиваем моки
        mock_config_instance = Mock()
        test_db_config = {
            'host': 'test_host',
            'port': '5432',
            'database': 'test_db',
            'username': 'test_user',
            'password': 'test_pass'
        }
        mock_config_instance.get_db_config.return_value = test_db_config
        mock_app_config.return_value = mock_config_instance
    
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        factory = StorageFactory()
>       storage = factory.create_storage('postgres')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=test_db'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'test_db', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД test_db: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных test_db недоступна и не может быть создана
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <MagicMock name='_handle_choice' id='140349828836368'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_handle_choice' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fa5be3f9ad0>
mock_stdout = <_io.StringIO object at 0x7fa5bdb7f1c0>
mock_input = <MagicMock name='input' id='140349824578000'>

    @patch('builtins.input', return_value='0')
    @patch('sys.stdout', new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
        with patch.object(ui, '_display_menu'):
            with patch.object(ui, '_handle_choice') as mock_handle:
                mock_handle.return_value = False
                ui.run()
>               mock_handle.assert_called()
E               AssertionError: Expected '_handle_choice' to have been called.

tests/test_user_interface.py:63: AssertionError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <MagicMock name='_search_vacancies' id='140349828946256'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected '_search_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fa5bdf16610>
mock_input = <MagicMock name='input' id='140349828851472'>

    @patch('builtins.input', return_value='1')
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
        with patch.object(ui, '_search_vacancies') as mock_search:
            result = ui._handle_choice('1')
            if hasattr(ui, '_search_vacancies'):
>               mock_search.assert_called()
E               AssertionError: Expected '_search_vacancies' to have been called.

tests/test_user_interface.py:72: AssertionError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fa5bdf15890>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        with patch('builtins.input', side_effect=KeyboardInterrupt):
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

tests/test_user_interface.py:92: Failed
______ TestVacancyDisplayHandler.test_display_vacancies_empty_list ______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfad450>
mock_print = <MagicMock name='print' id='140349824956688'>

    @patch('builtins.print')
    def test_display_vacancies_empty_list(self, mock_print):
        """Тест отображения пустого списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       handler.display_vacancies([])
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:84: AttributeError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfada10>
mock_print = <MagicMock name='print' id='140349820694864'>

    @patch('builtins.print')
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru")
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:100: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfae010>
mock_paginate = <MagicMock name='quick_paginate' id='140349825571088'>

    @patch('src.ui_interfaces.vacancy_display_handler.quick_paginate')
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:115: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfae610>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:131: TypeError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfaec10>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        employer = VacancyEmployer(id="1", name="Test Company")
>       vacancy = Vacancy(
            id="124",
            title="Junior Developer",
            url="https://test.com/vacancy/124",
            source="hh.ru",
            employer=employer
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:153: TypeError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fa5bdfaf210>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        salary = VacancySalary(from_amount=50000, currency="RUR")
>       vacancy = Vacancy(
            id="125",
            title="Intern",
            url="https://test.com/vacancy/125",
            source="hh.ru",
            salary=salary
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:174: TypeError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fa5bdfb1510>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary
        )

tests/test_vacancy_formatter.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fa5bd732aa0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fa5bdfae3d0>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость"
        )

tests/test_vacancy_formatter.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fa5bd7326e0>
salary_data = VacancySalary(from_amount=100000, to_amount=150000, currency='RUR')

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fa5bdfc6810>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:125: TypeError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fa5bdfc6e50>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            vacancy_id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"],
            source="hh.ru"
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:180: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fa5bdfc7490>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            vacancy_id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"],
            source="superjob.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:200: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fa5bdfc7a90>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:219: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fa5bdfcc0d0>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary),
            source="hh.ru"
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:242: TypeError
___ TestVacancyOperationsCoordinator.test_coordinator_initialization ____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfe9290>

    def test_coordinator_initialization(self):
        """Тест инициализации VacancyOperationsCoordinator"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
>       assert coordinator.api == mock_api
               ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyOperationsCoordinator' object has no attribute 'api'

tests/test_vacancy_operations_coordinator.py:21: AttributeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfe9850>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='140349820437648'>

    @patch('src.ui_interfaces.vacancy_search_handler.VacancySearchHandler')
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7fa5bf7afad0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfea410>
mock_print = <MagicMock name='print' id='140349825574544'>
mock_input = <MagicMock name='input' id='140349825576080'>

    @patch('builtins.input', return_value='5')
    @patch('builtins.print')
    def test_handle_top_vacancies_by_salary(self, mock_print, mock_input):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
>       from src.vacancies.models import Vacancy, VacancySalary
E       ImportError: cannot import name 'VacancySalary' from 'src.vacancies.models' (/home/runner/workspace/tests/../src/vacancies/models.py)

tests/test_vacancy_operations_coordinator.py:62: ImportError
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfeaa10>
mock_print = <MagicMock name='print' id='140349824572880'>
mock_input = <MagicMock name='input' id='140349829652112'>

    @patch('builtins.input', return_value='Python')
    @patch('builtins.print')
    def test_handle_search_saved_by_keyword(self, mock_print, mock_input):
        """Тест поиска сохраненных вакансий по ключевому слову"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:86: NameError
_____ TestVacancyOperationsCoordinator.test_handle_delete_vacancies _____

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfeb090>
mock_input = <MagicMock name='input' id='140349825514320'>

    @patch('builtins.input', return_value='Python')
    def test_handle_delete_vacancies(self, mock_input):
        """Тест удаления вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        test_vacancies = [
>           Vacancy("123", "Python Developer", "https://test.com", "hh.ru")
            ^^^^^^^
        ]
E       NameError: name 'Vacancy' is not defined

tests/test_vacancy_operations_coordinator.py:103: NameError
______ TestVacancyOperationsCoordinator.test_handle_cache_cleanup _______

self = <Mock name='mock.clear_cache' id='140349815629392'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear_cache' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fa5bdfeb750>

    def test_handle_cache_cleanup(self):
        """Тест очистки кэша"""
        mock_api = Mock()
        mock_storage = Mock()
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
        with patch('builtins.print'):
            coordinator.handle_cache_cleanup()
    
        # Проверяем, что очистка кэша была вызвана
>       mock_api.clear_cache.assert_called()
E       AssertionError: Expected 'clear_cache' to have been called.

tests/test_vacancy_operations_coordinator.py:126: AssertionError
------------------------- Captured stdout call --------------------------
Ваш выбор: 
--------------------------- Captured log call ---------------------------
ERROR    src.ui_interfaces.vacancy_operations_coordinator:vacancy_operations_coordinator.py:78 Ошибка при очистке кэша: pytest: reading from stdin while output is captured!  Consider using `-s`.
__ TestVacancySearchHandler.test_vacancy_search_handler_initialization __

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfecf50>

    def test_vacancy_search_handler_initialization(self):
        """Тест инициализации VacancySearchHandler"""
        mock_api = Mock()
        mock_storage = Mock()
    
        handler = VacancySearchHandler(mock_api, mock_storage)
    
>       assert handler.api == mock_api
               ^^^^^^^^^^^
E       AttributeError: 'VacancySearchHandler' object has no attribute 'api'

tests/test_vacancy_search_handler.py:22: AttributeError
__________ TestVacancySearchHandler.test_handle_search_success __________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfed310>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fa5bdfec5d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_empty_query ________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfed8d0>
mock_input = <MagicMock name='input' id='140349813360976'>

    @patch('builtins.input', return_value='')
    def test_handle_search_empty_query(self, mock_input):
        """Тест поиска с пустым запросом"""
        mock_api = Mock()
        mock_storage = Mock()
    
        handler = VacancySearchHandler(mock_api, mock_storage)
>       result = handler.handle_search()
                 ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySearchHandler' object has no attribute 'handle_search'

tests/test_vacancy_search_handler.py:52: AttributeError
________ TestVacancySearchHandler.test_handle_search_no_results _________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfeded0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fa5bdfeca90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_with_saving ________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfee490>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fa5bdfeab90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancySearchHandler.test_handle_search_cancelled_source_selection _

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fa5bdfeead0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fa5bdfea190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
=========================== warnings summary ============================
tests/test_cached_api.py:14
  /home/runner/workspace/tests/test_cached_api.py:14: PytestCollectionWarning: cannot collect test class 'TestCachedAPIImplementation' because it has a __init__ constructor (from: tests/test_cached_api.py)
    class TestCachedAPIImplementation(CachedAPI):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== short test summary info ========================
FAILED tests/test_cached_api.py::TestCachedAPI::test_clear_cache_method - AssertionError: Expected 'clear' to have been called once. Called 0 ...
FAILED tests/test_db_manager.py::TestDBManager::test_check_connection_success - assert False is True
FAILED tests/test_db_manager.py::TestDBManager::test_create_tables - AssertionError: Expected 'connect' to have been called.
FAILED tests/test_db_manager.py::TestDBManager::test_get_avg_salary - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - AttributeError: <module 'src.config.target_companies' from '/home/ru...
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancies_list - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancy_minimal_data - KeyError: 'id'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_employer_data - TypeError: string indices must be integers, not 'str'
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_quit - AssertionError: assert <Mock name='Paginator().total' id='1403498245...
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_navigation - AssertionError: assert <Mock name='Paginator().total' id='1403498251...
FAILED tests/test_salary_utils.py::TestSalaryUtils::test_parse_salary_range_invalid - AssertionError: assert (None, None) is None
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_sj_api_initialization - AttributeError: 'SuperJobAPI' object has no attribute 'base_url'
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancies_success - AssertionError: Expected 'get' to have been called.
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancy_by_id_success - AttributeError: 'SuperJobAPI' object has no attribute 'get_vacancy_b...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_api_key_validation - AssertionError: assert False
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_api_key_from_environment - AssertionError: assert False
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_postgres_storage - psycopg2.OperationalError: connection to server at "localhost" (127....
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_storage_with_db_config - psycopg2.OperationalError: could not translate host name "test_host"...
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_run_exit - AssertionError: Expected '_handle_choice' to have been called.
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_handle_search - AssertionError: Expected '_search_vacancies' to have been called.
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_error_handling - Failed: DID NOT RAISE <class 'KeyboardInterrupt'>
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_empty_list - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_data - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_pagination - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_employer - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_salary - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_full - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_str_representation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_hh - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_sj - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_to_dict - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_coordinator_initialization - AttributeError: 'VacancyOperationsCoordinator' object has no attribu...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_vacancy_search - OSError: pytest: reading from stdin while output is captured!  Consi...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_top_vacancies_by_salary - ImportError: cannot import name 'VacancySalary' from 'src.vacancies....
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_search_saved_by_keyword - NameError: name 'Vacancy' is not defined
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_delete_vacancies - NameError: name 'Vacancy' is not defined
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_cache_cleanup - AssertionError: Expected 'clear_cache' to have been called.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_vacancy_search_handler_initialization - AttributeError: 'VacancySearchHandler' object has no attribute 'api'
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_success - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_empty_query - AttributeError: 'VacancySearchHandler' object has no attribute 'hand...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_no_results - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_with_saving - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_cancelled_source_selection - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
=============== 47 failed, 238 passed, 1 warning in 5.45s ===============
~/workspace$ 