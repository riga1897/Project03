~/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1705 items                                                               

tests/test_abstract.py ........                                              [  0%]
tests/test_abstract_db_manager.py ....                                       [  0%]
tests/test_abstract_filter_complete.py .........                             [  1%]
tests/test_api_complete.py ...................                               [  2%]
tests/test_api_config.py ....                                                [  2%]
tests/test_api_data_filter.py ......                                         [  2%]
tests/test_api_fixes.py .......                                              [  3%]
tests/test_api_modules.py ............................                       [  4%]
tests/test_api_modules_consolidated.py ....                                  [  5%]
tests/test_api_modules_coverage.py .FF...F............                       [  6%]
tests/test_app_config.py .........                                           [  6%]
tests/test_base_api.py ...............                                       [  7%]
tests/test_base_formatter.py ..........                                      [  8%]
tests/test_base_formatter_complete.py ..............................         [ 10%]
tests/test_base_parser.py ......                                             [ 10%]
tests/test_cache.py ......................                                   [ 11%]
tests/test_cached_api.py ....                                                [ 11%]
tests/test_cached_api_complete.py ................                           [ 12%]
tests/test_components_fixed.py ...                                           [ 13%]
tests/test_comprehensive_fixed.py .....                                      [ 13%]
tests/test_comprehensive_missing_coverage.py FFFFFFFFFEFFFEEEFF.......FF.... [ 15%]
........FFFFFF.......F.......F..FFFFFFEEEE..FFFFFFFFFF.FF...FF.F..FF.F       [ 19%]
tests/test_config_consolidated.py .....                                      [ 19%]
tests/test_config_missing_coverage.py .....sssss.............ss...           [ 21%]
tests/test_config_modules_consolidated.py ......                             [ 21%]
tests/test_config_modules_coverage.py ...................FFF..........       [ 23%]
tests/test_console_interface.py ......                                       [ 23%]
tests/test_console_interface_coverage.py ..................                  [ 24%]
tests/test_core_functionality_consolidated.py .....                          [ 25%]
tests/test_core_modules_comprehensive.py ........                            [ 25%]
tests/test_data_normalizers_comprehensive.py ............................    [ 27%]
tests/test_database_connection.py ........                                   [ 27%]
tests/test_db_config.py .....                                                [ 28%]
tests/test_db_manager.py .................                                   [ 29%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                           [ 29%]
tests/test_decorators.py .......                                             [ 30%]
tests/test_description_parser.py ..........                                  [ 30%]
tests/test_env_loader.py ................                                    [ 31%]
tests/test_filter_utils.py ......                                            [ 32%]
tests/test_get_api_complete.py ....................                          [ 33%]
tests/test_hh_api_complete.py .................                              [ 34%]
tests/test_hh_api_config.py .....                                            [ 34%]
tests/test_hh_parser.py ........                                             [ 35%]
tests/test_integration.py .............                                      [ 35%]
tests/test_interfaces.py .ss                                                 [ 36%]
tests/test_interfaces_coverage.py ................................           [ 38%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F......FF  [ 39%]
tests/test_main_application_interface.py ...                                 [ 40%]
tests/test_main_application_interface_complete.py .......................... [ 41%]
.................                                                            [ 42%]
tests/test_main_consolidated.py .........                                    [ 43%]
tests/test_menu_manager.py ..........                                        [ 43%]
tests/test_missing_components.py .........                                   [ 44%]
tests/test_missing_coverage_components.py ..............F..                  [ 45%]
tests/test_models_fixed.py ...                                               [ 45%]
tests/test_paginator.py ......                                               [ 45%]
tests/test_parsers_complete.py ............                                  [ 46%]
tests/test_parsers_coverage.py .............................                 [ 48%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                     [ 49%]
tests/test_repository_fixed.py ..                                            [ 49%]
tests/test_salary_fixed.py ...........                                       [ 49%]
tests/test_salary_utils.py ......................                            [ 51%]
tests/test_search_utils.py ............................                      [ 52%]
tests/test_search_utils_complete.py ........................................ [ 55%]
......                                                                       [ 55%]
tests/test_services_consolidated.py ....                                     [ 55%]
tests/test_services_storage_consolidated.py ..........                       [ 56%]
tests/test_simple_db_adapter.py .........                                    [ 56%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                             [ 57%]
tests/test_sj_api.py ..............                                          [ 58%]
tests/test_sj_api_complete.py .............F....                             [ 59%]
tests/test_sj_api_config.py .....                                            [ 59%]
tests/test_sj_parser.py ........                                             [ 60%]
tests/test_sj_parser_complete.py ..............                              [ 61%]
tests/test_source_manager.py .................                               [ 62%]
tests/test_source_selector.py .................                              [ 63%]
tests/test_storage_abstractions.py ........                                  [ 63%]
tests/test_storage_complete.py .............                                 [ 64%]
tests/test_storage_components_complete.py ......F....FF...............F      [ 66%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF        [ 67%]
tests/test_storage_factory.py ........                                       [ 68%]
tests/test_storage_modules_consolidated.py ....                              [ 68%]
tests/test_target_companies.py .....                                         [ 68%]
tests/test_typed_data_processor.py ................                          [ 69%]
tests/test_ui_components_complete.py ......................................  [ 71%]
tests/test_ui_components_extended.py ..................                      [ 72%]
tests/test_ui_config.py .......................                              [ 74%]
tests/test_ui_helpers_comprehensive.py ..................................... [ 76%]
..                                                                           [ 76%]
tests/test_ui_helpers_extended.py ........................................   [ 78%]
tests/test_ui_modules_consolidated.py .....                                  [ 79%]
tests/test_ui_navigation.py ......................                           [ 80%]
tests/test_ui_navigation_complete.py ..s..                                   [ 80%]
tests/test_ui_navigation_comprehensive.py ......                             [ 81%]
tests/test_ui_navigation_extended.py .......F...........................     [ 83%]
tests/test_unified_api.py ................F...F.                             [ 84%]
tests/test_unified_api_complete.py ......F......................             [ 86%]
tests/test_unified_api_fixed.py ...                                          [ 86%]
tests/test_user_interface.py ...............                                 [ 87%]
tests/test_user_interface_consolidated.py F.F                                [ 87%]
tests/test_user_interface_coverage.py .........                              [ 87%]
tests/test_user_interface_fixed.py ...                                       [ 88%]
tests/test_utils_consolidated.py .....                                       [ 88%]
tests/test_utils_coverage.py .............................                   [ 90%]
tests/test_utils_ui_consolidated.py ......                                   [ 90%]
tests/test_vacancy_abstractions.py .................                         [ 91%]
tests/test_vacancy_display_handler.py ...................                    [ 92%]
tests/test_vacancy_formatter.py ........                                     [ 93%]
tests/test_vacancy_models_complete.py ....                                   [ 93%]
tests/test_vacancy_models_consolidated.py ....                               [ 93%]
tests/test_vacancy_operations.py ......                                      [ 93%]
tests/test_vacancy_operations_coordinator.py ...........................     [ 95%]
tests/test_vacancy_operations_coordinator_complete.py ...................... [ 96%]
                                                                             [ 96%]
tests/test_vacancy_processing_coordinator.py .............                   [ 97%]
tests/test_vacancy_repository.py .........                                   [ 98%]
tests/test_vacancy_stats.py ............                                     [ 98%]
tests/test_vacancy_stats_fixed.py .........                                  [ 99%]
tests/test_vacancy_validator.py ............                                 [100%]

====================================== ERRORS ======================================
_ ERROR at setup of TestPostgresSaverComprehensive.test_save_vacancies_single_vacancy _

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc2950>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_comprehensive_missing_coverage.py:222: TypeError
_ ERROR at setup of TestPostgresSaverComprehensive.test_delete_vacancy_with_object _

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc1490>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_comprehensive_missing_coverage.py:222: TypeError
___ ERROR at setup of TestPostgresSaverComprehensive.test_is_vacancy_exists_true ___

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc1ad0>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_comprehensive_missing_coverage.py:222: TypeError
__ ERROR at setup of TestPostgresSaverComprehensive.test_is_vacancy_exists_false ___

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbb0490>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_comprehensive_missing_coverage.py:222: TypeError
_ ERROR at setup of TestCachedAPIComprehensive.test_get_vacancies_with_cache_miss __

self = <tests.test_comprehensive_missing_coverage.TestCachedAPIComprehensive object at 0x7fbe3cba6650>
base_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe3ca7b0d0>
cache_dir = '/tmp/tmpbu379v22'

    @pytest.fixture
    def cached_api(self, base_api, cache_dir):
        """Фикстура для CachedAPI"""
>       return CachedAPI(base_api, cache_dir)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1038: TypeError
__ ERROR at setup of TestCachedAPIComprehensive.test_get_vacancies_with_cache_hit __

self = <tests.test_comprehensive_missing_coverage.TestCachedAPIComprehensive object at 0x7fbe3cb96d10>
base_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe3cbd2590>
cache_dir = '/tmp/tmp9osdyz54'

    @pytest.fixture
    def cached_api(self, base_api, cache_dir):
        """Фикстура для CachedAPI"""
>       return CachedAPI(base_api, cache_dir)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1038: TypeError
__________ ERROR at setup of TestCachedAPIComprehensive.test_clear_cache ___________

self = <tests.test_comprehensive_missing_coverage.TestCachedAPIComprehensive object at 0x7fbe3d1d12d0>
base_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe3c9d6810>
cache_dir = '/tmp/tmpw0hjlghz'

    @pytest.fixture
    def cached_api(self, base_api, cache_dir):
        """Фикстура для CachedAPI"""
>       return CachedAPI(base_api, cache_dir)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1038: TypeError
_________ ERROR at setup of TestCachedAPIComprehensive.test_get_cache_size _________

self = <tests.test_comprehensive_missing_coverage.TestCachedAPIComprehensive object at 0x7fbe3d1d2110>
base_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe3c9c1ed0>
cache_dir = '/tmp/tmpo8copqrh'

    @pytest.fixture
    def cached_api(self, base_api, cache_dir):
        """Фикстура для CachedAPI"""
>       return CachedAPI(base_api, cache_dir)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1038: TypeError
===================================== FAILURES =====================================
____________ TestUnifiedAPICoverage.test_get_vacancies_from_all_sources ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fbe3d455810>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe3ca71090>

    def test_get_vacancies_from_all_sources(self, unified_api):
        """Тест получения вакансий из всех источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Настраиваем моки для возврата данных
>       unified_api.hh_api.get_vacancies.return_value = [
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            {'id': '1', 'title': 'Python Dev', 'source': 'hh'},
            {'id': '2', 'title': 'Java Dev', 'source': 'hh'}
        ]
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:57: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestUnifiedAPICoverage.test_search_with_filters __________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fbe3d456ad0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe37bdcfd0>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
>       unified_api.hh_api.get_vacancies.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:80: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICoverage.test_error_handling_api_failures ______________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7fbe3d460750>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe3ca8ab50>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:156: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____ TestDBManagerComprehensive.test_get_companies_and_vacancies_count_success _____

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbd1810>
mock_connect = <MagicMock name='connect' id='140454955706640'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ca72550>
mock_connection = (<Mock name='connect()' id='140454956282384'>, <Mock id='140454956275984'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_comprehensive_missing_coverage.py:86: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
_____ TestDBManagerComprehensive.test_get_companies_and_vacancies_count_error ______

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbd1e90>
mock_connect = <MagicMock name='connect' id='140454956813968'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37ceec50>
mock_connection = (<Mock name='connect()' id='140454956821264'>, <Mock id='140454956821392'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_error(self, mock_connect, db_manager, mock_connection):
        """Тест обработки ошибки при получении компаний"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.execute.side_effect = Exception("Database error")
    
        result = db_manager.get_companies_and_vacancies_count()
    
>       assert result == []
E       AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
E         
E         Left contains 12 more items, first extra item: ('Яндекс', 0)
E         Use -v to get more diff

tests/test_comprehensive_missing_coverage.py:102: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
____________ TestDBManagerComprehensive.test_get_all_vacancies_success _____________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbd21d0>
mock_connect = <MagicMock name='connect' id='140455039476368'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ca1fed0>
mock_connection = (<Mock name='connect()' id='140455045650320'>, <Mock id='140455041425808'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения всех вакансий"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_comprehensive_missing_coverage.py:118: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956514448'>, исправляем...
_____________ TestDBManagerComprehensive.test_get_avg_salary_with_data _____________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbd2490>
mock_connect = <MagicMock name='connect' id='140454955964432'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c1c110>
mock_connection = (<Mock name='connect()' id='140454955974544'>, <Mock id='140454955968208'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary_with_data(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты при наличии данных"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_comprehensive_missing_coverage.py:130: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956533520'>, исправляем...
______________ TestDBManagerComprehensive.test_get_avg_salary_no_data ______________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbd3350>
mock_connect = <MagicMock name='connect' id='140454955814160'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37bfb590>
mock_connection = (<Mock name='connect()' id='140454955823696'>, <Mock id='140454955823952'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary_no_data(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты при отсутствии данных"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = None
    
        result = db_manager.get_avg_salary()
    
>       assert result is None
E       assert 1.0 is None

tests/test_comprehensive_missing_coverage.py:142: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956507344'>, исправляем...
_________ TestDBManagerComprehensive.test_get_vacancies_with_higher_salary _________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3d463fd0>
mock_connect = <MagicMock name='connect' id='140454956003856'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c275d0>
mock_connection = (<Mock name='connect()' id='140454956004944'>, <Mock id='140454956007312'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_comprehensive_missing_coverage.py:156: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454955959120'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956681552'>, исправляем...
____________ TestDBManagerComprehensive.test_get_vacancies_with_keyword ____________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbc3890>
mock_connect = <MagicMock name='connect' id='140454956151824'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c49f10>
mock_connection = (<Mock name='connect()' id='140454956151888'>, <Mock id='140454956147664'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'},
            {'id': '2', 'title': 'Python Analyst'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_comprehensive_missing_coverage.py:172: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956186512'>, исправляем...
________________ TestDBManagerComprehensive.test_get_database_stats ________________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbc3b10>
mock_connect = <MagicMock name='connect' id='140454956656080'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37cc7190>
mock_connection = (<Mock name='connect()' id='140454956656656'>, <Mock id='140454956657808'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140455038186768'>}

tests/test_comprehensive_missing_coverage.py:189: AssertionError
___________ TestDBManagerComprehensive.test_init_database_creates_tables ___________

self = <tests.test_comprehensive_missing_coverage.TestDBManagerComprehensive object at 0x7fbe3cbc20d0>
mock_connect = <MagicMock name='connect' id='140454956142288'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ccc7a90>
mock_connection = (<Mock name='connect()' id='140455040548304'>, <Mock id='140455040546320'>)

    @patch('psycopg2.connect')
    def test_init_database_creates_tables(self, mock_connect, db_manager, mock_connection):
        """Тест инициализации базы данных"""
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
    
>       db_manager._init_database()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute '_init_database'

tests/test_comprehensive_missing_coverage.py:202: AttributeError
__________ TestPostgresSaverComprehensive.test_get_vacancies_with_results __________

self = <Mock name='mock.execute' id='140454955459344'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc3010>
mock_connect = <MagicMock name='connect' id='140454956637008'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37cc2c50>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_results(self, mock_connect, postgres_saver):
        """Тест получения вакансий с результатами"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = [
                ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR',
                 'company1', 'TechCorp', 'https://example.com', 'hh')
            ]
    
            result = postgres_saver.get_vacancies()
    
            assert isinstance(result, list)
>           mock_cursor.execute.assert_called()
E           AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:270: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:969 Ошибка при получении вакансий: 'Mock' object does not support the context manager protocol
_________ TestPostgresSaverComprehensive.test_delete_vacancy_by_id_success _________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc0f90>
mock_connect = <MagicMock name='connect' id='140454955700368'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37cc0f50>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id_success(self, mock_connect, postgres_saver):
        """Тест успешного удаления вакансии по ID"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
        mock_cursor.rowcount = 1
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.delete_vacancy_by_id('test123')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37cc0f50>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
________ TestPostgresSaverComprehensive.test_delete_vacancy_by_id_not_found ________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbc0c90>
mock_connect = <MagicMock name='connect' id='140455042984528'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3d4548d0>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id_not_found(self, mock_connect, postgres_saver):
        """Тест удаления несуществующей вакансии"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
        mock_cursor.rowcount = 0
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.delete_vacancy_by_id('nonexistent')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3d4548d0>
vacancy_id = 'nonexistent'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_______ TestPostgresSaverComprehensive.test_get_vacancies_count_with_filters _______

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbb0c90>
mock_connect = <MagicMock name='connect' id='140454957303888'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3cbd2b10>

    @patch('psycopg2.connect')
    def test_get_vacancies_count_with_filters(self, mock_connect, postgres_saver):
        """Тест подсчета вакансий с фильтрами"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (42,)
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            filters = {'title': 'Python', 'salary_from': 100000}
>           result = postgres_saver.get_vacancies_count(filters)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3cbd2b10>
filters = {'salary_from': 100000, 'title': 'Python'}

    def get_vacancies_count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Возвращает количество вакансий с учетом фильтров
    
        Args:
            filters: Словарь с фильтрами
    
        Returns:
            int: Количество вакансий
        """
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            query = "SELECT COUNT(*) FROM vacancies v LEFT JOIN companies c ON v.company_id = c.id"
            params = []
            where_conditions = []
    
            # Добавляем фильтры
            if filters:
                if filters.get("title"):
                    where_conditions.append("LOWER(title) LIKE LOWER(%s)")
                    params.append(f"%{filters['title']}%")
    
                if filters.get("salary_from"):
                    where_conditions.append("salary_from >= %s")
                    params.append(filters["salary_from"])
    
                if filters.get("salary_to"):
                    where_conditions.append("salary_to <= %s")
                    params.append(filters["salary_to"])
    
                if filters.get("employer"):  # Filter by company name from joined table
                    where_conditions.append("LOWER(c.name) LIKE LOWER(%s)")
                    params.append(f"%{filters['employer']}%")
    
                # Filter by company name directly
                if filters.get("company_name"):
                    where_conditions.append("LOWER(company_name) LIKE LOWER(%s)")
                    params.append(f"%{filters['company_name']}%")
    
            if where_conditions:
                query += " WHERE " + " AND ".join(where_conditions)
    
            cursor.execute(query, params)
>           return cursor.fetchone()[0]
                   ^^^^^^^^^^^^^^^^^^^^
E           TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:1243: TypeError
_____________ TestPostgresSaverComprehensive.test_delete_all_vacancies _____________

self = <Mock name='mock.execute' id='140454956019344'>
args = ('DELETE FROM vacancies',), kwargs = {}
expected = "execute('DELETE FROM vacancies')", actual = 'not called.'
error_message = "expected call not found.\nExpected: execute('DELETE FROM vacancies')\n  Actual: not called."

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
>           raise AssertionError(error_message)
E           AssertionError: expected call not found.
E           Expected: execute('DELETE FROM vacancies')
E             Actual: not called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:930: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverComprehensive object at 0x7fbe3cbb1050>
mock_connect = <MagicMock name='connect' id='140454955734032'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3d87e3d0>

    @patch('psycopg2.connect')
    def test_delete_all_vacancies(self, mock_connect, postgres_saver):
        """Тест удаления всех вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            result = postgres_saver.delete_all_vacancies()
    
            assert result is True
>           mock_cursor.execute.assert_called_with("DELETE FROM vacancies")
E           AssertionError: expected call not found.
E           Expected: execute('DELETE FROM vacancies')
E             Actual: not called.

tests/test_comprehensive_missing_coverage.py:370: AssertionError
_____ TestSimpleDBAdapterComprehensive.test_get_companies_and_vacancies_count ______

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterComprehensive object at 0x7fbe3cbb1bd0>
mock_run = <MagicMock name='run' id='140454956467408'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37c98f10>

    @patch('subprocess.run')
    def test_get_companies_and_vacancies_count(self, mock_run, db_adapter):
        """Тест получения компаний и количества вакансий"""
        mock_run.return_value.returncode = 0
        mock_run.return_value.stdout = "Company1|10\nCompany2|15\n"
    
        with patch.object(db_adapter, 'cursor') as mock_cursor_method:
            mock_cursor = Mock()
            mock_cursor_method.return_value = mock_cursor
            mock_cursor.fetchall.return_value = [('Company1', 10), ('Company2', 15)]
    
>           result = db_adapter.get_companies_and_vacancies_count()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_comprehensive_missing_coverage.py:448: AttributeError
____________ TestSimpleDBAdapterComprehensive.test_init_database_schema ____________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterComprehensive object at 0x7fbe3cbb3990>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3d2eb3d0>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_comprehensive_missing_coverage.py:455: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3d069950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3d2eb3d0> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestCacheComprehensive.test_load_response_existing ________________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb95890>
cache = <src.utils.cache.FileCache object at 0x7fbe37bf2550>

    def test_load_response_existing(self, cache):
        """Тест загрузки существующих данных из кэша"""
        data = {"items": [{"id": "1", "name": "Test"}], "found": 1}
        params = {"query": "python", "page": 0}
    
        # Сначала сохраняем данные
        cache.save_response("hh", params, data)
    
        # Затем загружаем
        loaded_data = cache.load_response("hh", params)
    
        assert loaded_data is not None
        assert "data" in loaded_data
        assert loaded_data["data"]["items"] == data["items"]
        key = "existing_key"
    
        # Сначала сохраняем
>       cache.save_to_cache(key, data)
        ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:633: AttributeError
_____________ TestCacheComprehensive.test_load_from_cache_nonexistent ______________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb95110>
cache = <src.utils.cache.FileCache object at 0x7fbe37c0f150>

    def test_load_from_cache_nonexistent(self, cache):
        """Тест загрузки несуществующих данных из кэша"""
>       result = cache.load_from_cache("nonexistent_key")
                 ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'load_from_cache'

tests/test_comprehensive_missing_coverage.py:642: AttributeError
_________________ TestCacheComprehensive.test_is_cache_valid_fresh _________________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb94290>
cache = <src.utils.cache.FileCache object at 0x7fbe37c60990>

    def test_is_cache_valid_fresh(self, cache):
        """Тест проверки валидности свежего кэша"""
        key = "fresh_key"
>       cache.save_to_cache(key, {"data": "test"})
        ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:649: AttributeError
________________ TestCacheComprehensive.test_is_cache_valid_expired ________________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb956d0>
cache = <src.utils.cache.FileCache object at 0x7fbe37d64b90>

    def test_is_cache_valid_expired(self, cache):
        """Тест проверки валидности устаревшего кэша"""
        key = "old_key"
        cache_file = os.path.join(cache.cache_dir, f"{key}.json")
    
        # Создаем файл с данными
        with open(cache_file, 'w', encoding='utf-8') as f:
            json.dump({"data": "test"}, f)
    
        # Изменяем время модификации на старое
        old_time = os.path.getmtime(cache_file) - 7200  # 2 часа назад
        os.utime(cache_file, (old_time, old_time))
    
>       assert not cache.is_cache_valid(key, max_age_hours=1)
                   ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'is_cache_valid'

tests/test_comprehensive_missing_coverage.py:667: AttributeError
_____________________ TestCacheComprehensive.test_clear_cache ______________________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb962d0>
cache = <src.utils.cache.FileCache object at 0x7fbe3d358d50>

    def test_clear_cache(self, cache):
        """Тест очистки кэша"""
        # Создаем несколько файлов кэша
>       cache.save_to_cache("key1", {"data": 1})
        ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:672: AttributeError
____________________ TestCacheComprehensive.test_get_cache_size ____________________

self = <tests.test_comprehensive_missing_coverage.TestCacheComprehensive object at 0x7fbe3cb95c90>
cache = <src.utils.cache.FileCache object at 0x7fbe3cbfb210>

    def test_get_cache_size(self, cache):
        """Тест получения размера кэша"""
>       initial_size = cache.get_cache_size()
                       ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'get_cache_size'

tests/test_comprehensive_missing_coverage.py:686: AttributeError
______________ TestFileOperationsComprehensive.test_read_json_success ______________

self = <tests.test_comprehensive_missing_coverage.TestFileOperationsComprehensive object at 0x7fbe3cb97ad0>
file_operations = <src.utils.file_handlers.FileOperations object at 0x7fbe37c6abd0>
temp_file = ('/tmp/tmpy0caai2u.json', {'numbers': [1, 2, 3], 'test': 'data'})

    def test_read_json_success(self, file_operations, temp_file):
        """Тест успешного чтения JSON файла"""
        temp_path, expected_data = temp_file
        path_obj = Path(temp_path)
    
        result = file_operations.read_json(path_obj)
    
>       assert isinstance(result, list)
E       AssertionError: assert False
E        +  where False = isinstance({'numbers': [1, 2, 3], 'test': 'data'}, list)

tests/test_comprehensive_missing_coverage.py:834: AssertionError
________ TestFileOperationsComprehensive.test_json_handler_write_operations ________

self = <tests.test_comprehensive_missing_coverage.TestFileOperationsComprehensive object at 0x7fbe3cba6b90>

    def test_json_handler_write_operations(self):
        """Тест операций записи JSON через json_handler"""
        test_data = [{"test": "data", "id": 1}]
    
        with patch('pathlib.Path.parent') as mock_parent, \
             patch('pathlib.Path.with_suffix') as mock_suffix, \
             patch('pathlib.Path.open', mock_open()) as mock_file, \
             patch('json.dump') as mock_json_dump, \
             patch('pathlib.Path.replace') as mock_replace, \
             patch('pathlib.Path.exists', return_value=False), \
             patch('pathlib.Path.unlink'):
    
            mock_temp = Mock()
            mock_suffix.return_value = mock_temp
            mock_parent.mkdir = Mock()
    
>           json_handler.write_json(Path('test.json'), test_data)

tests/test_comprehensive_missing_coverage.py:931: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.file_handlers.FileOperations object at 0x7fbe3d3b7510>
file_path = PosixPath('test.json'), data = [{'id': 1, 'test': 'data'}]

    def write_json(self, file_path: Path, data: List[Dict[str, Any]]) -> None:
        """
        Атомарная запись в JSON-файл с обработкой ошибок
        Args:
            file_path: Путь к файлу
            data: Данные для записи
        """
        temp_file = file_path.with_suffix(".tmp")
        try:
            # Создаем директорию, если её нет
            file_path.parent.mkdir(parents=True, exist_ok=True)
    
>           with temp_file.open("w", encoding="utf-8") as f:
E           TypeError: 'Mock' object does not support the context manager protocol

src/utils/file_handlers.py:62: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.file_handlers:file_handlers.py:72 Failed to write test.json: 'Mock' object does not support the context manager protocol
_____________ TestStorageFactoryComprehensive.test_create_storage_json _____________

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3cba4250>

    def test_create_storage_json(self):
        """Тест создания JSON хранилища"""
>       with patch('src.storage.storage_factory.JSONSaver') as mock_json:

tests/test_comprehensive_missing_coverage.py:973: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37c60dd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.storage_factory' from '/home/runner/workspace/tests/../src/storage/storage_factory.py'> does not have the attribute 'JSONSaver'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestStorageFactoryComprehensive.test_create_storage_csv ______________

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3d1d0090>

    def test_create_storage_csv(self):
        """Тест создания CSV хранилища"""
>       with patch('src.storage.storage_factory.CSVSaver') as mock_csv:

tests/test_comprehensive_missing_coverage.py:984: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3ca46c10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.storage_factory' from '/home/runner/workspace/tests/../src/storage/storage_factory.py'> does not have the attribute 'CSVSaver'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestStorageFactoryComprehensive.test_create_storage_unknown_type _________

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3d1d05d0>

    def test_create_storage_unknown_type(self):
        """Тест создания хранилища неизвестного типа"""
        with pytest.raises(ValueError, match="Неизвестный тип хранилища"):
>           StorageFactory.create_storage('unknown_type')

tests/test_comprehensive_missing_coverage.py:996: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'unknown_type'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: unknown_type

src/storage/storage_factory.py:20: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3d1d05d0>

    def test_create_storage_unknown_type(self):
        """Тест создания хранилища неизвестного типа"""
>       with pytest.raises(ValueError, match="Неизвестный тип хранилища"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Неизвестный тип хранилища'
E        Input: 'Поддерживается только PostgreSQL хранилище, получен: unknown_type'

tests/test_comprehensive_missing_coverage.py:995: AssertionError
_________ TestStorageFactoryComprehensive.test_get_available_storage_types _________

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3d1d0dd0>

    def test_get_available_storage_types(self):
        """Тест получения доступных типов хранилищ"""
>       types = StorageFactory.get_available_storage_types()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'StorageFactory' has no attribute 'get_available_storage_types'

tests/test_comprehensive_missing_coverage.py:1000: AttributeError
_________ TestStorageFactoryComprehensive.test_create_storage_with_config __________

self = <tests.test_comprehensive_missing_coverage.TestStorageFactoryComprehensive object at 0x7fbe3d1d0810>

    def test_create_storage_with_config(self):
        """Тест создания хранилища с конфигурацией"""
        config = {'host': 'localhost', 'port': 5432}
    
        with patch('src.storage.storage_factory.PostgresSaver') as mock_postgres:
            mock_instance = Mock()
            mock_postgres.return_value = mock_instance
    
>           storage = StorageFactory.create_storage('postgres', config)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: StorageFactory.create_storage() takes from 0 to 1 positional arguments but 2 were given

tests/test_comprehensive_missing_coverage.py:1015: TypeError
____________ TestCachedAPIComprehensive.test_cached_api_initialization _____________

self = <tests.test_comprehensive_missing_coverage.TestCachedAPIComprehensive object at 0x7fbe3cba7ed0>
base_api = <src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe37c8da90>
cache_dir = '/tmp/tmpv4gwd_5a'

    def test_cached_api_initialization(self, base_api, cache_dir):
        """Тест инициализации CachedAPI"""
>       cached_api = CachedAPI(base_api, cache_dir)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1042: TypeError
________ TestEnvLoaderComprehensive.test_get_env_var_nonexistent_no_default ________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3d1d2150>

    def test_get_env_var_nonexistent_no_default(self):
        """Тест получения несуществующей переменной без значения по умолчанию"""
        with patch.dict(os.environ, {}, clear=True):
            result = EnvLoader.get_env_var('NONEXISTENT_VAR')
>           assert result is None
E           AssertionError: assert '' is None

tests/test_comprehensive_missing_coverage.py:1118: AssertionError
______________ TestEnvLoaderComprehensive.test_load_env_file_success _______________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3d1d3b50>
mock_file = <MagicMock name='open' id='140455039467920'>

    @patch('builtins.open', new_callable=mock_open, read_data='TEST_VAR=test_value\nANOTHER_VAR=another_value\n')
    def test_load_env_file_success(self, mock_file):
        """Тест успешной загрузки .env файла"""
        with patch('os.path.exists', return_value=True):
            result = EnvLoader.load_env_file('.env')
    
>           assert result is True
E           assert None is True

tests/test_comprehensive_missing_coverage.py:1126: AssertionError
____________ TestEnvLoaderComprehensive.test_load_env_file_nonexistent _____________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3d1d30d0>

    def test_load_env_file_nonexistent(self):
        """Тест загрузки несуществующего .env файла"""
        with patch('os.path.exists', return_value=False):
            result = EnvLoader.load_env_file('nonexistent.env')
    
>           assert result is False
E           assert None is False

tests/test_comprehensive_missing_coverage.py:1134: AssertionError
____________ TestEnvLoaderComprehensive.test_get_database_url_from_env _____________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3d1d3610>

    def test_get_database_url_from_env(self):
        """Тест получения DATABASE_URL из переменных окружения"""
        test_url = 'postgresql://user:pass@localhost:5432/db'
        with patch.dict(os.environ, {'DATABASE_URL': test_url}):
>           result = EnvLoader.get_database_url()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'EnvLoader' has no attribute 'get_database_url'

tests/test_comprehensive_missing_coverage.py:1140: AttributeError
_____________ TestEnvLoaderComprehensive.test_get_database_url_default _____________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3d1d3f90>

    def test_get_database_url_default(self):
        """Тест получения DATABASE_URL со значением по умолчанию"""
        with patch.dict(os.environ, {}, clear=True):
>           result = EnvLoader.get_database_url()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'EnvLoader' has no attribute 'get_database_url'

tests/test_comprehensive_missing_coverage.py:1146: AttributeError
________________ TestEnvLoaderComprehensive.test_is_debug_mode_true ________________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3cd7add0>

    def test_is_debug_mode_true(self):
        """Тест проверки режима отладки - включен"""
        with patch.dict(os.environ, {'DEBUG': 'True'}):
>           assert EnvLoader.is_debug_mode() is True
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'EnvLoader' has no attribute 'is_debug_mode'

tests/test_comprehensive_missing_coverage.py:1153: AttributeError
_______________ TestEnvLoaderComprehensive.test_is_debug_mode_false ________________

self = <tests.test_comprehensive_missing_coverage.TestEnvLoaderComprehensive object at 0x7fbe3cd7a190>

    def test_is_debug_mode_false(self):
        """Тест проверки режима отладки - выключен"""
        with patch.dict(os.environ, {'DEBUG': 'False'}):
>           assert EnvLoader.is_debug_mode() is False
                   ^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'EnvLoader' has no attribute 'is_debug_mode'

tests/test_comprehensive_missing_coverage.py:1161: AttributeError
__________ TestAPIModulesComprehensive.test_hh_api_get_vacancies_success ___________

self = <MagicMock name='get' id='140454956003920'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestAPIModulesComprehensive object at 0x7fbe3cd7a3d0>
mock_get = <MagicMock name='get' id='140454956003920'>

    @patch('requests.get')
    def test_hh_api_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий из HeadHunter API"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "items": [
                {"id": "1", "name": "Python Developer"},
                {"id": "2", "name": "Java Developer"}
            ],
            "found": 2
        }
        mock_get.return_value = mock_response
    
        hh_api = HeadHunterAPI()
        result = hh_api.get_vacancies("Python")
    
        assert isinstance(result, list)
        assert len(result) >= 0
>       mock_get.assert_called()
E       AssertionError: Expected 'get' to have been called.

tests/test_comprehensive_missing_coverage.py:1189: AssertionError
------------------------------- Captured stderr call -------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 465.45page/s, vacancies=931]
___________ TestAPIModulesComprehensive.test_hh_api_get_vacancies_error ____________

self = <tests.test_comprehensive_missing_coverage.TestAPIModulesComprehensive object at 0x7fbe3cd7a9d0>
mock_get = <MagicMock name='get' id='140454940814352'>

    @patch('requests.get')
    def test_hh_api_get_vacancies_error(self, mock_get):
        """Тест обработки ошибки при получении вакансий из HeadHunter API"""
        mock_get.side_effect = Exception("Network error")
    
        hh_api = HeadHunterAPI()
        result = hh_api.get_vacancies("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 0
E       AssertionError: assert 931 == 0
E        +  where 931 = len([{'accept_incomplete_resumes': False, 'accept_temporary': False, 'address': None, 'adv_context': None, ...}, {'accept_... ...}, {'accept_incomplete_resumes': False, 'accept_temporary': False, 'address': None, 'adv_context': None, ...}, ...])

tests/test_comprehensive_missing_coverage.py:1200: AssertionError
------------------------------- Captured stderr call -------------------------------
Fetching pages: 100%|██████████| 20/20 [00:00<00:00, 640.23page/s, vacancies=931]
__________ TestAPIModulesComprehensive.test_sj_api_get_vacancies_success ___________

self = <MagicMock name='get' id='140454938654672'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestAPIModulesComprehensive object at 0x7fbe3cd7b490>
mock_get = <MagicMock name='get' id='140454938654672'>

    @patch('requests.get')
    def test_sj_api_get_vacancies_success(self, mock_get):
        """Тест успешного получения вакансий из SuperJob API"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "objects": [
                {"id": 1, "profession": "Python Developer"},
                {"id": 2, "profession": "Java Developer"}
            ],
            "total": 2
        }
        mock_get.return_value = mock_response
    
        sj_api = SuperJobAPI()
        result = sj_api.get_vacancies("Python")
    
        assert isinstance(result, list)
>       mock_get.assert_called()
E       AssertionError: Expected 'get' to have been called.

tests/test_comprehensive_missing_coverage.py:1220: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
WARNING  src.api_modules.sj_api:sj_api.py:163 SuperJob API ключ не настроен или используется тестовый ключ
______________ TestAPIModulesComprehensive.test_hh_api_initialization ______________

self = <tests.test_comprehensive_missing_coverage.TestAPIModulesComprehensive object at 0x7fbe3cd78090>

    def test_hh_api_initialization(self):
        """Тест инициализации HeadHunter API"""
        hh_api = HeadHunterAPI()
    
        assert hh_api is not None
        assert hasattr(hh_api, 'get_vacancies')
>       assert hasattr(hh_api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.hh_api.HeadHunterAPI object at 0x7fbe36e47190>, 'base_url')

tests/test_comprehensive_missing_coverage.py:1239: AssertionError
______________ TestAPIModulesComprehensive.test_sj_api_initialization ______________

self = <tests.test_comprehensive_missing_coverage.TestAPIModulesComprehensive object at 0x7fbe3cd78750>

    def test_sj_api_initialization(self):
        """Тест инициализации SuperJob API"""
        sj_api = SuperJobAPI()
    
        assert sj_api is not None
        assert hasattr(sj_api, 'get_vacancies')
>       assert hasattr(sj_api, 'base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.sj_api.SuperJobAPI object at 0x7fbe3c9c2e90>, 'base_url')

tests/test_comprehensive_missing_coverage.py:1247: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________ TestIntegrationComprehensive.test_ui_config_cache_integration ___________

self = <tests.test_comprehensive_missing_coverage.TestIntegrationComprehensive object at 0x7fbe3cd6a9d0>

    def test_ui_config_cache_integration(self):
        """Тест интеграции UI конфигурации с кэшем"""
        config = UIConfig()
    
        with tempfile.TemporaryDirectory() as cache_dir:
            cache = Cache(cache_dir)
    
            # Тестируем сохранение настроек в кэш
            settings = config.get_pagination_settings()
>           cache.save_to_cache("ui_settings", settings)
            ^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:1310: AttributeError
_________ TestIntegrationComprehensive.test_api_cache_storage_integration __________

self = <tests.test_comprehensive_missing_coverage.TestIntegrationComprehensive object at 0x7fbe3cd7ad10>

    def test_api_cache_storage_integration(self):
        """Тест интеграции API, кэша и хранилища"""
        with tempfile.TemporaryDirectory() as cache_dir:
            base_api = HeadHunterAPI()
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_comprehensive_missing_coverage.py:1319: TypeError
___________ TestIntegrationComprehensive.test_full_workflow_integration ____________

self = <tests.test_comprehensive_missing_coverage.TestIntegrationComprehensive object at 0x7fbe3cd7bdd0>

    def test_full_workflow_integration(self):
        """Тест полного рабочего процесса"""
        config = UIConfig()
    
        with tempfile.TemporaryDirectory() as temp_dir:
>           file_handler = FileHandler()
                           ^^^^^^^^^^^
E           NameError: name 'FileHandler' is not defined

tests/test_comprehensive_missing_coverage.py:1352: NameError
_________________ TestEdgeCasesComprehensive.test_unicode_handling _________________

self = <tests.test_comprehensive_missing_coverage.TestEdgeCasesComprehensive object at 0x7fbe3cd6bf90>

    def test_unicode_handling(self):
        """Тест обработки Unicode данных"""
        with tempfile.TemporaryDirectory() as cache_dir:
            cache = Cache(cache_dir)
    
            unicode_data = {
                "title": "Разработчик Python 🐍",
                "company": "Яндекс",
                "emoji": "💼📊🚀"
            }
    
>           cache.save_to_cache("unicode_test", unicode_data)
            ^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:1401: AttributeError
___________ TestEdgeCasesComprehensive.test_concurrent_access_simulation ___________

self = <tests.test_comprehensive_missing_coverage.TestEdgeCasesComprehensive object at 0x7fbe3cd6b5d0>

    def test_concurrent_access_simulation(self):
        """Тест симуляции конкурентного доступа"""
        with tempfile.TemporaryDirectory() as cache_dir:
            cache1 = Cache(cache_dir)
            cache2 = Cache(cache_dir)
    
            # Имитируем одновременное использование
>           cache1.save_to_cache("concurrent1", {"data": 1})
            ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'FileCache' object has no attribute 'save_to_cache'

tests/test_comprehensive_missing_coverage.py:1413: AttributeError
___________________ TestEdgeCasesComprehensive.test_type_safety ____________________

self = <tests.test_comprehensive_missing_coverage.TestEdgeCasesComprehensive object at 0x7fbe3cd6a410>

    def test_type_safety(self):
        """Тест типобезопасности"""
        config = UIPaginationConfig()
    
        # Различные типы входных данных
>       assert config.validate_items_per_page("10") == 10  # строка
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:1435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = UIPaginationConfig(default_items_per_page=10, search_results_per_page=5, saved_vacancies_per_page=10, top_vacancies_per_page=10, max_items_per_page=50, min_items_per_page=1)
value = '10'

    def validate_items_per_page(self, value: int) -> int:
        """
        Валидация количества элементов на странице
    
        Args:
            value: Предполагаемое количество элементов
    
        Returns:
            Валидное количество элементов
        """
>       if value < self.min_items_per_page:
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'str' and 'int'

src/config/ui_config.py:54: TypeError
_____________________ TestSJAPIConfigCoverage.test_get_api_key _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fbe3d20eb50>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
____________________ TestSJAPIConfigCoverage.test_get_base_url _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fbe3d20ee50>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_________________ TestSJAPIConfigCoverage.test_get_request_headers _________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7fbe3d20ec90>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
________________ TestDBManagerCoverage.test_create_database_schema _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce46c90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37cc4ad0>
mock_connection = (<Mock id='140454956650384'>, <Mock name='mock.cursor()' id='140454956660240'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
___________________ TestDBManagerCoverage.test_save_company_data ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce47b90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe36b99950>
mock_connection = (<Mock id='140454956250832'>, <Mock name='mock.cursor()' id='140454931254736'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
______________ TestDBManagerCoverage.test_save_vacancy_comprehensive _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce47d90>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ca7ae10>
mock_connection = (<Mock id='140455038131664'>, <Mock name='mock.cursor()' id='140455038131856'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
_________________ TestDBManagerCoverage.test_bulk_save_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce44b10>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c81550>
mock_connection = (<Mock id='140454956376208'>, <Mock name='mock.cursor()' id='140454956373712'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
___________________ TestDBManagerCoverage.test_query_operations ____________________

self = <Mock name='mock.cursor().execute' id='140454956012880'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce448d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37bebf90>
mock_connection = (<Mock id='140454955749520'>, <Mock name='mock.cursor()' id='140454955746256'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454953634320'>, исправляем...
_________________ TestDBManagerCoverage.test_search_functionality __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce44f50>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c2ad50>
mock_connection = (<Mock id='140454956312656'>, <Mock name='mock.cursor()' id='140454956020432'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
___________________ TestDBManagerCoverage.test_filter_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce45890>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37beb850>
mock_connection = (<Mock id='140454955749456'>, <Mock name='mock.cursor()' id='140454955747216'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
________________ TestDBManagerCoverage.test_aggregation_operations _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce45cd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ca72e50>
mock_connection = (<Mock id='140455027639056'>, <Mock name='mock.cursor()' id='140455027646352'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
___________________ TestDBManagerCoverage.test_update_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce46610>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c240d0>
mock_connection = (<Mock id='140454956263184'>, <Mock name='mock.cursor()' id='140454956264208'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
___________________ TestDBManagerCoverage.test_delete_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce33d10>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3ca795d0>
mock_connection = (<Mock id='140454956631248'>, <Mock name='mock.cursor()' id='140455038139152'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
________________ TestDBManagerCoverage.test_transaction_management _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7fbe3ce32250>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37c3bf50>
mock_connection = (<Mock id='140454956080848'>, <Mock name='mock.cursor()' id='140454956075472'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
____________ TestDBManagerFixed.test_get_companies_and_vacancies_count _____________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d071ed0>
mock_connect = <MagicMock name='connect' id='140454952664592'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe378941d0>
mock_connection = (<Mock name='connect()' id='140454952260304'>, <Mock id='140454952259984'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
____________________ TestDBManagerFixed.test_get_all_vacancies _____________________

self = <Mock name='mock.execute' id='140454932255120'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d071f50>
mock_connect = <MagicMock name='connect' id='140454952501968'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe378d0fd0>
mock_connection = (<Mock name='connect()' id='140454952508816'>, <Mock id='140454952508560'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454952464528'>, исправляем...
______________________ TestDBManagerFixed.test_get_avg_salary ______________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d0702d0>
mock_connect = <MagicMock name='connect' id='140454956604816'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe37cb8650>
mock_connection = (<Mock name='connect()' id='140454956607504'>, <Mock id='140454956607568'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956010192'>, исправляем...
_____________ TestDBManagerFixed.test_get_vacancies_with_higher_salary _____________

self = <Mock name='mock.execute' id='140454956131984'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d06b010>
mock_connect = <MagicMock name='connect' id='140454952748688'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3790c1d0>
mock_connection = (<Mock name='connect()' id='140454952758288'>, <Mock id='140454952758096'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454952962384'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140455027575440'>, исправляем...
________________ TestDBManagerFixed.test_get_vacancies_with_keyword ________________

self = <Mock name='mock.execute' id='140454956217744'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d06b250>
mock_connect = <MagicMock name='connect' id='140455037800464'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3cd7b790>
mock_connection = (<Mock name='connect()' id='140455039299792'>, <Mock id='140455039302224'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454941166800'>, исправляем...
____________________ TestDBManagerFixed.test_get_database_stats ____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7fbe3d06b8d0>
mock_connect = <MagicMock name='connect' id='140454956250384'>
db_manager = <src.storage.db_manager.DBManager object at 0x7fbe3cd7a6d0>
mock_connection = (<Mock name='connect()' id='140454956240144'>, <Mock id='140454956245968'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140455027243216'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_______ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects _______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fbe3d069790>
mock_connect = <MagicMock name='connect' id='140454953002512'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37c85dd0>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7fbe37aad4a0>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37c85dd0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7fbe37aad4a0>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________________ TestPostgresSaverFixed.test_delete_vacancy_by_id _________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7fbe3d06a8d0>
mock_connect = <MagicMock name='connect' id='140454941314384'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe366056d0>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe366056d0>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count __________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fbe3d06acd0>
mock_connect = <MagicMock name='connect' id='140454931259728'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3648e690>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
_________________ TestSimpleDBAdapterFixed.test_get_all_vacancies __________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fbe3d068c50>
mock_connect = <MagicMock name='connect' id='140454955759504'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe379e5e10>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
_____________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword _____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fbe3d068210>
mock_connect = <MagicMock name='connect' id='140454953059472'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36ec8090>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
________________ TestSimpleDBAdapterFixed.test_init_database_schema ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7fbe3d068b10>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3ca86250>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3ca86b90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3ca86250> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIModulesFixed.test_hh_api_methods_coverage _________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fbe3d02c950>
mock_get = <MagicMock name='get' id='140454952368912'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
_____________ TestAPIModulesFixed.test_cached_api_basic_functionality ______________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7fbe3d02d050>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
_____________________ TestEdgeCasesFixed.test_db_empty_results _____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fbe3cff4f10>
mock_connect = <MagicMock name='connect' id='140454956052816'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454956658000'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140454952515472'>, исправляем...
________________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7fbe3d02ffd0>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
_______________ TestLowCoverageComponents.test_api_methods_coverage ________________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7fbe3d35b490>
mock_get = <MagicMock name='get' id='140454931898960'>

    @patch('requests.get')
    def test_api_methods_coverage(self, mock_get):
        """Тест покрытия методов API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
            from src.api_modules.sj_api import SuperJobAPI
    
            # Тестируем HeadHunter API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
                assert isinstance(result, (dict, list))
    
            # Тестируем SuperJob API
            sj_api = SuperJobAPI()
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:374: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
____________ TestPostgresSaverCoverage.test_database_connection_methods ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9d350>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37906710>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
_______________ TestPostgresSaverCoverage.test_create_tables_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9d710>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37c9b350>
mock_connection = (<Mock id='140454956467024'>, <Mock name='mock.cursor()' id='140454956478864'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
________________ TestPostgresSaverCoverage.test_save_vacancy_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9dd50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37cef610>
mock_connection = (<Mock id='140454956811728'>, <Mock name='mock.cursor()' id='140454956823952'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
______________ TestPostgresSaverCoverage.test_save_multiple_vacancies ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9e3d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36ccd310>
mock_connection = (<Mock id='140454956814736'>, <Mock name='mock.cursor()' id='140454939910416'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140454955410512'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140454955410512'> = <Mock name='mock.cursor()' id='140454939910416'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
_______________ TestPostgresSaverCoverage.test_get_vacancies_method ________________

self = <Mock name='mock.cursor().execute' id='140454932459280'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9ea50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3cbf8410>
mock_connection = (<Mock id='140454941314448'>, <Mock name='mock.cursor()' id='140454941313808'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
____________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9f0d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37904e90>
mock_connection = (<Mock id='140454955819728'>, <Mock name='mock.cursor()' id='140454955820624'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
______________ TestPostgresSaverCoverage.test_filter_by_salary_range _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9f750>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37ccf750>
mock_connection = (<Mock id='140454956685008'>, <Mock name='mock.cursor()' id='140454956682768'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
_______________ TestPostgresSaverCoverage.test_get_companies_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9fdd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe365affd0>
mock_connection = (<Mock id='140454956692624'>, <Mock name='mock.cursor()' id='140454956692880'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_______________ TestPostgresSaverCoverage.test_delete_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf67150>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37c2ec90>
mock_connection = (<Mock id='140454956034448'>, <Mock name='mock.cursor()' id='140454956027920'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe37c2ec90>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
__________________ TestPostgresSaverCoverage.test_clear_all_data ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf66750>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36b99950>
mock_connection = (<Mock id='140454938645008'>, <Mock name='mock.cursor()' id='140454938651408'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_______________ TestPostgresSaverCoverage.test_get_statistics_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf67010>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36719010>
mock_connection = (<Mock id='140454933926672'>, <Mock name='mock.cursor()' id='140454933932112'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
__________________ TestPostgresSaverCoverage.test_export_to_json ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf67ad0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36e7c190>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
_________________ TestPostgresSaverCoverage.test_import_from_json __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf640d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36eb7b50>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
_______________ TestPostgresSaverCoverage.test_transaction_rollback ________________

self = <Mock name='mock.rollback' id='140454933394384'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cf65110>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36670fd0>
mock_connection = (<Mock id='140454942235472'>, <Mock name='mock.cursor()' id='140454933314192'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
_________________ TestPostgresSaverCoverage.test_batch_operations __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7fbe3cd9d5d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3779ae10>
mock_connection = (<Mock id='140454951234000'>, <Mock name='mock.cursor()' id='140454951233616'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe3779ae10>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
_____________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3ceb6690>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3ca85250>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
___________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3d3519d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36670b50>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1c250>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36f17e10>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe36f14250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36f17e10> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1cf10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37ced510>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37cee2d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37ced510> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1da10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe366b87d0>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe366b9e50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe366b87d0> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1d0d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37d1bd10>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37d19ed0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37d1bd10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1e7d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3790ead0>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3790ea90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3790ead0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1f090>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe378ac950>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe378afe50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe378ac950> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ________________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1ecd0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3c062410>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3c060210>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe3c062410> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc1ff90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36eabb10>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe36ea9e10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe36eabb10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7fbe3cc28450>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37c32510>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37c31090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37c32510> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7fbe3cf3fd10>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7fbe365ac250>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe36917550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7fbe3d1f0e10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36de1f10>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe36f22650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36de1f10> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fbe3d1f2450>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe378714d0>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37870d50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe378714d0> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7fbe3d1f2810>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37ca9650>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe37ca9a50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe37ca9650> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7fbe3d0567d0>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='140454942529232'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______ TestVacancyStorageServiceCoverage.test_storage_service_initialization _______

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fbe3d055450>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
____________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fbe3d0546d0>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fbe36604090>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
___________ TestVacancyStorageServiceCoverage.test_search_functionality ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fbe3d0558d0>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fbe36dc9010>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_____________ TestVacancyStorageServiceCoverage.test_delete_operations _____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7fbe3d055d50>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7fbe36f7f590>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
__________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fbe3d048bd0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fbe36646610>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fbe3d049210>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fbe36604110>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
____________ TestDeduplicationServiceCoverage.test_identify_duplicates _____________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7fbe3d049890>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7fbe3d055750>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_____________ TestFilteringServiceCoverage.test_filter_by_salary_range _____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fbe3d04a790>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fbe3779a850>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_keyword ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fbe3d04add0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fbe378f1e10>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_company ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fbe3d04b450>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fbe37c27c10>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
_______________ TestFilteringServiceCoverage.test_complex_filtering ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7fbe3d04ba90>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7fbe37c5b590>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
________________ TestVacancyRepositoryCoverage.test_create_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fbe3d04afd0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe37895a50>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_______________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fbe3d04a310>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe378f2a10>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
________________ TestVacancyRepositoryCoverage.test_update_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fbe3d0557d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe37c25f10>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe37c25f10>
vacancy = <Mock id='140454956006288'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140454956006608'>: 'Mock' object does not support the context manager protocol
_______________ TestVacancyRepositoryCoverage.test_get_all_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fbe3d023950>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe379293d0>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe379293d0>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
________________ TestVacancyRepositoryCoverage.test_count_vacancies ________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7fbe3d022110>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7fbe3779b190>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fbe3d023510>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fbe366d5190>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_required_fields ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fbe3d023d10>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fbe37954f50>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
______________ TestVacancyValidatorCoverage.test_validate_data_types _______________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7fbe3d021710>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7fbe36590350>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________ TestUINavigationExtended.test_paginate_display_custom_actions ___________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7fbe3d11c310>
mock_print = <MagicMock name='print' id='140454953160848'>
mock_input = <MagicMock name='input' id='140455027239760'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='140454953167248'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
__________________ TestUnifiedAPI.test_filter_by_target_companies __________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fbe3d15bd10>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe37907050>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
___________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources ___________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7fbe3d155950>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe37beb190>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
______________ TestUnifiedAPIComplete.test_filter_by_target_companies ______________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7fbe3d15c210>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7fbe37794950>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestUserInterfaceConsolidated.test_main_interface_complete ____________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fbe3caaa710>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fbe3caa9710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterfaceConsolidated.test_interface_components_integration ________

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7fbe3caab2d0>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
================================== tests coverage ==================================
_________________ coverage: platform linux, python 3.11.13-final-0 _________________

Name                                                     Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------------
src/__init__.py                                              0      0   100%
src/api_modules/__init__.py                                  0      0   100%
src/api_modules/base_api.py                                 23      0   100%
src/api_modules/cached_api.py                              168     45    73%   114-115, 144-147, 157, 166-168, 183, 186-187, 203, 215-238, 247, 267-269, 298-299, 308-310, 335-336, 340-342
src/api_modules/get_api.py                                  53     19    64%   46-54, 64, 73-74, 102-103, 116-118, 124, 126-132, 134, 136
src/api_modules/hh_api.py                                  142     25    82%   77-85, 169, 178-180, 219-221, 233, 256, 276, 289, 293-295, 329-331
src/api_modules/sj_api.py                                  128     28    78%   99-106, 206-210, 222, 263-264, 277-279, 291-292, 296-308
src/api_modules/unified_api.py                             270     77    71%   124, 133, 154-155, 175-176, 212-213, 221-240, 245, 291-293, 304-306, 316-322, 390-391, 401-418, 422-432, 436-458
src/config/__init__.py                                       0      0   100%
src/config/api_config.py                                    13      0   100%
src/config/app_config.py                                    17      0   100%
src/config/db_config.py                                     61     25    59%   24, 44-48, 85-88, 96-99, 104, 133-136, 156-172
src/config/hh_api_config.py                                 21      2    90%   31, 37
src/config/sj_api_config.py                                 49     18    63%   39, 59, 62, 68-75, 79-87
src/config/target_companies.py                              61     25    59%   119, 124-130, 135-138, 143-146, 151, 156-162, 167, 185, 190
src/config/ui_config.py                                     27      0   100%
src/interfaces/__init__.py                                   0      0   100%
src/interfaces/main_application_interface.py               121     88    27%   76, 89-98, 109-136, 140-152, 156-161, 166-180, 184-214, 224-225, 230, 234-236
src/storage/__init__.py                                      6      0   100%
src/storage/abstract.py                                     14      0   100%
src/storage/abstract_db_manager.py                          21      6    71%   16, 26, 36, 46, 59, 69
src/storage/components/__init__.py                           0      0   100%
src/storage/components/database_connection.py               53     11    79%   14-16, 19-20, 77-78, 88-89, 97-98
src/storage/components/vacancy_repository.py               113     61    46%   50-51, 119-134, 146-150, 174-178, 190-209, 221-291
src/storage/components/vacancy_validator.py                 65     22    66%   62, 65, 73-74, 78-79, 92, 99, 110, 115, 120, 138-152
src/storage/db_manager.py                                  348    188    46%   17-24, 63, 83-139, 223-228, 246-247, 262-272, 282-338, 348-361, 376-405, 419-451, 519-522, 525-528, 533-535, 574-576, 593-594, 646-651, 665, 715-718, 723-728, 818-820, 832, 844-845, 857-859, 871-877, 892-1022
src/storage/interfaces/typed_data_processor.py              46     25    46%   32, 45, 64, 78, 94, 100, 106-117, 124, 130-133, 139-148
src/storage/postgres_saver.py                              790    500    37%   10-13, 72-74, 109-111, 124-125, 133-140, 145-146, 148-151, 176-183, 188-194, 199-200, 202-205, 263-265, 280-281, 295-305, 310-317, 322-323, 325-328, 338, 342-343, 374-380, 399-400, 404-409, 417-419, 442-445, 452, 455-458, 473, 480, 487, 594-598, 604-606, 628-634, 655, 662-664, 678, 690-692, 705, 721-779, 783-895, 918-958, 961, 981-988, 1002-1007, 1010-1016, 1024-1048, 1067-1098, 1102-1113, 1125-1180, 1184-1196, 1227-1228, 1231-1232, 1236-1237, 1246-1247, 1264-1303, 1323-1574, 1587-1601, 1611, 1614, 1617-1635
src/storage/services/__init__.py                             4      0   100%
src/storage/services/abstract_filter_service.py             30      7    77%   34, 44, 64, 88, 101, 114, 127
src/storage/services/abstract_storage_service.py            25      6    76%   34, 47, 60, 73, 83, 93
src/storage/services/company_id_filter_service.py           94     62    34%   49, 62, 68-76, 85-135, 141-202, 206-214, 223
src/storage/services/deduplication_service.py               64     43    33%   15-16, 20-21, 43, 56-129, 133-142, 146-154, 183, 192
src/storage/services/filtering_service.py                  105     66    37%   15-16, 20-21, 25-26, 48, 76-88, 95-132, 143-155, 159-170, 189-199, 228, 237
src/storage/services/sql_deduplication_service.py           64     49    23%   44-64, 68-111, 116-148, 152-160, 173-182
src/storage/services/sql_filter_service.py                  89     63    29%   47, 59-78, 82-146, 152-191, 195-202, 207-209, 218-247
src/storage/services/vacancy_processing_coordinator.py      44      0   100%
src/storage/services/vacancy_storage_service.py            334    239    28%   15-16, 20-21, 25-26, 31-32, 37-38, 42-43, 47-48, 52-53, 57-58, 93-94, 119-146, 150-170, 176-194, 211-215, 226-238, 244-320, 334, 338-339, 360-362, 366-395, 417-469, 499, 511-535, 539-590, 594-601, 606, 610, 614, 618
src/storage/simple_db_adapter.py                           142    104    27%   54, 57, 61-101, 105-117, 121, 125-165, 169-202, 206-210, 219
src/storage/storage_factory.py                              13      0   100%
src/ui_interfaces/__init__.py                                0      0   100%
src/ui_interfaces/console_interface.py                     394    306    22%   23-25, 69, 82, 84, 86, 88, 90, 92, 94, 97, 100, 102-110, 116-127, 157, 161, 165, 169, 173-224, 228-301, 305, 309, 319-355, 359, 370-371, 382-385, 395-544, 548-579, 584-604
src/ui_interfaces/source_selector.py                        44     30    32%   25-51, 64, 74-79
src/ui_interfaces/vacancy_display_handler.py                72     58    19%   32-70, 74-107, 111-141
src/ui_interfaces/vacancy_operations_coordinator.py        194    105    46%   68-79, 100, 102, 104, 108, 116-122, 126-165, 169-192, 196-198, 211, 248-273, 302-322
src/ui_interfaces/vacancy_search_handler.py                152    127    16%   38-76, 90-114, 124, 135-170, 180-197, 209-232, 248-262, 272-308
src/user_interface.py                                       55     47    15%   26-94, 98
src/utils/__init__.py                                        0      0   100%
src/utils/abstract_filter.py                                26     14    46%   30, 47, 61, 75, 88-102
src/utils/api_data_filter.py                               154     88    43%   9-10, 25, 55-56, 71-83, 97, 105-106, 122, 130-131, 148-160, 173-185, 191-196, 206, 212, 215, 217, 223-241, 245, 256, 269, 275-284, 288-307
src/utils/base_formatter.py                                 38     11    71%   14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64
src/utils/cache.py                                         135     44    67%   45-46, 61-62, 78, 93-94, 98-100, 115-117, 124-126, 130-139, 165, 169-170, 174-176, 205-210, 221-224, 227, 236-238, 244
src/utils/data_normalizers.py                               75     13    83%   77-80, 107, 113-121, 154-162
src/utils/db_manager_demo.py                               236    218     8%   32, 38-64, 73-81, 85-103, 107-155, 159-211, 215-224, 228-272, 276-315, 319-370, 377-382, 386
src/utils/decorators.py                                     73      7    90%   37-39, 44-46, 87
src/utils/description_parser.py                             70     55    21%   41-64, 77-103, 116-135, 141-177
src/utils/env_loader.py                                     59     34    42%   32-33, 41-76, 104-111
src/utils/file_handlers.py                                  38      3    92%   46-48
src/utils/menu_manager.py                                   49      8    84%   38, 52-56, 77, 93
src/utils/paginator.py                                      28      9    68%   43-44, 51-52, 57-61
src/utils/salary.py                                        113     18    84%   35-36, 55-61, 71-72, 78, 94, 152, 157, 164, 181, 207
src/utils/search_utils.py                                  156      6    96%   204, 215, 219, 223, 227, 282
src/utils/source_manager.py                                 60     38    37%   65, 77-80, 92-95, 108-119, 131-134, 146, 158-161, 173-176, 188-191, 198-200
src/utils/ui_helpers.py                                    161      4    98%   135, 225-226, 325
src/utils/ui_navigation.py                                  99      0   100%
src/utils/vacancy_formatter.py                             167     59    65%   122, 129, 148, 154, 159-164, 170-171, 176, 182, 188-201, 206, 213, 218, 225, 229-231, 235-241, 246, 259-262, 273-304
src/utils/vacancy_operations.py                            165     99    40%   43, 64, 75-87, 111, 122-134, 159, 170-182, 220-244, 248-261, 264-265, 268-269, 290-310, 320-339, 346-370
src/utils/vacancy_stats.py                                  86     53    38%   57-60, 83-91, 95-100, 110-158, 163-165
src/vacancies/__init__.py                                    0      0   100%
src/vacancies/abstract.py                                   10      0   100%
src/vacancies/abstract_models.py                            99     28    72%   18, 23, 28, 33, 38, 44, 53, 58, 63, 69, 75, 84, 89, 94, 100, 106, 115, 120, 125, 130, 135, 140, 146, 155, 160, 165, 171, 177
src/vacancies/models.py                                    390    212    46%   40, 44, 48, 64, 77, 81, 89, 91, 93, 98-102, 106, 122, 126, 131-133, 141, 144, 149, 153, 169, 173, 178-180, 188, 191, 196, 200, 299, 317, 329-332, 344, 348, 352, 358, 370, 374, 378, 384, 404-438, 443-451, 456-651, 670, 686, 701-706, 720, 725-727, 731-733, 737-739, 743-745, 749
src/vacancies/parsers/__init__.py                           55     11    80%   16, 21, 26, 31, 36, 88, 97, 106, 111, 116, 121
src/vacancies/parsers/base_parser.py                         9      2    78%   19, 32
src/vacancies/parsers/hh_parser.py                          55     10    82%   21, 32-33, 55-57, 96-98, 119
src/vacancies/parsers/sj_parser.py                          57     28    51%   24-43, 57-65, 107, 121-122, 145-147
--------------------------------------------------------------------------------------
TOTAL                                                     7192   3549    51%
============================= short test summary info ==============================
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_get_vacancies_from_all_sources - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_search_with_filters - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_error_handling_api_failures - AttributeError: 'method' object has no attribute 'side_effect'
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_companies_and_vacancies_count_success - AssertionError: assert 12 == 3
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_companies_and_vacancies_count_error - AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_all_vacancies_success - assert 0 == 2
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_avg_salary_with_data - assert 1.0 == 125000.0
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_avg_salary_no_data - assert 1.0 is None
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_vacancies_with_higher_salary - assert 0 == 1
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_vacancies_with_keyword - assert 0 == 2
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_em...
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerComprehensive::test_init_database_creates_tables - AttributeError: 'DBManager' object has no attribute '_init_database'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_get_vacancies_with_results - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_delete_vacancy_by_id_success - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_delete_vacancy_by_id_not_found - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_get_vacancies_count_with_filters - TypeError: 'Mock' object is not subscriptable
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_delete_all_vacancies - AssertionError: expected call not found.
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterComprehensive::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_va...
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterComprehensive::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_load_response_existing - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_load_from_cache_nonexistent - AttributeError: 'FileCache' object has no attribute 'load_from_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_is_cache_valid_fresh - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_is_cache_valid_expired - AttributeError: 'FileCache' object has no attribute 'is_cache_valid'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_clear_cache - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheComprehensive::test_get_cache_size - AttributeError: 'FileCache' object has no attribute 'get_cache_size'
FAILED tests/test_comprehensive_missing_coverage.py::TestFileOperationsComprehensive::test_read_json_success - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestFileOperationsComprehensive::test_json_handler_write_operations - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_comprehensive_missing_coverage.py::TestStorageFactoryComprehensive::test_create_storage_json - AttributeError: <module 'src.storage.storage_factory' from '/home/runner/worksp...
FAILED tests/test_comprehensive_missing_coverage.py::TestStorageFactoryComprehensive::test_create_storage_csv - AttributeError: <module 'src.storage.storage_factory' from '/home/runner/worksp...
FAILED tests/test_comprehensive_missing_coverage.py::TestStorageFactoryComprehensive::test_create_storage_unknown_type - AssertionError: Regex pattern did not match.
FAILED tests/test_comprehensive_missing_coverage.py::TestStorageFactoryComprehensive::test_get_available_storage_types - AttributeError: type object 'StorageFactory' has no attribute 'get_available_st...
FAILED tests/test_comprehensive_missing_coverage.py::TestStorageFactoryComprehensive::test_create_storage_with_config - TypeError: StorageFactory.create_storage() takes from 0 to 1 positional argumen...
FAILED tests/test_comprehensive_missing_coverage.py::TestCachedAPIComprehensive::test_cached_api_initialization - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_get_env_var_nonexistent_no_default - AssertionError: assert '' is None
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_load_env_file_success - assert None is True
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_load_env_file_nonexistent - assert None is False
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_get_database_url_from_env - AttributeError: type object 'EnvLoader' has no attribute 'get_database_url'
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_get_database_url_default - AttributeError: type object 'EnvLoader' has no attribute 'get_database_url'
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_is_debug_mode_true - AttributeError: type object 'EnvLoader' has no attribute 'is_debug_mode'
FAILED tests/test_comprehensive_missing_coverage.py::TestEnvLoaderComprehensive::test_is_debug_mode_false - AttributeError: type object 'EnvLoader' has no attribute 'is_debug_mode'
FAILED tests/test_comprehensive_missing_coverage.py::TestAPIModulesComprehensive::test_hh_api_get_vacancies_success - AssertionError: Expected 'get' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestAPIModulesComprehensive::test_hh_api_get_vacancies_error - AssertionError: assert 931 == 0
FAILED tests/test_comprehensive_missing_coverage.py::TestAPIModulesComprehensive::test_sj_api_get_vacancies_success - AssertionError: Expected 'get' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestAPIModulesComprehensive::test_hh_api_initialization - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestAPIModulesComprehensive::test_sj_api_initialization - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestIntegrationComprehensive::test_ui_config_cache_integration - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestIntegrationComprehensive::test_api_cache_storage_integration - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_comprehensive_missing_coverage.py::TestIntegrationComprehensive::test_full_workflow_integration - NameError: name 'FileHandler' is not defined
FAILED tests/test_comprehensive_missing_coverage.py::TestEdgeCasesComprehensive::test_unicode_handling - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestEdgeCasesComprehensive::test_concurrent_access_simulation - AttributeError: 'FileCache' object has no attribute 'save_to_cache'
FAILED tests/test_comprehensive_missing_coverage.py::TestEdgeCasesComprehensive::test_type_safety - TypeError: '<' not supported between instances of 'str' and 'int'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_base_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_request_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_create_database_schema - AttributeError: 'DBManager' object has no attribute 'create_database_schema'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_company_data - AttributeError: 'DBManager' object has no attribute 'save_company'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_vacancy_comprehensive - AttributeError: 'DBManager' object has no attribute 'save_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_bulk_save_operations - AttributeError: 'DBManager' object has no attribute 'save_companies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_query_operations - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_search_functionality - AttributeError: 'DBManager' object has no attribute 'search_by_keyword'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_filter_operations - AttributeError: 'DBManager' object has no attribute 'filter_by_experience'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_aggregation_operations - AttributeError: 'DBManager' object has no attribute 'count_vacancies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_update_operations - AttributeError: 'DBManager' object has no attribute 'update_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_delete_operations - AttributeError: 'DBManager' object has no attribute 'delete_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_transaction_management - AttributeError: 'DBManager' object has no attribute 'begin_transaction'
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_em...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_va...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_k...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_api_methods_coverage - assert False
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_ke...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have th...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7fbe36de1...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7fbe...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstract...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_v...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_company'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filt...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_required_f...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCo...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_save_vacancies_single_vacancy - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_delete_vacancy_with_object - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_is_vacancy_exists_true - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverComprehensive::test_is_vacancy_exists_false - TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'
ERROR tests/test_comprehensive_missing_coverage.py::TestCachedAPIComprehensive::test_get_vacancies_with_cache_miss - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_comprehensive_missing_coverage.py::TestCachedAPIComprehensive::test_get_vacancies_with_cache_hit - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_comprehensive_missing_coverage.py::TestCachedAPIComprehensive::test_clear_cache - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
ERROR tests/test_comprehensive_missing_coverage.py::TestCachedAPIComprehensive::test_get_cache_size - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
============= 138 failed, 1549 passed, 10 skipped, 8 errors in 19.15s ==============
~/workspace$ 