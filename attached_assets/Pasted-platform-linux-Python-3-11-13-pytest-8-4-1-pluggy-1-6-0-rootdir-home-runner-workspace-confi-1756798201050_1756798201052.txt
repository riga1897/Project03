platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 535 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  2%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  4%]
tests/test_app_config.py .....                                                           [  5%]
tests/test_base_api.py ......                                                            [  6%]
tests/test_base_formatter.py ..........                                                  [  8%]
tests/test_base_parser.py ......                                                         [  9%]
tests/test_cache.py .......                                                              [ 10%]
tests/test_cache_manager.py .....F.......                                                [ 13%]
tests/test_cached_api.py ...........                                                     [ 15%]
tests/test_console_interface.py ......                                                   [ 16%]
tests/test_db_config.py .....                                                            [ 17%]
tests/test_db_manager.py .................                                               [ 20%]
tests/test_decorators.py .......                                                         [ 21%]
tests/test_env_loader.py ............                                                    [ 24%]
tests/test_file_handlers.py ............                                                 [ 26%]
tests/test_get_api.py ......                                                             [ 27%]
tests/test_hh_api.py .......                                                             [ 28%]
tests/test_hh_api_config.py .....                                                        [ 29%]
tests/test_hh_parser.py ........                                                         [ 31%]
tests/test_menu_manager.py ..........                                                    [ 33%]
tests/test_menu_system.py .................F..                                           [ 36%]
tests/test_paginator.py ......                                                           [ 37%]
tests/test_postgres_saver.py .......                                                     [ 39%]
tests/test_salary_utils.py ......................                                        [ 43%]
tests/test_search_utils.py ............................                                  [ 48%]
tests/test_sj_api.py ..............                                                      [ 51%]
tests/test_sj_api_config.py .....                                                        [ 52%]
tests/test_sj_parser.py ........                                                         [ 53%]
tests/test_source_manager.py .................                                           [ 56%]
tests/test_source_selector.py ..................                                         [ 60%]
tests/test_storage_factory.py ........                                                   [ 61%]
tests/test_target_companies.py .....                                                     [ 62%]
tests/test_ui_config.py .....                                                            [ 63%]
tests/test_ui_helpers.py ...........                                                     [ 65%]
tests/test_unified_api.py .................                                              [ 68%]
tests/test_user_interface.py .........F............                                      [ 72%]
tests/test_vacancy_display_handler.py ..............                                     [ 75%]
tests/test_vacancy_formatter.py ........                                                 [ 77%]
tests/test_vacancy_models.py .................................................           [ 86%]
tests/test_vacancy_operations.py ......                                                  [ 87%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 92%]
tests/test_vacancy_search_handler.py .FFE.EFFEFFFF.FFF....E.                             [ 96%]
tests/test_vacancy_stats.py EEEFFE.F...EEFFFFF                                           [100%]

============================================ ERRORS ============================================
_____________ ERROR at setup of TestVacancySearchHandler.test_save_search_results ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf6f490>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b7e56c0>
salary_data = <src.utils.salary.Salary object at 0x7efd2b7e50c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_____________ ERROR at setup of TestVacancySearchHandler.test_storage_integration ______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf74310>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b3ccc40>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3ccb80>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancySearchHandler.test_search_statistics _______________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf74d10>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b3a40a0>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3a4ca0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________ ERROR at setup of TestVacancySearchHandler.test_search_handler_type_safety __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf7d590>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://hh.ru/vacancy/12345",
                vacancy_id="12345",
                source="hh.ru",
                employer={"name": "Tech Corp"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000})
            ),
            Vacancy(
                title="Java Developer",
                url="https://superjob.ru/vacancy/67890",
                vacancy_id="67890",
                source="superjob.ru",
                employer={"name": "Dev Company"},
                salary=Salary.from_range(100000, 160000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 160000})
            )
        ]

tests/test_vacancy_search_handler.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b330820>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3307c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_company_distribution _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf76010>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b332c20>
salary_data = <src.utils.salary.Salary object at 0x7efd2b332b00>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_source_distribution __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf845d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b321480>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3212a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ ERROR at setup of TestVacancyStats.test_salary_percentiles __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf84950>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b321180>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3211e0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
___________ ERROR at setup of TestVacancyStats.test_display_company_stats_with_data ____________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf85390>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b321360>
salary_data = <src.utils.salary.Salary object at 0x7efd2b320fa0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_type_safety _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf87790>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b323040>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3239a0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_performance _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf87e50>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7efd2b3238e0>
salary_data = <src.utils.salary.Salary object at 0x7efd2b3225c0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
__________________________ TestCacheManager.test_cache_ttl_expiration __________________________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7efd2d7fe110>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7efd2bfab310>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени
        with patch('tests.test_cache_manager.datetime') as mock_datetime:
            mock_datetime.now.return_value.timestamp.return_value = datetime.now().timestamp() + 2
>           assert cache_manager.get(key) is None
E           AssertionError: assert 'test_value' is None
E            +  where 'test_value' = get('test_key')
E            +    where get = <workspace.tests.test_cache_manager.CacheManager object at 0x7efd2bfab310>.get

tests/test_cache_manager.py:285: AssertionError
___________________________ TestMenuManager.test_submenu_navigation ____________________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7efd2c74d850>
mock_print = <MagicMock name='print' id='139625820669392'>
mock_input = <MagicMock name='input' id='139625820628880'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7efd2b714110>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='139625820628880'>, args = ('\nВыберите пункт меню: ',)
kwargs = {}, effect = <list_iterator object at 0x7efd2d368ee0>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
_________________________ TestUserInterface.test_logging_configuration _________________________

self = <MagicMock name='logging.getLogger' id='139625825379600'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'getLogger' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7efd2c3b58d0>
mock_logging = <MagicMock name='logging' id='139625830008016'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что модуль загружен
            assert hasattr(src.user_interface, 'main')
    
            # Логирование может быть настроено при импорте или в main
            # Проверяем хотя бы то, что getLogger был вызван
>           mock_logging.getLogger.assert_called()
E           AssertionError: Expected 'getLogger' to have been called.

tests/test_user_interface.py:242: AssertionError
_____________________ TestVacancySearchHandler.test_search_vacancies_basic _____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf6e7d0>
mock_print = <MagicMock name='print' id='139625825554512'>
mock_input = <MagicMock name='input' id='139625829811024'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bbbc090>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
        if SRC_AVAILABLE:
            # Мокируем интерактивные элементы для реального класса
            with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
                 patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                result = search_handler.search_vacancies()
        else:
            result = search_handler.search_vacancies()
    
>       assert isinstance(result, list)
E       assert False
E        +  where False = isinstance(None, list)

tests/test_vacancy_search_handler.py:258: AssertionError
-------------------------------------- Captured log call ---------------------------------------
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:70 Ошибка поиска вакансий: 'Mock' object is not iterable
___________________ TestVacancySearchHandler.test_search_vacancies_workflow ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf6ed90>
mock_print = <MagicMock name='print' id='139625825361296'>
mock_input = <MagicMock name='input' id='139625825566224'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bb8fe90>
consolidated_mocks = {'input': <Mock id='139625825364944'>, 'print': <Mock id='139625825369104'>, 'source_selector': <Mock id='139625825369232'>, 'storage': <Mock id='139625825369040'>, ...}

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_workflow(self, mock_print, mock_input, search_handler, consolidated_mocks):
        """Тест рабочего процесса поиска вакансий"""
        # Настройка моков для полного рабочего процесса
        consolidated_mocks['storage'].get_vacancies_count.return_value = 0
    
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
            if hasattr(search_handler, 'handle_search_workflow'):
                search_handler.handle_search_workflow()
                mock_print.assert_called()
            else:
                # Тестовая реализация workflow
                print("Запуск процесса поиска вакансий...")
>               source, display_name = search_handler.source_selector.get_user_source_choice()
                ^^^^^^^^^^^^^^^^^^^^
E               ValueError: not enough values to unpack (expected 2, got 1)

tests/test_vacancy_search_handler.py:278: ValueError
____________________ TestVacancySearchHandler.test_search_with_mocked_input ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf74990>
mock_print = <MagicMock name='print' id='139625825513296'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bbb26d0>
consolidated_mocks = {'input': <Mock id='139625825512912'>, 'print': <Mock id='139625825508112'>, 'source_selector': <Mock id='139625825506640'>, 'storage': <Mock id='139625825515344'>, ...}

    @patch('builtins.print')
    def test_search_with_mocked_input(self, mock_print, search_handler, consolidated_mocks):
        """Тест поиска с замокированным вводом"""
        # Полностью мокируем все input операции
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
____________________ TestVacancySearchHandler.test_search_results_structure ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf4a910>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bfb62d0>
consolidated_mocks = {'input': <Mock id='139625829723920'>, 'print': <Mock id='139625829726608'>, 'source_selector': <Mock id='139625829723728'>, 'storage': <Mock id='139625829715856'>, ...}

    def test_search_results_structure(self, search_handler, consolidated_mocks):
        """Тест структуры результатов поиска"""
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario0] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf756d0>
mock_print = <MagicMock name='print' id='139625820805904'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2b734610>
test_scenario = {'name': 'python_search', 'query': 'Python', 'source': 'hh.ru'}
consolidated_mocks = {'input': <Mock id='139625820805072'>, 'print': <Mock id='139625820801360'>, 'source_selector': <Mock id='139625820804112'>, 'storage': <Mock id='139625820803920'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario1] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf75810>
mock_print = <MagicMock name='print' id='139625829811280'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bfccf90>
test_scenario = {'name': 'java_search', 'query': 'Java', 'source': 'superjob.ru'}
consolidated_mocks = {'input': <Mock id='139625829819024'>, 'print': <Mock id='139625829811792'>, 'source_selector': <Mock id='139625829810896'>, 'storage': <Mock id='139625829813968'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario2] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf75950>
mock_print = <MagicMock name='print' id='139625820629136'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2b709a10>
test_scenario = {'name': 'empty_search', 'query': '', 'source': 'all'}
consolidated_mocks = {'input': <Mock id='139625820629904'>, 'print': <Mock id='139625820627280'>, 'source_selector': <Mock id='139625820620176'>, 'storage': <Mock id='139625820629968'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
______________________ TestVacancySearchHandler.test_concurrent_searches _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf75c10>
mock_print = <MagicMock name='print' id='139625821549136'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2b7e8990>
consolidated_mocks = {'input': <Mock id='139625821542096'>, 'print': <Mock id='139625821536400'>, 'source_selector': <Mock id='139625821547984'>, 'storage': <Mock id='139625825275536'>, ...}

    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, search_handler, consolidated_mocks):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
                 patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_vacancy_search_handler.py:399: in <listcomp>
    results = [future.result() for future in concurrent.futures.as_completed(futures)]
               ^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/concurrent/futures/thread.py:58: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_vacancy_search_handler.py:395: in search_task
    return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: Ваш выбор: Ваш выбор: Ваш выбор: 
______________________ TestVacancySearchHandler.test_performance_metrics _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf764d0>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2b734b10>
consolidated_mocks = {'input': <Mock id='139625825364944'>, 'print': <Mock id='139625825364688'>, 'source_selector': <Mock id='139625817673616'>, 'storage': <Mock id='139625817672912'>, ...}

    def test_performance_metrics(self, search_handler, consolidated_mocks):
        """Тест метрик производительности"""
        import time
    
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
            start_time = time.time()
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:434: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
______________________ TestVacancySearchHandler.test_integration_workflow ______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf76a90>
mock_print = <MagicMock name='print' id='139625829427472'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bfccbd0>
consolidated_mocks = {'input': <Mock id='139625829812496'>, 'print': <Mock id='139625829814352'>, 'source_selector': <Mock id='139625829810768'>, 'storage': <Mock id='139625829813840'>, ...}

    @patch('builtins.print')
    def test_integration_workflow(self, mock_print, search_handler, consolidated_mocks):
        """Тест интеграционного рабочего процесса"""
        search_handler.storage = consolidated_mocks['storage']
        consolidated_mocks['storage'].add_vacancy.return_value = True
    
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
            # Полный цикл: поиск -> сохранение -> статистика
>           vacancies = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
__________________________ TestVacancySearchHandler.test_memory_usage __________________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7efd2bf77150>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7efd2bbaec50>
consolidated_mocks = {'input': <Mock id='139625825485776'>, 'print': <Mock id='139625825496208'>, 'source_selector': <Mock id='139625825495760'>, 'storage': <Mock id='139625825485904'>, ...}

    def test_memory_usage(self, search_handler, consolidated_mocks):
        """Тест использования памяти"""
        import gc
    
        # Выполняем поиск и проверяем, что память освобождается
        initial_objects = len(gc.get_objects())
    
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
            for _ in range(10):
>               result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7efd2e047910>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
__________________________ TestVacancyStats.test_empty_vacancies_list __________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf84cd0>

    def test_empty_vacancies_list(self):
        """Тест с пустым списком вакансий"""
        empty_list = []
    
>       distribution = VacancyStats.get_company_distribution(empty_list)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:481: AttributeError
________________________ TestVacancyStats.test_vacancies_without_salary ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf85010>

    def test_vacancies_without_salary(self):
        """Тест вакансий без указания зарплаты"""
        vacancies_no_salary = [
            Vacancy(
                title="Intern Position",
                url="https://test.com/intern",
                vacancy_id="intern1",
                source="hh.ru",
                employer={"name": "StartupCorp"}
            )
        ]
    
        percentiles = VacancyStats.calculate_salary_percentiles(vacancies_no_salary)
>       assert percentiles == {'percentiles': {}, 'count': 0}
E       AssertionError: assert {} == {'count': 0, ...centiles': {}}
E         
E         Right contains 2 more items:
E         {'count': 0, 'percentiles': {}}
E         Use -v to get more diff

tests/test_vacancy_stats.py:503: AssertionError
______________________ TestVacancyStats.test_company_statistics_detailed _______________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf85f90>

    def test_company_statistics_detailed(self):
        """Тест детальной статистики по компаниям"""
        vacancies = [
            Vacancy(
                title="Job 1",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 2",
                url="https://test.com/2",
                vacancy_id="2",
                source="hh.ru",
                employer={"name": "Company A", "id": "123"}
            ),
            Vacancy(
                title="Job 3",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "Company B", "id": "456"}
            )
        ]
    
>       stats = VacancyStats.get_company_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:548: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

vacancies = [<src.vacancies.models.Vacancy object at 0x7efd2b58a340>, <src.vacancies.models.Vacancy object at 0x7efd2b58b040>, <src.vacancies.models.Vacancy object at 0x7efd2b5897e0>]

    def get_company_statistics(vacancies: List[Vacancy]) -> Dict[str, Any]:
        """
        Получение статистики по компаниям
    
        Args:
            vacancies: Список вакансий
    
        Returns:
            Словарь со статистикой по компаниям
        """
>       company_stats = VacancyStats.get_company_distribution(vacancies)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:278: AttributeError
________________________ TestVacancyStats.test_vacancy_stats_edge_cases ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf88550>

    def test_vacancy_stats_edge_cases(self):
        """Тест граничных случаев статистики"""
        # Тест с вакансиями без всех данных
        minimal_vacancies = [
            Vacancy(
                title="",
                url="",
                vacancy_id="1",
                source=""
            )
        ]
    
        # Все методы должны корректно обрабатывать минимальные данные
        stats_methods = [
>           VacancyStats.get_company_distribution,
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            VacancyStats.get_source_distribution,
            VacancyStats.calculate_salary_percentiles,
            VacancyStats.analyze_salaries,
            VacancyStats.get_company_statistics,
            VacancyStats.analyze_experience_requirements,
            VacancyStats.get_location_statistics
        ]
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:698: AttributeError
_____________________ TestVacancyStats.test_parametrized_vacancy_counts[0] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf89650>
vacancy_count = 0

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:731: AttributeError
_____________________ TestVacancyStats.test_parametrized_vacancy_counts[1] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf898d0>
vacancy_count = 1

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:731: AttributeError
____________________ TestVacancyStats.test_parametrized_vacancy_counts[10] _____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf89b50>
vacancy_count = 10

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:731: AttributeError
____________________ TestVacancyStats.test_parametrized_vacancy_counts[100] ____________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7efd2bf89dd0>
vacancy_count = 100

    @pytest.mark.parametrize("vacancy_count", [0, 1, 10, 100])
    def test_parametrized_vacancy_counts(self, vacancy_count):
        """Параметризованный тест с разным количеством вакансий"""
        # Создаем вакансии для тестирования
        vacancies = []
        for i in range(vacancy_count):
            vacancy = Vacancy(
                title=f"Job {i}",
                url=f"https://test.com/{i}",
                vacancy_id=str(i),
                source="hh.ru",
                employer={"name": f"Company {i % 3}"}  # 3 разные компании
            )
            vacancies.append(vacancy)
    
        # Тестируем основные статистические методы
>       company_dist = VacancyStats.get_company_distribution(vacancies)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'

tests/test_vacancy_stats.py:731: AttributeError
=================================== short test summary info ====================================
FAILED tests/test_cache_manager.py::TestCacheManager::test_cache_ttl_expiration - AssertionError: assert 'test_value' is None
FAILED tests/test_menu_system.py::TestMenuManager::test_submenu_navigation - StopIteration
FAILED tests/test_user_interface.py::TestUserInterface::test_logging_configuration - AssertionError: Expected 'getLogger' to have been called.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_basic - assert False
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_vacancies_workflow - ValueError: not enough values to unpack (expected 2, got 1)
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_with_mocked_input - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_search_results_structure - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario0] - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario1] - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_parametrized_search_scenarios[test_scenario2] - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_concurrent_searches - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_performance_metrics - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_integration_workflow - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_memory_usage - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_empty_vacancies_list - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_vacancies_without_salary - AssertionError: assert {} == {'count': 0, ...centiles': {}}
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_company_statistics_detailed - AttributeError: type object 'VacancyStats' has no attribute 'get_company_distribution'