~/workspace$ pytest --tb=auto
====================================== test session starts =======================================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.14.1
collected 1076 items                                                                             

tests/test_abstract.py ........                                                            [  0%]
tests/test_abstract_db_manager.py ....                                                     [  1%]
tests/test_advanced_coverage_comprehensive.py ...................F..........               [  3%]
tests/test_api_config.py ....                                                              [  4%]
tests/test_api_modules.py .............................                                    [  6%]
tests/test_api_modules_comprehensive.py ..F.F..F...F.F..FFFF..FF.F..F                      [  9%]
tests/test_app_config.py .....                                                             [ 10%]
tests/test_base_api.py ......                                                              [ 10%]
tests/test_base_formatter.py ..........                                                    [ 11%]
tests/test_base_parser.py ......                                                           [ 12%]
tests/test_cache.py .......                                                                [ 12%]
tests/test_cached_api.py ...........                                                       [ 13%]
tests/test_comprehensive_final.py ....................F..                                  [ 15%]
tests/test_config_modules_comprehensive.py FF.FFFFFF..FFFFFFF........................F.F.  [ 20%]
tests/test_console_interface.py ......                                                     [ 20%]
tests/test_core_modules_comprehensive.py FFF.FF....FF.FFF.                                 [ 22%]
tests/test_data_normalizers_comprehensive.py ............................                  [ 25%]
tests/test_database_connection.py F..F....                                                 [ 25%]
tests/test_db_config.py .....                                                              [ 26%]
tests/test_db_manager.py .................                                                 [ 27%]
tests/test_decorators.py .......                                                           [ 28%]
tests/test_env_loader.py ................                                                  [ 29%]
tests/test_final_complete_coverage.py FFFFF..FF.F.                                         [ 31%]
tests/test_get_api.py ......                                                               [ 31%]
tests/test_hh_api.py .......                                                               [ 32%]
tests/test_hh_api_config.py .....                                                          [ 32%]
tests/test_hh_parser.py ........                                                           [ 33%]
tests/test_integration.py .............                                                    [ 34%]
tests/test_main_application_interface.py EEEEEEEEEEE                                       [ 35%]
tests/test_menu_manager.py ..........                                                      [ 36%]
tests/test_missing_components.py .........                                                 [ 37%]
tests/test_paginator.py ......                                                             [ 38%]
tests/test_salary_fixed.py ...........                                                     [ 39%]
tests/test_salary_utils.py ......................                                          [ 41%]
tests/test_search_utils.py ............................                                    [ 43%]
tests/test_sj_api.py ..............                                                        [ 44%]
tests/test_sj_api_config.py .....                                                          [ 45%]
tests/test_sj_parser.py ........                                                           [ 46%]
tests/test_source_manager.py .................                                             [ 47%]
tests/test_source_selector.py .................                                            [ 49%]
tests/test_storage_factory.py ........                                                     [ 50%]
tests/test_storage_modules_comprehensive.py ....FFFFFFF.F....F.F.FF.....F....FEEEE.......F [ 54%]
FF                                                                                         [ 54%]
tests/test_target_companies.py .....                                                       [ 55%]
tests/test_typed_data_processor.py EEEEEEEEEEEEEE                                          [ 56%]
tests/test_ui_config.py .......................                                            [ 58%]
tests/test_ui_helpers_comprehensive.py ............................F......FF..             [ 62%]
tests/test_ui_interfaces_comprehensive.py FF.FF...F............................F...        [ 65%]
tests/test_ui_navigation.py ......................                                         [ 67%]
tests/test_ui_navigation_comprehensive.py .................F....E.F...                     [ 70%]
tests/test_unified_api.py .................                                                [ 72%]
tests/test_user_interface_complete.py .F.....F.........                                    [ 73%]
tests/test_user_interface_comprehensive.py ..F......F..FFFFFFFFFFFFFFFFFFF.F               [ 76%]
tests/test_utilities_comprehensive.py .................................                    [ 79%]
tests/test_vacancy_display_handler.py EEEEEEEEEEEEEEEEEEE                                  [ 81%]
tests/test_vacancy_formatter.py ........                                                   [ 82%]
tests/test_vacancy_modules_comprehensive.py .............................F..........FF.F.F [ 86%]
.FFF.FFF..                                                                                 [ 87%]
tests/test_vacancy_operations.py ......                                                    [ 88%]
tests/test_vacancy_operations_coordinator.py ...........................                   [ 90%]
tests/test_vacancy_operations_coordinator_complete.py EEEEEEEEEEEEEEEEEEEEEE               [ 92%]
tests/test_vacancy_processing_coordinator.py .............                                 [ 93%]
tests/test_vacancy_repository.py .FFFF.FFFF                                                [ 94%]
tests/test_vacancy_search_handler_complete.py EEEEEEEEEEEEEEEEEEEEEEE                      [ 96%]
tests/test_vacancy_stats.py ............                                                   [ 98%]
tests/test_vacancy_stats_fixed.py .........                                                [ 98%]
tests/test_vacancy_validator.py ..........F.                                               [100%]

============================================= ERRORS =============================================
______ ERROR at setup of TestMainApplicationInterface.test_main_application_interface_init _______

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745c850>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_____________ ERROR at setup of TestMainApplicationInterface.test_start_application ______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745cbd0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
______________ ERROR at setup of TestMainApplicationInterface.test_stop_application ______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745d010>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
___________ ERROR at setup of TestMainApplicationInterface.test_initialize_components ____________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745d650>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_______________ ERROR at setup of TestMainApplicationInterface.test_run_main_loop ________________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745dc10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_____________ ERROR at setup of TestMainApplicationInterface.test_handle_user_input ______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745e210>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_______________ ERROR at setup of TestMainApplicationInterface.test_show_main_menu _______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745e810>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_____________ ERROR at setup of TestMainApplicationInterface.test_cleanup_resources ______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745ee10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
______________ ERROR at setup of TestMainApplicationInterface.test_api_integration _______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745f3d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
____________ ERROR at setup of TestMainApplicationInterface.test_storage_integration _____________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f698745f990>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
_______________ ERROR at setup of TestMainApplicationInterface.test_error_handling _______________

self = <tests.test_main_application_interface.TestMainApplicationInterface object at 0x7f6987468090>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем конкретную реализацию для тестирования
        class TestMainApplicationInterface(MainApplicationInterface):
            def run_application(self):
                pass
    
>       self.app_interface = TestMainApplicationInterface()
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_main_application_interface.py:41: TypeError
________ ERROR at setup of TestVacancyStorageService.test_storage_service_initialization _________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f6987393f50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
>       self.storage_service = VacancyStorageService(mock_storage)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_modules_comprehensive.py:477: TypeError
__________ ERROR at setup of TestVacancyStorageService.test_process_and_save_vacancies ___________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f6987398590>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
>       self.storage_service = VacancyStorageService(mock_storage)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_modules_comprehensive.py:477: TypeError
_________________ ERROR at setup of TestVacancyStorageService.test_apply_filters _________________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f6987398b90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
>       self.storage_service = VacancyStorageService(mock_storage)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_modules_comprehensive.py:477: TypeError
_____________ ERROR at setup of TestVacancyStorageService.test_deduplicate_vacancies _____________

self = <tests.test_storage_modules_comprehensive.TestVacancyStorageService object at 0x7f69873991d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
>       self.storage_service = VacancyStorageService(mock_storage)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_modules_comprehensive.py:477: TypeError
____________ ERROR at setup of TestTypedDataProcessor.test_typed_data_processor_init _____________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f698739fa90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
________________ ERROR at setup of TestTypedDataProcessor.test_process_data_dict _________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bc0d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
________________ ERROR at setup of TestTypedDataProcessor.test_process_data_list _________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bc6d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
____________ ERROR at setup of TestTypedDataProcessor.test_validate_types_valid_data _____________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bcd10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
___________ ERROR at setup of TestTypedDataProcessor.test_validate_types_invalid_data ____________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bd310>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
___________ ERROR at setup of TestTypedDataProcessor.test_convert_types_string_to_int ____________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bd910>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
_________ ERROR at setup of TestTypedDataProcessor.test_convert_types_preserve_existing __________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bdf10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
____________ ERROR at setup of TestTypedDataProcessor.test_process_nested_structures _____________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873be510>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
________________ ERROR at setup of TestTypedDataProcessor.test_handle_none_values ________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873beb10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
________________ ERROR at setup of TestTypedDataProcessor.test_process_empty_data ________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873bf0d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
______________ ERROR at setup of TestTypedDataProcessor.test_type_conversion_safety ______________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f698739fe50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
_________________ ERROR at setup of TestTypedDataProcessor.test_batch_processing _________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f698738fd90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
________________ ERROR at setup of TestTypedDataProcessor.test_schema_validation _________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873be990>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
__________________ ERROR at setup of TestTypedDataProcessor.test_error_handling __________________

self = <tests.test_typed_data_processor.TestTypedDataProcessor object at 0x7f69873be410>

    def setup_method(self):
        """Настройка перед каждым тестом"""
>       self.processor = TypedDataProcessor()
                         ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_vacancies, validate_vacancy_data

tests/test_typed_data_processor.py:36: TypeError
_______________________ ERROR at setup of TestQuickPaginate.test_formatter _______________________
file /home/runner/workspace/tests/test_ui_navigation_comprehensive.py, line 301
      def test_formatter(self, item, number=None):
E       fixture 'item' not found
>       available fixtures: base_mock_api, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, mock_connection, mock_db_config, mock_vacancy, mock_vacancy_data, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, safe_db_config, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_ui_navigation_comprehensive.py:301
_________ ERROR at setup of TestVacancyDisplayHandler.test_vacancy_display_handler_init __________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987139f90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
____________ ERROR at setup of TestVacancyDisplayHandler.test_display_vacancies_list _____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713a550>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
____________ ERROR at setup of TestVacancyDisplayHandler.test_display_vacancy_details ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713ab10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
______________ ERROR at setup of TestVacancyDisplayHandler.test_display_empty_list _______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713b110>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
____________ ERROR at setup of TestVacancyDisplayHandler.test_display_vacancy_summary ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987117650>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
___________ ERROR at setup of TestVacancyDisplayHandler.test_display_formatted_salary ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713b190>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
______________ ERROR at setup of TestVacancyDisplayHandler.test_display_pagination _______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713b510>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
_____________ ERROR at setup of TestVacancyDisplayHandler.test_format_vacancy_title ______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713b850>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
______________ ERROR at setup of TestVacancyDisplayHandler.test_format_company_info ______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713bb90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
__________ ERROR at setup of TestVacancyDisplayHandler.test_display_vacancy_statistics ___________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f698713bed0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
_________ ERROR at setup of TestVacancyDisplayHandler.test_display_search_results_header _________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987140310>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
_____________ ERROR at setup of TestVacancyDisplayHandler.test_truncate_description ______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987140910>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
_____________ ERROR at setup of TestVacancyDisplayHandler.test_display_vacancy_table _____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987140ed0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
___________ ERROR at setup of TestVacancyDisplayHandler.test_select_vacancy_from_list ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987141490>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
__________ ERROR at setup of TestVacancyDisplayHandler.test_display_no_results_message ___________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987141a50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
___________ ERROR at setup of TestVacancyDisplayHandler.test_sort_vacancies_by_salary ____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987142050>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
____________ ERROR at setup of TestVacancyDisplayHandler.test_display_filter_options _____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987142610>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
______________ ERROR at setup of TestVacancyDisplayHandler.test_highlight_keywords _______________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f6987142c10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
____________ ERROR at setup of TestVacancyDisplayHandler.test_display_export_options _____________

self = <tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f69871431d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        mock_storage = Mock()
        self.display_handler = VacancyDisplayHandler(mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка веб-приложений на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Company",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка корпоративных приложений",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Enterprise Corp",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_display_handler.py:26: TypeError
________ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_coordinator_init ________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871ce390>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_search_and_display_vacancies __

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871cea50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
____ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_save_selected_vacancies _____

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871cf0d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_select_vacancies_for_operation _

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871bc850>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
___ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_filter_vacancies_by_salary ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f698717b7d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_filter_vacancies_by_company ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69872e2a90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_________ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_sort_vacancies _________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871ce750>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
___ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_delete_vacancies_operation ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871cf5d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
____ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_export_vacancies_to_file ____

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871cf950>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
___ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_import_vacancies_from_file ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871cfc90>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_______ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_compare_vacancies ________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d4050>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_____ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_analyze_vacancy_trends _____

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d4450>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_______ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_set_salary_filter ________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d4a10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_____ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_display_operation_menu _____

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d4fd0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_handle_user_operation_choice __

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d5590>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
___ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_batch_operation_processing ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d5b50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
______ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_undo_last_operation _______

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d6110>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_______ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_operation_history ________

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d66d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
_ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_validate_operation_parameters __

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d6cd0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_operation_progress_tracking ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d7290>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_error_handling_in_operations __

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d7850>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__ ERROR at setup of TestVacancyOperationsCoordinatorComplete.test_operation_result_validation ___

self = <tests.test_vacancy_operations_coordinator_complete.TestVacancyOperationsCoordinatorComplete object at 0x7f69871d7e50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.coordinator = VacancyOperationsCoordinator(mock_unified_api, mock_storage)
    
        self.sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Разработка на Python",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Tech Corp",
                url="https://example.com/1"
            ),
            Vacancy(
                id="2",
                title="Java Developer",
                description="Разработка на Java",
                salary_from=120000,
                salary_to=180000,
                currency="RUR",
                company_name="Software Inc",
                url="https://example.com/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_operations_coordinator_complete.py:34: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_search_handler_init ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987020250>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
____________ ERROR at setup of TestVacancySearchHandlerComplete.test_get_search_query ____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f69870205d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_select_search_source __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987020b50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_____________ ERROR at setup of TestVacancySearchHandlerComplete.test_execute_search _____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987021150>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_set_salary_filter ____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987021790>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_set_location_filter ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987021e10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_set_company_filter ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987022490>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
________ ERROR at setup of TestVacancySearchHandlerComplete.test_apply_filters_to_results ________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987022b10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_sort_search_results ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987023190>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_____ ERROR at setup of TestVacancySearchHandlerComplete.test_display_search_results_summary _____

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f69870237d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_set_results_limit ____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987023e50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_set_search_period ____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987028510>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_________ ERROR at setup of TestVacancySearchHandlerComplete.test_validate_search_query __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987028bd0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_save_search_criteria __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987029250>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_______ ERROR at setup of TestVacancySearchHandlerComplete.test_load_saved_search_criteria _______

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f69870298d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_____________ ERROR at setup of TestVacancySearchHandlerComplete.test_search_history _____________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987029f50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_repeat_last_search ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f698702a5d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_________ ERROR at setup of TestVacancySearchHandlerComplete.test_export_search_results __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f698702ac50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
________ ERROR at setup of TestVacancySearchHandlerComplete.test_advanced_search_options _________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f698702b2d0>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
__________ ERROR at setup of TestVacancySearchHandlerComplete.test_complex_search_query __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987022e50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
___________ ERROR at setup of TestVacancySearchHandlerComplete.test_search_suggestions ___________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987020310>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_____ ERROR at setup of TestVacancySearchHandlerComplete.test_search_performance_monitoring ______

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f698702ae10>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
_________ ERROR at setup of TestVacancySearchHandlerComplete.test_search_error_handling __________

self = <tests.test_vacancy_search_handler_complete.TestVacancySearchHandlerComplete object at 0x7f6987029c50>

    def setup_method(self):
        """Настройка перед каждым тестом"""
        # Создаем моки для обязательных зависимостей
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем поведение моков
        mock_unified_api.get_vacancies.return_value = []
        mock_unified_api.get_available_sources.return_value = ["hh.ru", "superjob.ru"]
        mock_storage.get_vacancies.return_value = []
        mock_storage.save_vacancies.return_value = True
    
        self.search_handler = VacancySearchHandler(mock_unified_api, mock_storage)
    
        self.sample_search_results = [
>           Vacancy(
                id="1",
                title="Senior Python Developer",
                description="Опытный Python разработчик для работы над проектами",
                salary_from=150000,
                salary_to=200000,
                currency="RUR",
                company_name="Tech Solutions",
                url="https://example.com/vacancy/1"
            ),
            Vacancy(
                id="2",
                title="Python Backend Developer",
                description="Backend разработчик на Python/Django",
                salary_from=120000,
                salary_to=160000,
                currency="RUR",
                company_name="Web Agency",
                url="https://example.com/vacancy/2"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_vacancy_search_handler_complete.py:35: TypeError
============================================ FAILURES ============================================
__________________ TestUIComponentsComprehensive.test_paginator_initialization ___________________

self = <tests.test_advanced_coverage_comprehensive.TestUIComponentsComprehensive object at 0x7f6987992490>

    def test_paginator_initialization(self):
        """Тестирование инициализации пагинатора"""
        try:
            from src.utils.paginator import Paginator
    
            # Проверяем, есть ли конструктор с аргументами
            import inspect
            sig = inspect.signature(Paginator.__init__)
            if len(sig.parameters) == 1:  # только self
                # Создаем простую реализацию для тестов
                class TestPaginator:
                    def __init__(self, items, page_size=10):
                        self.items = items
                        self.page_size = page_size
                        self.total_pages = len(items) // page_size + (1 if len(items) % page_size else 0)
    
                items = list(range(100))
                paginator = TestPaginator(items, page_size=10)
                assert paginator.items == items
                assert paginator.page_size == 10
                assert paginator.total_pages == 10
            else:
                items = list(range(100))
>               paginator = Paginator(items, page_size=10)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: Paginator() takes no arguments

tests/test_advanced_coverage_comprehensive.py:430: TypeError
_____________________ TestHeadHunterAPI.test_hh_api_search_vacancies_success _____________________

self = <tests.test_api_modules_comprehensive.TestHeadHunterAPI object at 0x7f698764ead0>
mock_get = <MagicMock name='get' id='140091202023312'>

    @patch('requests.get')
    def test_hh_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска вакансий через HH API"""
        # Настраиваем мок ответа
        mock_response = Mock()
        mock_response.json.return_value = {
            "items": [
                {
                    "id": "123",
                    "name": "Python Developer",
                    "alternate_url": "https://hh.ru/vacancy/123",
                    "employer": {"name": "Test Company", "id": "456"},
                    "salary": {"from": 100000, "to": 200000, "currency": "RUR"},
                    "snippet": {"requirement": "Python", "responsibility": "Development"}
                }
            ],
            "pages": 1,
            "per_page": 20,
            "page": 0,
            "found": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        # Выполняем поиск
        result = self.hh_api.get_vacancies("Python")
    
        # Проверяем результат
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:102: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.api_modules.hh_api:hh_api.py:179 Ошибка получения вакансий: 'Mock' object does not support item assignment
_______________________ TestHeadHunterAPI.test_hh_api_get_vacancy_details ________________________

self = <tests.test_api_modules_comprehensive.TestHeadHunterAPI object at 0x7f698764f810>
mock_get = <MagicMock name='get' id='140091200905744'>

    @patch('requests.get')
    def test_hh_api_get_vacancy_details(self, mock_get):
        """Тестирование получения деталей вакансии"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": "123",
            "name": "Python Developer",
            "description": "Full job description",
            "key_skills": [{"name": "Python"}, {"name": "Django"}]
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
>       result = self.hh_api.get_vacancy_details("123")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HeadHunterAPI' object has no attribute 'get_vacancy_details'

tests/test_api_modules_comprehensive.py:143: AttributeError
______________________ TestSuperJobAPI.test_sj_api_search_vacancies_success ______________________

self = <tests.test_api_modules_comprehensive.TestSuperJobAPI object at 0x7f6987658ed0>
mock_get = <MagicMock name='get' id='140091200916560'>

    @patch('requests.get')
    def test_sj_api_search_vacancies_success(self, mock_get):
        """Тестирование успешного поиска через SuperJob API"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "objects": [
                {
                    "id": 789,
                    "profession": "Python разработчик",
                    "link": "https://superjob.ru/vakansii/python-789.html",
                    "firm_name": "IT Company",
                    "payment_from": 120000,
                    "payment_to": 180000,
                    "currency": "rub",
                    "candidat": "Знание Python",
                    "work": "Разработка ПО"
                }
            ],
            "total": 1
        }
        mock_response.status_code = 200
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
    
        result = self.sj_api.get_vacancies("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_api_modules_comprehensive.py:207: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.cached_api:cached_api.py:115 Ошибка кэша памяти: Object of type Mock is not JSON serializable. Переключаемся на файловый кэш
ERROR    src.api_modules.sj_api:sj_api.py:198 Failed to get vacancies: cannot access local variable 'filepath' where it is not associated with a value
_______________________ TestCachedAPI.test_cached_api_search_with_caching ________________________

self = <Mock name='mock.get_vacancies' id='140091201098640'>

    def assert_not_called(self):
        """assert that the mock was never called.
        """
        if self.call_count != 0:
            msg = ("Expected '%s' to not have been called. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'get_vacancies' to not have been called. Called 1 times.
E           Calls: [call('Python')].

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:900: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestCachedAPI object at 0x7f698765abd0>

    def test_cached_api_search_with_caching(self):
        """Тестирование поиска с кэшированием"""
        # Первый запрос - должен обратиться к базовому API
        result1 = self.cached_api.get_vacancies("Python")
        assert result1 == [{"id": "123", "title": "Test"}]
        self.mock_base_api.get_vacancies.assert_called_once_with("Python")
    
        # Второй запрос - должен вернуть из кэша
        self.mock_base_api.get_vacancies.reset_mock()
        result2 = self.cached_api.get_vacancies("Python")
        assert result2 == [{"id": "123", "title": "Test"}]
>       self.mock_base_api.get_vacancies.assert_not_called()
E       AssertionError: Expected 'get_vacancies' to not have been called. Called 1 times.
E       Calls: [call('Python')].
E       
E       pytest introspection follows:
E       
E       Args:
E       assert ('Python',) == ()
E         
E         Left contains one more item: 'Python'
E         Use -v to get more diff

tests/test_api_modules_comprehensive.py:275: AssertionError
___________________________ TestCachedAPI.test_cached_api_clear_cache ____________________________

self = <tests.test_api_modules_comprehensive.TestCachedAPI object at 0x7f698764da50>

    def test_cached_api_clear_cache(self):
        """Тестирование очистки кэша"""
        # Заполняем кэш
        self.cached_api.get_vacancies("Python")
    
        # Очищаем кэш
>       self.cached_api.clear_cache()
E       TypeError: CachedAPI.clear_cache() missing 1 required positional argument: 'api_prefix'

tests/test_api_modules_comprehensive.py:291: TypeError
_______________________ TestUnifiedAPI.test_unified_api_search_all_sources _______________________

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f698765bcd0>

    def test_unified_api_search_all_sources(self):
        """Тестирование поиска по всем источникам"""
>       result = self.unified_api.get_vacancies("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_modules_comprehensive.py:338: AttributeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________________ TestUnifiedAPI.test_unified_api_search_specific_source _____________________

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f698765c050>

    def test_unified_api_search_specific_source(self):
        """Тестирование поиска по конкретному источнику"""
>       result = self.unified_api.search_vacancies("Python", sources=["hh.ru"])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'

tests/test_api_modules_comprehensive.py:349: AttributeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________________ TestUnifiedAPI.test_unified_api_get_available_sources ______________________

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f698765c3d0>

    def test_unified_api_get_available_sources(self):
        """Тестирование получения доступных источников"""
        sources = self.unified_api.get_available_sources()
    
        assert isinstance(sources, list)
        assert len(sources) > 0
>       assert "hh.ru" in sources or "superjob.ru" in sources
E       AssertionError: assert ('hh.ru' in ['hh', 'sj'] or 'superjob.ru' in ['hh', 'sj'])

tests/test_api_modules_comprehensive.py:361: AssertionError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________________ TestUnifiedAPI.test_unified_api_error_handling _________________________

self = <tests.test_api_modules_comprehensive.TestUnifiedAPI object at 0x7f698765c910>

    def test_unified_api_error_handling(self):
        """Тестирование обработки ошибок"""
        # Симулируем ошибку в одном из API
        self.mock_hh_api.get_vacancies.side_effect = Exception("HH API Error")
    
        # API должен продолжить работу с другими источниками
>       result = self.unified_api.get_vacancies("Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_modules_comprehensive.py:369: AttributeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________________ TestAPIConnector.test_api_connector_connect ___________________________

self = <src.api_modules.get_api.APIConnector object at 0x7f6986508c90>, url = 'https://test.api'
params = None, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
>               params={k: v for k, v in params.items() if v is not None},
                                         ^^^^^^^^^^^^
                headers=self.headers,
                timeout=self.config.timeout,
            )
E           AttributeError: 'NoneType' object has no attribute 'items'

src/api_modules/get_api.py:108: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f698765dcd0>
mock_get = <MagicMock name='get' id='140091201718992'>

    @patch('requests.get')
    def test_api_connector_connect(self, mock_get):
        """Тестирование метода connect APIConnector"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"status": "ok"}
        mock_response.status_code = 200
        mock_get.return_value = mock_response
    
>       result = api_connector.connect("https://test.api")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f6986508c90>, url = 'https://test.api'
params = None, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
            raise ConnectionError(f"Connection error: {str(e)}")
        except ValueError as e:
            raise ConnectionError(f"JSON decode error: {str(e)}")
        except Exception as e:
>           raise ConnectionError(f"Unexpected error: {str(e)}")
E           ConnectionError: Unexpected error: 'NoneType' object has no attribute 'items'

src/api_modules/get_api.py:138: ConnectionError
_______________________ TestAPIConnector.test_api_connector_error_handling _______________________

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f698765e290>
mock_get = <MagicMock name='get' id='140091202438032'>

    @patch('requests.get')
    def test_api_connector_error_handling(self, mock_get):
        """Тестирование обработки ошибок APIConnector"""
        api_connector = APIConnector()
>       mock_get.side_effect = requests.exceptions.ConnectionError("Network error")
                               ^^^^^^^^
E       NameError: name 'requests' is not defined

tests/test_api_modules_comprehensive.py:412: NameError
________________________ TestAPIConnector.test_api_connector_with_params _________________________

self = <urllib3.connection.HTTPSConnection object at 0x7f6986567490>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/util/connection.py:60: in create_connection
    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

host = 'test.api', port = 443, family = <AddressFamily.AF_INET: 2>
type = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0

    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
        """Resolve host and port into list of address info entries.
    
        Translate the host/port argument into a sequence of 5-tuples that contain
        all the necessary arguments for creating a socket connected to that service.
        host is a domain name, a string representation of an IPv4/v6 address or
        None. port is a string service name such as 'http', a numeric port number or
        None. By passing None as the value of host and port, you can pass NULL to
        the underlying C API.
    
        The family, type and proto arguments can be optionally specified in order to
        narrow the list of addresses returned. Passing zero as a value for each of
        these arguments selects the full range of results.
        """
        # We override this function since we want to translate the numeric family
        # and socket type values to enum constants.
        addrlist = []
>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       socket.gaierror: [Errno -2] Name or service not known

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/socket.py:974: gaierror

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f6986564450>, method = 'GET'
url = '/?query=Python&page=1', body = None
headers = {'User-Agent': 'MyVacancyApp/1.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': 'application/json', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False
assert_same_host = False, timeout = Timeout(connect=15, read=15, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/', query='query=Python&page=1', fragment=None)
destination_scheme = None, conn = None, release_this_conn = True, http_tunnel_required = False
err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:488: in _make_request
    raise new_e
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:464: in _make_request
    self._validate_conn(conn)
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:1093: in _validate_conn
    conn.connect()
.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:753: in connect
    self.sock = sock = self._new_conn()
                       ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connection.HTTPSConnection object at 0x7f6986567490>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
>           raise NameResolutionError(self.host, self, e) from e
E           urllib3.exceptions.NameResolutionError: <urllib3.connection.HTTPSConnection object at 0x7f6986567490>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)

.pythonlibs/lib/python3.11/site-packages/urllib3/connection.py:205: NameResolutionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x7f698708d390>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = 'GET'
url = '/?query=Python&page=1', response = None
error = NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f6986567490>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)")
_pool = <urllib3.connectionpool.HTTPSConnectionPool object at 0x7f6986564450>
_stacktrace = <traceback object at 0x7f6986566940>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f6986567490>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/urllib3/util/retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <src.api_modules.get_api.APIConnector object at 0x7f698708ddd0>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
>           response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )

src/api_modules/get_api.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.pythonlibs/lib/python3.11/site-packages/requests/sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x7f698708d390>, request = <PreparedRequest [GET]>
stream = False, timeout = Timeout(connect=15, read=15, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f6986567490>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

.pythonlibs/lib/python3.11/site-packages/requests/adapters.py:677: ConnectionError

During handling of the above exception, another exception occurred:

self = <tests.test_api_modules_comprehensive.TestAPIConnector object at 0x7f698765ee90>
mock_get = <MagicMock name='get' id='140091213792208'>

    @patch('requests.get')
    def test_api_connector_with_params(self, mock_get):
        """Тестирование APIConnector с параметрами"""
        api_connector = APIConnector()
        mock_response = Mock()
        mock_response.json.return_value = {"data": "test"}
        mock_response.status_code = 200
        mock_get.return_value = mock_response
    
        params = {"query": "Python", "page": 1}
>       result = api_connector.connect("https://test.api", params=params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_api_modules_comprehensive.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/api_modules/get_api.py:153: in connect
    return self._APIConnector__connect(url, params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.api_modules.get_api.APIConnector object at 0x7f698708ddd0>, url = 'https://test.api'
params = {'page': 1, 'query': 'Python'}, delay = 0.15, show_progress = False, progress_desc = None

    def __connect(
        self,
        url: str,
        params: Dict,
        delay: float = 0.15,
        show_progress: bool = False,
        progress_desc: Optional[str] = None,
    ) -> Dict:
        """
        Выполнение API-запроса с обработкой ошибок и прогрессом
    
        Args:
            url: URL для запроса
            params: Параметры запроса
            delay: Задержка между запросами в секундах
            show_progress: Показывать ли прогресс-бар
            progress_desc: Описание для прогресс-бара
    
        Returns:
            Dict: Ответ API в формате JSON
    
        Raises:
            ConnectionError: При ошибках сети или API
        """
        try:
            if show_progress:
                desc = progress_desc or f"Request to {url.split('/')[-1]}"
                self._init_progress(1, desc)
    
            sleep(delay)
            response = requests.get(
                url,
                params={k: v for k, v in params.items() if v is not None},
                headers=self.headers,
                timeout=self.config.timeout,
            )
    
            self._update_progress()
    
            if response.status_code == 429:
                retry_after = int(response.headers.get("Retry-After", 1))
                sleep(retry_after)
                return self.__connect(url, params, delay, show_progress, progress_desc)
    
            response.raise_for_status()
            return response.json()
    
        except requests.Timeout as e:
            raise ConnectionError(f"Timeout error: {str(e)}")
        except requests.HTTPError as e:
            if e.response is None:
                error_msg = "HTTP error (no response details)"
            else:
                error_msg = f"HTTP error {e.response.status_code}"
                if e.response.text:
                    error_msg += f": {e.response.text[:200]}"
            raise ConnectionError(error_msg)
        except requests.RequestException as e:
>           raise ConnectionError(f"Connection error: {str(e)}")
E           ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retries exceeded with url: /?query=Python&page=1 (Caused by NameResolutionError("<urllib3.connection.HTTPSConnection object at 0x7f6986567490>: Failed to resolve 'test.api' ([Errno -2] Name or service not known)"))

src/api_modules/get_api.py:134: ConnectionError
__________________________ TestAPIIntegration.test_full_search_workflow __________________________

self = <tests.test_api_modules_comprehensive.TestAPIIntegration object at 0x7f698766c4d0>
mock_get = <MagicMock name='get' id='140091202103440'>

    @patch('requests.get')
    def test_full_search_workflow(self, mock_get):
        """Тестирование полного рабочего процесса поиска"""
        # Настраиваем ответы для всех API
        hh_response = Mock()
        hh_response.json.return_value = {
            "items": [{"id": "hh_1", "name": "HH Vacancy"}],
            "pages": 1,
            "page": 0
        }
        hh_response.status_code = 200
        hh_response.raise_for_status.return_value = None
    
        sj_response = Mock()
        sj_response.json.return_value = {
            "objects": [{"id": 1, "profession": "SJ Vacancy"}],
            "total": 1
        }
        sj_response.status_code = 200
        sj_response.raise_for_status.return_value = None
    
        # Настраиваем mock_get для возврата разных ответов
        def get_response(url, **kwargs):
            if "hh.ru" in url:
                return hh_response
            elif "superjob.ru" in url:
                return sj_response
            return Mock()
    
        mock_get.side_effect = get_response
    
        # Тестируем полный workflow
        with patch('src.config.api_config.APIConfig') as mock_hh_config, \
             patch('src.config.sj_api_config.SJAPIConfig') as mock_sj_config:
    
            # Настраиваем конфигурации
            mock_hh_config.return_value.get_base_url.return_value = "https://api.hh.ru"
            mock_hh_config.return_value.get_search_url.return_value = "https://api.hh.ru/vacancies"
            mock_hh_config.return_value.get_headers.return_value = {}
            mock_hh_config.return_value.get_default_parameters.return_value = {}
            mock_hh_config.return_value.should_filter_by_salary.return_value = False
    
            mock_sj_config.return_value.get_base_url.return_value = "https://api.superjob.ru"
            mock_sj_config.return_value.get_search_url.return_value = "https://api.superjob.ru/2.0/vacancies/"
            mock_sj_config.return_value.get_headers.return_value = {}
            mock_sj_config.return_value.get_default_parameters.return_value = {}
            mock_sj_config.return_value.should_filter_by_salary.return_value = False
    
            unified_api = UnifiedAPI()
>           result = unified_api.get_vacancies("Python")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'

tests/test_api_modules_comprehensive.py:554: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestSpecialModules.test_vacancy_storage_service_full_coverage __________________

self = <tests.test_comprehensive_final.TestSpecialModules object at 0x7f69876caf50>
mock_connect = <MagicMock name='connect' id='140091191001744'>

    @patch('psycopg2.connect')
    def test_vacancy_storage_service_full_coverage(self, mock_connect):
        """Полное покрытие vacancy_storage_service"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_cursor.execute.return_value = None
        mock_cursor.fetchone.return_value = (1, 'Test Company', '123')
        mock_cursor.fetchall.return_value = [(1, 'vacancy1'), (2, 'vacancy2')]
        mock_cursor.rowcount = 5
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
>           storage = VacancyStorageService()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_comprehensive_final.py:770: TypeError
__________________________ TestAPIConfig.test_api_config_initialization __________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f69874f49d0>

    def test_api_config_initialization(self):
        """Тестирование инициализации базовой конфигурации API"""
        config = APIConfig()
        assert config is not None
>       assert hasattr(config, 'get_base_url')
E       AssertionError: assert False
E        +  where False = hasattr(<src.config.api_config.APIConfig object at 0x7f698674ddd0>, 'get_base_url')

tests/test_config_modules_comprehensive.py:34: AssertionError
_________________________ TestAPIConfig.test_api_config_abstract_methods _________________________

self = <tests.test_config_modules_comprehensive.TestAPIConfig object at 0x7f69874f4fd0>

    def test_api_config_abstract_methods(self):
        """Тестирование абстрактных методов базовой конфигурации"""
        config = APIConfig()
    
        # Базовая конфигурация должна возвращать значения по умолчанию
>       base_url = config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'APIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:43: AttributeError
______________________________ TestHHAPIConfig.test_hh_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f5e50>

    def test_hh_config_urls(self):
        """Тестирование URL конфигурации HH"""
>       base_url = self.config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:67: AttributeError
_____________________________ TestHHAPIConfig.test_hh_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f6450>

    def test_hh_config_headers(self):
        """Тестирование заголовков HTTP для HH API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:81: AttributeError
_______________________ TestHHAPIConfig.test_hh_config_default_parameters ________________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f6a90>

    def test_hh_config_default_parameters(self):
        """Тестирование параметров по умолчанию для HH API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:90: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_enabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f7010>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_hh_config_salary_filter_enabled(self):
        """Тестирование фильтрации по зарплате когда включена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:102: AttributeError
_____________________ TestHHAPIConfig.test_hh_config_salary_filter_disabled ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f7590>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'false'})
    def test_hh_config_salary_filter_disabled(self):
        """Тестирование фильтрации по зарплате когда отключена"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:109: AttributeError
______________________ TestHHAPIConfig.test_hh_config_salary_filter_default ______________________

self = <tests.test_config_modules_comprehensive.TestHHAPIConfig object at 0x7f69874f7b10>

    @patch.dict(os.environ, {}, clear=True)
    def test_hh_config_salary_filter_default(self):
        """Тестирование значения по умолчанию для фильтрации по зарплате"""
        config = HHAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:116: AttributeError
______________________________ TestSJAPIConfig.test_sj_config_urls _______________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987505010>

    def test_sj_config_urls(self):
        """Тестирование URL конфигурации SuperJob"""
>       base_url = self.config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_comprehensive.py:144: AttributeError
_____________________________ TestSJAPIConfig.test_sj_config_headers _____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987505610>

    def test_sj_config_headers(self):
        """Тестирование заголовков HTTP для SuperJob API"""
>       headers = self.config.get_headers()
                  ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:154: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_with_api_key ___________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987505bd0>

    @patch.dict(os.environ, {'SUPERJOB_API_KEY': 'test_api_key_123'})
    def test_sj_config_with_api_key(self):
        """Тестирование конфигурации с API ключом"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:165: AttributeError
_________________________ TestSJAPIConfig.test_sj_config_without_api_key _________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987506150>

    @patch.dict(os.environ, {}, clear=True)
    def test_sj_config_without_api_key(self):
        """Тестирование конфигурации без API ключа"""
        config = SJAPIConfig()
>       headers = config.get_headers()
                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_comprehensive.py:174: AttributeError
___________________________ TestSJAPIConfig.test_sj_config_parameters ____________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987506750>

    def test_sj_config_parameters(self):
        """Тестирование параметров SuperJob API"""
>       params = self.config.get_default_parameters()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_default_parameters'

tests/test_config_modules_comprehensive.py:181: AttributeError
__________________________ TestSJAPIConfig.test_sj_config_salary_filter __________________________

self = <tests.test_config_modules_comprehensive.TestSJAPIConfig object at 0x7f6987506cd0>

    @patch.dict(os.environ, {'FILTER_ONLY_WITH_SALARY': 'true'})
    def test_sj_config_salary_filter(self):
        """Тестирование фильтрации по зарплате в SuperJob"""
        config = SJAPIConfig()
>       should_filter = config.should_filter_by_salary()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:193: AttributeError
________________________ TestDatabaseConfig.test_db_config_initialization ________________________

self = <tests.test_config_modules_comprehensive.TestDatabaseConfig object at 0x7f69874f7350>

    def test_db_config_initialization(self):
        """Тестирование инициализации конфигурации БД"""
        assert self.config is not None
        assert hasattr(self.config, 'default_config')
        # Исправленная проверка на допустимые типы хранилищ
>       assert self.config.default_storage_type in ["postgresql", "json", "memory", "postgres"]
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DatabaseConfig' object has no attribute 'default_storage_type'

tests/test_config_modules_comprehensive.py:209: AttributeError
________________________ TestTargetCompanies.test_company_ids_extraction _________________________

self = <tests.test_config_modules_comprehensive.TestTargetCompanies object at 0x7f6987511f10>

    def test_company_ids_extraction(self):
        """Тестирование извлечения ID компаний"""
        if hasattr(self.companies, 'get_all_ids'):
            all_ids = self.companies.get_all_ids()
>           assert isinstance(all_ids, list)
E           AssertionError: assert False
E            +  where False = isinstance({'1057', '1122', '1145', '1165', '12258', '1237', ...}, list)

tests/test_config_modules_comprehensive.py:504: AssertionError
__________________ TestConfigIntegration.test_environment_variables_propagation __________________

self = <tests.test_config_modules_comprehensive.TestConfigIntegration object at 0x7f69875125d0>

    @patch.dict(os.environ, {
        'LOG_LEVEL': 'INFO',
        'CACHE_TTL': '7200',
        'FILTER_ONLY_WITH_SALARY': 'true',
        'DATABASE_URL': 'postgresql://test:test@localhost:5432/test'
    })
    def test_environment_variables_propagation(self):
        """Тестирование распространения переменных окружения между конфигурациями"""
        # Проверяем, что переменные окружения корректно используются
        app_config = AppConfig()
        db_config = DatabaseConfig()
        hh_config = HHAPIConfig()
    
        # Все конфигурации должны учитывать переменные окружения
        if hasattr(app_config, 'get_log_level'):
            assert app_config.get_log_level() == 'INFO'
    
        if hasattr(app_config, 'get_cache_ttl'):
            assert app_config.get_cache_ttl() == 7200
    
        db_config_values = db_config.get_config()
        assert db_config_values['host'] == 'localhost'
        assert db_config_values['database'] == 'test'
    
>       assert hh_config.should_filter_by_salary() is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'

tests/test_config_modules_comprehensive.py:561: AttributeError
_______________________ TestUserInterfaceModule.test_main_function_success _______________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f6987579fd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6987572610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_db_connection_error _________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f698757a690>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6987573ed0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestUserInterfaceModule.test_main_function_keyboard_interrupt __________________

args = (<tests.test_core_modules_comprehensive.TestUserInterfaceModule object at 0x7f698757acd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6987578310>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestDBManagerComprehensive.test_check_connection_success ____________________

self = <tests.test_core_modules_comprehensive.TestDBManagerComprehensive object at 0x7f698757bcd0>

    def test_check_connection_success(self) -> None:
        """Тестирование успешной проверки подключения"""
        with patch.object(self.db_manager, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.cursor.return_value = mock_cursor
            mock_get_conn.return_value = mock_connection
    
            result = self.db_manager.check_connection()
    
>           assert result is True
E           assert False is True

tests/test_core_modules_comprehensive.py:195: AssertionError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.storage.db_manager:db_manager.py:790 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
_____________________ TestDBManagerComprehensive.test_create_tables_success ______________________

self = <tests.test_core_modules_comprehensive.TestDBManagerComprehensive object at 0x7f6987579c90>

    def test_create_tables_success(self) -> None:
        """Тестирование успешного создания таблиц"""
        with patch.object(self.db_manager, '_get_connection') as mock_get_conn:
            mock_connection = Mock()
            mock_cursor = Mock()
            mock_connection.cursor.return_value = mock_cursor
            mock_get_conn.return_value = mock_connection
    
>           self.db_manager.create_tables()

tests/test_core_modules_comprehensive.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7f698707e9d0>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/db_manager.py:82: TypeError
--------------------------------------- Captured log call ----------------------------------------
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'Mock' object does not support the context manager protocol
________________________ TestVacancyModels.test_vacancy_validation_valid _________________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f698757da90>

    def test_vacancy_validation_valid(self) -> None:
        """Тестирование валидации корректной вакансии"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="Python Developer",
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is True
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:283: AttributeError
____________________ TestVacancyModels.test_vacancy_validation_invalid_title _____________________

self = <tests.test_core_modules_comprehensive.TestVacancyModels object at 0x7f698757e110>

    def test_vacancy_validation_invalid_title(self) -> None:
        """Тестирование валидации вакансии с некорректным названием"""
        employer = Employer("Test Company", "123")
        vacancy = Vacancy(
            title="",  # Пустое название
            employer=employer,
            url="https://test.com/vacancy/1"
        )
    
>       assert vacancy.is_valid() is False
               ^^^^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_core_modules_comprehensive.py:294: AttributeError
___________________ TestAppConfigComprehensive.test_app_config_default_values ____________________

self = <tests.test_core_modules_comprehensive.TestAppConfigComprehensive object at 0x7f698757ef90>

    def test_app_config_default_values(self) -> None:
        """Тестирование значений по умолчанию"""
        config = AppConfig()
    
        # Проверяем, что есть тип хранилища по умолчанию
>       assert config.default_storage_type in ["postgresql", "json", "memory"]
E       AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
E        +  where 'postgres' = <src.config.app_config.AppConfig object at 0x7f69866f87d0>.default_storage_type

tests/test_core_modules_comprehensive.py:312: AssertionError
________________ TestStorageFactoryComprehensive.test_storage_factory_postgresql _________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f698757f850>

    def test_storage_factory_postgresql(self) -> None:
        """Тестирование создания PostgreSQL хранилища"""
>       storage = StorageFactory.create_storage("postgresql")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
___________________ TestStorageFactoryComprehensive.test_storage_factory_json ____________________

self = <tests.test_core_modules_comprehensive.TestStorageFactoryComprehensive object at 0x7f698757fed0>

    def test_storage_factory_json(self) -> None:
        """Тестирование создания JSON хранилища"""
>       storage = StorageFactory.create_storage("json")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_core_modules_comprehensive.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'json'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: json

src/storage/storage_factory.py:20: ValueError
______________________ TestDatabaseConnection.test_database_connection_init ______________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f69876a7b50>
mock_connect = <MagicMock name='connect' id='140091203466704'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_database_connection_init(self, mock_connect):
        """Тест инициализации подключения к базе данных"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
    
        assert db_conn is not None
>       assert hasattr(db_conn, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.database_connection.DatabaseConnection object at 0x7f69866f9b90>, 'config')

tests/test_database_connection.py:38: AssertionError
__________________________ TestDatabaseConnection.test_close_connection __________________________

self = <tests.test_database_connection.TestDatabaseConnection object at 0x7f69875a8e50>
mock_connect = <MagicMock name='connect' id='140091203358736'>

    @patch('src.storage.components.database_connection.psycopg2.connect')
    def test_close_connection(self, mock_connect):
        """Тест закрытия подключения"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        db_conn = DatabaseConnection(self.db_config)
        connection = db_conn.get_connection()
>       db_conn.close_connection(connection)
E       TypeError: DatabaseConnection.close_connection() takes 1 positional argument but 2 were given

tests/test_database_connection.py:70: TypeError
______________ TestCompleteAPIModuleCoverage.test_headhunter_api_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f698740de90>
mock_get = <MagicMock name='get' id='140091189446736'>

    @patch('requests.get')
    def test_headhunter_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование HeadHunter API клиента.
    
        Покрывает все специфичные для HH.ru функции:
        - Поиск вакансий с различными параметрами
        - Получение детальной информации о вакансии
        - Обработка пагинации результатов
        - Работа с фильтрами по компаниям и регионам
        - Обработка rate limiting и ошибок API
        """
        mock_get.return_value = self.mocks['hh_response']
    
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            api = HeadHunterAPI()
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('python developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:159: AttributeError
_______________ TestCompleteAPIModuleCoverage.test_superjob_api_complete_coverage ________________

self = <tests.test_final_complete_coverage.TestCompleteAPIModuleCoverage object at 0x7f698740e450>
mock_get = <MagicMock name='get' id='140091189451344'>

    @patch('requests.get')
    def test_superjob_api_complete_coverage(self, mock_get: Mock) -> None:
        """
        Полное тестирование SuperJob API клиента.
    
        Покрывает все специфичные для SuperJob.ru функции:
        - Аутентификация с API ключом
        - Поиск вакансий с различными критериями
        - Обработка специфичного формата данных SuperJob
        - Работа с профессиональными каталогами
        - Региональная фильтрация
        """
        # Настраиваем мок для SuperJob ответа
        sj_response = Mock()
        sj_response.json.return_value = {
            'objects': [
                {
                    'id': 456,
                    'profession': 'Java Developer',
                    'firm_name': 'Dev Company',
                    'payment_from': 120000,
                    'payment_to': 180000,
                    'currency': 'rub'
                }
            ],
            'total': 1
        }
        mock_get.return_value = sj_response
    
        try:
            from src.api_modules.sj_api import SuperJobAPI
    
            api = SuperJobAPI('test_api_key')
            assert api is not None
    
            # Тестируем поиск вакансий
>           result = api.search_vacancies('java developer')
                     ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'

tests/test_final_complete_coverage.py:210: AttributeError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
______________ TestCompleteStorageModuleCoverage.test_db_manager_complete_coverage _______________

self = <Mock name='mock.connect().cursor().execute' id='140091202608272'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f698740ed10>
mock_connect = <MagicMock name='connect' id='140091189109968'>

    @patch('psycopg2.connect')
    def test_db_manager_complete_coverage(self, mock_connect: Mock) -> None:
        """
        Полное тестирование менеджера базы данных.
    
        Покрывает все операции с PostgreSQL:
        - Создание подключения и проверка доступности
        - Создание таблиц и индексов
        - Операции CRUD для вакансий и компаний
        - Сложные запросы и агрегации
        - Транзакции и откаты
        """
        mock_connect.return_value = self.mocks['connection']
    
        try:
            from src.storage.db_manager import DBManager
    
            db = DBManager()
            assert db is not None
    
            # Тестируем проверку подключения
            is_connected = db.check_connection()
            assert isinstance(is_connected, bool)
    
            # Тестируем создание таблиц
            db.create_tables()
>           self.mocks['cursor'].execute.assert_called()
E           AssertionError: Expected 'execute' to have been called.

tests/test_final_complete_coverage.py:259: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091202449040'>, исправляем...
____________ TestCompleteStorageModuleCoverage.test_storage_factory_complete_coverage ____________

self = <tests.test_final_complete_coverage.TestCompleteStorageModuleCoverage object at 0x7f698740f350>

    def test_storage_factory_complete_coverage(self) -> None:
        """
        Полное тестирование фабрики хранилищ.
    
        Покрывает создание различных типов хранилищ:
        - PostgreSQL хранилище
        - JSON файловое хранилище
        - In-memory хранилище для тестов
        - Автоматический выбор хранилища по конфигурации
        """
        try:
            from src.storage.storage_factory import StorageFactory
    
            # Тестируем создание PostgreSQL хранилища
            with patch('psycopg2.connect', return_value=self.mocks['connection']):
>               pg_storage = StorageFactory.create_storage('postgresql')
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_complete_coverage.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'postgresql'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql

src/storage/storage_factory.py:20: ValueError
_______________ TestCompleteUIModuleCoverage.test_user_interface_complete_coverage _______________

self = <MagicMock name='print' id='140091202385104'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'print' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_final_complete_coverage.TestCompleteUIModuleCoverage object at 0x7f698740f7d0>
mock_print = <MagicMock name='print' id='140091202385104'>
mock_input = <MagicMock name='input' id='140091202372176'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_user_interface_complete_coverage(self, mock_print: Mock, mock_input: Mock) -> None:
        """
        Полное тестирование основного пользовательского интерфейса.
    
        Покрывает все сценарии взаимодействия:
        - Отображение главного меню
        - Навигация между разделами
        - Поиск вакансий с различными параметрами
        - Просмотр статистики и результатов
        - Обработка некорректного ввода
        """
        mock_input.return_value = '0'  # Выход из приложения
    
        try:
            from src.ui_interfaces.console_interface import UserInterface
    
            mock_storage = Mock()
            mock_db_manager = Mock()
            mock_db_manager.get_companies_and_vacancies_count.return_value = [
                {'company': 'Tech Corp', 'vacancies': 15}
            ]
    
            ui = UserInterface(mock_storage, mock_db_manager)
            assert ui is not None
    
            # Проверяем, что были вызовы print (отображение меню)
>           mock_print.assert_called()
E           AssertionError: Expected 'print' to have been called.

tests/test_final_complete_coverage.py:334: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
__________________ TestCompleteUtilityModuleCoverage.test_salary_comprehensive ___________________

self = <tests.test_final_complete_coverage.TestCompleteUtilityModuleCoverage object at 0x7f6987414950>

    def test_salary_comprehensive(self) -> None:
        """
        Полное тестирование класса Salary.
    
        Покрывает все аспекты работы с зарплатами:
        - Инициализация с различными параметрами
        - Валидация входных данных
        - Вычисление средних значений
        - Форматирование для отображения
        - Сравнение зарплатных предложений
        """
        try:
            from src.utils.salary import Salary
    
            # Тестируем полную зарплату
            salary_data = {'from': 100000, 'to': 200000, 'currency': 'RUR'}
            salary = Salary(salary_data)
            assert salary.salary_from == 100000
            assert salary.salary_to == 200000
            assert salary.currency == 'RUR'
    
            # Тестируем вычисление средней зарплаты
>           average = salary.get_average()
                      ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'Salary' object has no attribute 'get_average'

tests/test_final_complete_coverage.py:425: AttributeError
_____________ TestCompleteVacancyModelCoverage.test_vacancy_model_complete_coverage ______________

self = <tests.test_final_complete_coverage.TestCompleteVacancyModelCoverage object at 0x7f6987415190>

    def test_vacancy_model_complete_coverage(self) -> None:
        """
        Полное тестирование модели вакансии.
    
        Покрывает все аспекты вакансии:
        - Создание с полными и частичными данными
        - Валидация обязательных полей
        - Методы сравнения и сортировки
        - Сериализация в JSON и словари
        - Вычисляемые свойства и методы
        """
        try:
            from src.vacancies.models import Vacancy, Employer
    
            # Создаем полную вакансию
            employer = Employer("Test Company", "123")
            vacancy = Vacancy(
                title="Senior Python Developer",
                employer=employer,
                url="https://example.com/vacancy/12345"
            )
    
            assert vacancy is not None
            assert vacancy.title == "Senior Python Developer"
            assert vacancy.employer.name == "Test Company"
    
            # Тестируем валидацию
>           assert vacancy.is_valid() is True
                   ^^^^^^^^^^^^^^^^
E           AttributeError: 'Vacancy' object has no attribute 'is_valid'

tests/test_final_complete_coverage.py:474: AttributeError
______________ TestCompleteConfigurationCoverage.test_app_config_complete_coverage _______________

self = <tests.test_final_complete_coverage.TestCompleteConfigurationCoverage object at 0x7f6987416010>

    def test_app_config_complete_coverage(self) -> None:
        """
        Полное тестирование общей конфигурации приложения.
    
        Покрывает основные настройки:
        - Выбор типа хранилища по умолчанию
        - Настройки логирования
        - Конфигурация кэширования
        - Параметры производительности
        - Режимы работы (debug/production)
        """
        try:
            from src.config.app_config import AppConfig
    
            config = AppConfig()
            assert config is not None
    
            # Тестируем основные настройки
            assert hasattr(config, 'default_storage_type')
            storage_type = config.default_storage_type
>           assert storage_type in ['postgresql', 'json', 'memory']
E           AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']

tests/test_final_complete_coverage.py:543: AssertionError
__________________________ TestDBManager.test_db_manager_initialization __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987385d90>
mock_connect = <MagicMock name='connect' id='140091182859088'>

    @patch('psycopg2.connect')
    def test_db_manager_initialization(self, mock_connect):
        """Тестирование инициализации менеджера БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        assert self.db_manager is not None
>       assert hasattr(self.db_manager, 'config')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.db_manager.DBManager object at 0x7f6985279410>, 'config')
E        +    where <src.storage.db_manager.DBManager object at 0x7f6985279410> = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987385d90>.db_manager

tests/test_storage_modules_comprehensive.py:106: AssertionError
______________________ TestDBManager.test_get_companies_and_vacancies_count ______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987384a10>
mock_connect = <MagicMock name='connect' id='140091216458768'>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect):
        """Тестирование получения количества компаний и вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 10),
            ('Company B', 15),
            ('Company C', 5)
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_storage_modules_comprehensive.py:124: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:308 Нет подключения к базе данных
______________________________ TestDBManager.test_get_all_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987386350>
mock_connect = <MagicMock name='connect' id='140091203270096'>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тестирование получения всех вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 100000, 'https://test.com/1'),
            ('Company B', 'Java Developer', 120000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:144: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091188039056'>, исправляем...
_______________________________ TestDBManager.test_get_avg_salary ________________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987386710>
mock_connect = <MagicMock name='connect' id='140091190226256'>

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect):
        """Тестирование получения средней зарплаты"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (125000.0,)
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_avg_salary()
    
        assert isinstance(result, float)
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_storage_modules_comprehensive.py:158: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091202158224'>, исправляем...
______________________ TestDBManager.test_get_vacancies_with_higher_salary _______________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987386c10>
mock_connect = <MagicMock name='connect' id='140091201500368'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тестирование получения вакансий с зарплатой выше средней"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Senior Python Developer', 150000, 'https://test.com/1'),
            ('Company B', 'Lead Java Developer', 180000, 'https://test.com/2')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:175: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091200914000'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091203181456'>, исправляем...
_________________________ TestDBManager.test_get_vacancies_with_keyword __________________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987387210>
mock_connect = <MagicMock name='connect' id='140091184002448'>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect):
        """Тестирование поиска вакансий по ключевому слову"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ('Company A', 'Python Developer', 120000, 'https://test.com/1')
        ]
        mock_connect.return_value = mock_conn
    
        result = self.db_manager.get_vacancies_with_keyword("Python")
    
        assert isinstance(result, list)
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_storage_modules_comprehensive.py:191: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:139 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140091189639952'>, исправляем...
____________________ TestDBManager.test_db_manager_connection_error_handling _____________________

self = <tests.test_storage_modules_comprehensive.TestDBManager object at 0x7f6987387890>
mock_connect = <MagicMock name='connect' id='140091200685840'>

    @patch('psycopg2.connect')
    def test_db_manager_connection_error_handling(self, mock_connect):
        """Тестирование обработки ошибок подключения"""
        mock_connect.side_effect = Exception("Connection failed")
    
        # Методы должны обрабатывать ошибки подключения
        result = self.db_manager.get_companies_and_vacancies_count()
>       assert result == []
E       AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
E         
E         Left contains 12 more items, first extra item: ('Яндекс', 0)
E         Use -v to get more diff

tests/test_storage_modules_comprehensive.py:200: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.db_manager:db_manager.py:308 Нет подключения к базе данных
_____________________________ TestPostgresSaver.test_save_vacancies ______________________________

self = <tests.test_storage_modules_comprehensive.TestPostgresSaver object at 0x7f698738c810>
mock_connect = <MagicMock name='connect' id='140091184119504'>

    @patch('psycopg2.connect')
    def test_save_vacancies(self, mock_connect):
        """Тестирование сохранения вакансий"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        vacancies = [create_mock_vacancy() for _ in range(3)]
    
        self.postgres_saver.save_vacancies(vacancies)
    
        # Проверяем, что курсор был использован для выполнения запросов
>       assert mock_cursor.execute.called
E       AssertionError: assert False
E        +  where False = <Mock name='connect().cursor().execute' id='140091202616272'>.called
E        +    where <Mock name='connect().cursor().execute' id='140091202616272'> = <Mock name='connect().cursor()' id='140091184108944'>.execute

tests/test_storage_modules_comprehensive.py:242: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='140091183915472'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='140091183866640'>
WARNING  src.storage.postgres_saver:postgres_saver.py:1685 Не удалось распознать формат даты: <Mock name='mock.published_at' id='140091183860048'>
_________________________ TestStorageFactory.test_create_invalid_storage _________________________

self = <tests.test_storage_modules_comprehensive.TestStorageFactory object at 0x7f698738ea90>

    def test_create_invalid_storage(self):
        """Тестирование создания несуществующего типа хранилища"""
>       storage = StorageFactory.create_storage("invalid_type")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

storage_type = 'invalid_type'

    @staticmethod
    def create_storage(storage_type: str = "postgres") -> AbstractVacancyStorage:
        """
        Создает экземпляр хранилища PostgreSQL
    
        Args:
            storage_type: Тип хранилища (только 'postgres' поддерживается)
    
        Returns:
            AbstractVacancyStorage: Экземпляр PostgreSQL хранилища
        """
        if storage_type != "postgres":
>           raise ValueError(f"Поддерживается только PostgreSQL хранилище, получен: {storage_type}")
E           ValueError: Поддерживается только PostgreSQL хранилище, получен: invalid_type

src/storage/storage_factory.py:20: ValueError
_________________ TestDatabaseConnection.test_database_connection_establishment __________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f698738fa10>
mock_connect = <MagicMock name='connect' id='140091182265552'>

    @patch('psycopg2.connect')
    def test_database_connection_establishment(self, mock_connect):
        """Тестирование установки подключения к БД"""
        mock_conn = Mock()
        mock_connect.return_value = mock_conn
    
        connection = self.db_connection.get_connection()
    
        if connection:
>           assert connection == mock_conn
E           AssertionError: assert <MagicMock name='mock.connect()' id='140091203368144'> == <Mock name='connect()' id='140091182262224'>

tests/test_storage_modules_comprehensive.py:330: AssertionError
_________________ TestDatabaseConnection.test_database_connection_error_handling _________________

self = <tests.test_storage_modules_comprehensive.TestDatabaseConnection object at 0x7f69873907d0>

    def test_database_connection_error_handling(self):
        """Тестирование обработки ошибок подключения"""
        with patch('psycopg2.connect', side_effect=Exception("Connection failed")):
            connection = self.db_connection.get_connection()
>           assert connection is None
E           AssertionError: assert <MagicMock name='mock.connect()' id='140091203368144'> is None

tests/test_storage_modules_comprehensive.py:346: AssertionError
__________________ TestVacancyRepository.test_vacancy_repository_initialization __________________

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f69873910d0>

    def test_vacancy_repository_initialization(self):
        """Тестирование инициализации репозитория вакансий"""
        assert self.vacancy_repository is not None
>       assert hasattr(self.vacancy_repository, 'db_manager')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69866ffbd0>, 'db_manager')
E        +    where <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69866ffbd0> = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f69873910d0>.vacancy_repository

tests/test_storage_modules_comprehensive.py:364: AssertionError
___________________________ TestVacancyRepository.test_delete_vacancy ____________________________

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69854471d0>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:159: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_storage_modules_comprehensive.TestVacancyRepository object at 0x7f69873912d0>

    def test_delete_vacancy(self):
        """Тестирование удаления вакансии"""
        if hasattr(self.vacancy_repository, 'delete_vacancy'):
>           result = self.vacancy_repository.delete_vacancy("test_123")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_modules_comprehensive.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69854471d0>
vacancy = 'test_123'

    def delete_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Удаляет вакансию из хранилища
    
        Args:
            vacancy: Объект вакансии для удаления
        """
        try:
            with self._db_connection.get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.execute(
                        "DELETE FROM vacancies WHERE vacancy_id = %s",
                        (vacancy.vacancy_id,)
                    )
                    conn.commit()
    
                    if cursor.rowcount > 0:
                        logger.debug(f"Вакансия {vacancy.vacancy_id} успешно удалена")
                    else:
                        logger.warning(f"Вакансия {vacancy.vacancy_id} не найдена для удаления")
    
        except Exception as e:
>           logger.error(f"Ошибка удаления вакансии {vacancy.vacancy_id}: {e}")
                                                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/components/vacancy_repository.py:173: AttributeError
________________________ TestVacancyValidator.test_get_validation_errors _________________________

self = <tests.test_storage_modules_comprehensive.TestVacancyValidator object at 0x7f6987393690>

    def test_get_validation_errors(self):
        """Тестирование получения ошибок валидации"""
        vacancy = Mock()
        vacancy.vacancy_id = ""
        vacancy.title = ""
        vacancy.url = "invalid_url"
    
        if hasattr(self.validator, 'get_validation_errors'):
>           errors = self.validator.get_validation_errors(vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given

tests/test_storage_modules_comprehensive.py:466: TypeError
_______________________ TestStorageIntegration.test_full_storage_workflow ________________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f698739c9d0>
mock_connect = <MagicMock name='connect' id='140091190473296'>

    @patch('psycopg2.connect')
    def test_full_storage_workflow(self, mock_connect):
        """Тестирование полного рабочего процесса хранения"""
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Создаем компоненты
>       with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69852aacd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________________ TestStorageIntegration.test_storage_error_recovery _______________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f698739d010>

    def test_storage_error_recovery(self):
        """Тестирование восстановления после ошибок хранения"""
        with patch('psycopg2.connect', side_effect=Exception("Database unavailable")):
>           with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f698531a390>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestStorageIntegration.test_storage_performance_simulation ___________________

self = <tests.test_storage_modules_comprehensive.TestStorageIntegration object at 0x7f698739b790>

    def test_storage_performance_simulation(self):
        """Симуляция тестирования производительности хранения"""
        # Создаем большое количество вакансий
        large_vacancy_list = [create_mock_vacancy() for _ in range(100)]
    
        with patch('psycopg2.connect') as mock_connect:
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_conn.cursor.return_value = mock_cursor
            mock_connect.return_value = mock_conn
    
>           with patch('src.storage.postgres_saver.DatabaseConfig'):

tests/test_storage_modules_comprehensive.py:661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69872e2510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../src/storage/postgres_saver.py'> does not have the attribute 'DatabaseConfig'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestParseSearchQuery.test_parse_search_query_case_insensitive __________________

self = <tests.test_ui_helpers_comprehensive.TestParseSearchQuery object at 0x7f6987218410>

    def test_parse_search_query_case_insensitive(self):
        """Тестирование нечувствительности к регистру операторов"""
        result = _parse_search_query("python and django")
>       assert result["keywords"] == ["python", "django"]
E       AssertionError: assert ['python and django'] == ['python', 'django']
E         
E         At index 0 diff: 'python and django' != 'python'
E         Right contains one more item: 'django'
E         Use -v to get more diff

tests/test_ui_helpers_comprehensive.py:305: AssertionError
________________________ TestDisplayVacancyInfo.test_display_vacancy_info ________________________

self = <MagicMock name='vacancy_formatter.display_vacancy_info' id='140091182445136'>
args = (<src.vacancies.models.Vacancy object at 0x7f69854cb450>, 1), kwargs = {}
msg = "Expected 'display_vacancy_info' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_ui_helpers_comprehensive.TestDisplayVacancyInfo object at 0x7f698721b550>
mock_formatter = <MagicMock name='vacancy_formatter' id='140091189759696'>

    @patch('src.utils.vacancy_formatter.vacancy_formatter')
    def test_display_vacancy_info(self, mock_formatter):
        """Тестирование отображения информации о вакансии"""
        vacancy = Vacancy(
            title="Test Job",
            url="https://test.com/job"
        )
    
        display_vacancy_info(vacancy, 1)
    
        # Проверяем, что форматер был вызван
>       mock_formatter.display_vacancy_info.assert_called_once_with(vacancy, 1)
E       AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.

tests/test_ui_helpers_comprehensive.py:426: AssertionError
-------------------------------------- Captured stdout call --------------------------------------
1.
ID: 0e501a22-0cef-42c6-b5a9-40e10279ed05
Название: Test Job
Зарплата: Не указана
Источник: unknown
Ссылка: https://test.com/job
________________ TestDisplayVacancyInfo.test_display_vacancy_info_without_number _________________

self = <MagicMock name='vacancy_formatter.display_vacancy_info' id='140091191089488'>
args = (<src.vacancies.models.Vacancy object at 0x7f69852b4ae0>, None), kwargs = {}
msg = "Expected 'display_vacancy_info' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_ui_helpers_comprehensive.TestDisplayVacancyInfo object at 0x7f6987217b90>
mock_formatter = <MagicMock name='vacancy_formatter' id='140091191096912'>

    @patch('src.utils.vacancy_formatter.vacancy_formatter')
    def test_display_vacancy_info_without_number(self, mock_formatter):
        """Тестирование отображения без номера"""
        vacancy = Vacancy(
            title="Test Job",
            url="https://test.com/job"
        )
    
        display_vacancy_info(vacancy)
    
>       mock_formatter.display_vacancy_info.assert_called_once_with(vacancy, None)
E       AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.

tests/test_ui_helpers_comprehensive.py:438: AssertionError
-------------------------------------- Captured stdout call --------------------------------------
ID: 723ed2f2-4e9a-4c60-8622-ddf492b85f11
Название: Test Job
Зарплата: Не указана
Источник: unknown
Ссылка: https://test.com/job
_____________________ TestUserInterface.test_main_interface_startup_and_exit _____________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f6987240110>
mock_input = <MagicMock name='input' id='140091182550992'>

    @patch('builtins.input', return_value='0')
    def test_main_interface_startup_and_exit(self, mock_input):
        """Тестирование запуска и выхода из главного интерфейса"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69852c3fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestUserInterface.test_main_interface_menu_navigation ______________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f69872406d0>
mock_input = <MagicMock name='input' id='140091190517712'>

    @patch('builtins.input', side_effect=['1', '0'])
    def test_main_interface_menu_navigation(self, mock_input):
        """Тестирование навигации по меню главного интерфейса"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985a5a950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestUserInterface.test_cache_clearing_option __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f6987240a50>
mock_input = <MagicMock name='input' id='140091184169488'>

    @patch('builtins.input', side_effect=['8', '0'])
    def test_cache_clearing_option(self, mock_input):
        """Тестирование опции очистки кэша"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f698544f950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________________ TestUserInterface.test_db_manager_demo_option __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUserInterface object at 0x7f6987240dd0>
mock_input = <MagicMock name='input' id='140091202614288'>

    @patch('builtins.input', side_effect=['10', '0'])
    def test_db_manager_demo_option(self, mock_input):
        """Тестирование опции демонстрации DBManager"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_ui_interfaces_comprehensive.py:487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69865e05d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________________ TestSourceSelector.test_get_user_source_choice _________________________

self = <tests.test_ui_interfaces_comprehensive.TestSourceSelector object at 0x7f69872427d0>
mock_input = <MagicMock name='input' id='140091203257616'>

    @patch('builtins.input', return_value='1')
    def test_get_user_source_choice(self, mock_input):
        """Тестирование получения выбора источника пользователем"""
        if hasattr(self.source_selector, 'get_user_source_choice'):
            choice = self.source_selector.get_user_source_choice()
    
            # Результат может быть списком источников или None
>           assert choice is None or isinstance(choice, list)
E           AssertionError: assert ({'hh.ru'} is None or False)
E            +  where False = isinstance({'hh.ru'}, list)

tests/test_ui_interfaces_comprehensive.py:149: AssertionError
-------------------------------------- Captured stdout call --------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Выбран источник: HH.ru
_________________________ TestUIPerformance.test_pagination_performance __________________________

self = <tests.test_ui_interfaces_comprehensive.TestUIPerformance object at 0x7f6987258890>

    def test_pagination_performance(self):
        """Тестирование производительности пагинации"""
        large_dataset = list(range(10000))
    
        from src.utils.paginator import Paginator
>       paginator = Paginator(large_dataset, page_size=100)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_ui_interfaces_comprehensive.py:580: TypeError
___________________ TestUINavigation.test_handle_navigation_choice_page_number ___________________

self = <tests.test_ui_navigation_comprehensive.TestUINavigation object at 0x7f698729e650>

    def test_handle_navigation_choice_page_number(self):
        """Тестирование прямого указания номера страницы"""
        result = self.ui_nav._handle_navigation_choice("3", 1, 5)
        assert result == 3
    
        # Некорректный номер страницы
>       result = self.ui_nav._handle_navigation_choice("10", 1, 5)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_navigation_comprehensive.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/ui_navigation.py:153: in _handle_navigation_choice
    input("Нажмите Enter для продолжения...")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f6988b57b10>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
-------------------------------------- Captured stdout call --------------------------------------
Некорректный номер страницы. Доступно: 1-5
Нажмите Enter для продолжения...
___________________ TestQuickPaginate.test_quick_paginate_with_custom_actions ____________________

self = <tests.test_ui_navigation_comprehensive.TestQuickPaginate object at 0x7f69872a56d0>
mock_print = <MagicMock name='print' id='140091185940112'>
mock_input = <MagicMock name='input' id='140091185950480'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_quick_paginate_with_custom_actions(self, mock_print, mock_input):
        """Тестирование quick_paginate с пользовательскими действиями"""
        mock_input.side_effect = ["c", "q"]
    
        action_called = False
        def custom_action():
            nonlocal action_called
            action_called = True
    
        custom_actions = {"c": custom_action}
        items = ["item1", "item2", "item3"]
    
        quick_paginate(
            items,
            self.test_formatter,
            "Quick Test",
            custom_actions=custom_actions
        )
    
>       assert action_called is True
E       assert False is True

tests/test_ui_navigation_comprehensive.py:341: AssertionError
_________________________ TestUserInterfaceComplete.test_start_interface _________________________

self = <tests.test_user_interface_complete.TestUserInterfaceComplete object at 0x7f69872bba50>
mock_print = <MagicMock name='print' id='140091186337552'>
mock_input = <MagicMock name='input' id='140091186331920'>

    @patch('builtins.input', return_value='0')
    @patch('builtins.print')
    def test_start_interface(self, mock_print, mock_input):
        """Тест запуска интерфейса"""
>       with patch.object(self.user_interface, 'show_main_menu', return_value=None):

tests/test_user_interface_complete.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f698565c610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7f69856a0f90> does not have the attribute 'show_main_menu'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________________ TestUserInterfaceComplete.test_display_vacancies ________________________

self = <tests.test_user_interface_complete.TestUserInterfaceComplete object at 0x7f69872cdcd0>
mock_print = <MagicMock name='print' id='140091189392848'>

    @patch('builtins.print')
    def test_display_vacancies(self, mock_print):
        """Тест отображения вакансий"""
        from src.vacancies.models import Vacancy
    
        sample_vacancies = [
>           Vacancy(
                id="1",
                title="Python Developer",
                description="Test description",
                salary_from=100000,
                salary_to=150000,
                currency="RUR",
                company_name="Test Company",
                url="https://test.com/1"
            )
        ]
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'

tests/test_user_interface_complete.py:98: TypeError
--------------------------------------- Captured log setup ---------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
________________________ TestUserInterfaceComponents.test_search_handler _________________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f69872e1b10>
mock_print = <MagicMock name='print' id='140091188237776'>
mock_input = <MagicMock name='input' id='140091184945552'>

    @patch('builtins.input', side_effect=['1', 'Python', '7'])
    @patch('builtins.print')
    def test_search_handler(self, mock_print, mock_input):
        """Тестирование обработчика поиска вакансий"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Настраиваем мок для возврата тестовых данных
        ui.unified_api.search_vacancies_from_all_sources = Mock(return_value=[
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ])
    
        try:
            ui.search_handler.search_vacancies()
    
            # Проверяем, что API был вызван
>           assert ui.unified_api.search_vacancies_from_all_sources.called
E           AssertionError: assert False
E            +  where False = <Mock id='140091188243856'>.called
E            +    where <Mock id='140091188243856'> = <src.api_modules.unified_api.UnifiedAPI object at 0x7f698582fdd0>.search_vacancies_from_all_sources
E            +      where <src.api_modules.unified_api.UnifiedAPI object at 0x7f698582fdd0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f698582f490>.unified_api

tests/test_user_interface_comprehensive.py:80: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f69872e1b10>
mock_print = <MagicMock name='print' id='140091188237776'>
mock_input = <MagicMock name='input' id='140091184945552'>

    @patch('builtins.input', side_effect=['1', 'Python', '7'])
    @patch('builtins.print')
    def test_search_handler(self, mock_print, mock_input):
        """Тестирование обработчика поиска вакансий"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Настраиваем мок для возврата тестовых данных
        ui.unified_api.search_vacancies_from_all_sources = Mock(return_value=[
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ])
    
        try:
            ui.search_handler.search_vacancies()
    
            # Проверяем, что API был вызван
            assert ui.unified_api.search_vacancies_from_all_sources.called
    
        except Exception as e:
>           pytest.fail(f"search handler should not raise exceptions: {e}")
E           Failed: search handler should not raise exceptions: assert False
E            +  where False = <Mock id='140091188243856'>.called
E            +    where <Mock id='140091188243856'> = <src.api_modules.unified_api.UnifiedAPI object at 0x7f698582fdd0>.search_vacancies_from_all_sources
E            +      where <src.api_modules.unified_api.UnifiedAPI object at 0x7f698582fdd0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f698582f490>.unified_api

tests/test_user_interface_comprehensive.py:83: Failed
-------------------------------------- Captured stderr call --------------------------------------
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 2133.42page/s, vacancies=3]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 3887.21page/s, vacancies=0]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 991.09page/s, vacancies=17]
Fetching pages: 100%|██████████| 1/1 [00:00<00:00, 3366.22page/s, vacancies=0]
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:218 check_vacancies_exist_batch вернул неожиданный тип: <class 'unittest.mock.Mock'>
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:70 Ошибка поиска вакансий:
______________________ TestUserInterfaceComponents.test_unified_api_methods ______________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceComponents object at 0x7f69872e3a10>

    def test_unified_api_methods(self):
        """Тестирование методов унифицированного API"""
        mock_storage = Mock()
        mock_db = Mock()
        ui = UserInterface(storage=mock_storage, db_manager=mock_db)
    
        # Проверяем методы UnifiedAPI
>       assert hasattr(ui.unified_api, 'search_vacancies_from_all_sources')
E       AssertionError: assert False
E        +  where False = hasattr(<src.api_modules.unified_api.UnifiedAPI object at 0x7f69857c14d0>, 'search_vacancies_from_all_sources')
E        +    where <src.api_modules.unified_api.UnifiedAPI object at 0x7f69857c14d0> = <src.ui_interfaces.console_interface.UserInterface object at 0x7f69857c1590>.unified_api

tests/test_user_interface_comprehensive.py:183: AssertionError
--------------------------------------- Captured log call ----------------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______________________ TestMainApplicationFlow.test_main_application_exit _______________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f69870ecc10>
mock_input = <MagicMock name='input' id='140091186308752'>

    @patch('builtins.input', return_value='0')
    def test_main_application_exit(self, mock_input):
        """Тестирование выхода из приложения"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69856554d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestMainApplicationFlow.test_main_application_search_workflow __________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f69870ed1d0>
mock_input = <MagicMock name='input' id='140091189656592'>

    @patch('builtins.input', side_effect=['1', '1', 'Python', '7', '0'])
    def test_main_application_search_workflow(self, mock_input):
        """Тестирование рабочего процесса поиска в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985987610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestMainApplicationFlow.test_main_application_display_workflow _________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f69870ed790>
mock_input = <MagicMock name='input' id='140091216961936'>

    @patch('builtins.input', side_effect=['2', '0'])
    def test_main_application_display_workflow(self, mock_input):
        """Тестирование рабочего процесса отображения в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6987392b50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestMainApplicationFlow.test_main_application_demo_workflow ___________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f69870edd90>
mock_input = <MagicMock name='input' id='140091183081872'>

    @patch('builtins.input', side_effect=['10', '0'])
    def test_main_application_demo_workflow(self, mock_input):
        """Тестирование рабочего процесса демонстрации в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985343d90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestMainApplicationFlow.test_main_application_invalid_choice __________________

self = <tests.test_user_interface_comprehensive.TestMainApplicationFlow object at 0x7f69870ee350>
mock_input = <MagicMock name='input' id='140091186335888'>

    @patch('builtins.input', side_effect=['999', '0'])
    def test_main_application_invalid_choice(self, mock_input):
        """Тестирование обработки некорректного выбора в главном приложении"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f698565d950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestErrorHandling.test_create_instances_error_handling _____________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870eeb90>

    def test_create_instances_error_handling(self):
        """Тестирование обработки ошибок при создании экземпляров"""
>       with patch('src.user_interface.PostgresSaver', side_effect=Exception("Database error")):

tests/test_user_interface_comprehensive.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985970110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'PostgresSaver'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestErrorHandling.test_search_error_handling __________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870ef210>

    def test_search_error_handling(self):
        """Тестирование обработки ошибок поиска"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # API возвращает ошибку
        mock_unified_api.search_vacancies.side_effect = Exception("API Error")
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            try:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:348: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870ef210>

    def test_search_error_handling(self):
        """Тестирование обработки ошибок поиска"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # API возвращает ошибку
        mock_unified_api.search_vacancies.side_effect = Exception("API Error")
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            try:
                search_and_save_vacancies(mock_unified_api, mock_storage)
                # Функция должна обработать ошибку
            except Exception as e:
>               pytest.fail(f"search function should handle API errors: {e}")
E               Failed: search function should handle API errors: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:351: Failed
_________________________ TestErrorHandling.test_storage_error_handling __________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870ef8d0>

    def test_storage_error_handling(self):
        """Тестирование обработки ошибок хранения"""
        mock_storage = Mock()
        mock_storage.get_vacancies.side_effect = Exception("Storage Error")
    
        try:
>           display_all_vacancies(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:359: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870ef8d0>

    def test_storage_error_handling(self):
        """Тестирование обработки ошибок хранения"""
        mock_storage = Mock()
        mock_storage.get_vacancies.side_effect = Exception("Storage Error")
    
        try:
            display_all_vacancies(mock_storage)
            # Функция должна обработать ошибку
        except Exception as e:
>           pytest.fail(f"display function should handle storage errors: {e}")
E           Failed: display function should handle storage errors: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:362: Failed
________________________ TestErrorHandling.test_db_manager_error_handling ________________________

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870effd0>

    def test_db_manager_error_handling(self):
        """Тестирование обработки ошибок DB Manager"""
        mock_db_manager = Mock()
        mock_db_manager.get_companies_and_vacancies_count.side_effect = Exception("DB Error")
    
        try:
>           display_database_statistics(mock_db_manager)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'display_database_statistics' is not defined

tests/test_user_interface_comprehensive.py:370: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestErrorHandling object at 0x7f69870effd0>

    def test_db_manager_error_handling(self):
        """Тестирование обработки ошибок DB Manager"""
        mock_db_manager = Mock()
        mock_db_manager.get_companies_and_vacancies_count.side_effect = Exception("DB Error")
    
        try:
            display_database_statistics(mock_db_manager)
            # Функция должна обработать ошибку
        except Exception as e:
>           pytest.fail(f"statistics function should handle DB errors: {e}")
E           Failed: statistics function should handle DB errors: name 'display_database_statistics' is not defined

tests/test_user_interface_comprehensive.py:373: Failed
______________________ TestInputValidation.test_empty_search_query_handling ______________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f4810>
mock_input = <MagicMock name='input' id='140091183018576'>

    @patch('builtins.input', side_effect=['', 'Python'])
    def test_empty_search_query_handling(self, mock_input):
        """Тестирование обработки пустого поискового запроса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        with patch('builtins.print'):
            try:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:387: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f4810>
mock_input = <MagicMock name='input' id='140091183018576'>

    @patch('builtins.input', side_effect=['', 'Python'])
    def test_empty_search_query_handling(self, mock_input):
        """Тестирование обработки пустого поискового запроса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        with patch('builtins.print'):
            try:
                search_and_save_vacancies(mock_unified_api, mock_storage)
            except Exception as e:
>               pytest.fail(f"Should handle empty search query: {e}")
E               Failed: Should handle empty search query: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:389: Failed
_____________________ TestInputValidation.test_invalid_salary_input_handling _____________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f4e50>
mock_input = <MagicMock name='input' id='140091216955664'>

    @patch('builtins.input', side_effect=['invalid_number', '100000'])
    def test_invalid_salary_input_handling(self, mock_input):
        """Тестирование обработки некорректного ввода зарплаты"""
        mock_storage = Mock()
        mock_storage.get_vacancies.return_value = []
    
        try:
>           filter_vacancies_by_salary(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:398: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f4e50>
mock_input = <MagicMock name='input' id='140091216955664'>

    @patch('builtins.input', side_effect=['invalid_number', '100000'])
    def test_invalid_salary_input_handling(self, mock_input):
        """Тестирование обработки некорректного ввода зарплаты"""
        mock_storage = Mock()
        mock_storage.get_vacancies.return_value = []
    
        try:
            filter_vacancies_by_salary(mock_storage)
        except Exception as e:
>           pytest.fail(f"Should handle invalid salary input: {e}")
E           Failed: Should handle invalid salary input: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:400: Failed
__________________ TestInputValidation.test_invalid_confirmation_input_handling __________________

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f54d0>
mock_input = <MagicMock name='input' id='140091214187728'>

    @patch('builtins.input', side_effect=['maybe', 'y'])
    def test_invalid_confirmation_input_handling(self, mock_input):
        """Тестирование обработки некорректного подтверждения"""
        mock_storage = Mock()
    
        try:
>           clear_vacancy_data(mock_storage)
            ^^^^^^^^^^^^^^^^^^
E           NameError: name 'clear_vacancy_data' is not defined

tests/test_user_interface_comprehensive.py:408: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_user_interface_comprehensive.TestInputValidation object at 0x7f69870f54d0>
mock_input = <MagicMock name='input' id='140091214187728'>

    @patch('builtins.input', side_effect=['maybe', 'y'])
    def test_invalid_confirmation_input_handling(self, mock_input):
        """Тестирование обработки некорректного подтверждения"""
        mock_storage = Mock()
    
        try:
            clear_vacancy_data(mock_storage)
        except Exception as e:
>           pytest.fail(f"Should handle invalid confirmation input: {e}")
E           Failed: Should handle invalid confirmation input: name 'clear_vacancy_data' is not defined

tests/test_user_interface_comprehensive.py:410: Failed
____________________________ TestDataFlow.test_search_to_storage_flow ____________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f69870f5cd0>

    def test_search_to_storage_flow(self):
        """Тестирование потока данных от поиска к хранению"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Настраиваем данные для потока
        test_vacancies = [
            {'id': '1', 'name': 'Python Developer', 'url': 'https://test1.com'},
            {'id': '2', 'name': 'Java Developer', 'url': 'https://test2.com'}
        ]
        mock_unified_api.search_vacancies.return_value = test_vacancies
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
>           search_and_save_vacancies(mock_unified_api, mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:429: NameError
___________________________ TestDataFlow.test_storage_to_display_flow ____________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f69870f6350>

    def test_storage_to_display_flow(self):
        """Тестирование потока данных от хранения к отображению"""
        mock_storage = Mock()
    
        # Настраиваем данные в хранилище
        stored_vacancies = [
            ('Company A', 'Python Developer', 100000, 'https://test1.com'),
            ('Company B', 'Java Developer', 120000, 'https://test2.com')
        ]
        mock_storage.get_vacancies.return_value = stored_vacancies
    
>       display_all_vacancies(mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:450: NameError
_______________________________ TestDataFlow.test_filter_data_flow _______________________________

self = <tests.test_user_interface_comprehensive.TestDataFlow object at 0x7f69870f6a10>

    def test_filter_data_flow(self):
        """Тестирование потока данных при фильтрации"""
        mock_storage = Mock()
    
        # Данные с разными зарплатами для фильтрации
        test_vacancies = [
            ('Company A', 'Senior Developer', 150000, 'https://test1.com'),
            ('Company B', 'Junior Developer', 80000, 'https://test2.com'),
            ('Company C', 'Lead Developer', 200000, 'https://test3.com')
        ]
        mock_storage.get_vacancies.return_value = test_vacancies
    
        with patch('builtins.input', return_value='100000'):
>           filter_vacancies_by_salary(mock_storage)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           NameError: name 'filter_vacancies_by_salary' is not defined

tests/test_user_interface_comprehensive.py:468: NameError
_____________ TestUserInterfaceIntegration.test_complete_search_and_display_workflow _____________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f69870f7250>
mock_input = <MagicMock name='input' id='140091183202576'>

    @patch('builtins.input', side_effect=['1', '1', 'Python', '7', '2', '0'])
    def test_complete_search_and_display_workflow(self, mock_input):
        """Тестирование полного рабочего процесса поиска и отображения"""
>       with patch('src.user_interface.create_storage_and_api_instances') as mock_create:

tests/test_user_interface_comprehensive.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f69853603d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'create_storage_and_api_instances'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterfaceIntegration.test_interface_performance_with_large_dataset ___________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f69870f78d0>

    def test_interface_performance_with_large_dataset(self):
        """Тестирование производительности интерфейса с большим объемом данных"""
        mock_storage = Mock()
    
        # Создаем большой набор данных
        large_dataset = [
            (f'Company {i}', f'Job {i}', 100000 + i * 1000, f'https://test{i}.com')
            for i in range(1000)
        ]
        mock_storage.get_vacancies.return_value = large_dataset
    
        import time
        start_time = time.time()
    
>       display_all_vacancies(mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'display_all_vacancies' is not defined

tests/test_user_interface_comprehensive.py:522: NameError
________________ TestUserInterfaceIntegration.test_concurrent_operations_handling ________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceIntegration object at 0x7f69870edf10>

    def test_concurrent_operations_handling(self):
        """Тестирование обработки одновременных операций"""
        # Симулируем одновременные операции с разными компонентами
        mock_unified_api = Mock()
        mock_storage = Mock()
        mock_db_manager = Mock()
    
        # Операции не должны конфликтовать
>       search_and_save_vacancies(mock_unified_api, mock_storage)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:537: NameError
__________________ TestUserInterfaceAccessibility.test_menu_display_formatting ___________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceAccessibility object at 0x7f69870f7750>

    def test_menu_display_formatting(self):
        """Тестирование форматирования отображения меню"""
        with patch('builtins.print') as mock_print:
>           display_main_menu()
            ^^^^^^^^^^^^^^^^^
E           NameError: name 'display_main_menu' is not defined

tests/test_user_interface_comprehensive.py:550: NameError
____________________ TestUserInterfaceAccessibility.test_progress_indication _____________________

self = <tests.test_user_interface_comprehensive.TestUserInterfaceAccessibility object at 0x7f69870f6090>

    def test_progress_indication(self):
        """Тестирование индикации прогресса"""
        mock_unified_api = Mock()
        mock_storage = Mock()
    
        # Симулируем долгую операцию
        mock_unified_api.search_vacancies.return_value = [
            {'id': str(i), 'name': f'Job {i}', 'url': f'https://test{i}.com'}
            for i in range(100)
        ]
    
        with patch('builtins.input', side_effect=['1', 'Python', '7']):
            with patch('builtins.print') as mock_print:
>               search_and_save_vacancies(mock_unified_api, mock_storage)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E               NameError: name 'search_and_save_vacancies' is not defined

tests/test_user_interface_comprehensive.py:581: NameError
_____________________________ TestVacancy.test_vacancy_html_cleaning _____________________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancy object at 0x7f698717e710>

    def test_vacancy_html_cleaning(self):
        """Тестирование очистки HTML в тексте вакансии"""
        html_description = "<p>Test <b>description</b> with <a href='#'>HTML</a></p>"
        vacancy = Vacancy(
            title="Test",
            url="https://test.com",
            description=html_description,
            requirements="<ul><li>Python</li></ul>",
            responsibilities="<div>Development</div>"
        )
    
        # HTML теги должны быть удалены
>       assert "<p>" not in vacancy.description
E       AssertionError: assert '<p>' not in '<p>Test <b>...HTML</a></p>'
E         
E         '<p>' is contained here:
E           <p>Test <b>description</b> with <a href='#'>HTML</a></p>
E         ? +++

tests/test_vacancy_modules_comprehensive.py:417: AssertionError
___________________________ TestHHParser.test_hh_parser_salary_parsing ___________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f6987185cd0>

    def test_hh_parser_salary_parsing(self):
        """Тестирование парсинга зарплаты в HH"""
        hh_data = create_hh_vacancy_data()
        vacancy = self.parser.parse_vacancy(hh_data)
    
>       assert vacancy.salary is not None
               ^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'salary'

tests/test_vacancy_modules_comprehensive.py:601: AttributeError
__________________________ TestHHParser.test_hh_parser_employer_parsing __________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f69871862d0>

    def test_hh_parser_employer_parsing(self):
        """Тестирование парсинга работодателя в HH"""
        hh_data = create_hh_vacancy_data()
        vacancy = self.parser.parse_vacancy(hh_data)
    
>       assert isinstance(vacancy.employer, Employer)
                          ^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'employer'

tests/test_vacancy_modules_comprehensive.py:609: AttributeError
___________________________ TestHHParser.test_hh_parser_missing_fields ___________________________

self = <tests.test_vacancy_modules_comprehensive.TestHHParser object at 0x7f6987186ed0>

    def test_hh_parser_missing_fields(self):
        """Тестирование обработки отсутствующих полей"""
        minimal_data = {
            "id": "123",
            "name": "Test Job",
            "alternate_url": "https://hh.ru/vacancy/123"
        }
    
        vacancy = self.parser.parse_vacancy(minimal_data)
    
        if vacancy is not None:
>           assert isinstance(vacancy, Vacancy)
E           AssertionError: assert False
E            +  where False = isinstance({'area': '', 'employer': '', 'employment': '', 'experience': '', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:638: AssertionError
_____________________ TestSuperJobParser.test_sj_parser_parse_single_vacancy _____________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f6987187d90>

    def test_sj_parser_parse_single_vacancy(self):
        """Тестирование парсинга одной вакансии SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy, Vacancy)
E       AssertionError: assert False
E        +  where False = isinstance({'area': 'Москва', 'description': 'Разработка и поддержка веб-приложений', 'employer': 'IT Компания', 'employment': 'Полная занятость', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:660: AssertionError
________________________ TestSuperJobParser.test_sj_parser_salary_parsing ________________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f6987188a10>

    def test_sj_parser_salary_parsing(self):
        """Тестирование парсинга зарплаты в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert vacancy.salary is not None
               ^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'salary'

tests/test_vacancy_modules_comprehensive.py:685: AttributeError
_______________________ TestSuperJobParser.test_sj_parser_employer_parsing _______________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f6987189010>

    def test_sj_parser_employer_parsing(self):
        """Тестирование парсинга работодателя в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy.employer, Employer)
                          ^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'employer'

tests/test_vacancy_modules_comprehensive.py:693: AttributeError
______________________ TestSuperJobParser.test_sj_parser_timestamp_handling ______________________

self = <tests.test_vacancy_modules_comprehensive.TestSuperJobParser object at 0x7f6987189610>

    def test_sj_parser_timestamp_handling(self):
        """Тестирование обработки timestamp в SuperJob"""
        sj_data = create_sj_vacancy_data()
        vacancy = self.parser.parse_vacancy(sj_data)
    
>       assert isinstance(vacancy.published_at, datetime)
                          ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'published_at'

tests/test_vacancy_modules_comprehensive.py:701: AttributeError
___________________ TestVacancyModelsIntegration.test_full_parsing_workflow_hh ___________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f6987186090>

    def test_full_parsing_workflow_hh(self):
        """Тестирование полного рабочего процесса парсинга HH"""
        hh_data = create_hh_vacancy_data()
        parser = HHParser()
    
        # Парсим вакансию
        vacancy = parser.parse_vacancy(hh_data)
    
>       assert isinstance(vacancy, Vacancy)
E       AssertionError: assert False
E        +  where False = isinstance({'area': 'Москва', 'employer': 'Яндекс', 'employment': 'Полная занятость', 'experience': 'От 1 года до 3 лет', ...}, Vacancy)

tests/test_vacancy_modules_comprehensive.py:725: AssertionError
___________________ TestVacancyModelsIntegration.test_full_parsing_workflow_sj ___________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f698717fcd0>

    def test_full_parsing_workflow_sj(self):
        """Тестирование полного рабочего процесса парсинга SuperJob"""
        sj_data = create_sj_vacancy_data()
>       parser = SJParser()
                 ^^^^^^^^
E       NameError: name 'SJParser' is not defined

tests/test_vacancy_modules_comprehensive.py:737: NameError
__________________ TestVacancyModelsIntegration.test_cross_format_compatibility __________________

self = <tests.test_vacancy_modules_comprehensive.TestVacancyModelsIntegration object at 0x7f698717e190>

    def test_cross_format_compatibility(self):
        """Тестирование совместимости между форматами"""
        # Создаем вакансию из HH формата
        hh_data = create_hh_vacancy_data()
        hh_parser = HHParser()
        hh_vacancy = hh_parser.parse_vacancy(hh_data)
    
        # Создаем вакансию из SJ формата
        sj_data = create_sj_vacancy_data()
>       sj_parser = SJParser()
                    ^^^^^^^^
E       NameError: name 'SJParser' is not defined

tests/test_vacancy_modules_comprehensive.py:760: NameError
____________________________ TestVacancyRepository.test_save_vacancy _____________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987004f90>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091185527376'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_save_vacancy(self, mock_db_connection):
        """Тест сохранения вакансии"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
        vacancy = Mock()
        vacancy.vacancy_id = "test_123"
        vacancy.title = "Test Vacancy"
    
>       with patch.object(repo, 'save_vacancy') as mock_save:

tests/test_vacancy_repository.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985700b10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6985700710> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________________ TestVacancyRepository.test_get_vacancy_by_id __________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987005310>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091190009808'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_vacancy_by_id(self, mock_db_connection):
        """Тест получения вакансии по ID"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (
            "123", "Python Developer", "Test description",
            100000, 150000, "RUR", "Test Company", "https://test.com/vacancy/123"
        )
    
>       vacancy = repo.get_vacancy_by_id("123")
                  ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_vacancy_by_id'

tests/test_vacancy_repository.py:74: AttributeError
__________________________ TestVacancyRepository.test_get_all_vacancies __________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f69870056d0>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091182560848'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_all_vacancies(self, mock_db_connection):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "Test description",
             100000, 150000, "RUR", "Test Company", "https://test.com/vacancy/123")
        ]
    
>       vacancies = repo.get_all_vacancies()
                    ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_all_vacancies'

tests/test_vacancy_repository.py:92: AttributeError
___________________________ TestVacancyRepository.test_update_vacancy ____________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987005a50>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091183014352'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_update_vacancy(self, mock_db_connection):
        """Тест обновления вакансии"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
>       with patch.object(repo, 'update_vacancy') as mock_update:

tests/test_vacancy_repository.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985667d10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6985664150> does not have the attribute 'update_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestVacancyRepository.test_find_vacancies_by_criteria ______________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987006410>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091187059024'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_find_vacancies_by_criteria(self, mock_db_connection):
        """Тест поиска вакансий по критериям"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = []
    
        criteria = {"salary_from": 100000, "company_name": "Test Company"}
>       vacancies = repo.find_vacancies_by_criteria(criteria)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'find_vacancies_by_criteria'

tests/test_vacancy_repository.py:134: AttributeError
___________________________ TestVacancyRepository.test_count_vacancies ___________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f69870069d0>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091187067344'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_count_vacancies(self, mock_db_connection):
        """Тест подсчета количества вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (10,)
    
>       count = repo.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count_vacancies'

tests/test_vacancy_repository.py:149: AttributeError
________________________ TestVacancyRepository.test_batch_save_vacancies _________________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987006f90>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091185389456'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_batch_save_vacancies(self, mock_db_connection):
        """Тест пакетного сохранения вакансий"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
        vacancies = [self.sample_vacancy]
    
>       with patch.object(repo, 'batch_save_vacancies') as mock_batch_save:

tests/test_vacancy_repository.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6985577750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69855762d0> does not have the attribute 'batch_save_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestVacancyRepository.test_get_vacancies_by_salary_range ____________________

self = <tests.test_vacancy_repository.TestVacancyRepository object at 0x7f6987007510>
mock_db_connection = <MagicMock name='DatabaseConnection' id='140091188890768'>

    @patch('src.storage.components.vacancy_repository.DatabaseConnection')
    def test_get_vacancies_by_salary_range(self, mock_db_connection):
        """Тест получения вакансий по диапазону зарплат"""
        mock_connection = Mock()
        mock_validator = Mock()
        repo = VacancyRepository(mock_connection, mock_validator)
    
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.fetchall.return_value = []
    
>       vacancies = repo.get_vacancies_by_salary_range(100000, 200000)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_vacancies_by_salary_range'

tests/test_vacancy_repository.py:179: AttributeError
________________________ TestVacancyValidator.test_get_validation_errors _________________________

self = <tests.test_vacancy_validator.TestVacancyValidator object at 0x7f6987050890>

    def test_get_validation_errors(self):
        """Тест получения ошибок валидации"""
        if hasattr(self.validator, 'get_validation_errors'):
>           errors = self.validator.get_validation_errors(self.invalid_vacancy)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given

tests/test_vacancy_validator.py:130: TypeError
==================================== short test summary info =====================================
FAILED tests/test_advanced_coverage_comprehensive.py::TestUIComponentsComprehensive::test_paginator_initialization - TypeError: Paginator() takes no arguments
FAILED tests/test_api_modules_comprehensive.py::TestHeadHunterAPI::test_hh_api_search_vacancies_success - assert 0 == 1
FAILED tests/test_api_modules_comprehensive.py::TestHeadHunterAPI::test_hh_api_get_vacancy_details - AttributeError: 'HeadHunterAPI' object has no attribute 'get_vacancy_details'
FAILED tests/test_api_modules_comprehensive.py::TestSuperJobAPI::test_sj_api_search_vacancies_success - assert 0 == 1
FAILED tests/test_api_modules_comprehensive.py::TestCachedAPI::test_cached_api_search_with_caching - AssertionError: Expected 'get_vacancies' to not have been called. Called 1 times.
FAILED tests/test_api_modules_comprehensive.py::TestCachedAPI::test_cached_api_clear_cache - TypeError: CachedAPI.clear_cache() missing 1 required positional argument: 'api_prefix'
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_search_all_sources - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_search_specific_source - AttributeError: 'UnifiedAPI' object has no attribute 'search_vacancies'
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_get_available_sources - AssertionError: assert ('hh.ru' in ['hh', 'sj'] or 'superjob.ru' in ['hh', 'sj'])
FAILED tests/test_api_modules_comprehensive.py::TestUnifiedAPI::test_unified_api_error_handling - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_connect - ConnectionError: Unexpected error: 'NoneType' object has no attribute 'items'
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_error_handling - NameError: name 'requests' is not defined
FAILED tests/test_api_modules_comprehensive.py::TestAPIConnector::test_api_connector_with_params - ConnectionError: Connection error: HTTPSConnectionPool(host='test.api', port=443): Max retrie...
FAILED tests/test_api_modules_comprehensive.py::TestAPIIntegration::test_full_search_workflow - AttributeError: 'UnifiedAPI' object has no attribute 'get_vacancies'
FAILED tests/test_comprehensive_final.py::TestSpecialModules::test_vacancy_storage_service_full_coverage - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
FAILED tests/test_config_modules_comprehensive.py::TestAPIConfig::test_api_config_initialization - AssertionError: assert False
FAILED tests/test_config_modules_comprehensive.py::TestAPIConfig::test_api_config_abstract_methods - AttributeError: 'APIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_urls - AttributeError: 'HHAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_headers - AttributeError: 'HHAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_default_parameters - AttributeError: 'HHAPIConfig' object has no attribute 'get_default_parameters'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_enabled - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_disabled - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestHHAPIConfig::test_hh_config_salary_filter_default - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_urls - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_with_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_without_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_parameters - AttributeError: 'SJAPIConfig' object has no attribute 'get_default_parameters'
FAILED tests/test_config_modules_comprehensive.py::TestSJAPIConfig::test_sj_config_salary_filter - AttributeError: 'SJAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_config_modules_comprehensive.py::TestDatabaseConfig::test_db_config_initialization - AttributeError: 'DatabaseConfig' object has no attribute 'default_storage_type'
FAILED tests/test_config_modules_comprehensive.py::TestTargetCompanies::test_company_ids_extraction - AssertionError: assert False
FAILED tests/test_config_modules_comprehensive.py::TestConfigIntegration::test_environment_variables_propagation - AttributeError: 'HHAPIConfig' object has no attribute 'should_filter_by_salary'
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_success - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_db_connection_error - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestUserInterfaceModule::test_main_function_keyboard_interrupt - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_core_modules_comprehensive.py::TestDBManagerComprehensive::test_check_connection_success - assert False is True
FAILED tests/test_core_modules_comprehensive.py::TestDBManagerComprehensive::test_create_tables_success - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_core_modules_comprehensive.py::TestVacancyModels::test_vacancy_validation_valid - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_core_modules_comprehensive.py::TestVacancyModels::test_vacancy_validation_invalid_title - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_core_modules_comprehensive.py::TestAppConfigComprehensive::test_app_config_default_values - AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
FAILED tests/test_core_modules_comprehensive.py::TestStorageFactoryComprehensive::test_storage_factory_postgresql - ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql
FAILED tests/test_core_modules_comprehensive.py::TestStorageFactoryComprehensive::test_storage_factory_json - ValueError: Поддерживается только PostgreSQL хранилище, получен: json
FAILED tests/test_database_connection.py::TestDatabaseConnection::test_database_connection_init - AssertionError: assert False
FAILED tests/test_database_connection.py::TestDatabaseConnection::test_close_connection - TypeError: DatabaseConnection.close_connection() takes 1 positional argument but 2 were given
FAILED tests/test_final_complete_coverage.py::TestCompleteAPIModuleCoverage::test_headhunter_api_complete_coverage - AttributeError: 'HeadHunterAPI' object has no attribute 'search_vacancies'
FAILED tests/test_final_complete_coverage.py::TestCompleteAPIModuleCoverage::test_superjob_api_complete_coverage - AttributeError: 'SuperJobAPI' object has no attribute 'search_vacancies'
FAILED tests/test_final_complete_coverage.py::TestCompleteStorageModuleCoverage::test_db_manager_complete_coverage - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_final_complete_coverage.py::TestCompleteStorageModuleCoverage::test_storage_factory_complete_coverage - ValueError: Поддерживается только PostgreSQL хранилище, получен: postgresql
FAILED tests/test_final_complete_coverage.py::TestCompleteUIModuleCoverage::test_user_interface_complete_coverage - AssertionError: Expected 'print' to have been called.
FAILED tests/test_final_complete_coverage.py::TestCompleteUtilityModuleCoverage::test_salary_comprehensive - AttributeError: 'Salary' object has no attribute 'get_average'
FAILED tests/test_final_complete_coverage.py::TestCompleteVacancyModelCoverage::test_vacancy_model_complete_coverage - AttributeError: 'Vacancy' object has no attribute 'is_valid'
FAILED tests/test_final_complete_coverage.py::TestCompleteConfigurationCoverage::test_app_config_complete_coverage - AssertionError: assert 'postgres' in ['postgresql', 'json', 'memory']
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_db_manager_initialization - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_all_vacancies - assert 0 == 2
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_vacancies_with_higher_salary - assert 0 == 2
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_get_vacancies_with_keyword - assert 0 == 1
FAILED tests/test_storage_modules_comprehensive.py::TestDBManager::test_db_manager_connection_error_handling - AssertionError: assert [('Яндекс', 0...'VK', 0), ...] == []
FAILED tests/test_storage_modules_comprehensive.py::TestPostgresSaver::test_save_vacancies - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestStorageFactory::test_create_invalid_storage - ValueError: Поддерживается только PostgreSQL хранилище, получен: invalid_type
FAILED tests/test_storage_modules_comprehensive.py::TestDatabaseConnection::test_database_connection_establishment - AssertionError: assert <MagicMock name='mock.connect()' id='140091203368144'> == <Mock name='...
FAILED tests/test_storage_modules_comprehensive.py::TestDatabaseConnection::test_database_connection_error_handling - AssertionError: assert <MagicMock name='mock.connect()' id='140091203368144'> is None
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyRepository::test_vacancy_repository_initialization - AssertionError: assert False
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyRepository::test_delete_vacancy - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_storage_modules_comprehensive.py::TestVacancyValidator::test_get_validation_errors - TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_full_storage_workflow - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_storage_error_recovery - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_storage_modules_comprehensive.py::TestStorageIntegration::test_storage_performance_simulation - AttributeError: <module 'src.storage.postgres_saver' from '/home/runner/workspace/tests/../sr...
FAILED tests/test_ui_helpers_comprehensive.py::TestParseSearchQuery::test_parse_search_query_case_insensitive - AssertionError: assert ['python and django'] == ['python', 'django']
FAILED tests/test_ui_helpers_comprehensive.py::TestDisplayVacancyInfo::test_display_vacancy_info - AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.
FAILED tests/test_ui_helpers_comprehensive.py::TestDisplayVacancyInfo::test_display_vacancy_info_without_number - AssertionError: Expected 'display_vacancy_info' to be called once. Called 0 times.
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_main_interface_startup_and_exit - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_main_interface_menu_navigation - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_cache_clearing_option - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestUserInterface::test_db_manager_demo_option - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_ui_interfaces_comprehensive.py::TestSourceSelector::test_get_user_source_choice - AssertionError: assert ({'hh.ru'} is None or False)
FAILED tests/test_ui_interfaces_comprehensive.py::TestUIPerformance::test_pagination_performance - TypeError: Paginator() takes no arguments
FAILED tests/test_ui_navigation_comprehensive.py::TestUINavigation::test_handle_navigation_choice_page_number - OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.
FAILED tests/test_ui_navigation_comprehensive.py::TestQuickPaginate::test_quick_paginate_with_custom_actions - assert False is True
FAILED tests/test_user_interface_complete.py::TestUserInterfaceComplete::test_start_interface - AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7f69856a0f90> ...
FAILED tests/test_user_interface_complete.py::TestUserInterfaceComplete::test_display_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceComponents::test_search_handler - Failed: search handler should not raise exceptions: assert False
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceComponents::test_unified_api_methods - AssertionError: assert False
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_exit - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_search_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_display_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_demo_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestMainApplicationFlow::test_main_application_invalid_choice - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestErrorHandling::test_create_instances_error_handling - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestErrorHandling::test_search_error_handling - Failed: search function should handle API errors: name 'search_and_save_vacancies' is not def...
FAILED tests/test_user_interface_comprehensive.py::TestErrorHandling::test_storage_error_handling - Failed: display function should handle storage errors: name 'display_all_vacancies' is not de...
FAILED tests/test_user_interface_comprehensive.py::TestErrorHandling::test_db_manager_error_handling - Failed: statistics function should handle DB errors: name 'display_database_statistics' is no...
FAILED tests/test_user_interface_comprehensive.py::TestInputValidation::test_empty_search_query_handling - Failed: Should handle empty search query: name 'search_and_save_vacancies' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestInputValidation::test_invalid_salary_input_handling - Failed: Should handle invalid salary input: name 'filter_vacancies_by_salary' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestInputValidation::test_invalid_confirmation_input_handling - Failed: Should handle invalid confirmation input: name 'clear_vacancy_data' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestDataFlow::test_search_to_storage_flow - NameError: name 'search_and_save_vacancies' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestDataFlow::test_storage_to_display_flow - NameError: name 'display_all_vacancies' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestDataFlow::test_filter_data_flow - NameError: name 'filter_vacancies_by_salary' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceIntegration::test_complete_search_and_display_workflow - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_i...
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceIntegration::test_interface_performance_with_large_dataset - NameError: name 'display_all_vacancies' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceIntegration::test_concurrent_operations_handling - NameError: name 'search_and_save_vacancies' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceAccessibility::test_menu_display_formatting - NameError: name 'display_main_menu' is not defined
FAILED tests/test_user_interface_comprehensive.py::TestUserInterfaceAccessibility::test_progress_indication - NameError: name 'search_and_save_vacancies' is not defined
FAILED tests/test_vacancy_modules_comprehensive.py::TestVacancy::test_vacancy_html_cleaning - AssertionError: assert '<p>' not in '<p>Test <b>...HTML</a></p>'
FAILED tests/test_vacancy_modules_comprehensive.py::TestHHParser::test_hh_parser_salary_parsing - AttributeError: 'dict' object has no attribute 'salary'
FAILED tests/test_vacancy_modules_comprehensive.py::TestHHParser::test_hh_parser_employer_parsing - AttributeError: 'dict' object has no attribute 'employer'
FAILED tests/test_vacancy_modules_comprehensive.py::TestHHParser::test_hh_parser_missing_fields - AssertionError: assert False
FAILED tests/test_vacancy_modules_comprehensive.py::TestSuperJobParser::test_sj_parser_parse_single_vacancy - AssertionError: assert False
FAILED tests/test_vacancy_modules_comprehensive.py::TestSuperJobParser::test_sj_parser_salary_parsing - AttributeError: 'dict' object has no attribute 'salary'
FAILED tests/test_vacancy_modules_comprehensive.py::TestSuperJobParser::test_sj_parser_employer_parsing - AttributeError: 'dict' object has no attribute 'employer'
FAILED tests/test_vacancy_modules_comprehensive.py::TestSuperJobParser::test_sj_parser_timestamp_handling - AttributeError: 'dict' object has no attribute 'published_at'
FAILED tests/test_vacancy_modules_comprehensive.py::TestVacancyModelsIntegration::test_full_parsing_workflow_hh - AssertionError: assert False
FAILED tests/test_vacancy_modules_comprehensive.py::TestVacancyModelsIntegration::test_full_parsing_workflow_sj - NameError: name 'SJParser' is not defined
FAILED tests/test_vacancy_modules_comprehensive.py::TestVacancyModelsIntegration::test_cross_format_compatibility - NameError: name 'SJParser' is not defined
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_save_vacancy - AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69...
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_vacancy_by_id'
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_get_all_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'get_all_vacancies'
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_update_vacancy - AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69...
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_find_vacancies_by_criteria - AttributeError: 'VacancyRepository' object has no attribute 'find_vacancies_by_criteria'
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count_vacancies'
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_batch_save_vacancies - AttributeError: <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f69...
FAILED tests/test_vacancy_repository.py::TestVacancyRepository::test_get_vacancies_by_salary_range - AttributeError: 'VacancyRepository' object has no attribute 'get_vacancies_by_salary_range'
FAILED tests/test_vacancy_validator.py::TestVacancyValidator::test_get_validation_errors - TypeError: VacancyValidator.get_validation_errors() takes 1 positional argument but 2 were given
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_main_application_interface_init - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_start_application - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_stop_application - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_initialize_components - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_run_main_loop - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_handle_user_input - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_show_main_menu - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_cleanup_resources - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_api_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_storage_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_main_application_interface.py::TestMainApplicationInterface::test_error_handling - TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'prov...
ERROR tests/test_storage_modules_comprehensive.py::TestVacancyStorageService::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
ERROR tests/test_storage_modules_comprehensive.py::TestVacancyStorageService::test_process_and_save_vacancies - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
ERROR tests/test_storage_modules_comprehensive.py::TestVacancyStorageService::test_apply_filters - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
ERROR tests/test_storage_modules_comprehensive.py::TestVacancyStorageService::test_deduplicate_vacancies - TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delet...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_typed_data_processor_init - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_process_data_dict - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_process_data_list - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_validate_types_valid_data - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_validate_types_invalid_data - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_convert_types_string_to_int - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_convert_types_preserve_existing - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_process_nested_structures - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_handle_none_values - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_process_empty_data - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_type_conversion_safety - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_batch_processing - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_schema_validation - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_typed_data_processor.py::TestTypedDataProcessor::test_error_handling - TypeError: Can't instantiate abstract class TypedDataProcessor with abstract methods process_...
ERROR tests/test_ui_navigation_comprehensive.py::TestQuickPaginate::test_formatter
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_vacancy_display_handler_init - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_list - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancy_details - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_empty_list - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancy_summary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_formatted_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_pagination - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_title - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_company_info - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancy_statistics - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_search_results_header - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_truncate_description - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancy_table - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_select_vacancy_from_list - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_no_results_message - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_sort_vacancies_by_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_filter_options - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_highlight_keywords - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_export_options - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_coordinator_init - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_search_and_display_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_save_selected_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_select_vacancies_for_operation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_filter_vacancies_by_salary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_filter_vacancies_by_company - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_sort_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_delete_vacancies_operation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_export_vacancies_to_file - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_import_vacancies_from_file - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_compare_vacancies - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_analyze_vacancy_trends - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_set_salary_filter - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_display_operation_menu - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_handle_user_operation_choice - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_batch_operation_processing - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_undo_last_operation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_operation_history - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_validate_operation_parameters - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_operation_progress_tracking - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_error_handling_in_operations - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_operations_coordinator_complete.py::TestVacancyOperationsCoordinatorComplete::test_operation_result_validation - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_search_handler_init - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_get_search_query - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_select_search_source - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_execute_search - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_set_salary_filter - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_set_location_filter - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_set_company_filter - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_apply_filters_to_results - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_sort_search_results - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_display_search_results_summary - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_set_results_limit - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_set_search_period - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_validate_search_query - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_save_search_criteria - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_load_saved_search_criteria - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_search_history - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_repeat_last_search - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_export_search_results - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_advanced_search_options - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_complex_search_query - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_search_suggestions - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_search_performance_monitoring - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
ERROR tests/test_vacancy_search_handler_complete.py::TestVacancySearchHandlerComplete::test_search_error_handling - TypeError: Vacancy.__init__() got an unexpected keyword argument 'id'
========================== 124 failed, 858 passed, 94 errors in 19.60s ===========================
~/workspace$ 