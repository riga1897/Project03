src/storage/postgres_saver.py:603: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
____ TestDeduplicationServiceCoverage.test_deduplication_service_initialization ____

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f351910d310>

    def test_deduplication_service_initialization(self):
        """Тест инициализации DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
>       service = DeduplicationService()
                  ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:190: TypeError
_____________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f351913b410>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35180f0590>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
___________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519131c10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35180f2650>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519138690>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35182610d0>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3518260710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35182610d0> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f351913b950>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130ae0d0>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f35130afa50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130ae0d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f351913bcd0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35194c0610>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f35194c1410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35194c0610> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519148090>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35183c3d50>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f35183c31d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35183c3d50> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519148410>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130e91d0>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f35130ea990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130e91d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519148990>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513cf49d0>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3513cf4c90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513cf49d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ________________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519148f90>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3518263710>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3518261f50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3518263710> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f35191495d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f351947a5d0>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3519478450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f351947a5d0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f3519149c10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130c9010>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f35192ee410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35130c9010> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f3518f7f090>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f3513a36450>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3513a107d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f3519006a50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f3513f06690>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3513fa0d50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f3513f06690> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f351900c290>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513ba1610>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3513ba1650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513ba1610> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f351900c650>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513fee250>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3513fee110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f3513fee250> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f3519013150>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='139865941731920'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______ TestVacancyStorageServiceCoverage.test_storage_service_initialization _______

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f3519013f10>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
____________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f35190282d0>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f3513cf5890>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
___________ TestVacancyStorageServiceCoverage.test_search_functionality ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f3519029150>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f351811ca90>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_____________ TestVacancyStorageServiceCoverage.test_delete_operations _____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f3519029790>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f35180ac410>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
__________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f351902a690>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f3513038310>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f351902acd0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f35180f1ad0>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
____________ TestDeduplicationServiceCoverage.test_identify_duplicates _____________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f351902b350>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f35180b0710>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_____________ TestFilteringServiceCoverage.test_filter_by_salary_range _____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f3519030290>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f3513f08cd0>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_keyword ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f35190308d0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f35180b1710>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_company ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f3519030f50>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f35180f1610>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
_______________ TestFilteringServiceCoverage.test_complex_filtering ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f3519031590>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f3513a13390>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
________________ TestVacancyRepositoryCoverage.test_create_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f35190292d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f35183a9110>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_______________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f3519031490>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f3513ef9d50>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
________________ TestVacancyRepositoryCoverage.test_update_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f3519032150>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f35191335d0>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f35191335d0>
vacancy = <Mock id='139866030678800'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='139865939426000'>: 'Mock' object does not support the context manager protocol
_______________ TestVacancyRepositoryCoverage.test_get_all_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f3519032850>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f3513a69590>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f3513a69590>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
________________ TestVacancyRepositoryCoverage.test_count_vacancies ________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f3519032bd0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f35180f23d0>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f3519033d90>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f3513f127d0>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_required_fields ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f351903c450>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f3513c2f6d0>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
______________ TestVacancyValidatorCoverage.test_validate_data_types _______________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f351903ca90>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f35180af290>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________ TestUINavigationExtended.test_paginate_display_custom_actions ___________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f3518d92ad0>
mock_print = <MagicMock name='print' id='139865943312784'>
mock_input = <MagicMock name='input' id='139865942649360'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='139865943326416'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
__________________ TestUnifiedAPI.test_filter_by_target_companies __________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f3518dbe450>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f351813e250>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
___________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources ___________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f3518dbfed0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f35182a8b50>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
______________ TestUnifiedAPIComplete.test_filter_by_target_companies ______________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7f3518dc6c90>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f3513f4a490>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestUserInterfaceConsolidated.test_main_interface_complete ____________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f3518def6d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f3518dee4d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterfaceConsolidated.test_interface_components_integration ________

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f3518df82d0>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
================================== tests coverage ==================================
_________________ coverage: platform linux, python 3.11.13-final-0 _________________

============================= short test summary info ==============================
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_get_vacancies_from_all_sources - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_search_with_filters - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_error_handling_api_failures - AttributeError: 'method' object has no attribute 'side_effect'
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count_success - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_true - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_false - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_initialization - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_empty_list - AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_save_and_load_response - assert None is not None
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_clear_cache_method - AttributeError: 'FileCache' object has no attribute 'clear_cache'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_base_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_request_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_create_database_schema - AttributeError: 'DBManager' object has no attribute 'create_database_schema'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_company_data - AttributeError: 'DBManager' object has no attribute 'save_company'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_vacancy_comprehensive - AttributeError: 'DBManager' object has no attribute 'save_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_bulk_save_operations - AttributeError: 'DBManager' object has no attribute 'save_companies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_query_operations - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_search_functionality - AttributeError: 'DBManager' object has no attribute 'search_by_keyword'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_filter_operations - AttributeError: 'DBManager' object has no attribute 'filter_by_experience'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_aggregation_operations - AttributeError: 'DBManager' object has no attribute 'count_vacancies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_update_operations - AttributeError: 'DBManager' object has no attribute 'update_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_delete_operations - AttributeError: 'DBManager' object has no attribute 'delete_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_transaction_management - AttributeError: 'DBManager' object has no attribute 'begin_transaction'
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_em...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_va...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_k...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_api_methods_coverage - assert False
FAILED tests/test_missing_coverage_extended.py::TestVacancyFormatterCoverage::test_format_salary - TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 ...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_display_handler_display - TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argum...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_search_handler_search - TypeError: VacancySearchHandler.__init__() missing 2 required positional argume...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_operations_coordinator_coordinate - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positiona...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_ke...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_service_initialization - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have th...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f3513f06...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f35...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstract...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_v...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_company'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filt...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_required_f...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCo...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_save_vacancies_single_vacancy - TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_paginator_initialization - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_get_current_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_url - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_title_company - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_find_duplicates - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_statistics - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
============= 102 failed, 1659 passed, 10 skipped, 11 errors in 15.13s =============
~/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1782 items                                                               

tests/test_abstract.py ........                                              [  0%]
tests/test_abstract_db_manager.py ....                                       [  0%]
tests/test_abstract_filter_complete.py .........                             [  1%]
tests/test_api_complete.py ...................                               [  2%]
tests/test_api_config.py ....                                                [  2%]
tests/test_api_data_filter.py ......                                         [  2%]
tests/test_api_fixes.py .......                                              [  3%]
tests/test_api_modules.py ............................                       [  4%]
tests/test_api_modules_consolidated.py ....                                  [  4%]
tests/test_api_modules_coverage.py .FF...F............                       [  6%]
tests/test_app_config.py .........                                           [  6%]
tests/test_base_api.py ...............                                       [  7%]
tests/test_base_formatter.py ..........                                      [  7%]
tests/test_base_formatter_complete.py ..............................         [  9%]
tests/test_base_parser.py ......                                             [  9%]
tests/test_cache.py ......................                                   [ 11%]
tests/test_cached_api.py ....                                                [ 11%]
tests/test_cached_api_complete.py ................                           [ 12%]
tests/test_components_fixed.py ...                                           [ 12%]
tests/test_comprehensive_fixed.py .....                                      [ 12%]
tests/test_comprehensive_missing_coverage.py F...E..FFFFF.F................. [ 14%]
.........                                                                    [ 15%]
tests/test_config_consolidated.py .....                                      [ 15%]
tests/test_config_missing_coverage.py .....sssss.............ss...           [ 16%]
tests/test_config_modules_consolidated.py ......                             [ 17%]
tests/test_config_modules_coverage.py ...................FFF..........       [ 19%]
tests/test_console_interface.py ......                                       [ 19%]
tests/test_console_interface_coverage.py ..................                  [ 20%]
tests/test_core_functionality_consolidated.py .....                          [ 20%]
tests/test_core_modules_comprehensive.py ........                            [ 21%]
tests/test_data_normalizers_comprehensive.py ............................    [ 22%]
tests/test_database_connection.py ........                                   [ 23%]
tests/test_db_config.py .....                                                [ 23%]
tests/test_db_manager.py .................                                   [ 24%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                           [ 25%]
tests/test_decorators.py .......                                             [ 25%]
tests/test_description_parser.py ..........                                  [ 26%]
tests/test_env_loader.py ................                                    [ 27%]
tests/test_filter_utils.py ......                                            [ 27%]
tests/test_formatters_coverage.py ...........................                [ 28%]
tests/test_get_api_complete.py ....................                          [ 30%]
tests/test_hh_api_complete.py .................                              [ 31%]
tests/test_hh_api_config.py .....                                            [ 31%]
tests/test_hh_parser.py ........                                             [ 31%]
tests/test_integration.py .............                                      [ 32%]
tests/test_interfaces.py .ss                                                 [ 32%]
tests/test_interfaces_coverage.py ................................           [ 34%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F......FF  [ 36%]
tests/test_main_application_interface.py ...                                 [ 36%]
tests/test_main_application_interface_complete.py .......................... [ 37%]
.................                                                            [ 38%]
tests/test_main_consolidated.py .........                                    [ 39%]
tests/test_menu_manager.py ..........                                        [ 39%]
tests/test_missing_components.py .........                                   [ 40%]
tests/test_missing_coverage_components.py ..............F..                  [ 41%]
tests/test_missing_coverage_extended.py ...........EEEEEE...........F....... [ 43%]
..............FFF...                                                         [ 44%]
tests/test_models_coverage.py ...........................                    [ 45%]
tests/test_models_fixed.py ...                                               [ 46%]
tests/test_paginator.py ......                                               [ 46%]
tests/test_parsers_complete.py ............                                  [ 47%]
tests/test_parsers_coverage.py .............................                 [ 48%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                     [ 49%]
tests/test_repository_fixed.py ..                                            [ 49%]
tests/test_salary_fixed.py ...........                                       [ 50%]
tests/test_salary_utils.py ......................                            [ 51%]
tests/test_search_utils.py ............................                      [ 53%]
tests/test_search_utils_complete.py ........................................ [ 55%]
......                                                                       [ 55%]
tests/test_services_consolidated.py ....                                     [ 56%]
tests/test_services_coverage.py .......FEEEE................                 [ 57%]
tests/test_services_storage_consolidated.py ..........                       [ 58%]
tests/test_simple_db_adapter.py .........                                    [ 58%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                             [ 59%]
tests/test_sj_api.py ..............                                          [ 60%]
tests/test_sj_api_complete.py .............F....                             [ 61%]
tests/test_sj_api_config.py .....                                            [ 61%]
tests/test_sj_parser.py ........                                             [ 62%]
tests/test_sj_parser_complete.py ..............                              [ 62%]
tests/test_source_manager.py .................                               [ 63%]
tests/test_source_selector.py .................                              [ 64%]
tests/test_storage_abstractions.py ........                                  [ 65%]
tests/test_storage_complete.py .............                                 [ 65%]
tests/test_storage_components_complete.py ......F....FF...............F      [ 67%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF        [ 69%]
tests/test_storage_factory.py ........                                       [ 69%]
tests/test_storage_modules_consolidated.py ....                              [ 69%]
tests/test_target_companies.py .....                                         [ 70%]
tests/test_typed_data_processor.py ................                          [ 70%]
tests/test_ui_components_complete.py ......................................  [ 73%]
tests/test_ui_components_extended.py ..................                      [ 74%]
tests/test_ui_config.py .......................                              [ 75%]
tests/test_ui_helpers_comprehensive.py ..................................... [ 77%]
..                                                                           [ 77%]
tests/test_ui_helpers_extended.py ........................................   [ 79%]
tests/test_ui_modules_consolidated.py .....                                  [ 80%]
tests/test_ui_navigation.py ......................                           [ 81%]
tests/test_ui_navigation_complete.py ..s..                                   [ 81%]
tests/test_ui_navigation_comprehensive.py ......                             [ 81%]
tests/test_ui_navigation_extended.py .......F...........................     [ 83%]
tests/test_unified_api.py ................F...F.                             [ 85%]
tests/test_unified_api_complete.py ......F......................             [ 86%]
tests/test_unified_api_fixed.py ...                                          [ 86%]
tests/test_user_interface.py ...............                                 [ 87%]
tests/test_user_interface_consolidated.py F.F                                [ 87%]
tests/test_user_interface_coverage.py .........                              [ 88%]
tests/test_user_interface_fixed.py ...                                       [ 88%]
tests/test_utils_consolidated.py .....                                       [ 88%]
tests/test_utils_coverage.py .............................                   [ 90%]
tests/test_utils_ui_consolidated.py ......                                   [ 90%]
tests/test_vacancy_abstractions.py .................                         [ 91%]
tests/test_vacancy_display_handler.py ...................                    [ 92%]
tests/test_vacancy_formatter.py ........                                     [ 93%]
tests/test_vacancy_models_complete.py ....                                   [ 93%]
tests/test_vacancy_models_consolidated.py ....                               [ 93%]
tests/test_vacancy_operations.py ......                                      [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................     [ 95%]
tests/test_vacancy_operations_coordinator_complete.py ...................... [ 96%]
                                                                             [ 96%]
tests/test_vacancy_processing_coordinator.py .............                   [ 97%]
tests/test_vacancy_repository.py .........                                   [ 98%]
tests/test_vacancy_stats.py ............                                     [ 98%]
tests/test_vacancy_stats_fixed.py .........                                  [ 99%]
tests/test_vacancy_validator.py ............                                 [100%]

====================================== ERRORS ======================================
__ ERROR at setup of TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f5ab2ea7810>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        from src.vacancies.models import Vacancy, Employer
        from src.utils.salary import Salary
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(from_amount=100000, to_amount=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'

tests/test_comprehensive_missing_coverage.py:164: TypeError
______ ERROR at setup of TestPaginatorCoverage.test_paginator_initialization _______

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29da150>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_get_current_page ___________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29da790>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
______________ ERROR at setup of TestPaginatorCoverage.test_next_page ______________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29dadd0>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_previous_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29db450>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_has_next_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29dba90>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_has_previous_page __________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f5ab29fc110>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_remove_duplicates_by_url _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab294ac10>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_remove_duplicates_by_title_company _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab294b250>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_____ ERROR at setup of TestDeduplicationServiceCoverage.test_find_duplicates ______

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab294b8d0>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
_ ERROR at setup of TestDeduplicationServiceCoverage.test_deduplication_statistics _

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab294bf10>

    @pytest.fixture
    def deduplication_service(self):
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return Mock()
>       return DeduplicationService()
               ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:160: TypeError
===================================== FAILURES =====================================
____________ TestUnifiedAPICoverage.test_get_vacancies_from_all_sources ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f5ab2f87350>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab23fced0>

    def test_get_vacancies_from_all_sources(self, unified_api):
        """Тест получения вакансий из всех источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Настраиваем моки для возврата данных
>       unified_api.hh_api.get_vacancies.return_value = [
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            {'id': '1', 'title': 'Python Dev', 'source': 'hh'},
            {'id': '2', 'title': 'Java Dev', 'source': 'hh'}
        ]
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:57: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestUnifiedAPICoverage.test_search_with_filters __________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f5ab2f87a50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab241f410>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
>       unified_api.hh_api.get_vacancies.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:80: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICoverage.test_error_handling_api_failures ______________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f5ab2f916d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab2413c90>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:156: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success _______

self = <Mock name='mock.execute' id='140027514892304'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7f5ab2ea6150>
mock_connect = <MagicMock name='connect' id='140027514296016'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1a65190>
mock_connection = (<Mock name='connect()' id='140027504261648'>, <Mock id='140027499604752'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_true _______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f5ab2cb0c10>
mock_connect = <MagicMock name='connect' id='140027500749008'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1794750>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_true(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (1,)
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('test123')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1794750>
vacancy = 'test123'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_false ______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f5ab2cb1290>
mock_connect = <MagicMock name='connect' id='140027500460368'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab16c8250>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_false(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - не существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = None
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('nonexistent')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab16c8250>
vacancy = 'nonexistent'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
_________________ TestSimpleDBAdapterCoverage.test_initialization __________________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2cb1b90>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1784e90>

    def test_initialization(self, db_adapter):
        """Тест инициализации SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        assert db_adapter is not None
>       assert hasattr(db_adapter, 'save_vacancies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1784e90>, 'save_vacancies')

tests/test_comprehensive_missing_coverage.py:296: AssertionError
____________ TestSimpleDBAdapterCoverage.test_save_vacancies_empty_list ____________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2cb2250>
mock_run = <MagicMock name='run' id='140027500497232'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab16d0f90>

    @patch('subprocess.run')
    def test_save_vacancies_empty_list(self, mock_run, db_adapter):
        """Тест сохранения пустого списка вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       result = db_adapter.save_vacancies([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'

tests/test_comprehensive_missing_coverage.py:304: AttributeError
__________________ TestCacheCoverage.test_save_and_load_response ___________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7f5ab2cb2bd0>
cache = <src.utils.cache.FileCache object at 0x7f5ab256eed0>

    def test_save_and_load_response(self, cache):
        """Тест сохранения и загрузки ответа"""
        if not CACHE_AVAILABLE:
            return
    
        data = {"items": [{"id": "1", "name": "Test"}], "found": 1}
        params = {"query": "python", "page": 0}
    
        # Сначала сохраняем данные
        cache.save_response("hh", params, data)
    
        # Затем загружаем
        loaded_data = cache.load_response("hh", params)
    
>       assert loaded_data is not None
E       assert None is not None

tests/test_comprehensive_missing_coverage.py:335: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpiuhb3hxm/hh_706f9072b3b7694d22a2ab464b8a25aa.json'
____________________ TestCacheCoverage.test_clear_cache_method _____________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7f5ab2cb3a50>
cache = <src.utils.cache.FileCache object at 0x7f5ab1277ed0>

    def test_clear_cache_method(self, cache):
        """Тест очистки кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем несколько файлов кэша
        cache.save_response("hh", {"query": "test1"}, {"data": 1})
        cache.save_response("hh", {"query": "test2"}, {"data": 2})
    
        # Очищаем кэш
>       cache.clear_cache()
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'clear_cache'

tests/test_comprehensive_missing_coverage.py:357: AttributeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpg_4smw4c/hh_0bb438ddfe366eb2b5cd8d8bf3fba2c3.json'
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpg_4smw4c/hh_b1a5cf751caed3a23aae5e87e985cb3a.json'
_____________________ TestSJAPIConfigCoverage.test_get_api_key _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f5ab2d258d0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
____________________ TestSJAPIConfigCoverage.test_get_base_url _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f5ab2d25f10>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_________________ TestSJAPIConfigCoverage.test_get_request_headers _________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f5ab2d26590>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
________________ TestDBManagerCoverage.test_create_database_schema _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2bc8cd0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab17547d0>
mock_connection = (<Mock id='140027514540240'>, <Mock name='mock.cursor()' id='140027514536528'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
___________________ TestDBManagerCoverage.test_save_company_data ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be03d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1754450>
mock_connection = (<Mock id='140027514547536'>, <Mock name='mock.cursor()' id='140027514544400'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
______________ TestDBManagerCoverage.test_save_vacancy_comprehensive _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be07d0>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab13236d0>
mock_connection = (<Mock id='140027496630800'>, <Mock name='mock.cursor()' id='140027501025168'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
_________________ TestDBManagerCoverage.test_bulk_save_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be0c10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab173f990>
mock_connection = (<Mock id='140027500951440'>, <Mock name='mock.cursor()' id='140027500950544'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
___________________ TestDBManagerCoverage.test_query_operations ____________________

self = <Mock name='mock.cursor().execute' id='140027495992848'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be1050>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1723650>
mock_connection = (<Mock id='140027500834704'>, <Mock name='mock.cursor()' id='140027500830096'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027501240272'>, исправляем...
_________________ TestDBManagerCoverage.test_search_functionality __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be1650>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab23dd9d0>
mock_connection = (<Mock id='140027514177360'>, <Mock name='mock.cursor()' id='140027514183120'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
___________________ TestDBManagerCoverage.test_filter_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be1d50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab241de90>
mock_connection = (<Mock id='140027514441552'>, <Mock name='mock.cursor()' id='140027514446672'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
________________ TestDBManagerCoverage.test_aggregation_operations _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be2410>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1717850>
mock_connection = (<Mock id='140027500784208'>, <Mock name='mock.cursor()' id='140027500787088'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
___________________ TestDBManagerCoverage.test_update_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be2b10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab23dff90>
mock_connection = (<Mock id='140027514178000'>, <Mock name='mock.cursor()' id='140027514186256'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
___________________ TestDBManagerCoverage.test_delete_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be3210>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1505710>
mock_connection = (<Mock id='140027498616400'>, <Mock name='mock.cursor()' id='140027498616272'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
________________ TestDBManagerCoverage.test_transaction_management _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f5ab2be3910>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab23fac90>
mock_connection = (<Mock id='140027514300752'>, <Mock name='mock.cursor()' id='140027514303248'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
____________ TestDBManagerFixed.test_get_companies_and_vacancies_count _____________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b19390>
mock_connect = <MagicMock name='connect' id='140027499941328'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab16482d0>
mock_connection = (<Mock name='connect()' id='140027499939088'>, <Mock id='140027499939216'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
____________________ TestDBManagerFixed.test_get_all_vacancies _____________________

self = <Mock name='mock.execute' id='140027500016272'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b19950>
mock_connect = <MagicMock name='connect' id='140027504246864'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1648450>
mock_connection = (<Mock name='connect()' id='140027514234448'>, <Mock id='140027504897168'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027499832080'>, исправляем...
______________________ TestDBManagerFixed.test_get_avg_salary ______________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b19f10>
mock_connect = <MagicMock name='connect' id='140027523705744'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab2ea7950>
mock_connection = (<Mock name='connect()' id='140027502718736'>, <Mock id='140027502708944'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027499462416'>, исправляем...
_____________ TestDBManagerFixed.test_get_vacancies_with_higher_salary _____________

self = <Mock name='mock.execute' id='140027495929296'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b1a510>
mock_connect = <MagicMock name='connect' id='140027504993744'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1b18e90>
mock_connection = (<Mock name='connect()' id='140027504990160'>, <Mock id='140027504987344'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027499553424'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027501306192'>, исправляем...
________________ TestDBManagerFixed.test_get_vacancies_with_keyword ________________

self = <Mock name='mock.execute' id='140027514642832'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b1aad0>
mock_connect = <MagicMock name='connect' id='140027504992912'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1613d10>
mock_connection = (<Mock name='connect()' id='140027499722256'>, <Mock id='140027499716048'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027501246224'>, исправляем...
____________________ TestDBManagerFixed.test_get_database_stats ____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f5ab2b1b090>
mock_connect = <MagicMock name='connect' id='140027501033168'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f5ab1753d10>
mock_connection = (<Mock name='connect()' id='140027501033616'>, <Mock id='140027501031056'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027504895312'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_______ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects _______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f5ab2b1b990>
mock_connect = <MagicMock name='connect' id='140027499528464'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab16a7050>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f5ab16db040>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab16a7050>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f5ab16db040>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________________ TestPostgresSaverFixed.test_delete_vacancy_by_id _________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f5ab2b28550>
mock_connect = <MagicMock name='connect' id='140027485477840'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab12e8910>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab12e8910>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count __________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f5ab2b29490>
mock_connect = <MagicMock name='connect' id='140027504859280'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab244f550>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
_________________ TestSimpleDBAdapterFixed.test_get_all_vacancies __________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f5ab2b29ad0>
mock_connect = <MagicMock name='connect' id='140027504856016'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1af9150>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
_____________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword _____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f5ab2b2a150>
mock_connect = <MagicMock name='connect' id='140027500459792'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab16c4b90>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
________________ TestSimpleDBAdapterFixed.test_init_database_schema ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f5ab2b2a890>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab15e6b50>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab15e7190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab15e6b50> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIModulesFixed.test_hh_api_methods_coverage _________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f5ab2b2c050>
mock_get = <MagicMock name='get' id='140027501303760'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
_____________ TestAPIModulesFixed.test_cached_api_basic_functionality ______________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f5ab2b2c8d0>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
_____________________ TestEdgeCasesFixed.test_db_empty_results _____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f5ab2b2f950>
mock_connect = <MagicMock name='connect' id='140027499916176'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027498244560'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140027495975056'>, исправляем...
________________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f5ab2b2ff50>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
_______________ TestLowCoverageComponents.test_api_methods_coverage ________________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7f5ab29ccb50>
mock_get = <MagicMock name='get' id='140027501254864'>

    @patch('requests.get')
    def test_api_methods_coverage(self, mock_get):
        """Тест покрытия методов API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
            from src.api_modules.sj_api import SuperJobAPI
    
            # Тестируем HeadHunter API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
                assert isinstance(result, (dict, list))
    
            # Тестируем SuperJob API
            sj_api = SuperJobAPI()
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:374: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestVacancyFormatterCoverage.test_format_salary __________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7f5ab29fc7d0>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7f5ab1660fd0>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:537: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_display_handler_display ___________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f5ab2a0e510>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:824: TypeError
___________ TestUIInterfacesCoverage.test_vacancy_search_handler_search ____________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f5ab2a0d590>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:835: TypeError
_____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ______

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f5ab2a0ca90>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____________ TestPostgresSaverCoverage.test_database_connection_methods ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a6fc90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab23ebc10>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
_______________ TestPostgresSaverCoverage.test_create_tables_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a78710>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1753ad0>
mock_connection = (<Mock id='140027501029008'>, <Mock name='mock.cursor()' id='140027501021968'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
________________ TestPostgresSaverCoverage.test_save_vacancy_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a79610>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab124e410>
mock_connection = (<Mock id='140027495760720'>, <Mock name='mock.cursor()' id='140027495772240'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
______________ TestPostgresSaverCoverage.test_save_multiple_vacancies ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a799d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab169cf10>
mock_connection = (<Mock id='140027495773072'>, <Mock name='mock.cursor()' id='140027495768144'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140027514541072'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140027514541072'> = <Mock name='mock.cursor()' id='140027495768144'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
_______________ TestPostgresSaverCoverage.test_get_vacancies_method ________________

self = <Mock name='mock.cursor().execute' id='140027505003088'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a79d90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab2436550>
mock_connection = (<Mock id='140027500473936'>, <Mock name='mock.cursor()' id='140027500462992'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
____________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a7a150>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab16a5c90>
mock_connection = (<Mock id='140027500320848'>, <Mock name='mock.cursor()' id='140027500319184'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
______________ TestPostgresSaverCoverage.test_filter_by_salary_range _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a7a650>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab24a20d0>
mock_connection = (<Mock id='140027514992080'>, <Mock name='mock.cursor()' id='140027499716432'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
_______________ TestPostgresSaverCoverage.test_get_companies_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a7acd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1257210>
mock_connection = (<Mock id='140027495795088'>, <Mock name='mock.cursor()' id='140027495806288'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_______________ TestPostgresSaverCoverage.test_delete_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a7b310>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab14b7910>
mock_connection = (<Mock id='140027514395344'>, <Mock name='mock.cursor()' id='140027514392080'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab14b7910>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
__________________ TestPostgresSaverCoverage.test_clear_all_data ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a7b9d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1910910>
mock_connection = (<Mock id='140027502855312'>, <Mock name='mock.cursor()' id='140027502869648'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_______________ TestPostgresSaverCoverage.test_get_statistics_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a80110>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1750190>
mock_connection = (<Mock id='140027501029712'>, <Mock name='mock.cursor()' id='140027501034960'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
__________________ TestPostgresSaverCoverage.test_export_to_json ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a80810>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab256fa10>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
_________________ TestPostgresSaverCoverage.test_import_from_json __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a80e90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab128e1d0>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
_______________ TestPostgresSaverCoverage.test_transaction_rollback ________________

self = <Mock name='mock.rollback' id='140027504517520'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a81b90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1afbf10>
mock_connection = (<Mock id='140027504452688'>, <Mock name='mock.cursor()' id='140027504449808'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
_________________ TestPostgresSaverCoverage.test_batch_operations __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f5ab2a82210>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1788f50>
mock_connection = (<Mock id='140027501264720'>, <Mock name='mock.cursor()' id='140027501251856'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab1788f50>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
____ TestDeduplicationServiceCoverage.test_deduplication_service_initialization ____

self = <tests.test_services_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab294a5d0>

    def test_deduplication_service_initialization(self):
        """Тест инициализации DeduplicationService"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
>       service = DeduplicationService()
                  ^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: DeduplicationService.__init__() missing 1 required positional argument: 'strategy'

tests/test_services_coverage.py:190: TypeError
_____________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2982e10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1a740d0>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
___________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2983190>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab17579d0>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab29837d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1a75f50>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab16d1cd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1a75f50> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2983e10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab14d4150>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab14d6a50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab14d4150> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2988490>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab2492ad0>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab16d3250>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab2492ad0> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2988ad0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab23d8a90>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab23d9b50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab23d8a90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2989110>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab2460210>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab15d3d90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab2460210> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2989750>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1693890>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab1692dd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1693890> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ________________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab2989d50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1aa7650>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab1aa6850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1aa7650> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab298a390>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1330fd0>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab13322d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab1330fd0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f5ab298a9d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab24a2d10>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab29d9910>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab24a2d10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f5ab27bae10>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f5ab14a4c90>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab1612090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f5ab2847090>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab09f0490>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab17ec5d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab09f0490> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f5ab2849410>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab08b9f50>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab08b9010>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab08b9f50> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f5ab2849a90>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab09a1e90>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab09a3f50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5ab09a1e90> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f5ab2856650>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='140027502700624'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______ TestVacancyStorageServiceCoverage.test_storage_service_initialization _______

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f5ab2868ed0>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
____________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f5ab2869510>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f5ab2492250>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
___________ TestVacancyStorageServiceCoverage.test_search_functionality ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f5ab286a810>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f5ab1aea850>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_____________ TestVacancyStorageServiceCoverage.test_delete_operations _____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f5ab286ae50>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f5ab1692290>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
__________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab2869910>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f5ab1644390>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab286b550>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f5ab2493490>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
____________ TestDeduplicationServiceCoverage.test_identify_duplicates _____________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f5ab286b910>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f5ab1841a50>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_____________ TestFilteringServiceCoverage.test_filter_by_salary_range _____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f5ab2878250>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f5ab1a918d0>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_keyword ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f5ab2878710>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f5ab14ea6d0>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_company ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f5ab2878d90>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f5ab23eb350>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
_______________ TestFilteringServiceCoverage.test_complex_filtering ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f5ab28793d0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f5ab18f4d10>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
________________ TestVacancyRepositoryCoverage.test_create_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f5ab287a290>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab1320d50>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_______________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f5ab287a8d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab08dc050>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
________________ TestVacancyRepositoryCoverage.test_update_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f5ab287af50>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab18760d0>

    def test_update_vacancy(self, repository):
        """Тест обновления вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        update_data = {
            'title': 'Senior Software Developer',
            'salary_from': 150000
        }
    
        # Используем реальные методы класса
        if hasattr(repository, 'add_vacancy'):
            mock_vacancy = Mock()
>           repository.add_vacancy(mock_vacancy)

tests/test_storage_components_coverage.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab18760d0>
vacancy = <Mock id='140027502225552'>

    def add_vacancy(self, vacancy: AbstractVacancy) -> None:
        """
        Добавляет вакансию в хранилище
    
        Args:
            vacancy: Объект вакансии для добавления
    
        Raises:
            ValueError: Если вакансия не прошла валидацию
            ConnectionError: При ошибках подключения к БД
        """
        # Валидация перед сохранением
        if not self._validator.validate_vacancy(vacancy):
            errors = self._validator.get_validation_errors()
            raise ValueError(f"Вакансия не прошла валидацию: {', '.join(errors)}")
    
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:54: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:97 Ошибка добавления вакансии <Mock name='mock.vacancy_id' id='140027502218192'>: 'Mock' object does not support the context manager protocol
_______________ TestVacancyRepositoryCoverage.test_get_all_vacancies _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f5ab287bbd0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab146b9d0>

    def test_get_all_vacancies(self, repository):
        """Тест получения всех вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        # Используем реальные методы класса
        if hasattr(repository, 'get_vacancies'):
>           vacancies = repository.get_vacancies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_coverage.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab146b9d0>
filters = None

    def get_vacancies(self, filters: Optional[Dict[str, Any]] = None) -> List[AbstractVacancy]:
        """
        Возвращает список вакансий из хранилища с учетом фильтров
    
        Args:
            filters: Словарь с критериями фильтрации
    
        Returns:
            List[AbstractVacancy]: Список вакансий
        """
        try:
>           with self._db_connection.get_connection() as conn:
E           TypeError: 'Mock' object does not support the context manager protocol

src/storage/components/vacancy_repository.py:111: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.components.vacancy_repository:vacancy_repository.py:155 Ошибка получения вакансий: 'Mock' object does not support the context manager protocol
________________ TestVacancyRepositoryCoverage.test_count_vacancies ________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f5ab2880250>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f5ab14eb550>

    def test_count_vacancies(self, repository):
        """Тест подсчета вакансий"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       count = repository.count()
                ^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'count'

tests/test_storage_components_coverage.py:365: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_invalid_vacancy ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f5ab28817d0>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f5ab1874750>

    def test_validate_invalid_vacancy(self, validator):
        """Тест валидации некорректной вакансии"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        invalid_vacancy = {
            'id': '',  # Пустой ID
            'title': None,  # Отсутствует название
            'salary_from': 'invalid',  # Некорректная зарплата
            'url': 'not-a-url'  # Некорректный URL
        }
    
>       result = validator.validate(invalid_vacancy)
                 ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate'

tests/test_storage_components_coverage.py:420: AttributeError
____________ TestVacancyValidatorCoverage.test_validate_required_fields ____________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f5ab2881e50>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f5ab18a91d0>

    def test_validate_required_fields(self, validator):
        """Тест валидации обязательных полей"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_missing_fields = {
            'description': 'Some description'
            # Отсутствуют id и title
        }
    
>       result = validator.validate_required_fields(vacancy_missing_fields)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_required_fields'

tests/test_storage_components_coverage.py:433: AttributeError
______________ TestVacancyValidatorCoverage.test_validate_data_types _______________

self = <tests.test_storage_components_coverage.TestVacancyValidatorCoverage object at 0x7f5ab2882490>
validator = <src.storage.components.vacancy_validator.VacancyValidator object at 0x7f5ab1640f90>

    def test_validate_data_types(self, validator):
        """Тест валидации типов данных"""
        if not VACANCY_VALIDATOR_AVAILABLE:
            return
    
        vacancy_wrong_types = {
            'id': 123,  # Должно быть строкой
            'title': ['Python', 'Developer'],  # Должно быть строкой
            'salary_from': '100000',  # Может быть числом
            'published_at': 'not-a-date'  # Должна быть дата
        }
    
>       result = validator.validate_data_types(vacancy_wrong_types)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'

tests/test_storage_components_coverage.py:448: AttributeError
__________ TestUINavigationExtended.test_paginate_display_custom_actions ___________

self = <tests.test_ui_navigation_extended.TestUINavigationExtended object at 0x7f5ab25cf1d0>
mock_print = <MagicMock name='print' id='140027486877584'>
mock_input = <MagicMock name='input' id='140027486877648'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_paginate_display_custom_actions(self, mock_print, mock_input):
        """Тестирование кастомных действий"""
        mock_action = Mock()
        mock_action.__doc__ = "Кастомное действие"
    
        custom_actions = {"c": mock_action}
        mock_input.side_effect = ["c", "q"]
    
        def formatter(item, number):
            return f"{number}: {item}"
    
        self.navigator.paginate_display(
            self.test_items[:5],
            formatter,
            "Custom Actions",
            custom_actions=custom_actions
        )
    
        # Проверяем что действие было вызвано (может быть вызвано с аргументами или без)
>       assert mock_action.called, "Custom action should have been called"
E       AssertionError: Custom action should have been called
E       assert False
E        +  where False = <Mock id='140027486873104'>.called

tests/test_ui_navigation_extended.py:137: AssertionError
__________________ TestUnifiedAPI.test_filter_by_target_companies __________________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f5ab25fac50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab0906e90>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        # Мокаем TargetCompanies
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["company1", "company2"]
            mock_target_companies.get_sj_ids.return_value = ["company3"]
    
            # Тестовые вакансии
            test_vacancies = [
                {"id": "1", "employer": {"id": "company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "company3"}, "source": "sj"},
                {"id": "4", "employer": {"id": "unknown"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться только вакансии от целевых компаний
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:282: AssertionError
___________ TestUnifiedAPI.test_filter_by_target_companies_mixed_sources ___________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f5ab25fb750>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab1863c50>

    def test_filter_by_target_companies_mixed_sources(self, unified_api):
        """Тест фильтрации вакансий из разных источников"""
        with patch('src.config.target_companies.TargetCompanies') as mock_target_companies:
            mock_target_companies.get_hh_ids.return_value = ["hh_company1", "hh_company2"]
            mock_target_companies.get_sj_ids.return_value = ["sj_company1"]
    
            # Вакансии из разных источников
            test_vacancies = [
                {"id": "1", "employer": {"id": "hh_company1"}, "source": "hh"},
                {"id": "2", "employer": {"id": "hh_company2"}, "source": "hh"},
                {"id": "3", "employer": {"id": "sj_company1"}, "source": "sj"},
                {"id": "4", "employer": {"id": "other_company"}, "source": "hh"},
            ]
    
            result = unified_api._filter_by_target_companies(test_vacancies)
    
            # Должны остаться вакансии от целевых компаний обоих источников
>           assert len(result) == 3
E           assert 0 == 3
E            +  where 0 = len([])

tests/test_unified_api.py:348: AssertionError
______________ TestUnifiedAPIComplete.test_filter_by_target_companies ______________

self = <tests.test_unified_api_complete.TestUnifiedAPIComplete object at 0x7f5ab2606e50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f5ab1875dd0>

    def test_filter_by_target_companies(self, unified_api):
        """Тест фильтрации по целевым компаниям"""
        mock_vacancies = [
            {
                "id": "1",
                "employer": {"id": "123"},
                "source": "hh"
            },
            {
                "id": "2",
                "employer": {"id": "999"},  # не в целевых
                "source": "hh"
            },
            {
                "id": "3",
                "id_client": "456",  # SJ формат
                "source": "sj"
            }
        ]
    
        mock_companies = [
            Mock(hh_id=123, sj_id=None),
            Mock(hh_id=None, sj_id=456)
        ]
    
>       with patch('src.api_modules.unified_api.TargetCompanies.get_all_companies', return_value=mock_companies):

tests/test_unified_api_complete.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api_modules.unified_api.TargetCompanies'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCompanies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestUserInterfaceConsolidated.test_main_interface_complete ____________

args = (<tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f5ab26349d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f5ab2627990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterfaceConsolidated.test_interface_components_integration ________

self = <tests.test_user_interface_consolidated.TestUserInterfaceConsolidated object at 0x7f5ab2635590>

    def test_interface_components_integration(self):
        """Тестирование интеграции компонентов интерфейса"""
        try:
            from src.interfaces.main_application_interface import MainApplicationInterface
    
            # Создаем конкретную реализацию абстрактного класса
            class ConcreteMainApplication(MainApplicationInterface):
                def run_application(self):
                    pass
    
>           interface = ConcreteMainApplication()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_user_interface_consolidated.py:96: TypeError
================================== tests coverage ==================================
_________________ coverage: platform linux, python 3.11.13-final-0 _________________

Name                                                     Stmts   Miss  Cover   Missing
--------------------------------------------------------------------------------------
src/__init__.py                                              0      0   100%
src/api_modules/__init__.py                                  0      0   100%
src/api_modules/base_api.py                                 23      0   100%
src/api_modules/cached_api.py                              168     47    72%   114-115, 144-147, 157, 159, 166-168, 183, 186-187, 203, 215-238, 247, 267-269, 289, 298-299, 308-310, 335-336, 340-342
src/api_modules/get_api.py                                  53     19    64%   46-54, 64, 73-74, 102-103, 116-118, 124, 126-132, 134, 136
src/api_modules/hh_api.py                                  142     25    82%   77-85, 169, 178-180, 219-221, 233, 256, 276, 289, 293-295, 329-331
src/api_modules/sj_api.py                                  128     28    78%   99-106, 206-210, 222, 263-264, 277-279, 291-292, 296-308
src/api_modules/unified_api.py                             270     77    71%   124, 133, 154-155, 175-176, 212-213, 221-240, 245, 291-293, 304-306, 316-322, 390-391, 401-418, 422-432, 436-458
src/config/__init__.py                                       0      0   100%
src/config/api_config.py                                    13      0   100%
src/config/app_config.py                                    17      0   100%
src/config/db_config.py                                     61     25    59%   24, 44-48, 85-88, 96-99, 104, 133-136, 156-172
src/config/hh_api_config.py                                 21      2    90%   31, 37
src/config/sj_api_config.py                                 49     18    63%   39, 59, 62, 68-75, 79-87
src/config/target_companies.py                              61     25    59%   119, 124-130, 135-138, 143-146, 151, 156-162, 167, 185, 190
src/config/ui_config.py                                     27      0   100%
src/interfaces/__init__.py                                   0      0   100%
src/interfaces/main_application_interface.py               121     88    27%   76, 89-98, 109-136, 140-152, 156-161, 166-180, 184-214, 224-225, 230, 234-236
src/storage/__init__.py                                      6      0   100%
src/storage/abstract.py                                     14      0   100%
src/storage/abstract_db_manager.py                          21      6    71%   16, 26, 36, 46, 59, 69
src/storage/components/__init__.py                           0      0   100%
src/storage/components/database_connection.py               53     11    79%   14-16, 19-20, 77-78, 88-89, 97-98
src/storage/components/vacancy_repository.py               113     61    46%   50-51, 119-134, 146-150, 174-178, 190-209, 221-291
src/storage/components/vacancy_validator.py                 65     22    66%   62, 65, 73-74, 78-79, 92, 99, 110, 115, 120, 138-152
src/storage/db_manager.py                                  348    188    46%   17-24, 63, 83-139, 223-228, 246-247, 262-272, 282-338, 348-361, 376-405, 419-451, 519-522, 525-528, 533-535, 574-576, 593-594, 646-651, 665, 715-718, 723-728, 818-820, 832, 844-845, 857-859, 871-877, 892-1022
src/storage/interfaces/typed_data_processor.py              46     25    46%   32, 45, 64, 78, 94, 100, 106-117, 124, 130-133, 139-148
src/storage/postgres_saver.py                              790    521    34%   10-13, 72-74, 109-111, 124-125, 133-140, 145-146, 148-151, 176-183, 188-194, 199-200, 202-205, 263-265, 280-281, 295-305, 310-317, 322-323, 325-328, 338, 342-343, 374-380, 399-400, 404-409, 417-419, 442-445, 452, 455-458, 473, 480, 487, 594-598, 604-606, 628-634, 655, 662-664, 678, 690-692, 705, 721-779, 783-895, 918-958, 961, 974-992, 1010-1016, 1024-1048, 1067-1098, 1106, 1108-1109, 1125-1180, 1184-1196, 1208-1251, 1264-1303, 1323-1574, 1587-1601, 1611, 1614, 1617-1635
src/storage/services/__init__.py                             4      0   100%
src/storage/services/abstract_filter_service.py             30      7    77%   34, 44, 64, 88, 101, 114, 127
src/storage/services/abstract_storage_service.py            25      6    76%   34, 47, 60, 73, 83, 93
src/storage/services/company_id_filter_service.py           94     62    34%   49, 62, 68-76, 85-135, 141-202, 206-214, 223
src/storage/services/deduplication_service.py               64     43    33%   15-16, 20-21, 43, 56-129, 133-142, 146-154, 183, 192
src/storage/services/filtering_service.py                  105     66    37%   15-16, 20-21, 25-26, 48, 76-88, 95-132, 143-155, 159-170, 189-199, 228, 237
src/storage/services/sql_deduplication_service.py           64     49    23%   44-64, 68-111, 116-148, 152-160, 173-182
src/storage/services/sql_filter_service.py                  89     63    29%   47, 59-78, 82-146, 152-191, 195-202, 207-209, 218-247
src/storage/services/vacancy_processing_coordinator.py      44      0   100%
src/storage/services/vacancy_storage_service.py            334    239    28%   15-16, 20-21, 25-26, 31-32, 37-38, 42-43, 47-48, 52-53, 57-58, 93-94, 119-146, 150-170, 176-194, 211-215, 226-238, 244-320, 334, 338-339, 360-362, 366-395, 417-469, 499, 511-535, 539-590, 594-601, 606, 610, 614, 618
src/storage/simple_db_adapter.py                           142    109    23%   21, 25, 29, 42-43, 54, 57, 61-101, 105-117, 121, 125-165, 169-202, 206-210, 219
src/storage/storage_factory.py                              13      0   100%
src/ui_interfaces/__init__.py                                0      0   100%
src/ui_interfaces/console_interface.py                     394    306    22%   23-25, 69, 82, 84, 86, 88, 90, 92, 94, 97, 100, 102-110, 116-127, 157, 161, 165, 169, 173-224, 228-301, 305, 309, 319-355, 359, 370-371, 382-385, 395-544, 548-579, 584-604
src/ui_interfaces/source_selector.py                        44     30    32%   25-51, 64, 74-79
src/ui_interfaces/vacancy_display_handler.py                72     58    19%   32-70, 74-107, 111-141
src/ui_interfaces/vacancy_operations_coordinator.py        194    105    46%   68-79, 100, 102, 104, 108, 116-122, 126-165, 169-192, 196-198, 211, 248-273, 302-322
src/ui_interfaces/vacancy_search_handler.py                152    127    16%   38-76, 90-114, 124, 135-170, 180-197, 209-232, 248-262, 272-308
src/user_interface.py                                       55     47    15%   26-94, 98
src/utils/__init__.py                                        0      0   100%
src/utils/abstract_filter.py                                26     14    46%   30, 47, 61, 75, 88-102
src/utils/api_data_filter.py                               154     88    43%   9-10, 25, 55-56, 71-83, 97, 105-106, 122, 130-131, 148-160, 173-185, 191-196, 206, 212, 215, 217, 223-241, 245, 256, 269, 275-284, 288-307
src/utils/base_formatter.py                                 38     11    71%   14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64
src/utils/cache.py                                         135     42    69%   45-46, 78, 93-94, 98-100, 115-117, 124-126, 130-139, 165, 169-170, 174-176, 205-210, 221-224, 227, 236-238, 244
src/utils/data_normalizers.py                               75     13    83%   77-80, 107, 113-121, 154-162
src/utils/db_manager_demo.py                               236    218     8%   32, 38-64, 73-81, 85-103, 107-155, 159-211, 215-224, 228-272, 276-315, 319-370, 377-382, 386
src/utils/decorators.py                                     73     42    42%   31-39, 44-46, 61, 77-91, 97-106, 112-121
src/utils/description_parser.py                             70     44    37%   41-64, 78, 88-90, 96-101, 116-135, 141-177
src/utils/env_loader.py                                     59     34    42%   32-33, 41-76, 104-111
src/utils/file_handlers.py                                  38      9    76%   46-48, 69-73, 76
src/utils/menu_manager.py                                   49      8    84%   38, 52-56, 77, 93
src/utils/paginator.py                                      28      9    68%   43-44, 51-52, 57-61
src/utils/salary.py                                        113     18    84%   35-36, 55-61, 71-72, 78, 94, 152, 157, 164, 181, 207
src/utils/search_utils.py                                  156      6    96%   204, 215, 219, 223, 227, 282
src/utils/source_manager.py                                 60     37    38%   77-80, 92-95, 108-119, 131-134, 146, 158-161, 173-176, 188-191, 198-200
src/utils/ui_helpers.py                                    161      4    98%   135, 225-226, 325
src/utils/ui_navigation.py                                  99      0   100%
src/utils/vacancy_formatter.py                             167     59    65%   122, 129, 148, 154, 159-164, 170-171, 176, 182, 188-201, 206, 213, 218, 225, 229-231, 235-241, 246, 259-262, 273-304
src/utils/vacancy_operations.py                            165     99    40%   43, 64, 75-87, 111, 122-134, 159, 170-182, 220-244, 248-261, 264-265, 268-269, 290-310, 320-339, 346-370
src/utils/vacancy_stats.py                                  86     53    38%   57-60, 83-91, 95-100, 110-158, 163-165
src/vacancies/__init__.py                                    0      0   100%
src/vacancies/abstract.py                                   10      0   100%
src/vacancies/abstract_models.py                            99     28    72%   18, 23, 28, 33, 38, 44, 53, 58, 63, 69, 75, 84, 89, 94, 100, 106, 115, 120, 125, 130, 135, 140, 146, 155, 160, 165, 171, 177
src/vacancies/models.py                                    390    150    62%   40, 44, 64, 77, 81, 89, 91, 93, 99, 102, 106, 122, 126, 131-133, 141, 144, 149, 153, 169, 173, 178-180, 188, 191, 196, 200, 299, 317, 329-332, 344, 348, 352, 358, 370, 374, 378, 384, 404-438, 443-451, 458, 476, 483, 491-499, 502-510, 514-521, 544-550, 554-564, 568, 598, 600-605, 612, 614, 616, 618, 620, 649-651, 670, 686, 701-706, 720, 725-727, 731-733, 737-739, 743-745, 749
src/vacancies/parsers/__init__.py                           55     11    80%   16, 21, 26, 31, 36, 88, 97, 106, 111, 116, 121
src/vacancies/parsers/base_parser.py                         9      2    78%   19, 32
src/vacancies/parsers/hh_parser.py                          55     10    82%   21, 32-33, 55-57, 96-98, 119
src/vacancies/parsers/sj_parser.py                          57     28    51%   24-43, 57-65, 107, 121-122, 145-147
--------------------------------------------------------------------------------------
TOTAL                                                     7192   3542    51%
============================= short test summary info ==============================
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_get_vacancies_from_all_sources - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_search_with_filters - AttributeError: 'method' object has no attribute 'return_value'
FAILED tests/test_api_modules_coverage.py::TestUnifiedAPICoverage::test_error_handling_api_failures - AttributeError: 'method' object has no attribute 'side_effect'
FAILED tests/test_comprehensive_missing_coverage.py::TestDBManagerCoverage::test_get_companies_and_vacancies_count_success - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_true - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_is_vacancy_exists_false - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_initialization - AssertionError: assert False
FAILED tests/test_comprehensive_missing_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_empty_list - AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_save_and_load_response - assert None is not None
FAILED tests/test_comprehensive_missing_coverage.py::TestCacheCoverage::test_clear_cache_method - AttributeError: 'FileCache' object has no attribute 'clear_cache'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_api_key - AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_base_url - AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'
FAILED tests/test_config_modules_coverage.py::TestSJAPIConfigCoverage::test_get_request_headers - AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_create_database_schema - AttributeError: 'DBManager' object has no attribute 'create_database_schema'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_company_data - AttributeError: 'DBManager' object has no attribute 'save_company'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_save_vacancy_comprehensive - AttributeError: 'DBManager' object has no attribute 'save_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_bulk_save_operations - AttributeError: 'DBManager' object has no attribute 'save_companies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_query_operations - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_search_functionality - AttributeError: 'DBManager' object has no attribute 'search_by_keyword'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_filter_operations - AttributeError: 'DBManager' object has no attribute 'filter_by_experience'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_aggregation_operations - AttributeError: 'DBManager' object has no attribute 'count_vacancies'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_update_operations - AttributeError: 'DBManager' object has no attribute 'update_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_delete_operations - AttributeError: 'DBManager' object has no attribute 'delete_vacancy'
FAILED tests/test_db_manager_coverage.py::TestDBManagerCoverage::test_transaction_management - AttributeError: 'DBManager' object has no attribute 'begin_transaction'
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_companies_and_vacancies_count - AssertionError: assert 12 == 3
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_all_vacancies - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_avg_salary - assert 1.0 == 125000.0
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_higher_salary - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_vacancies_with_keyword - AssertionError: Expected 'execute' to have been called once. Called 0 times.
FAILED tests/test_low_coverage_components_fixed.py::TestDBManagerFixed::test_get_database_stats - AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_em...
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_save_vacancies_with_real_vacancy_objects - TypeError: 'Mock' object is not iterable
FAILED tests/test_low_coverage_components_fixed.py::TestPostgresSaverFixed::test_delete_vacancy_by_id - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_companies_and_vacancies_count - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_va...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_all_vacancies - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_get_vacancies_with_keyword - AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_k...
FAILED tests/test_low_coverage_components_fixed.py::TestSimpleDBAdapterFixed::test_init_database_schema - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_hh_api_methods_coverage - assert False
FAILED tests/test_low_coverage_components_fixed.py::TestAPIModulesFixed::test_cached_api_basic_functionality - TypeError: Can't instantiate abstract class CachedAPI with abstract methods _ge...
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_db_empty_results - assert 1.0 is None
FAILED tests/test_low_coverage_components_fixed.py::TestEdgeCasesFixed::test_postgres_saver_edge_cases - assert False
FAILED tests/test_missing_coverage_components.py::TestLowCoverageComponents::test_api_methods_coverage - assert False
FAILED tests/test_missing_coverage_extended.py::TestVacancyFormatterCoverage::test_format_salary - TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 ...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_display_handler_display - TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argum...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_search_handler_search - TypeError: VacancySearchHandler.__init__() missing 2 required positional argume...
FAILED tests/test_missing_coverage_extended.py::TestUIInterfacesCoverage::test_vacancy_operations_coordinator_coordinate - TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positiona...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_database_connection_methods - AttributeError: 'PostgresSaver' object has no attribute 'connect'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_create_tables_method - AttributeError: 'PostgresSaver' object has no attribute 'create_tables'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_vacancy_method - AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_save_multiple_vacancies - AssertionError: assert 0 >= 3
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_vacancies_method - AssertionError: Expected 'execute' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_search_vacancies_by_keyword - AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_ke...
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_filter_by_salary_range - AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_companies_method - AttributeError: 'PostgresSaver' object has no attribute 'get_companies'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_delete_vacancy_method - AttributeError: 'str' object has no attribute 'vacancy_id'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_clear_all_data - AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_get_statistics_method - AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_export_to_json - AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_import_from_json - AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_transaction_rollback - AssertionError: Expected 'rollback' to have been called.
FAILED tests/test_postgres_saver_coverage.py::TestPostgresSaverCoverage::test_batch_operations - TypeError: '>' not supported between instances of 'MagicMock' and 'int'
FAILED tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_service_initialization - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_connect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_disconnect_method_coverage - AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_execute_query_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_save_vacancies_bulk_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_search_vacancies_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_delete_vacancy_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_clear_all_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_get_statistics_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_simple_db_coverage.py::TestSimpleDBAdapterCoverage::test_error_handling_coverage - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_sj_api_complete.py::TestSuperJobAPIComplete::test_deduplicate_vacancies - AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have th...
FAILED tests/test_storage_components_complete.py::TestPostgresSaver::test_save_vacancies_batch - AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f5ab09f0...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_insert_vacancy - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_storage_components_complete.py::TestSimpleDBAdapter::test_get_vacancies - AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f5a...
FAILED tests/test_storage_components_complete.py::TestStorageIntegration::test_repository_with_validator_integration - AttributeError: __enter__
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_storage_service_initialization - TypeError: Can't instantiate abstract class VacancyStorageService with abstract...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_save_vacancy_method - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_v...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_search_functionality - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search...
FAILED tests/test_storage_components_coverage.py::TestVacancyStorageServiceCoverage::test_delete_operations - AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_basic - AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_field - AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_...
FAILED tests/test_storage_components_coverage.py::TestDeduplicationServiceCoverage::test_identify_duplicates - AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_salary_range - AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_keyword - AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_filter_by_company - AttributeError: 'FilteringService' object has no attribute 'filter_by_company'
FAILED tests/test_storage_components_coverage.py::TestFilteringServiceCoverage::test_complex_filtering - AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filt...
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_create_vacancy - AttributeError: 'VacancyRepository' object has no attribute 'create'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_vacancy_by_id - AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_update_vacancy - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_get_all_vacancies - TypeError: 'Mock' object does not support the context manager protocol
FAILED tests/test_storage_components_coverage.py::TestVacancyRepositoryCoverage::test_count_vacancies - AttributeError: 'VacancyRepository' object has no attribute 'count'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_invalid_vacancy - AttributeError: 'VacancyValidator' object has no attribute 'validate'
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_required_fields - AttributeError: 'VacancyValidator' object has no attribute 'validate_required_f...
FAILED tests/test_storage_components_coverage.py::TestVacancyValidatorCoverage::test_validate_data_types - AttributeError: 'VacancyValidator' object has no attribute 'validate_data_types'
FAILED tests/test_ui_navigation_extended.py::TestUINavigationExtended::test_paginate_display_custom_actions - AssertionError: Custom action should have been called
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies - assert 0 == 3
FAILED tests/test_unified_api.py::TestUnifiedAPI::test_filter_by_target_companies_mixed_sources - assert 0 == 3
FAILED tests/test_unified_api_complete.py::TestUnifiedAPIComplete::test_filter_by_target_companies - AttributeError: module 'src.api_modules.unified_api' has no attribute 'TargetCo...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_main_interface_complete - AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests...
FAILED tests/test_user_interface_consolidated.py::TestUserInterfaceConsolidated::test_interface_components_integration - TypeError: MainApplicationInterface.__init__() missing 3 required positional ar...
ERROR tests/test_comprehensive_missing_coverage.py::TestPostgresSaverCoverage::test_save_vacancies_single_vacancy - TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_paginator_initialization - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_get_current_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_next_page - TypeError: Paginator() takes no arguments
ERROR tests/test_missing_coverage_extended.py::TestPaginatorCoverage::test_has_previous_page - TypeError: Paginator() takes no arguments
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_url - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_remove_duplicates_by_title_company - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_find_duplicates - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
ERROR tests/test_services_coverage.py::TestDeduplicationServiceCoverage::test_deduplication_statistics - TypeError: DeduplicationService.__init__() missing 1 required positional argume...
============= 102 failed, 1659 passed, 10 skipped, 11 errors in 16.29s =============
~/workspace$ 