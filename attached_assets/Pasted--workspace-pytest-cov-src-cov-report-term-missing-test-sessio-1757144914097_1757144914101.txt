~/workspace$ pytest --cov=src --cov-report=term-missing
=============================== test session starts ================================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: cov-6.2.1, mock-3.15.0
collected 1832 items                                                               

tests/test_abstract.py ........                                              [  0%]
tests/test_abstract_db_manager.py ....                                       [  0%]
tests/test_abstract_filter_complete.py .........                             [  1%]
tests/test_api_complete.py ...................                               [  2%]
tests/test_api_config.py ....                                                [  2%]
tests/test_api_data_filter.py ......                                         [  2%]
tests/test_api_fixes.py .......                                              [  3%]
tests/test_api_modules.py ............................                       [  4%]
tests/test_api_modules_consolidated.py ....                                  [  4%]
tests/test_api_modules_coverage.py .FF...F............                       [  5%]
tests/test_app_config.py .........                                           [  6%]
tests/test_base_api.py ...............                                       [  7%]
tests/test_base_formatter.py ..........                                      [  7%]
tests/test_base_formatter_complete.py ..............................         [  9%]
tests/test_base_parser.py ......                                             [  9%]
tests/test_cache.py ......................                                   [ 10%]
tests/test_cached_api.py ....                                                [ 11%]
tests/test_cached_api_complete.py ................                           [ 12%]
tests/test_components_fixed.py ...                                           [ 12%]
tests/test_comprehensive_fixed.py .....                                      [ 12%]
tests/test_comprehensive_missing_coverage.py F...E..FFFFF.F................. [ 14%]
.........                                                                    [ 14%]
tests/test_config_consolidated.py .....                                      [ 14%]
tests/test_config_missing_coverage.py .....sssss.............ss...           [ 16%]
tests/test_config_modules_consolidated.py ......                             [ 16%]
tests/test_config_modules_coverage.py ...................FFF..........       [ 18%]
tests/test_console_interface.py ......                                       [ 18%]
tests/test_console_interface_coverage.py ..................                  [ 19%]
tests/test_core_functionality_consolidated.py .....                          [ 20%]
tests/test_core_modules_comprehensive.py ........                            [ 20%]
tests/test_data_normalizers_comprehensive.py ............................    [ 22%]
tests/test_database_connection.py ........                                   [ 22%]
tests/test_db_config.py .....                                                [ 22%]
tests/test_db_manager.py .................                                   [ 23%]
tests/test_db_manager_coverage.py ..FFFFFFFFFFF...                           [ 24%]
tests/test_decorators.py .......                                             [ 24%]
tests/test_description_parser.py ..........                                  [ 25%]
tests/test_env_loader.py ................                                    [ 26%]
tests/test_filter_utils.py ......                                            [ 26%]
tests/test_final_coverage_fixes.py EEF...................                    [ 27%]
tests/test_formatters_coverage.py ...........................                [ 29%]
tests/test_get_api_complete.py ....................                          [ 30%]
tests/test_hh_api_complete.py .................                              [ 31%]
tests/test_hh_api_config.py .....                                            [ 31%]
tests/test_hh_parser.py ........                                             [ 32%]
tests/test_integration.py .............                                      [ 32%]
tests/test_interfaces.py .ss                                                 [ 32%]
tests/test_interfaces_coverage.py ................................           [ 34%]
tests/test_low_coverage_components_fixed.py FFFFFFF.F.FFFF......F.F......FF  [ 36%]
tests/test_main_application_interface.py ...                                 [ 36%]
tests/test_main_application_interface_complete.py .......................... [ 37%]
.................                                                            [ 38%]
tests/test_main_consolidated.py .........                                    [ 39%]
tests/test_menu_manager.py ..........                                        [ 39%]
tests/test_missing_components.py .........                                   [ 40%]
tests/test_missing_coverage_components.py ..............F..                  [ 41%]
tests/test_missing_coverage_extended.py ...........EEEEEE...........F....... [ 43%]
..............FFF...                                                         [ 44%]
tests/test_models_coverage.py ...........................                    [ 45%]
tests/test_models_fixed.py ...                                               [ 46%]
tests/test_paginator.py ......                                               [ 46%]
tests/test_parsers_complete.py ............                                  [ 47%]
tests/test_parsers_coverage.py .............................                 [ 48%]
tests/test_postgres_saver_coverage.py .FFFFFFFFFFFFF.FF.                     [ 49%]
tests/test_real_components_coverage.py ......EEEEFE......F.                  [ 50%]
tests/test_repository_fixed.py ..                                            [ 50%]
tests/test_salary_fixed.py ...........                                       [ 51%]
tests/test_salary_utils.py ......................                            [ 52%]
tests/test_search_utils.py ............................                      [ 54%]
tests/test_search_utils_complete.py ........................................ [ 56%]
......                                                                       [ 56%]
tests/test_services_consolidated.py ....                                     [ 56%]
tests/test_services_coverage.py ............................                 [ 58%]
tests/test_services_storage_consolidated.py ..........                       [ 58%]
tests/test_simple_db_adapter.py .........                                    [ 59%]
tests/test_simple_db_coverage.py .FFFFFFFFFFF...                             [ 60%]
tests/test_sj_api.py ..............                                          [ 61%]
tests/test_sj_api_complete.py .............F....                             [ 62%]
tests/test_sj_api_config.py .....                                            [ 62%]
tests/test_sj_parser.py ........                                             [ 62%]
tests/test_sj_parser_complete.py ..............                              [ 63%]
tests/test_source_manager.py .................                               [ 64%]
tests/test_source_selector.py .................                              [ 65%]
tests/test_storage_abstractions.py ........                                  [ 65%]
tests/test_storage_abstractions_coverage.py ......EE                         [ 66%]
tests/test_storage_complete.py .............                                 [ 66%]
tests/test_storage_components_complete.py ......F....FF...............F      [ 68%]
tests/test_storage_components_coverage.py FF..FF.FFF.FFFF.FFF.FF..FFF        [ 69%]
tests/test_storage_factory.py ........                                       [ 70%]
tests/test_storage_modules_consolidated.py ....                              [ 70%]
tests/test_target_companies.py .....                                         [ 70%]
tests/test_typed_data_processor.py ................                          [ 71%]
tests/test_ui_components_complete.py ......................................  [ 73%]
tests/test_ui_components_extended.py ..................                      [ 74%]
tests/test_ui_config.py .......................                              [ 76%]
tests/test_ui_helpers_comprehensive.py ..................................... [ 78%]
..                                                                           [ 78%]
tests/test_ui_helpers_extended.py ........................................   [ 80%]
tests/test_ui_modules_consolidated.py .....                                  [ 80%]
tests/test_ui_navigation.py ......................                           [ 81%]
tests/test_ui_navigation_complete.py ..s..                                   [ 82%]
tests/test_ui_navigation_comprehensive.py ......                             [ 82%]
tests/test_ui_navigation_extended.py .......F...........................     [ 84%]
tests/test_unified_api.py ................F...F.                             [ 85%]
tests/test_unified_api_complete.py ......F......................             [ 87%]
tests/test_unified_api_fixed.py ...                                          [ 87%]
tests/test_user_interface.py ...............                                 [ 88%]
tests/test_user_interface_consolidated.py F.F                                [ 88%]
tests/test_user_interface_coverage.py .........                              [ 88%]
tests/test_user_interface_fixed.py ...                                       [ 88%]
tests/test_utils_consolidated.py .....                                       [ 89%]
tests/test_utils_coverage.py .............................                   [ 90%]
tests/test_utils_ui_consolidated.py ......                                   [ 91%]
tests/test_vacancy_abstractions.py .................                         [ 92%]
tests/test_vacancy_display_handler.py ...................                    [ 93%]
tests/test_vacancy_formatter.py ........                                     [ 93%]
tests/test_vacancy_models_complete.py ....                                   [ 93%]
tests/test_vacancy_models_consolidated.py ....                               [ 93%]
tests/test_vacancy_operations.py ......                                      [ 94%]
tests/test_vacancy_operations_coordinator.py ...........................     [ 95%]
tests/test_vacancy_operations_coordinator_complete.py ...................... [ 96%]
                                                                             [ 96%]
tests/test_vacancy_processing_coordinator.py .............                   [ 97%]
tests/test_vacancy_repository.py .........                                   [ 98%]
tests/test_vacancy_stats.py ............                                     [ 98%]
tests/test_vacancy_stats_fixed.py .........                                  [ 99%]
tests/test_vacancy_validator.py ............                                 [100%]

====================================== ERRORS ======================================
__ ERROR at setup of TestPostgresSaverCoverage.test_save_vacancies_single_vacancy __

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f6b1f4b8510>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        from src.vacancies.models import Vacancy, Employer
        from src.utils.salary import Salary
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(from_amount=100000, to_amount=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'from_amount'

tests/test_comprehensive_missing_coverage.py:164: TypeError
_ ERROR at setup of TestPostgresSaverFinalFixes.test_is_vacancy_exists_with_real_vacancy _

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f6b1f2b5fd0>

    @pytest.fixture
    def mock_vacancy(self):
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return Mock()
    
        # Создаем реальный объект Vacancy
        employer = Employer(name="Test Company", employer_id="comp123")
        # Используем правильные параметры для Salary
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_final_coverage_fixes.py:80: TypeError
___ ERROR at setup of TestPostgresSaverFinalFixes.test_save_real_vacancy_objects ___

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f6b1f2b6610>

    @pytest.fixture
    def mock_vacancy(self):
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return Mock()
    
        # Создаем реальный объект Vacancy
        employer = Employer(name="Test Company", employer_id="comp123")
        # Используем правильные параметры для Salary
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_final_coverage_fixes.py:80: TypeError
______ ERROR at setup of TestPaginatorCoverage.test_paginator_initialization _______

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f04f850>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_get_current_page ___________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f04fe90>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
______________ ERROR at setup of TestPaginatorCoverage.test_next_page ______________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f058510>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_previous_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f058b90>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
____________ ERROR at setup of TestPaginatorCoverage.test_has_next_page ____________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f0591d0>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
__________ ERROR at setup of TestPaginatorCoverage.test_has_previous_page __________

self = <tests.test_missing_coverage_extended.TestPaginatorCoverage object at 0x7f6b1f04e410>

    @pytest.fixture
    def paginator(self):
        """Фикстура для Paginator"""
        if not PAGINATOR_AVAILABLE:
            return Mock()
    
        test_data = [f"item_{i}" for i in range(100)]
>       return Paginator(test_data, items_per_page=10)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_missing_coverage_extended.py:306: TypeError
_ ERROR at setup of TestPostgresSaverRealInterface.test_is_vacancy_exists_with_vacancy_object _

self = <tests.test_real_components_coverage.TestPostgresSaverRealInterface object at 0x7f6b1ef08710>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        if not MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            mock.salary = None
            return mock
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_real_components_coverage.py:161: TypeError
_ ERROR at setup of TestPostgresSaverRealInterface.test_delete_vacancy_with_vacancy_object _

self = <tests.test_real_components_coverage.TestPostgresSaverRealInterface object at 0x7f6b1ef06dd0>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для реальной вакансии"""
        if not MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            mock.salary = None
            return mock
    
        employer = Employer(name="Test Company", employer_id="comp123")
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_real_components_coverage.py:161: TypeError
_______ ERROR at setup of TestFileCacheRealMethods.test_cache_key_generation _______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f6b1ef08210>
temp_cache_dir = '/tmp/tmpqonkaht3'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_______ ERROR at setup of TestFileCacheRealMethods.test_save_and_load_cycle ________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f6b1ef08f90>
temp_cache_dir = '/tmp/tmpbuxms2tx'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
______ ERROR at setup of TestFileCacheRealMethods.test_invalid_cache_handling ______

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f6b1ef09710>
temp_cache_dir = '/tmp/tmpa1_x2w8a'

    @pytest.fixture
    def cache(self, temp_cache_dir):
        """Фикстура для FileCache"""
        if not CACHE_AVAILABLE:
            return Mock()
>       return FileCache(cache_dir=temp_cache_dir, ttl_seconds=3600)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:234: TypeError
_ ERROR at setup of TestVacancyModelIntegration.test_storage_with_real_vacancy_objects _

self = <tests.test_storage_abstractions_coverage.TestVacancyModelIntegration object at 0x7f6b1ee76050>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для создания mock вакансии"""
        if not VACANCY_MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            return mock
    
        # Создаем реальную вакансию для тестов
        employer = Employer(name="Test Company", employer_id="comp123")
    
        # Создаем зарплату с правильными параметрами
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_storage_abstractions_coverage.py:266: TypeError
_ ERROR at setup of TestVacancyModelIntegration.test_db_manager_with_vacancy_filtering _

self = <tests.test_storage_abstractions_coverage.TestVacancyModelIntegration object at 0x7f6b1ee77890>

    @pytest.fixture
    def mock_vacancy(self):
        """Фикстура для создания mock вакансии"""
        if not VACANCY_MODELS_AVAILABLE:
            mock = Mock()
            mock.vacancy_id = "test123"
            mock.title = "Test Job"
            mock.employer = Mock()
            mock.employer.name = "Test Company"
            return mock
    
        # Создаем реальную вакансию для тестов
        employer = Employer(name="Test Company", employer_id="comp123")
    
        # Создаем зарплату с правильными параметрами
>       salary = Salary(salary_from=100000, salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_from'

tests/test_storage_abstractions_coverage.py:266: TypeError
===================================== FAILURES =====================================
____________ TestUnifiedAPICoverage.test_get_vacancies_from_all_sources ____________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f6b1f5a0450>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6b1e071710>

    def test_get_vacancies_from_all_sources(self, unified_api):
        """Тест получения вакансий из всех источников"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Настраиваем моки для возврата данных
>       unified_api.hh_api.get_vacancies.return_value = [
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            {'id': '1', 'title': 'Python Dev', 'source': 'hh'},
            {'id': '2', 'title': 'Java Dev', 'source': 'hh'}
        ]
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:57: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestUnifiedAPICoverage.test_search_with_filters __________________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f6b1f5a0b50>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6b1e073e50>

    def test_search_with_filters(self, unified_api):
        """Тест поиска с фильтрами"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        search_params = {
            'text': 'python',
            'salary': 100000,
            'experience': 'between1And3',
            'area': '1'  # Москва
        }
    
>       unified_api.hh_api.get_vacancies.return_value = []
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'return_value'

tests/test_api_modules_coverage.py:80: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_____________ TestUnifiedAPICoverage.test_error_handling_api_failures ______________

self = <tests.test_api_modules_coverage.TestUnifiedAPICoverage object at 0x7f6b1f5a2790>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f6b1dd6ff50>

    def test_error_handling_api_failures(self, unified_api):
        """Тест обработки ошибок API"""
        if not UNIFIED_API_AVAILABLE:
            return
    
        # Симулируем ошибку в одном из API
>       unified_api.hh_api.get_vacancies.side_effect = Exception("HH API Error")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'method' object has no attribute 'side_effect'

tests/test_api_modules_coverage.py:156: AttributeError
-------------------------------- Captured log setup --------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_______ TestDBManagerCoverage.test_get_companies_and_vacancies_count_success _______

self = <Mock name='mock.execute' id='140098038951184'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_comprehensive_missing_coverage.TestDBManagerCoverage object at 0x7f6b1f4b6e90>
mock_connect = <MagicMock name='connect' id='140098039406736'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1de18110>
mock_connection = (<Mock name='connect()' id='140098052682064'>, <Mock id='140098039001552'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count_success(self, mock_connect, db_manager, mock_connection):
        """Тест успешного получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        with patch.object(db_manager, '_get_connection', return_value=mock_conn):
            result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
        # DBManager возвращает список по умолчанию при отсутствии подключения
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_comprehensive_missing_coverage.py:111: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.db_manager:db_manager.py:855 Ошибка подключения к БД: 'Mock' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_true _______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f6b1f4b98d0>
mock_connect = <MagicMock name='connect' id='140098052533904'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1ddad890>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_true(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = (1,)
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('test123')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1ddad890>
vacancy = 'test123'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
______________ TestPostgresSaverCoverage.test_is_vacancy_exists_false ______________

self = <tests.test_comprehensive_missing_coverage.TestPostgresSaverCoverage object at 0x7f6b1f4b9f50>
mock_connect = <MagicMock name='connect' id='140098038869328'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1f535910>

    @patch('psycopg2.connect')
    def test_is_vacancy_exists_false(self, mock_connect, postgres_saver):
        """Тест проверки существования вакансии - не существует"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value = mock_cursor
        mock_cursor.fetchone.return_value = None
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           result = postgres_saver.is_vacancy_exists('nonexistent')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_comprehensive_missing_coverage.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1f535910>
vacancy = 'nonexistent'

    def is_vacancy_exists(self, vacancy: Vacancy) -> bool:
        """Проверяет, существует ли вакансия в БД"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
>           cursor.execute("SELECT 1 FROM vacancies WHERE vacancy_id = %s", (vacancy.vacancy_id,))
                                                                             ^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1105: AttributeError
_________________ TestSimpleDBAdapterCoverage.test_initialization __________________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1f4ba890>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1ebb7fd0>

    def test_initialization(self, db_adapter):
        """Тест инициализации SimpleDBAdapter"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        assert db_adapter is not None
>       assert hasattr(db_adapter, 'save_vacancies')
E       AssertionError: assert False
E        +  where False = hasattr(<src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1ebb7fd0>, 'save_vacancies')

tests/test_comprehensive_missing_coverage.py:296: AssertionError
____________ TestSimpleDBAdapterCoverage.test_save_vacancies_empty_list ____________

self = <tests.test_comprehensive_missing_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1f4baf50>
mock_run = <MagicMock name='run' id='140098062107088'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1f39c290>

    @patch('subprocess.run')
    def test_save_vacancies_empty_list(self, mock_run, db_adapter):
        """Тест сохранения пустого списка вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       result = db_adapter.save_vacancies([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'save_vacancies'

tests/test_comprehensive_missing_coverage.py:304: AttributeError
__________________ TestCacheCoverage.test_save_and_load_response ___________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7f6b1f4bb850>
cache = <src.utils.cache.FileCache object at 0x7f6b1ddc8950>

    def test_save_and_load_response(self, cache):
        """Тест сохранения и загрузки ответа"""
        if not CACHE_AVAILABLE:
            return
    
        data = {"items": [{"id": "1", "name": "Test"}], "found": 1}
        params = {"query": "python", "page": 0}
    
        # Сначала сохраняем данные
        cache.save_response("hh", params, data)
    
        # Затем загружаем
        loaded_data = cache.load_response("hh", params)
    
>       assert loaded_data is not None
E       assert None is not None

tests/test_comprehensive_missing_coverage.py:335: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpai9wyr2c/hh_706f9072b3b7694d22a2ab464b8a25aa.json'
____________________ TestCacheCoverage.test_clear_cache_method _____________________

self = <tests.test_comprehensive_missing_coverage.TestCacheCoverage object at 0x7f6b1f2cc710>
cache = <src.utils.cache.FileCache object at 0x7f6b1de0bb90>

    def test_clear_cache_method(self, cache):
        """Тест очистки кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем несколько файлов кэша
        cache.save_response("hh", {"query": "test1"}, {"data": 1})
        cache.save_response("hh", {"query": "test2"}, {"data": 2})
    
        # Очищаем кэш
>       cache.clear_cache()
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'FileCache' object has no attribute 'clear_cache'

tests/test_comprehensive_missing_coverage.py:357: AttributeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpfex12wlf/hh_0bb438ddfe366eb2b5cd8d8bf3fba2c3.json'
ERROR    src.utils.cache:cache.py:62 Ошибка сохранения в кэш: [Errno 2] No such file or directory: '/tmp/tmpfex12wlf/hh_b1a5cf751caed3a23aae5e87e985cb3a.json'
_____________________ TestSJAPIConfigCoverage.test_get_api_key _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f6b1f3322d0>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_api_key(self, sj_config):
        """Тест получения API ключа"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_api_key_123'}):
>           api_key = sj_config.get_api_key()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_api_key'

tests/test_config_modules_coverage.py:332: AttributeError
____________________ TestSJAPIConfigCoverage.test_get_base_url _____________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f6b1f332910>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_base_url(self, sj_config):
        """Тест получения базового URL"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
>       base_url = sj_config.get_base_url()
                   ^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SJAPIConfig' object has no attribute 'get_base_url'

tests/test_config_modules_coverage.py:340: AttributeError
_________________ TestSJAPIConfigCoverage.test_get_request_headers _________________

self = <tests.test_config_modules_coverage.TestSJAPIConfigCoverage object at 0x7f6b1f332f90>
sj_config = SJAPIConfig(count=500, published=15, only_with_salary=False, custom_params=None)

    def test_get_request_headers(self, sj_config):
        """Тест получения заголовков запроса"""
        if not SJ_API_CONFIG_AVAILABLE:
            return
    
        with patch.dict('os.environ', {'SJ_API_KEY': 'test_key'}):
>           headers = sj_config.get_headers()
                      ^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'SJAPIConfig' object has no attribute 'get_headers'

tests/test_config_modules_coverage.py:349: AttributeError
________________ TestDBManagerCoverage.test_create_database_schema _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f3bbf50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1e0732d0>
mock_connection = (<Mock id='140098039611472'>, <Mock name='mock.cursor()' id='140098039616656'>)

    def test_create_database_schema(self, db_manager, mock_connection):
        """Тест создания схемы базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
>       db_manager.create_database_schema()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'create_database_schema'

tests/test_db_manager_coverage.py:75: AttributeError
___________________ TestDBManagerCoverage.test_save_company_data ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f4a10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1e09b350>
mock_connection = (<Mock id='140098039489616'>, <Mock name='mock.cursor()' id='140098041929488'>)

    def test_save_company_data(self, db_manager, mock_connection):
        """Тест сохранения данных компании"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        company_data = {
            'id': 'company123',
            'name': 'TechCorp',
            'description': 'Leading tech company',
            'website': 'https://techcorp.com',
            'industry': 'Technology'
        }
    
>       db_manager.save_company(company_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_company'

tests/test_db_manager_coverage.py:96: AttributeError
______________ TestDBManagerCoverage.test_save_vacancy_comprehensive _______________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f4e10>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1ea686d0>
mock_connection = (<Mock id='140098052459408'>, <Mock name='mock.cursor()' id='140098052460304'>)

    def test_save_vacancy_comprehensive(self, db_manager, mock_connection):
        """Тест комплексного сохранения вакансии"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        vacancy_data = {
            'id': 'vac123',
            'title': 'Senior Python Developer',
            'description': 'Exciting opportunity for experienced developer',
            'company_id': 'company123',
            'salary_from': 150000,
            'salary_to': 200000,
            'currency': 'RUR',
            'experience': 'between3and6',
            'employment': 'full',
            'schedule': 'fullDay',
            'area': 'Moscow',
            'published_at': '2024-01-15T10:00:00',
            'url': 'https://hh.ru/vacancy/123',
            'source': 'hh'
        }
    
>       db_manager.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_vacancy'

tests/test_db_manager_coverage.py:124: AttributeError
_________________ TestDBManagerCoverage.test_bulk_save_operations __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f5250>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1ddac3d0>
mock_connection = (<Mock id='140098063780112'>, <Mock name='mock.cursor()' id='140098063793936'>)

    def test_bulk_save_operations(self, db_manager, mock_connection):
        """Тест массовых операций сохранения"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Массовое сохранение компаний
        companies = [
            {'id': 'comp1', 'name': 'Company 1'},
            {'id': 'comp2', 'name': 'Company 2'},
            {'id': 'comp3', 'name': 'Company 3'}
        ]
    
>       db_manager.save_companies(companies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'save_companies'

tests/test_db_manager_coverage.py:142: AttributeError
___________________ TestDBManagerCoverage.test_query_operations ____________________

self = <Mock name='mock.cursor().execute' id='140098035871120'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f5690>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1dda1310>
mock_connection = (<Mock id='140098038964304'>, <Mock name='mock.cursor()' id='140098038960080'>)

    def test_query_operations(self, db_manager, mock_connection):
        """Тест операций запросов"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Получение всех вакансий
        mock_cursor.fetchall.return_value = [
            ('vac1', 'Python Developer', 'Great job', 'comp1', 100000, 150000, 'RUR'),
            ('vac2', 'Java Developer', 'Another job', 'comp2', 120000, 180000, 'RUR')
        ]
    
        vacancies = db_manager.get_all_vacancies()
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_db_manager_coverage.py:171: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098039231696'>, исправляем...
_________________ TestDBManagerCoverage.test_search_functionality __________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f5c90>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1e05be10>
mock_connection = (<Mock id='140098041912080'>, <Mock name='mock.cursor()' id='140098041905808'>)

    def test_search_functionality(self, db_manager, mock_connection):
        """Тест функций поиска"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Поиск по ключевому слову
>       results = db_manager.search_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'search_by_keyword'

tests/test_db_manager_coverage.py:185: AttributeError
___________________ TestDBManagerCoverage.test_filter_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f6390>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1ef7a1d0>
mock_connection = (<Mock id='140098056246032'>, <Mock name='mock.cursor()' id='140098064160336'>)

    def test_filter_operations(self, db_manager, mock_connection):
        """Тест операций фильтрации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
        # Фильтрация по опыту
>       results = db_manager.filter_by_experience('between3and6')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'filter_by_experience'

tests/test_db_manager_coverage.py:207: AttributeError
________________ TestDBManagerCoverage.test_aggregation_operations _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f6a50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1f1da810>
mock_connection = (<Mock id='140098056710416'>, <Mock name='mock.cursor()' id='140098056714128'>)

    def test_aggregation_operations(self, db_manager, mock_connection):
        """Тест операций агрегации"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Подсчет общего количества вакансий
        mock_cursor.fetchone.return_value = (150,)
>       count = db_manager.count_vacancies()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'count_vacancies'

tests/test_db_manager_coverage.py:228: AttributeError
___________________ TestDBManagerCoverage.test_update_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f7150>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1dd71610>
mock_connection = (<Mock id='140098038863440'>, <Mock name='mock.cursor()' id='140098038858256'>)

    def test_update_operations(self, db_manager, mock_connection):
        """Тест операций обновления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Обновление вакансии
        update_data = {
            'title': 'Senior Python Developer',
            'salary_from': 180000,
            'salary_to': 250000
        }
    
>       db_manager.update_vacancy('vac123', update_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'update_vacancy'

tests/test_db_manager_coverage.py:261: AttributeError
___________________ TestDBManagerCoverage.test_delete_operations ___________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f7850>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1ddc9150>
mock_connection = (<Mock id='140098039233168'>, <Mock name='mock.cursor()' id='140098039234192'>)

    def test_delete_operations(self, db_manager, mock_connection):
        """Тест операций удаления"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Удаление отдельной вакансии
>       db_manager.delete_vacancy('vac123')
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'delete_vacancy'

tests/test_db_manager_coverage.py:282: AttributeError
________________ TestDBManagerCoverage.test_transaction_management _________________

self = <tests.test_db_manager_coverage.TestDBManagerCoverage object at 0x7f6b1f1f7f50>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b219e9050>
mock_connection = (<Mock id='140098053856848'>, <Mock name='mock.cursor()' id='140098063269584'>)

    def test_transaction_management(self, db_manager, mock_connection):
        """Тест управления транзакциями"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        db_manager.connection = mock_conn
    
        # Начало транзакции
>       db_manager.begin_transaction()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DBManager' object has no attribute 'begin_transaction'

tests/test_db_manager_coverage.py:302: AttributeError
_____________ TestPostgresSaverFinalFixes.test_vacancy_type_validation _____________

self = <tests.test_final_coverage_fixes.TestPostgresSaverFinalFixes object at 0x7f6b1f2b6d10>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1ea78550>

    def test_vacancy_type_validation(self, postgres_saver):
        """Тест валидации типов вакансий"""
        if not POSTGRES_COMPONENTS_AVAILABLE:
            return
    
        # Тест с неправильным типом данных
        invalid_data = {"id": "123", "title": "Test"}
    
        mock_conn = Mock()
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            # Метод должен корректно обрабатывать неправильные типы
>           result = postgres_saver.save_vacancies([invalid_data])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_final_coverage_fixes.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1ea78550>
vacancies = [{'id': '123', 'title': 'Test'}], search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
____________ TestDBManagerFixed.test_get_companies_and_vacancies_count _____________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f176cd0>
mock_connect = <MagicMock name='connect' id='140098040753232'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1df3e110>
mock_connection = (<Mock name='connect()' id='140098040750928'>, <Mock id='140098040751056'>)

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager, mock_connection):
        """Тест получения списка компаний и количества вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            ('TechCorp', 50),
            ('DataCorp', 30),
            ('WebCorp', 25)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
        assert isinstance(result, list)
>       assert len(result) == 3
E       AssertionError: assert 12 == 3
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_low_coverage_components_fixed.py:85: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:373 Нет подключения к базе данных
____________________ TestDBManagerFixed.test_get_all_vacancies _____________________

self = <Mock name='mock.execute' id='140098035863056'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f177290>
mock_connect = <MagicMock name='connect' id='140098033597456'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1df3e250>
mock_connection = (<Mock name='connect()' id='140098033596688'>, <Mock id='140098033594064'>)

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager, mock_connection):
        """Тест получения всех вакансий"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'}
        ]
    
        result = db_manager.get_all_vacancies()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:105: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098033705296'>, исправляем...
______________________ TestDBManagerFixed.test_get_avg_salary ______________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f177850>
mock_connect = <MagicMock name='connect' id='140098039428688'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1ddb9550>
mock_connection = (<Mock name='connect()' id='140098039425552'>, <Mock id='140098039415824'>)

    @patch('psycopg2.connect')
    def test_get_avg_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения средней зарплаты"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.return_value = (125000.0,)
    
        result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert 1.0 == 125000.0

tests/test_low_coverage_components_fixed.py:119: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098040609808'>, исправляем...
_____________ TestDBManagerFixed.test_get_vacancies_with_higher_salary _____________

self = <Mock name='mock.execute' id='140098040670160'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f177e50>
mock_connect = <MagicMock name='connect' id='140098033198800'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1d80aed0>
mock_connection = (<Mock name='connect()' id='140098033200464'>, <Mock id='140098033201296'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager, mock_connection):
        """Тест получения вакансий с зарплатой выше средней"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Senior Developer', 'salary': 150000}
        ]
    
        result = db_manager.get_vacancies_with_higher_salary()
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:137: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098040801872'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098040658576'>, исправляем...
________________ TestDBManagerFixed.test_get_vacancies_with_keyword ________________

self = <Mock name='mock.execute' id='140098040743504'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:918: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f184450>
mock_connect = <MagicMock name='connect' id='140098040968848'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1df73ed0>
mock_connection = (<Mock name='connect()' id='140098040969872'>, <Mock id='140098040969744'>)

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchall.return_value = [
            {'id': '1', 'title': 'Python Developer'}
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
        assert isinstance(result, list)
>       mock_cursor.execute.assert_called_once()
E       AssertionError: Expected 'execute' to have been called once. Called 0 times.

tests/test_low_coverage_components_fixed.py:154: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098036086672'>, исправляем...
____________________ TestDBManagerFixed.test_get_database_stats ____________________

self = <tests.test_low_coverage_components_fixed.TestDBManagerFixed object at 0x7f6b1f1845d0>
mock_connect = <MagicMock name='connect' id='140098035713936'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f6b1da72c10>
mock_connection = (<Mock name='connect()' id='140098035723792'>, <Mock id='140098035720080'>)

    @patch('psycopg2.connect')
    def test_get_database_stats(self, mock_connect, db_manager, mock_connection):
        """Тест получения статистики базы данных"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        mock_connect.return_value = mock_conn
        mock_cursor.fetchone.side_effect = [
            (150,),  # total_vacancies
            (25,),   # total_companies
            (125000.0,)  # avg_salary
        ]
    
        result = db_manager.get_database_stats()
    
        assert isinstance(result, dict)
>       assert 'total_vacancies' in result
E       AssertionError: assert 'total_vacancies' in {'salary_distribution': [], 'top_employers': [], 'total_companies': <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098038831184'>}

tests/test_low_coverage_components_fixed.py:173: AssertionError
_______ TestPostgresSaverFixed.test_save_vacancies_with_real_vacancy_objects _______

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f6b1f184bd0>
mock_connect = <MagicMock name='connect' id='140098036259152'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d84afd0>
mock_vacancy = <src.vacancies.models.Vacancy object at 0x7f6b1dada270>

    @patch('psycopg2.connect')
    def test_save_vacancies_with_real_vacancy_objects(self, mock_connect, postgres_saver, mock_vacancy):
        """Тест сохранения вакансий с реальными объектами Vacancy"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
            mock_cursor.fetchall.return_value = []  # Пустой список компаний
            mock_cursor.rowcount = 1
    
>           result = postgres_saver.save_vacancies([mock_vacancy])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_low_coverage_components_fixed.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d84afd0>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f6b1dada270>]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
>           for row in results:
E           TypeError: 'Mock' object is not iterable

src/storage/postgres_saver.py:373: TypeError
_________________ TestPostgresSaverFixed.test_delete_vacancy_by_id _________________

self = <tests.test_low_coverage_components_fixed.TestPostgresSaverFixed object at 0x7f6b1f185590>
mock_connect = <MagicMock name='connect' id='140098033354768'>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d8a1a10>

    @patch('psycopg2.connect')
    def test_delete_vacancy_by_id(self, mock_connect, postgres_saver):
        """Тест удаления вакансии по ID"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        with patch.object(postgres_saver, '_get_connection', return_value=mock_conn):
>           postgres_saver.delete_vacancy_by_id('test123')

tests/test_low_coverage_components_fixed.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d8a1a10>
vacancy_id = 'test123'

    def delete_vacancy_by_id(self, vacancy_id: str) -> bool:
        """Удаляет вакансию по ID"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
            cursor.execute("DELETE FROM vacancies WHERE vacancy_id = %s", (vacancy_id,))
    
>           if cursor.rowcount > 0:
               ^^^^^^^^^^^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/storage/postgres_saver.py:1001: TypeError
_________ TestSimpleDBAdapterFixed.test_get_companies_and_vacancies_count __________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f6b1f186490>
mock_connect = <MagicMock name='connect' id='140098033143376'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1df860d0>

    @patch('psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_adapter):
        """Тест получения компаний и количества вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('Company1', 10),
            ('Company2', 15)
        ]
    
>       result = db_adapter.get_companies_and_vacancies_count()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_companies_and_vacancies_count'

tests/test_low_coverage_components_fixed.py:319: AttributeError
_________________ TestSimpleDBAdapterFixed.test_get_all_vacancies __________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f6b1f186a50>
mock_connect = <MagicMock name='connect' id='140098042300752'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1e0ba790>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_adapter):
        """Тест получения всех вакансий"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_all_vacancies()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_all_vacancies'

tests/test_low_coverage_components_fixed.py:338: AttributeError
_____________ TestSimpleDBAdapterFixed.test_get_vacancies_with_keyword _____________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f6b1f1870d0>
mock_connect = <MagicMock name='connect' id='140098039002000'>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1dd92610>

    @patch('psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_adapter):
        """Тест поиска вакансий по ключевому слову"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       result = db_adapter.get_vacancies_with_keyword('Python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'get_vacancies_with_keyword'

tests/test_low_coverage_components_fixed.py:356: AttributeError
________________ TestSimpleDBAdapterFixed.test_init_database_schema ________________

self = <tests.test_low_coverage_components_fixed.TestSimpleDBAdapterFixed object at 0x7f6b1f187810>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1e13b4d0>

    def test_init_database_schema(self, db_adapter):
        """Тест инициализации схемы базы данных"""
        if not SIMPLE_DB_ADAPTER_AVAILABLE:
            return
    
>       with patch.object(db_adapter, '_execute_ddl_script') as mock_execute:

tests/test_low_coverage_components_fixed.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1e13b850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1e13b4d0> does not have the attribute '_execute_ddl_script'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestAPIModulesFixed.test_hh_api_methods_coverage _________________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f6b1f18aa50>
mock_get = <MagicMock name='get' id='140098038840080'>

    @patch('requests.get')
    def test_hh_api_methods_coverage(self, mock_get):
        """Тест покрытия методов HeadHunter API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
    
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
    
            # Тестируем существующие методы
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_low_coverage_components_fixed.py:475: AssertionError
_____________ TestAPIModulesFixed.test_cached_api_basic_functionality ______________

self = <tests.test_low_coverage_components_fixed.TestAPIModulesFixed object at 0x7f6b1f18b750>

    def test_cached_api_basic_functionality(self):
        """Тест базовой функциональности кэшированного API"""
        try:
            from src.api_modules.cached_api import CachedAPI
            from src.api_modules.hh_api import HeadHunterAPI
    
            base_api = HeadHunterAPI()
            cache_dir = "test_cache"
    
            # Создаем экземпляр с реальными параметрами
>           cached_api = CachedAPI(base_api, cache_dir)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class CachedAPI with abstract methods _get_empty_response, _validate_vacancy, get_vacancies, get_vacancies_page

tests/test_low_coverage_components_fixed.py:519: TypeError
_____________________ TestEdgeCasesFixed.test_db_empty_results _____________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f6b1f190b90>
mock_connect = <MagicMock name='connect' id='140098040598672'>

    @patch('psycopg2.connect')
    def test_db_empty_results(self, mock_connect):
        """Тест обработки пустых результатов из БД"""
        if not DB_MANAGER_AVAILABLE:
            return
    
        mock_conn = Mock()
        mock_cursor = Mock()
        mock_conn.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_conn.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connect.return_value = mock_conn
    
        db_manager = DBManager()
    
        # Тест с пустыми результатами
        mock_cursor.fetchall.return_value = []
        result = db_manager.get_all_vacancies()
        assert isinstance(result, list)
        assert len(result) == 0
    
        # Тест с None результатом
        mock_cursor.fetchone.return_value = None
        avg_salary = db_manager.get_avg_salary()
>       assert avg_salary is None
E       assert 1.0 is None

tests/test_low_coverage_components_fixed.py:679: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098040797200'>, исправляем...
WARNING  src.storage.db_manager:db_manager.py:204 Поле company_id имеет неправильный тип <MagicMock name='mock.__enter__().cursor().__enter__().fetchone().__getitem__()' id='140098035966736'>, исправляем...
________________ TestEdgeCasesFixed.test_postgres_saver_edge_cases _________________

self = <tests.test_low_coverage_components_fixed.TestEdgeCasesFixed object at 0x7f6b1f190ed0>

    def test_postgres_saver_edge_cases(self):
        """Тест граничных случаев PostgresSaver"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        postgres_saver = PostgresSaver()
    
        # Тест с пустым списком вакансий
        with patch.object(postgres_saver, '_get_connection') as mock_conn:
            result = postgres_saver.save_vacancies([])
>           assert isinstance(result, list)
E           assert False
E            +  where False = isinstance(0, list)

tests/test_low_coverage_components_fixed.py:691: AssertionError
_______________ TestLowCoverageComponents.test_api_methods_coverage ________________

self = <tests.test_missing_coverage_components.TestLowCoverageComponents object at 0x7f6b1f021950>
mock_get = <MagicMock name='get' id='140098040460304'>

    @patch('requests.get')
    def test_api_methods_coverage(self, mock_get):
        """Тест покрытия методов API"""
        try:
            from src.api_modules.hh_api import HeadHunterAPI
            from src.api_modules.sj_api import SuperJobAPI
    
            # Тестируем HeadHunter API
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {"items": [], "found": 0}
            mock_get.return_value = mock_response
    
            hh_api = HeadHunterAPI()
            if hasattr(hh_api, 'get_vacancies_page'):
                result = hh_api.get_vacancies_page("Python")
                assert isinstance(result, (dict, list))
    
            # Тестируем SuperJob API
            sj_api = SuperJobAPI()
            if hasattr(sj_api, 'get_vacancies_page'):
                result = sj_api.get_vacancies_page("Python")
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_missing_coverage_components.py:374: AssertionError
-------------------------------- Captured log call ---------------------------------
WARNING  src.api_modules.sj_api:sj_api.py:55 Используется тестовый API ключ SuperJob.                 Для полной функциональности добавьте реальный ключ                 в переменную окружения SUPERJOB_API_KEY
_________________ TestVacancyFormatterCoverage.test_format_salary __________________

self = <tests.test_missing_coverage_extended.TestVacancyFormatterCoverage object at 0x7f6b1f061050>
formatter = <src.utils.vacancy_formatter.VacancyFormatter object at 0x7f6b1daadf90>

    def test_format_salary(self, formatter):
        """Тест форматирования зарплаты"""
        if not VACANCY_FORMATTER_AVAILABLE:
            return
    
        if hasattr(formatter, 'format_salary'):
>           result = formatter.format_salary(100000, 150000, 'RUR')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyFormatter.format_salary() takes 2 positional arguments but 4 were given

tests/test_missing_coverage_extended.py:537: TypeError
__________ TestUIInterfacesCoverage.test_vacancy_display_handler_display ___________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f6b1f06c5d0>

    def test_vacancy_display_handler_display(self):
        """Тест отображения вакансий"""
        if not VACANCY_DISPLAY_HANDLER_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
        with patch('builtins.print'):
>           handler = VacancyDisplayHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancyDisplayHandler.__init__() missing 1 required positional argument: 'storage'

tests/test_missing_coverage_extended.py:824: TypeError
___________ TestUIInterfacesCoverage.test_vacancy_search_handler_search ____________

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f6b1f06cc10>

    def test_vacancy_search_handler_search(self):
        """Тест обработки поиска вакансий"""
        if not VACANCY_SEARCH_HANDLER_AVAILABLE:
            return
    
        with patch('builtins.input', return_value='Python'), \
             patch('builtins.print'):
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:835: TypeError
_____ TestUIInterfacesCoverage.test_vacancy_operations_coordinator_coordinate ______

self = <tests.test_missing_coverage_extended.TestUIInterfacesCoverage object at 0x7f6b1f06d210>

    def test_vacancy_operations_coordinator_coordinate(self):
        """Тест координации операций с вакансиями"""
        if not VACANCY_OPERATIONS_COORDINATOR_AVAILABLE:
            return
    
        vacancies = [{'id': '1', 'title': 'Test Job'}]
    
>       coordinator = VacancyOperationsCoordinator()
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: VacancyOperationsCoordinator.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_missing_coverage_extended.py:847: TypeError
____________ TestPostgresSaverCoverage.test_database_connection_methods ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeddbd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1de09050>

    def test_database_connection_methods(self, postgres_saver):
        """Тест методов подключения к базе данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
    
            # Тест подключения
>           postgres_saver.connect()
            ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'connect'

tests/test_postgres_saver_coverage.py:63: AttributeError
_______________ TestPostgresSaverCoverage.test_create_tables_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eede250>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1e0f08d0>
mock_connection = (<Mock id='140098039488528'>, <Mock name='mock.cursor()' id='140098039486352'>)

    def test_create_tables_method(self, postgres_saver, mock_connection):
        """Тест создания таблиц"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.create_tables()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'create_tables'

tests/test_postgres_saver_coverage.py:76: AttributeError
________________ TestPostgresSaverCoverage.test_save_vacancy_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eede910>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1db56950>
mock_connection = (<Mock id='140098042531344'>, <Mock name='mock.cursor()' id='140098039493392'>)

    def test_save_vacancy_method(self, postgres_saver, mock_connection):
        """Тест сохранения вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'description': 'Great job',
            'salary_from': 100000,
            'salary_to': 150000,
            'currency': 'RUR',
            'company_id': 'company123',
            'company_name': 'TechCorp',
            'url': 'https://example.com/job/123',
            'source': 'hh'
        }
    
>       postgres_saver.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'save_vacancy'

tests/test_postgres_saver_coverage.py:102: AttributeError
______________ TestPostgresSaverCoverage.test_save_multiple_vacancies ______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eedef90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1da78850>
mock_connection = (<Mock id='140098035757584'>, <Mock name='mock.cursor()' id='140098035749008'>)

    def test_save_multiple_vacancies(self, postgres_saver, mock_connection):
        """Тест массового сохранения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        vacancies = [
            {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'},
            {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'},
            {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
        ]
    
        postgres_saver.save_vacancies(vacancies)
    
        # Должны быть выполнены множественные запросы
>       assert mock_cursor.execute.call_count >= len(vacancies)
E       AssertionError: assert 0 >= 3
E        +  where 0 = <Mock name='mock.cursor().execute' id='140098035376336'>.call_count
E        +    where <Mock name='mock.cursor().execute' id='140098035376336'> = <Mock name='mock.cursor()' id='140098035749008'>.execute
E        +  and   3 = len([{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'}, {'company_name': 'Company 3', 'id': '3', 'title': 'Job 3'}])

tests/test_postgres_saver_coverage.py:124: AssertionError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
_______________ TestPostgresSaverCoverage.test_get_vacancies_method ________________

self = <Mock name='mock.cursor().execute' id='140098037880592'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eedf610>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1da1e090>
mock_connection = (<Mock id='140098034843536'>, <Mock name='mock.cursor()' id='140098034841872'>)

    def test_get_vacancies_method(self, postgres_saver, mock_connection):
        """Тест получения вакансий"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Мокаем результат запроса
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Great job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh'),
            ('2', 'Java Developer', 'Another job', 120000, 180000, 'RUR', 'company2', 'JavaCorp', 'https://example2.com', 'sj')
        ]
    
        vacancies = postgres_saver.get_vacancies()
    
>       mock_cursor.execute.assert_called()
E       AssertionError: Expected 'execute' to have been called.

tests/test_postgres_saver_coverage.py:142: AssertionError
____________ TestPostgresSaverCoverage.test_search_vacancies_by_keyword ____________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eedfc90>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d987d50>
mock_connection = (<Mock id='140098035644048'>, <Mock name='mock.cursor()' id='140098035644880'>)

    def test_search_vacancies_by_keyword(self, postgres_saver, mock_connection):
        """Тест поиска вакансий по ключевому слову"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('1', 'Python Developer', 'Python programming job', 100000, 150000, 'RUR', 'company1', 'TechCorp', 'https://example.com', 'hh')
        ]
    
>       results = postgres_saver.search_vacancies_by_keyword('python')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'search_vacancies_by_keyword'

tests/test_postgres_saver_coverage.py:157: AttributeError
______________ TestPostgresSaverCoverage.test_filter_by_salary_range _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeec350>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1db1f0d0>
mock_connection = (<Mock id='140098052393744'>, <Mock name='mock.cursor()' id='140098036418576'>)

    def test_filter_by_salary_range(self, postgres_saver, mock_connection):
        """Тест фильтрации по диапазону зарплаты"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = []
    
>       results = postgres_saver.filter_by_salary_range(100000, 200000)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'filter_by_salary_range'

tests/test_postgres_saver_coverage.py:172: AttributeError
_______________ TestPostgresSaverCoverage.test_get_companies_method ________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeec9d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d80d090>
mock_connection = (<Mock id='140098033220560'>, <Mock name='mock.cursor()' id='140098033218512'>)

    def test_get_companies_method(self, postgres_saver, mock_connection):
        """Тест получения списка компаний"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchall.return_value = [
            ('company1', 'TechCorp'),
            ('company2', 'JavaCorp'),
            ('company3', 'PythonCorp')
        ]
    
>       companies = postgres_saver.get_companies()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_companies'

tests/test_postgres_saver_coverage.py:191: AttributeError
_______________ TestPostgresSaverCoverage.test_delete_vacancy_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeed010>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1daefe10>
mock_connection = (<Mock id='140098036220496'>, <Mock name='mock.cursor()' id='140098036223312'>)

    def test_delete_vacancy_method(self, postgres_saver, mock_connection):
        """Тест удаления вакансии"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.delete_vacancy('123')

tests/test_postgres_saver_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1daefe10>
vacancy = '123'

    def delete_vacancy(self, vacancy: "AbstractVacancy") -> None:
        """
        Удаляет вакансию из PostgreSQL хранилища
        :param vacancy: Объект вакансии для удаления
        """
>       self.delete_vacancy_by_id(vacancy.vacancy_id)
                                  ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'vacancy_id'

src/storage/postgres_saver.py:1055: AttributeError
__________________ TestPostgresSaverCoverage.test_clear_all_data ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeed6d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1ea28d10>
mock_connection = (<Mock id='140098052195600'>, <Mock name='mock.cursor()' id='140098052207888'>)

    def test_clear_all_data(self, postgres_saver, mock_connection):
        """Тест очистки всех данных"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
>       postgres_saver.clear_all_data()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'clear_all_data'

tests/test_postgres_saver_coverage.py:216: AttributeError
_______________ TestPostgresSaverCoverage.test_get_statistics_method _______________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeeddd0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1e05ad50>
mock_connection = (<Mock id='140098041921360'>, <Mock name='mock.cursor()' id='140098041916240'>)

    def test_get_statistics_method(self, postgres_saver, mock_connection):
        """Тест получения статистики"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        mock_cursor.fetchone.return_value = (150, 125000.0, 250000, 50000)
    
>       stats = postgres_saver.get_statistics()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PostgresSaver' object has no attribute 'get_statistics'

tests/test_postgres_saver_coverage.py:230: AttributeError
__________________ TestPostgresSaverCoverage.test_export_to_json ___________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eede010>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1dde2e50>

    def test_export_to_json(self, postgres_saver):
        """Тест экспорта в JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.dump') as mock_json_dump, \
             patch.object(postgres_saver, 'get_vacancies', return_value=mock_vacancies):
    
>           postgres_saver.export_to_json('test_export.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'export_to_json'

tests/test_postgres_saver_coverage.py:249: AttributeError
_________________ TestPostgresSaverCoverage.test_import_from_json __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeed510>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1d9ebd90>

    def test_import_from_json(self, postgres_saver):
        """Тест импорта из JSON"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_data = [
            {'id': '1', 'title': 'Imported Job 1'},
            {'id': '2', 'title': 'Imported Job 2'}
        ]
    
        with patch('builtins.open', create=True), \
             patch('json.load', return_value=mock_data) as mock_json_load, \
             patch.object(postgres_saver, 'save_vacancies') as mock_save:
    
>           postgres_saver.import_from_json('test_import.json')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'PostgresSaver' object has no attribute 'import_from_json'

tests/test_postgres_saver_coverage.py:266: AttributeError
_______________ TestPostgresSaverCoverage.test_transaction_rollback ________________

self = <Mock name='mock.rollback' id='140098040964496'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'rollback' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeee3d0>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1df0e090>
mock_connection = (<Mock id='140098034686544'>, <Mock name='mock.cursor()' id='140098040550544'>)

    def test_transaction_rollback(self, postgres_saver, mock_connection):
        """Тест отката транзакций при ошибках"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        # Симулируем ошибку при выполнении запроса
        mock_cursor.execute.side_effect = Exception("SQL Error")
    
        try:
            postgres_saver.save_vacancy({'id': '1', 'title': 'Test'})
        except Exception:
            pass
    
        # Проверяем что rollback был вызван при ошибке
>       mock_conn.rollback.assert_called()
E       AssertionError: Expected 'rollback' to have been called.

tests/test_postgres_saver_coverage.py:301: AssertionError
_________________ TestPostgresSaverCoverage.test_batch_operations __________________

self = <tests.test_postgres_saver_coverage.TestPostgresSaverCoverage object at 0x7f6b1eeee790>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1de340d0>
mock_connection = (<Mock id='140098039676560'>, <Mock name='mock.cursor()' id='140098039671824'>)

    def test_batch_operations(self, postgres_saver, mock_connection):
        """Тест пакетных операций"""
        if not POSTGRES_SAVER_AVAILABLE:
            return
    
        mock_conn, mock_cursor = mock_connection
        postgres_saver.connection = mock_conn
    
        large_dataset = [
            {'id': str(i), 'title': f'Job {i}', 'company_name': f'Company {i}'}
            for i in range(1, 101)  # 100 записей
        ]
    
>       postgres_saver.save_vacancies(large_dataset)

tests/test_postgres_saver_coverage.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/storage/postgres_saver.py:707: in save_vacancies
    update_messages = self.add_vacancy_batch_optimized(vacancies)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1de340d0>
vacancies = [{'company_name': 'Company 1', 'id': '1', 'title': 'Job 1'}, {'company_name': 'Company 2', 'id': '2', 'title': 'Job 2'...pany_name': 'Company 5', 'id': '5', 'title': 'Job 5'}, {'company_name': 'Company 6', 'id': '6', 'title': 'Job 6'}, ...]
search_query = None

    def add_vacancy_batch_optimized(
        self, vacancies: Union[Vacancy, List[Vacancy]], search_query: str = None
    ) -> List[str]:
        """
        Максимально оптимизированное batch-добавление вакансий через временные таблицы.
        Использует SQL для всех операций, минимизирует количество запросов.
        """
        if not isinstance(vacancies, list):
            vacancies = [vacancies]
    
        # Исправляем двойную вложенность списков
        if len(vacancies) == 1 and isinstance(vacancies[0], list):
            vacancies = vacancies[0]
            logger.debug(f"Исправлена двойная вложенность списка: получено {len(vacancies)} вакансий")
    
        if not vacancies:
            return []
    
        connection = self._get_connection()
        update_messages: List[str] = []
    
        try:
            cursor = connection.cursor()
    
            # Создаем временную таблицу с такой же структурой как основная таблица vacancies
            cursor.execute(
                """
                CREATE TEMP TABLE temp_new_vacancies AS
                SELECT * FROM vacancies WHERE 1=0
            """
            )
    
            # Получаем сопоставление компаний только по ID
            cursor.execute(
                """
                SELECT id, name, hh_id, sj_id
                FROM companies
            """
            )
    
            company_id_mapping = {}  # hh_id/sj_id -> company_id
    
            results = cursor.fetchall()
            for row in results:
                comp_id, name, hh_id, sj_id = row
    
                # Добавляем только ID-маппинги с приведением к строке
                if hh_id:
                    company_id_mapping[str(hh_id)] = comp_id
                if sj_id:
                    company_id_mapping[str(sj_id)] = comp_id
    
            # Подготавливаем данные для вставки/обновления (все переданные вакансии)
            insert_data = []
            vacancy_company_mapping = {}  # Словарь для сохранения соответствия vacancy_id -> company_id
    
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy: {type(vacancy)} - {vacancy}")
                    continue
    
                # Определяем company_id для связи с таблицей companies
                mapped_company_id = None
                employer_name = None
                employer_id = None
    
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_name = vacancy.employer.get("name", "").strip()
                        employer_id = vacancy.employer.get("id", "").strip()
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_name = vacancy.employer.get_name().strip()
                        employer_id = getattr(vacancy.employer, "id", "").strip()
                    elif hasattr(vacancy.employer, "name"):
                        employer_name = str(getattr(vacancy.employer, "name", "")).strip()
                        employer_id = str(getattr(vacancy.employer, "id", "")).strip()
                    else:
                        employer_name = str(vacancy.employer).strip()
                        employer_id = ""
    
                # Фильтруем ТОЛЬКО по ID компаний (hh_id и sj_id)
                if employer_id:
                    mapped_company_id = company_id_mapping.get(str(employer_id))
    
                # Сохраняем соответствие и устанавливаем company_id
                if mapped_company_id:
                    vacancy_company_mapping[vacancy.vacancy_id] = mapped_company_id
                    vacancy.company_id = mapped_company_id
                    logger.debug(
                        f"Сопоставлено: '{employer_name}' (ID: {employer_id}) -> company_id: {mapped_company_id}"
                    )
    
            # Обрабатываем ВСЕ переданные вакансии
            for vacancy in vacancies:
                # Проверяем, что vacancy действительно объект Vacancy
                if not hasattr(vacancy, "employer"):
                    logger.error(f"Объект не является Vacancy во втором цикле: {type(vacancy)}")
                    continue
    
                mapped_company_id = vacancy_company_mapping.get(vacancy.vacancy_id, None)
    
                # Безопасная обработка salary
                salary_from = None
                salary_to = None
                salary_currency = None
    
                if vacancy.salary:
                    if hasattr(vacancy.salary, "salary_from"):
                        salary_from = vacancy.salary.salary_from
                        salary_to = vacancy.salary.salary_to
                        salary_currency = vacancy.salary.currency
                    elif isinstance(vacancy.salary, dict):
                        salary_from = vacancy.salary.get("from")
                        salary_to = vacancy.salary.get("to")
                        salary_currency = vacancy.salary.get("currency")
                    # Если salary - boolean или что-то другое, оставляем None
    
                # Конвертируем employer в строку для сохранения в БД
                employer_str = None
                if vacancy.employer:
                    if isinstance(vacancy.employer, dict):
                        employer_str = vacancy.employer.get("name", str(vacancy.employer))
                    elif hasattr(vacancy.employer, "get_name"):
                        employer_str = vacancy.employer.get_name()
                    elif hasattr(vacancy.employer, "name"):
                        employer_str = str(getattr(vacancy.employer, "name", ""))
                    else:
                        employer_str = str(vacancy.employer)
    
                # Унифицированная обработка area для сохранения в БД
                try:
                    from utils.data_normalizers import normalize_area_data
                except ImportError:
                    from src.utils.data_normalizers import normalize_area_data
                area_str = normalize_area_data(vacancy.area)
    
                # Обработка полей объектов в строки для БД
                experience_str = None
                if vacancy.experience:
                    if hasattr(vacancy.experience, "get_name"):
                        experience_str = vacancy.experience.get_name()
                    else:
                        experience_str = str(vacancy.experience)
    
                employment_str = None
                if vacancy.employment:
                    if hasattr(vacancy.employment, "get_name"):
                        employment_str = vacancy.employment.get_name()
                    else:
                        employment_str = str(vacancy.employment)
    
                schedule_str = None
                if vacancy.schedule:
                    if hasattr(vacancy.schedule, "get_name"):
                        schedule_str = vacancy.schedule.get_name()
                    else:
                        schedule_str = str(vacancy.schedule)
    
                # Обработка даты published_at
                published_date = self._normalize_published_date(vacancy.published_at)
    
                insert_data.append(
                    (
                        vacancy.vacancy_id,
                        vacancy.title,
                        vacancy.url,
                        salary_from,
                        salary_to,
                        salary_currency,
                        vacancy.description,
                        vacancy.requirements,
                        vacancy.responsibilities,
                        experience_str,
                        employment_str,
                        schedule_str,
                        area_str,
                        vacancy.source,
                        published_date,
                        mapped_company_id,  # Всегда будет не None для целевых компаний
                        search_query,
                    )
                )
    
            # Bulk insert во временную таблицу
            from psycopg2.extras import execute_values
    
            execute_values(
                cursor,
                """INSERT INTO temp_new_vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                ) VALUES %s""",
                insert_data,
                template=None,
                page_size=1000,
            )
    
            # Находим новые вакансии (которых нет в основной таблице)
            cursor.execute(
                """
                INSERT INTO vacancies (
                    vacancy_id, title, url, salary_from, salary_to, salary_currency,
                    description, requirements, responsibilities, experience,
                    employment, schedule, area, source, published_at, company_id, search_query
                )
                SELECT t.vacancy_id, t.title, t.url, t.salary_from, t.salary_to, t.salary_currency,
                       t.description, t.requirements, t.responsibilities, t.experience,
                       t.employment, t.schedule, t.area, t.source, t.published_at, t.company_id, t.search_query
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                WHERE v.vacancy_id IS NULL
            """
            )
    
            new_count = cursor.rowcount
    
            # Находим и обновляем существующие вакансии с изменениями
            cursor.execute(
                """
                UPDATE vacancies v SET
                    title = t.title,
                    url = t.url,
                    description = t.description,
                    experience = t.experience,
                    employment = t.employment,
                    schedule = t.schedule,
                    area = t.area,
                    source = t.source,
                    published_at = t.published_at,
                    company_id = t.company_id,
                    updated_at = CURRENT_TIMESTAMP
                FROM temp_new_vacancies t
                WHERE v.vacancy_id = t.vacancy_id
                AND (
                    v.title != t.title OR
                    v.url != t.url OR
                    v.description != t.description OR
                    COALESCE(v.salary_from, 0) != COALESCE(t.salary_from, 0) OR
                    COALESCE(v.salary_to, 0) != COALESCE(t.salary_to, 0) OR
                    COALESCE(v.salary_currency, '') != COALESCE(t.salary_currency, '') OR
                    COALESCE(v.company_id::text, '') IS DISTINCT FROM COALESCE(t.company_id::text, '') -- Приведение к text для сравнения
                )
            """
            )
    
            updated_count = cursor.rowcount
    
            # Получаем информацию о добавленных и обновленных вакансиях для сообщений
            cursor.execute(
                """
                SELECT t.vacancy_id, t.title,
                       CASE WHEN v.vacancy_id IS NULL THEN 'new' ELSE 'updated' END as action
                FROM temp_new_vacancies t
                LEFT JOIN vacancies v ON t.vacancy_id = v.vacancy_id
                ORDER BY action, t.vacancy_id
                LIMIT 10
            """
            )
    
            results = cursor.fetchall()
            for row in results:
                # Используем индексы вместо ключей для обычного cursor
                vacancy_id, title, action = row[0], row[1], row[2]
                if action == "new":
                    update_messages.append(f"Добавлена новая вакансия ID {vacancy_id}: '{title}'")
                else:
                    update_messages.append(f"Вакансия ID {vacancy_id} обновлена: '{title}'")
    
            # Добавляем сводку если много операций
            total_processed = len(vacancies)
            if total_processed > 10:
>               if new_count > 5:
                   ^^^^^^^^^^^^^
E               TypeError: '>' not supported between instances of 'MagicMock' and 'int'

src/storage/postgres_saver.py:603: TypeError
-------------------------------- Captured log call ---------------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '1', 'title': 'Job 1', 'company_name': 'Company 1'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '2', 'title': 'Job 2', 'company_name': 'Company 2'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '3', 'title': 'Job 3', 'company_name': 'Company 3'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '4', 'title': 'Job 4', 'company_name': 'Company 4'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '5', 'title': 'Job 5', 'company_name': 'Company 5'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '6', 'title': 'Job 6', 'company_name': 'Company 6'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '7', 'title': 'Job 7', 'company_name': 'Company 7'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '8', 'title': 'Job 8', 'company_name': 'Company 8'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '9', 'title': 'Job 9', 'company_name': 'Company 9'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '10', 'title': 'Job 10', 'company_name': 'Company 10'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '11', 'title': 'Job 11', 'company_name': 'Company 11'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '12', 'title': 'Job 12', 'company_name': 'Company 12'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '13', 'title': 'Job 13', 'company_name': 'Company 13'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '14', 'title': 'Job 14', 'company_name': 'Company 14'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '15', 'title': 'Job 15', 'company_name': 'Company 15'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '16', 'title': 'Job 16', 'company_name': 'Company 16'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '17', 'title': 'Job 17', 'company_name': 'Company 17'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '18', 'title': 'Job 18', 'company_name': 'Company 18'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '19', 'title': 'Job 19', 'company_name': 'Company 19'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '20', 'title': 'Job 20', 'company_name': 'Company 20'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '21', 'title': 'Job 21', 'company_name': 'Company 21'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '22', 'title': 'Job 22', 'company_name': 'Company 22'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '23', 'title': 'Job 23', 'company_name': 'Company 23'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '24', 'title': 'Job 24', 'company_name': 'Company 24'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '25', 'title': 'Job 25', 'company_name': 'Company 25'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '26', 'title': 'Job 26', 'company_name': 'Company 26'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '27', 'title': 'Job 27', 'company_name': 'Company 27'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '28', 'title': 'Job 28', 'company_name': 'Company 28'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '29', 'title': 'Job 29', 'company_name': 'Company 29'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '30', 'title': 'Job 30', 'company_name': 'Company 30'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '31', 'title': 'Job 31', 'company_name': 'Company 31'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '32', 'title': 'Job 32', 'company_name': 'Company 32'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '33', 'title': 'Job 33', 'company_name': 'Company 33'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '34', 'title': 'Job 34', 'company_name': 'Company 34'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '35', 'title': 'Job 35', 'company_name': 'Company 35'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '36', 'title': 'Job 36', 'company_name': 'Company 36'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '37', 'title': 'Job 37', 'company_name': 'Company 37'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '38', 'title': 'Job 38', 'company_name': 'Company 38'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '39', 'title': 'Job 39', 'company_name': 'Company 39'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '40', 'title': 'Job 40', 'company_name': 'Company 40'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '41', 'title': 'Job 41', 'company_name': 'Company 41'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '42', 'title': 'Job 42', 'company_name': 'Company 42'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '43', 'title': 'Job 43', 'company_name': 'Company 43'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '44', 'title': 'Job 44', 'company_name': 'Company 44'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '45', 'title': 'Job 45', 'company_name': 'Company 45'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '46', 'title': 'Job 46', 'company_name': 'Company 46'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '47', 'title': 'Job 47', 'company_name': 'Company 47'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '48', 'title': 'Job 48', 'company_name': 'Company 48'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '49', 'title': 'Job 49', 'company_name': 'Company 49'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '50', 'title': 'Job 50', 'company_name': 'Company 50'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '51', 'title': 'Job 51', 'company_name': 'Company 51'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '52', 'title': 'Job 52', 'company_name': 'Company 52'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '53', 'title': 'Job 53', 'company_name': 'Company 53'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '54', 'title': 'Job 54', 'company_name': 'Company 54'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '55', 'title': 'Job 55', 'company_name': 'Company 55'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '56', 'title': 'Job 56', 'company_name': 'Company 56'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '57', 'title': 'Job 57', 'company_name': 'Company 57'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '58', 'title': 'Job 58', 'company_name': 'Company 58'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '59', 'title': 'Job 59', 'company_name': 'Company 59'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '60', 'title': 'Job 60', 'company_name': 'Company 60'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '61', 'title': 'Job 61', 'company_name': 'Company 61'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '62', 'title': 'Job 62', 'company_name': 'Company 62'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '63', 'title': 'Job 63', 'company_name': 'Company 63'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '64', 'title': 'Job 64', 'company_name': 'Company 64'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '65', 'title': 'Job 65', 'company_name': 'Company 65'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '66', 'title': 'Job 66', 'company_name': 'Company 66'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '67', 'title': 'Job 67', 'company_name': 'Company 67'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '68', 'title': 'Job 68', 'company_name': 'Company 68'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '69', 'title': 'Job 69', 'company_name': 'Company 69'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '70', 'title': 'Job 70', 'company_name': 'Company 70'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '71', 'title': 'Job 71', 'company_name': 'Company 71'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '72', 'title': 'Job 72', 'company_name': 'Company 72'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '73', 'title': 'Job 73', 'company_name': 'Company 73'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '74', 'title': 'Job 74', 'company_name': 'Company 74'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '75', 'title': 'Job 75', 'company_name': 'Company 75'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '76', 'title': 'Job 76', 'company_name': 'Company 76'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '77', 'title': 'Job 77', 'company_name': 'Company 77'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '78', 'title': 'Job 78', 'company_name': 'Company 78'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '79', 'title': 'Job 79', 'company_name': 'Company 79'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '80', 'title': 'Job 80', 'company_name': 'Company 80'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '81', 'title': 'Job 81', 'company_name': 'Company 81'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '82', 'title': 'Job 82', 'company_name': 'Company 82'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '83', 'title': 'Job 83', 'company_name': 'Company 83'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '84', 'title': 'Job 84', 'company_name': 'Company 84'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '85', 'title': 'Job 85', 'company_name': 'Company 85'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '86', 'title': 'Job 86', 'company_name': 'Company 86'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '87', 'title': 'Job 87', 'company_name': 'Company 87'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '88', 'title': 'Job 88', 'company_name': 'Company 88'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '89', 'title': 'Job 89', 'company_name': 'Company 89'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '90', 'title': 'Job 90', 'company_name': 'Company 90'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '91', 'title': 'Job 91', 'company_name': 'Company 91'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '92', 'title': 'Job 92', 'company_name': 'Company 92'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '93', 'title': 'Job 93', 'company_name': 'Company 93'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '94', 'title': 'Job 94', 'company_name': 'Company 94'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '95', 'title': 'Job 95', 'company_name': 'Company 95'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '96', 'title': 'Job 96', 'company_name': 'Company 96'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '97', 'title': 'Job 97', 'company_name': 'Company 97'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '98', 'title': 'Job 98', 'company_name': 'Company 98'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '99', 'title': 'Job 99', 'company_name': 'Company 99'}
ERROR    src.storage.postgres_saver:postgres_saver.py:389 Объект не является Vacancy: <class 'dict'> - {'id': '100', 'title': 'Job 100', 'company_name': 'Company 100'}
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
ERROR    src.storage.postgres_saver:postgres_saver.py:427 Объект не является Vacancy во втором цикле: <class 'dict'>
__________________ TestFileCacheRealMethods.test_cache_expiration __________________

self = <tests.test_real_components_coverage.TestFileCacheRealMethods object at 0x7f6b1ef09310>
temp_cache_dir = '/tmp/tmp1785fh_v'

    def test_cache_expiration(self, temp_cache_dir):
        """Тест истечения срока действия кэша"""
        if not CACHE_AVAILABLE:
            return
    
        # Создаем кэш с очень коротким TTL
>       cache = FileCache(cache_dir=temp_cache_dir, ttl_seconds=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: FileCache.__init__() got an unexpected keyword argument 'ttl_seconds'

tests/test_real_components_coverage.py:273: TypeError
__________ TestIntegrationWithRealClasses.test_cache_with_api_integration __________

self = <tests.test_real_components_coverage.TestIntegrationWithRealClasses object at 0x7f6b1ef10650>

    def test_cache_with_api_integration(self):
        """Тест интеграции кэша с API"""
        if not CACHE_AVAILABLE:
            return
    
        with tempfile.TemporaryDirectory() as temp_dir:
            cache = FileCache(cache_dir=temp_dir)
    
            # Симулируем работу с API через кэш
            api_response = {
                "items": [
                    {"id": "1", "title": "Python Developer"},
                    {"id": "2", "title": "Java Developer"}
                ],
                "found": 2
            }
    
            # Сохраняем ответ API в кэш
            cache.save_response("hh", {"text": "developer"}, api_response)
    
            # Загружаем из кэша
            cached_response = cache.load_response("hh", {"text": "developer"})
    
            if cached_response is not None:
>               assert cached_response["found"] == 2
                       ^^^^^^^^^^^^^^^^^^^^^^^^
E               KeyError: 'found'

tests/test_real_components_coverage.py:424: KeyError
_____________ TestSimpleDBAdapterCoverage.test_connect_method_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1edd3d10>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d869ad0>

    def test_connect_method_coverage(self, adapter):
        """Тест метода подключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем успешное подключение
        with patch('psycopg2.connect') as mock_connect:
            mock_connect.return_value = Mock()
>           result = adapter.connect()
                     ^^^^^^^^^^^^^^^
E           AttributeError: 'SimpleDBAdapter' object has no attribute 'connect'

tests/test_simple_db_coverage.py:81: AttributeError
___________ TestSimpleDBAdapterCoverage.test_disconnect_method_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede00d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d9da8d0>

    def test_disconnect_method_coverage(self, adapter):
        """Тест метода отключения"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       adapter.disconnect()
        ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SimpleDBAdapter' object has no attribute 'disconnect'

tests/test_simple_db_coverage.py:89: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_execute_query_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede0710>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d8bf950>

    def test_execute_query_coverage(self, adapter):
        """Тест выполнения запросов"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        test_queries = [
            "SELECT * FROM vacancies",
            "INSERT INTO vacancies (id, title) VALUES (1, 'test')",
            "UPDATE vacancies SET title='new' WHERE id=1",
            "DELETE FROM vacancies WHERE id=1"
        ]
    
        for query in test_queries:
>           with patch.object(adapter, 'db') as mock_db:

tests/test_simple_db_coverage.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1dd97690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d8bf950> does not have the attribute 'db'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestSimpleDBAdapterCoverage.test_save_vacancy_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede0d50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1edcc250>

    def test_save_vacancy_coverage(self, adapter):
        """Тест сохранения вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '1',
            'title': 'Test Job',
            'description': 'Test description',
            'salary': 100000,
            'company': 'Test Company'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1efa9550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1edcc250> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestSimpleDBAdapterCoverage.test_save_vacancies_bulk_coverage ___________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede1390>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1da05b10>

    def test_save_vacancies_bulk_coverage(self, adapter):
        """Тест массового сохранения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Job 1'},
            {'id': '2', 'title': 'Job 2'},
            {'id': '3', 'title': 'Job 3'}
        ]
    
>       with patch.object(adapter, 'save_vacancy') as mock_save:

tests/test_simple_db_coverage.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1de10fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1da05b10> does not have the attribute 'save_vacancy'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_vacancies_coverage ______________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede19d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d7ff910>

    def test_get_vacancies_coverage(self, adapter):
        """Тест получения вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1d7fd310>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d7ff910> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
____________ TestSimpleDBAdapterCoverage.test_search_vacancies_coverage ____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede2010>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d9e8ad0>

    def test_search_vacancies_coverage(self, adapter):
        """Тест поиска вакансий"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 100000,
            'max_salary': 200000,
            'location': 'Москва'
        }
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1d9e8050>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d9e8ad0> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_delete_vacancy_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede2650>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d831550>

    def test_delete_vacancy_coverage(self, adapter):
        """Тест удаления вакансии"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1d832d90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1d831550> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestSimpleDBAdapterCoverage.test_clear_all_coverage ________________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede2c50>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1dfb6690>

    def test_clear_all_coverage(self, adapter):
        """Тест очистки всех данных"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1dfb4310>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1dfb6690> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_get_statistics_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede3290>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1daeae10>

    def test_get_statistics_coverage(self, adapter):
        """Тест получения статистики"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
>       with patch.object(adapter, 'execute_query') as mock_execute:

tests/test_simple_db_coverage.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1dfcd850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1daeae10> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestSimpleDBAdapterCoverage.test_error_handling_coverage _____________

self = <tests.test_simple_db_coverage.TestSimpleDBAdapterCoverage object at 0x7f6b1ede38d0>
adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1db56f90>

    def test_error_handling_coverage(self, adapter):
        """Тест обработки ошибок"""
        if not SIMPLE_DB_AVAILABLE:
            return
    
        # Тестируем обработку ошибок базы данных
>       with patch.object(adapter, 'execute_query', side_effect=Exception("DB Error")):

tests/test_simple_db_coverage.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1db562d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1db56f90> does not have the attribute 'execute_query'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestSuperJobAPIComplete.test_deduplicate_vacancies ________________

self = <tests.test_sj_api_complete.TestSuperJobAPIComplete object at 0x7f6b1ee0fcd0>
sj_api = <src.api_modules.sj_api.SuperJobAPI object at 0x7f6b1da5aa10>

    def test_deduplicate_vacancies(self, sj_api):
        """Тест дедупликации вакансий"""
        mock_vacancies = [
            {"id": "1", "profession": "Test 1"},
            {"id": "2", "profession": "Test 2"}
        ]
    
>       with patch('src.api_modules.cached_api.CachedAPI._deduplicate_vacancies', return_value=mock_vacancies):

tests/test_sj_api_complete.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1d9e4cd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.api_modules.cached_api.CachedAPI'> does not have the attribute '_deduplicate_vacancies'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPostgresSaver.test_save_vacancies_batch ____________________

self = <tests.test_storage_components_complete.TestPostgresSaver object at 0x7f6b1eea4c50>
postgres_saver = <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1cf86ed0>

    def test_save_vacancies_batch(self, postgres_saver):
        """Тест пакетного сохранения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancies = [
            {"id": "1", "title": "Dev 1"},
            {"id": "2", "title": "Dev 2"}
        ]
    
>       with patch.object(postgres_saver, 'save', return_value=True) as mock_save:

tests/test_storage_components_complete.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1cf29750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.postgres_saver.PostgresSaver object at 0x7f6b1cf86ed0> does not have the attribute 'save'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________________ TestSimpleDBAdapter.test_insert_vacancy ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f6b1eea5e90>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1cfcdb90>

    def test_insert_vacancy(self, db_adapter):
        """Тест вставки вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
        vacancy = {"id": "123", "title": "Test"}
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1cfcd950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1cfcdb90> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestSimpleDBAdapter.test_get_vacancies ______________________

self = <tests.test_storage_components_complete.TestSimpleDBAdapter object at 0x7f6b1eea6510>
db_adapter = <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1ddc9f10>

    def test_get_vacancies(self, db_adapter):
        """Тест получения вакансий"""
        if not STORAGE_COMPONENTS_AVAILABLE:
            pytest.skip("Storage components not available")
    
>       with patch.object(db_adapter, '_connection') as mock_conn:

tests/test_storage_components_complete.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7f6b1ddcb4d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.storage.simple_db_adapter.SimpleDBAdapter object at 0x7f6b1ddc9f10> does not have the attribute '_connection'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestStorageIntegration.test_repository_with_validator_integration _________

self = <tests.test_storage_components_complete.TestStorageIntegration object at 0x7f6b1eeada50>

    def test_repository_with_validator_integration(self):
        """Тест интеграции Repository с Validator"""
        if not STORAGE_SUBCOMPONENTS_AVAILABLE:
            pytest.skip("Storage subcomponents not available")
    
        # Создаем моки с правильными context managers
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = Mock()
        mock_connection.cursor.return_value.__enter__ = Mock(return_value=mock_cursor)
        mock_connection.cursor.return_value.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value.__exit__.return_value = None
>       mock_connection.__enter__.return_value = mock_connection
        ^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_components_complete.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock id='140098041237328'>, name = '__enter__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __enter__

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:655: AttributeError
______ TestVacancyStorageServiceCoverage.test_storage_service_initialization _______

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f6b1eebdd90>

    def test_storage_service_initialization(self):
        """Тест инициализации сервиса хранилища"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        mock_db = Mock()
>       service = VacancyStorageService(mock_db)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_storage_components_coverage.py:71: TypeError
____________ TestVacancyStorageServiceCoverage.test_save_vacancy_method ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f6b1eebe110>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6b1da5f690>

    def test_save_vacancy_method(self, storage_service):
        """Тест сохранения вакансии"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Python Developer',
            'company': 'TechCorp',
            'salary': 100000
        }
    
>       storage_service.save_vacancy(vacancy_data)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'save_vacancy'

tests/test_storage_components_coverage.py:86: AttributeError
___________ TestVacancyStorageServiceCoverage.test_search_functionality ____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f6b1eebf350>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6b1e09b450>

    def test_search_functionality(self, storage_service):
        """Тест функций поиска"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        search_params = {
            'keyword': 'python',
            'min_salary': 80000,
            'max_salary': 150000
        }
    
>       result = storage_service.search_vacancies(search_params)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'search_vacancies'

tests/test_storage_components_coverage.py:121: AttributeError
_____________ TestVacancyStorageServiceCoverage.test_delete_operations _____________

self = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage object at 0x7f6b1eebf990>
storage_service = <tests.test_storage_components_coverage.TestVacancyStorageServiceCoverage.storage_service.<locals>.ConcreteVacancyStorageService object at 0x7f6b1d9bb810>

    def test_delete_operations(self, storage_service):
        """Тест операций удаления"""
        if not VACANCY_STORAGE_SERVICE_AVAILABLE:
            return
    
        # Удаление по ID
        storage_service.delete_vacancy('123')
    
        # Очистка всех данных
>       storage_service.clear_all()
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ConcreteVacancyStorageService' object has no attribute 'clear_all'

tests/test_storage_components_coverage.py:133: AttributeError
__________ TestDeduplicationServiceCoverage.test_remove_duplicates_basic ___________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f6b1ecd48d0>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f6b1dcd7790>

    def test_remove_duplicates_basic(self, dedup_service):
        """Тест базового удаления дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies_with_duplicates = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp'},  # Дубликат
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp'},
            {'id': '3', 'title': 'C++ Developer', 'company': 'CPPCorp'}
        ]
    
>       result = dedup_service.remove_duplicates(vacancies_with_duplicates)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'remove_duplicates'

tests/test_storage_components_coverage.py:167: AttributeError
_________ TestDeduplicationServiceCoverage.test_remove_duplicates_by_field _________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f6b1ecd4f10>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f6b1eebef90>

    def test_remove_duplicates_by_field(self, dedup_service):
        """Тест удаления дубликатов по конкретному полю"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        vacancies = [
            {'id': '1', 'title': 'Developer', 'url': 'https://job1.com'},
            {'id': '2', 'title': 'Developer', 'url': 'https://job1.com'},  # Дубликат по URL
            {'id': '3', 'title': 'Analyst', 'url': 'https://job2.com'}
        ]
    
>       result = dedup_service.deduplicate_by_field(vacancies, 'url')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_by_field'

tests/test_storage_components_coverage.py:181: AttributeError
____________ TestDeduplicationServiceCoverage.test_identify_duplicates _____________

self = <tests.test_storage_components_coverage.TestDeduplicationServiceCoverage object at 0x7f6b1ecd5590>
dedup_service = <src.storage.services.deduplication_service.DeduplicationService object at 0x7f6b1da96210>

    def test_identify_duplicates(self, dedup_service):
        """Тест идентификации дубликатов"""
        if not DEDUPLICATION_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Job A'},
            {'id': '1', 'title': 'Job A'},  # Точный дубликат
            {'id': '2', 'title': 'Job B'}
        ]
    
>       duplicates = dedup_service.find_duplicates(test_vacancies)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DeduplicationService' object has no attribute 'find_duplicates'

tests/test_storage_components_coverage.py:195: AttributeError
_____________ TestFilteringServiceCoverage.test_filter_by_salary_range _____________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f6b1ecd6490>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6b1da4c7d0>

    def test_filter_by_salary_range(self, filtering_service):
        """Тест фильтрации по диапазону зарплаты"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'salary_from': 80000, 'salary_to': 120000},
            {'id': '2', 'salary_from': 120000, 'salary_to': 160000},
            {'id': '3', 'salary_from': 50000, 'salary_to': 80000},
            {'id': '4', 'salary_from': None, 'salary_to': None}
        ]
    
>       result = filtering_service.filter_by_salary(test_vacancies, min_salary=100000, max_salary=200000)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_salary'

tests/test_storage_components_coverage.py:230: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_keyword ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f6b1ecd6ad0>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6b1d8337d0>

    def test_filter_by_keyword(self, filtering_service):
        """Тест фильтрации по ключевым словам"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'description': 'Python programming'},
            {'id': '2', 'title': 'Java Developer', 'description': 'Java development'},
            {'id': '3', 'title': 'Data Scientist', 'description': 'Python and machine learning'}
        ]
    
>       result = filtering_service.filter_by_keyword(test_vacancies, 'python')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_keyword'

tests/test_storage_components_coverage.py:244: AttributeError
_______________ TestFilteringServiceCoverage.test_filter_by_company ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f6b1eebdc50>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6b1dceb5d0>

    def test_filter_by_company(self, filtering_service):
        """Тест фильтрации по компании"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'company': 'Google', 'title': 'Software Engineer'},
            {'id': '2', 'company': 'Microsoft', 'title': 'Developer'},
            {'id': '3', 'company': 'Apple', 'title': 'iOS Developer'}
        ]
    
>       result = filtering_service.filter_by_company(test_vacancies, 'Google')
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'filter_by_company'

tests/test_storage_components_coverage.py:258: AttributeError
_______________ TestFilteringServiceCoverage.test_complex_filtering ________________

self = <tests.test_storage_components_coverage.TestFilteringServiceCoverage object at 0x7f6b1ecd5350>
filtering_service = <src.storage.services.filtering_service.FilteringService object at 0x7f6b1df21950>

    def test_complex_filtering(self, filtering_service):
        """Тест комплексной фильтрации"""
        if not FILTERING_SERVICE_AVAILABLE:
            return
    
        test_vacancies = [
            {'id': '1', 'title': 'Python Developer', 'company': 'TechCorp', 'salary_from': 100000},
            {'id': '2', 'title': 'Java Developer', 'company': 'JavaCorp', 'salary_from': 90000},
            {'id': '3', 'title': 'Python Engineer', 'company': 'TechCorp', 'salary_from': 120000}
        ]
    
        filters = {
            'keyword': 'python',
            'company': 'TechCorp',
            'min_salary': 95000
        }
    
>       result = filtering_service.apply_multiple_filters(test_vacancies, filters)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'FilteringService' object has no attribute 'apply_multiple_filters'

tests/test_storage_components_coverage.py:278: AttributeError
________________ TestVacancyRepositoryCoverage.test_create_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f6b1ecd7550>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6b1dae8b90>

    def test_create_vacancy(self, repository):
        """Тест создания вакансии"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
        vacancy_data = {
            'id': '123',
            'title': 'Software Developer',
            'description': 'Great opportunity',
            'company': 'TechCorp'
        }
    
>       repository.create(vacancy_data)
        ^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'create'

tests/test_storage_components_coverage.py:316: AttributeError
_______________ TestVacancyRepositoryCoverage.test_get_vacancy_by_id _______________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f6b1ecd78d0>
repository = <src.storage.components.vacancy_repository.VacancyRepository object at 0x7f6b1da94f90>

    def test_get_vacancy_by_id(self, repository):
        """Тест получения вакансии по ID"""
        if not VACANCY_REPOSITORY_AVAILABLE:
            return
    
>       vacancy = repository.get_by_id('123')
                  ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyRepository' object has no attribute 'get_by_id'

tests/test_storage_components_coverage.py:323: AttributeError
________________ TestVacancyRepositoryCoverage.test_update_vacancy _________________

self = <tests.test_storage_components_coverage.TestVacancyRepositoryCoverage object at 0x7f6b1ecd7c90>