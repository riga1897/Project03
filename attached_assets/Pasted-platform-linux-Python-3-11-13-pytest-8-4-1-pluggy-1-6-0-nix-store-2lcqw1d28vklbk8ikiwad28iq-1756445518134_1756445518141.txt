platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0 -- /nix/store/2lcqw1d28vklbk8ikiwad28iq2smwndv-python-wrapped-0.1.0/bin/python3
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 358 items                                                           

tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_hh_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_sj_data_by_salary_range PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_keywords PASSED [  0%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_location PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_experience PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_employment_type PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_by_company PASSED [  1%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_complex_filter_chain PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_empty_filter_results PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_with_empty_data PASSED [  2%]
tests/test_api_data_filter.py::TestAPIDataFilter::test_filter_invalid_data_structure PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_api_initialization PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_valid PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_validate_vacancy_invalid PASSED [  3%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_page_success PASSED [  4%]
tests/test_api_modules.py::TestHeadHunterAPI::test_get_vacancies_empty_response PASSED [  4%]
tests/test_api_modules.py::TestHeadHunterAPI::test_empty_response_structure PASSED [  4%]
tests/test_api_modules.py::TestSuperJobAPI::test_api_initialization_with_custom_key PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_valid PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_validate_vacancy_invalid PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_get_vacancies_page_with_source PASSED [  5%]
tests/test_api_modules.py::TestSuperJobAPI::test_empty_response_structure PASSED [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_full_range ERROR [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_from_only ERROR [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_to_only ERROR [  6%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_none ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_salary_empty_dict ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_rur ERROR [  7%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_usd ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_eur ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_currency_unknown ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_truncate ERROR [  8%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_short ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_text_none ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_date_string ERROR [  9%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_date_none ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_string ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_experience_none ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_employment_type ERROR [ 10%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_schedule ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_dict ERROR [ 11%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_company_name_none ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_tags ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_clean_html_none ERROR [ 12%]
tests/test_base_formatter.py::TestBaseFormatter::test_format_number_thousands ERROR [ 12%]
tests/test_cache.py::TestFileCache::test_cache_initialization PASSED    [ 13%]
tests/test_cache.py::TestFileCache::test_generate_params_hash PASSED    [ 13%]
tests/test_cache.py::TestFileCache::test_generate_params_hash_different_params PASSED [ 13%]
tests/test_cache.py::TestFileCache::test_save_and_load_response FAILED  [ 13%]
tests/test_cache.py::TestFileCache::test_load_response_nonexistent PASSED [ 14%]
tests/test_cache.py::TestFileCache::test_clear_cache_source FAILED      [ 14%]
tests/test_cache.py::TestFileCache::test_clear_cache_all PASSED         [ 14%]
tests/test_cache.py::TestFileCache::test_cache_with_complex_params FAILED [ 15%]
tests/test_cache.py::TestFileCache::test_cache_file_corrupted PASSED    [ 15%]
tests/test_cache.py::TestFileCache::test_cache_unicode_support FAILED   [ 15%]
tests/test_config.py::TestAppConfig::test_default_initialization PASSED [ 15%]
tests/test_config.py::TestAppConfig::test_get_storage_type PASSED       [ 16%]
tests/test_config.py::TestAppConfig::test_set_storage_type_valid PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_set_storage_type_invalid PASSED [ 16%]
tests/test_config.py::TestAppConfig::test_get_db_config PASSED          [ 17%]
tests/test_config.py::TestAppConfig::test_db_config_from_env PASSED     [ 17%]
tests/test_config.py::TestDatabaseConfig::test_default_initialization SKIPPED [ 17%]
tests/test_config.py::TestDatabaseConfig::test_initialization_with_env PASSED [ 17%]
tests/test_config.py::TestDatabaseConfig::test_get_connection_params PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_get_dsn PASSED           [ 18%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_success PASSED [ 18%]
tests/test_config.py::TestDatabaseConfig::test_test_connection_failure PASSED [ 18%]
tests/test_config.py::TestHHAPIConfig::test_initialization SKIPPED      [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_headers PASSED          [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_vacancies_url PASSED    [ 19%]
tests/test_config.py::TestHHAPIConfig::test_get_employers_url PASSED    [ 20%]
tests/test_config.py::TestHHAPIConfig::test_get_areas_url PASSED        [ 20%]
tests/test_config.py::TestHHAPIConfig::test_get_request_params PASSED   [ 20%]
tests/test_config.py::TestSJAPIConfig::test_initialization PASSED       [ 20%]
tests/test_config.py::TestSJAPIConfig::test_initialization_with_secret_key PASSED [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_without_key PASSED [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_headers_with_key PASSED [ 21%]
tests/test_config.py::TestSJAPIConfig::test_get_vacancies_url PASSED    [ 22%]
tests/test_config.py::TestSJAPIConfig::test_set_secret_key PASSED       [ 22%]
tests/test_config.py::TestSJAPIConfig::test_is_configured PASSED        [ 22%]
tests/test_config.py::TestSJAPIConfig::test_get_request_params PASSED   [ 22%]
tests/test_db_manager.py::TestDBManager::test_get_connection_success PASSED [ 23%]
tests/test_db_manager.py::TestDBManager::test_get_connection_failure PASSED [ 23%]
tests/test_db_manager.py::TestDBManager::test_create_tables_success FAILED [ 23%]
tests/test_db_manager.py::TestDBManager::test_populate_companies_table FAILED [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_companies_and_vacancies_count FAILED [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_all_vacancies FAILED  [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary PASSED     [ 24%]
tests/test_db_manager.py::TestDBManager::test_get_avg_salary_no_data PASSED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary FAILED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword FAILED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_keyword_empty PASSED [ 25%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats PASSED [ 26%]
tests/test_db_manager.py::TestDBManager::test_get_database_stats_error PASSED [ 26%]
tests/test_db_manager.py::TestDBManager::test_check_connection_success FAILED [ 26%]
tests/test_db_manager.py::TestDBManager::test_check_connection_failure PASSED [ 27%]
tests/test_db_manager.py::TestDBManager::test_is_target_company_match PASSED [ 27%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_initialization PASSED [ 27%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_run_full_demo PASSED [ 27%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_get_db_manager_creation PASSED [ 28%]
tests/test_db_manager_demo.py::TestDBManagerDemo::test_display_database_stats PASSED [ 28%]
tests/test_decorators.py::TestDecorators::test_simple_cache_basic_functionality PASSED [ 28%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_ttl PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_simple_cache_max_size PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_kwargs PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_cache_clear_function PASSED [ 29%]
tests/test_decorators.py::TestDecorators::test_cache_info_function PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_simple_cache_with_env_variables PASSED [ 30%]
tests/test_decorators.py::TestDecorators::test_cache_with_complex_arguments FAILED [ 30%]
tests/test_env_loader.py::TestEnvLoader::test_load_env_file_exists FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_load_env_file_not_exists FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_valid FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_with_quotes FAILED [ 31%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_invalid FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_parse_env_line_comment FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_set_environment_variable FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable FAILED [ 32%]
tests/test_env_loader.py::TestEnvLoader::test_get_environment_variable_with_default FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_load_environment_variables FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_success FAILED [ 33%]
tests/test_env_loader.py::TestEnvLoader::test_validate_required_env_vars_missing FAILED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_json_data PASSED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_json_data PASSED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_nonexistent_json_file PASSED [ 34%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_empty_json_file PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_read_invalid_json_file PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_write_creates_directory PASSED [ 35%]
tests/test_file_handlers.py::TestJSONFileHandler::test_atomic_write_on_error PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_cache_clearing_on_write PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_global_json_handler_instance PASSED [ 36%]
tests/test_file_handlers.py::TestJSONFileHandler::test_caching_behavior PASSED [ 36%]
tests/test_integration.py::TestAPIIntegration::test_hh_api_search_integration PASSED [ 37%]
tests/test_integration.py::TestAPIIntegration::test_sj_api_search_integration PASSED [ 37%]
tests/test_integration.py::TestStorageIntegration::test_postgres_saver_integration PASSED [ 37%]
tests/test_integration.py::TestCacheIntegration::test_cached_api_integration PASSED [ 37%]
tests/test_integration.py::TestFullWorkflowIntegration::test_search_and_save_workflow PASSED [ 38%]
tests/test_integration.py::TestFullWorkflowIntegration::test_error_handling_integration PASSED [ 38%]
tests/test_integration.py::TestFullWorkflowIntegration::test_data_consistency_integration PASSED [ 38%]
tests/test_menu_manager.py::TestMenuManager::test_menu_manager_initialization PASSED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_valid FAILED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_invalid_then_valid FAILED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_display_menu_items FAILED [ 39%]
tests/test_menu_manager.py::TestMenuManager::test_get_user_choice_exit FAILED [ 40%]
tests/test_paginator.py::TestPaginator::test_paginator_initialization FAILED [ 40%]
tests/test_paginator.py::TestPaginator::test_get_current_page_data FAILED [ 40%]
tests/test_paginator.py::TestPaginator::test_next_page FAILED           [ 41%]
tests/test_paginator.py::TestPaginator::test_next_page_at_end FAILED    [ 41%]
tests/test_paginator.py::TestPaginator::test_previous_page FAILED       [ 41%]
tests/test_paginator.py::TestPaginator::test_previous_page_at_start FAILED [ 41%]
tests/test_paginator.py::TestPaginator::test_go_to_page_valid FAILED    [ 42%]
tests/test_paginator.py::TestPaginator::test_go_to_page_invalid FAILED  [ 42%]
tests/test_paginator.py::TestPaginator::test_empty_data FAILED          [ 42%]
tests/test_paginator.py::TestPaginator::test_single_page_data FAILED    [ 43%]
tests/test_paginator.py::TestPaginator::test_page_info FAILED           [ 43%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_full_data PASSED [ 43%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_minimal_data PASSED [ 43%]
tests/test_parsers.py::TestHHParser::test_parse_vacancy_no_salary PASSED [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_company_data FAILED     [ 44%]
tests/test_parsers.py::TestHHParser::test_parse_companies_list FAILED   [ 44%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_full_data PASSED [ 44%]
tests/test_parsers.py::TestSuperJobParser::test_parse_vacancy_minimal_data PASSED [ 45%]
tests/test_parsers.py::TestSuperJobParser::test_parse_companies_list FAILED [ 45%]
tests/test_postgres_saver.py::TestPostgresSaver::test_initialization ERROR [ 45%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_success ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_empty_list ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies_database_error ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_all_vacancies ERROR [ 46%]
tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_count ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found ERROR [ 47%]
tests/test_postgres_saver.py::TestPostgresSaver::test_filter_vacancies_by_salary ERROR [ 48%]
tests/test_postgres_saver.py::TestPostgresSaver::test_search_vacancies_by_keyword ERROR [ 48%]
tests/test_salary.py::TestSalary::test_salary_initialization_with_range FAILED [ 48%]
tests/test_salary.py::TestSalary::test_salary_initialization_from_only FAILED [ 48%]
tests/test_salary.py::TestSalary::test_salary_initialization_to_only FAILED [ 49%]
tests/test_salary.py::TestSalary::test_salary_initialization_none_values FAILED [ 49%]
tests/test_salary.py::TestSalary::test_salary_from_dict_complete FAILED [ 49%]
tests/test_salary.py::TestSalary::test_salary_from_dict_partial FAILED  [ 50%]
tests/test_salary.py::TestSalary::test_salary_from_dict_none FAILED     [ 50%]
tests/test_salary.py::TestSalary::test_salary_from_dict_empty FAILED    [ 50%]
tests/test_salary.py::TestSalary::test_salary_to_dict FAILED            [ 50%]
tests/test_salary.py::TestSalary::test_salary_to_dict_partial FAILED    [ 51%]
tests/test_salary.py::TestSalary::test_salary_average_with_both_values FAILED [ 51%]
tests/test_salary.py::TestSalary::test_salary_average_from_only FAILED  [ 51%]
tests/test_salary.py::TestSalary::test_salary_average_to_only FAILED    [ 51%]
tests/test_salary.py::TestSalary::test_salary_average_none_values FAILED [ 52%]
tests/test_salary.py::TestSalary::test_salary_comparison_greater FAILED [ 52%]
tests/test_salary.py::TestSalary::test_salary_comparison_less FAILED    [ 52%]
tests/test_salary.py::TestSalary::test_salary_comparison_equal FAILED   [ 53%]
tests/test_salary.py::TestSalary::test_salary_comparison_with_none FAILED [ 53%]
tests/test_salary.py::TestSalary::test_salary_string_representation_full FAILED [ 53%]
tests/test_salary.py::TestSalary::test_salary_string_representation_from_only FAILED [ 53%]
tests/test_salary.py::TestSalary::test_salary_string_representation_none FAILED [ 54%]
tests/test_salary.py::TestSalary::test_salary_is_specified FAILED       [ 54%]
tests/test_salary.py::TestSalary::test_salary_currency_conversion FAILED [ 54%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_title_match FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_description_match FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_requirements_match FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_responsibilities_match FAILED [ 55%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_detailed_description_match FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_skills_match FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_case_insensitive FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_no_matches FAILED [ 56%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_relevance_scoring FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_true FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_false FAILED [ 57%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_title FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_requirements FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_responsibilities FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_description FAILED [ 58%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_detailed_description FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_vacancy_contains_keyword_in_skills FAILED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_empty_list PASSED [ 59%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_empty_keyword FAILED [ 60%]
tests/test_search_utils.py::TestSearchUtils::test_filter_vacancies_by_keyword_none_fields FAILED [ 60%]
tests/test_source_manager.py::TestSourceManager::test_source_manager_initialization PASSED [ 60%]
tests/test_source_manager.py::TestSourceManager::test_get_available_sources PASSED [ 60%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_hh PASSED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_sj PASSED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_get_source_config_invalid PASSED [ 61%]
tests/test_source_manager.py::TestSourceManager::test_is_source_available_true PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_is_source_available_false PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_get_source_display_name PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_get_source_api_limits PASSED [ 62%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_hh PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_sj_valid PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_validate_source_credentials_sj_invalid PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_get_source_priority PASSED [ 63%]
tests/test_source_manager.py::TestSourceManager::test_sort_sources_by_priority PASSED [ 64%]
tests/test_source_manager.py::TestSourceManager::test_get_source_features PASSED [ 64%]
tests/test_source_selector.py::TestSourceSelector::test_source_selector_initialization FAILED [ 64%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_single FAILED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_all FAILED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_exit PASSED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_get_user_source_choice_invalid_then_valid FAILED [ 65%]
tests/test_source_selector.py::TestSourceSelector::test_display_sources_info PASSED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_get_available_sources FAILED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_validate_source_choice FAILED [ 66%]
tests/test_source_selector.py::TestSourceSelector::test_get_source_name_by_choice FAILED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_is_source_available FAILED [ 67%]
tests/test_source_selector.py::TestSourceSelector::test_display_source_menu FAILED [ 67%]
tests/test_storage.py::TestPostgresSaver::test_postgres_saver_initialization PASSED [ 67%]
tests/test_storage.py::TestPostgresSaver::test_get_connection PASSED    [ 68%]
tests/test_storage.py::TestPostgresSaver::test_add_vacancy_with_sample_data PASSED [ 68%]
tests/test_storage.py::TestPostgresSaver::test_ensure_database_exists PASSED [ 68%]
tests/test_storage.py::TestPostgresSaver::test_format_vacancy_data PASSED [ 68%]
tests/test_storage.py::TestStorageFactory::test_get_storage_postgres PASSED [ 69%]
tests/test_storage.py::TestStorageFactory::test_get_storage_invalid_type PASSED [ 69%]
tests/test_storage.py::TestStorageFactory::test_get_storage_missing_config PASSED [ 69%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_valid PASSED [ 70%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_invalid_then_valid PASSED [ 70%]
tests/test_ui_helpers.py::TestUIHelpers::test_get_positive_integer_non_numeric PASSED [ 70%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_title PASSED [ 70%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_in_description PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_case_insensitive PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_filter_vacancies_by_keyword_no_matches PASSED [ 71%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_both_values PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_min PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_only_max PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_single_value PASSED [ 72%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_invalid_format PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_empty_string PASSED [ 73%]
tests/test_ui_helpers.py::TestUIHelpers::test_parse_salary_range_with_spaces PASSED [ 73%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_empty_items FAILED [ 74%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_single_page FAILED [ 74%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_multiple_pages FAILED [ 74%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_next FAILED [ 74%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_navigation_previous FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_quit_immediately FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_invalid_input FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_custom_items_per_page FAILED [ 75%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_last_page_boundary FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_first_page_boundary FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_display_format FAILED [ 76%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_edge_case_zero_items_per_page FAILED [ 77%]
tests/test_ui_navigation.py::TestUINavigation::test_quick_paginate_string_items FAILED [ 77%]
tests/test_unified_api.py::TestUnifiedAPI::test_initialization PASSED   [ 77%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_all_sources FAILED [ 77%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_hh FAILED [ 78%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_sj FAILED [ 78%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_vacancies_from_source_unknown PASSED [ 78%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_all_sources FAILED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_source_hh PASSED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_companies_from_source_sj PASSED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_search_with_multiple_keywords PASSED [ 79%]
tests/test_unified_api.py::TestUnifiedAPI::test_get_available_sources PASSED [ 80%]
tests/test_unified_api.py::TestUnifiedAPI::test_api_error_handling PASSED [ 80%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_handler_initialization PASSED [ 80%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_empty PASSED [ 81%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_with_data PASSED [ 81%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_empty PASSED [ 81%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_with_data PASSED [ 81%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_found FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_not_found FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_empty_query FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_by_keyword_no_saved_vacancies FAILED [ 82%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_handler_has_vacancy_operations PASSED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_handler_storage_integration PASSED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_by_salary_user_cancellation PASSED [ 83%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_all_saved_vacancies_exception_handling PASSED [ 84%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_handler_methods_exist PASSED [ 84%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_no_salary_data PASSED [ 84%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_search_saved_vacancies_exception_handling FAILED [ 84%]
tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_show_top_vacancies_exception_handling PASSED [ 85%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief PASSED [ 85%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_number PASSED [ 85%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_no_salary PASSED [ 86%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_brief_partial_salary PASSED [ 86%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_dict PASSED [ 86%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_object PASSED [ 86%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_display_vacancy_info PASSED [ 87%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_dict PASSED [ 87%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_company_info PASSED [ 87%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_company_name PASSED [ 87%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_salary_info PASSED [ 88%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_description PASSED [ 88%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_responsibilities PASSED [ 88%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_requirements PASSED [ 89%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_extract_conditions PASSED [ 89%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines PASSED [ 89%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_build_vacancy_lines_with_api_url PASSED [ 89%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_object PASSED [ 90%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_with_dict PASSED [ 90%]
tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_salary_none PASSED [ 90%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_with_dict_salary PASSED [ 91%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_creation_without_salary PASSED [ 91%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_string_representation PASSED [ 91%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison PASSED [ 91%]
tests/test_vacancy_models.py::TestVacancy::test_vacancy_equality PASSED [ 92%]
tests/test_vacancy_models.py::TestSalary::test_salary_creation_from_dict PASSED [ 92%]
tests/test_vacancy_models.py::TestSalary::test_salary_string_representation PASSED [ 92%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_from PASSED  [ 93%]
tests/test_vacancy_models.py::TestSalary::test_salary_only_to PASSED    [ 93%]
tests/test_vacancy_models.py::TestSalary::test_salary_comparison PASSED [ 93%]
tests/test_vacancy_models.py::TestSalary::test_source_detection_from_dict PASSED [ 93%]
tests/test_vacancy_models.py::TestSalary::test_source_fallback_detection PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_get_vacancies_with_salary PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_sort_vacancies_by_salary PASSED [ 94%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_filter_vacancies_by_multiple_keywords PASSED [ 95%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_and_operator PASSED [ 95%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_or_operator PASSED [ 95%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_search_vacancies_advanced_simple_query PASSED [ 96%]
tests/test_vacancy_operations.py::TestVacancyOperations::test_vacancy_operations_basic_functionality PASSED [ 96%]
tests/test_vacancy_stats.py::TestVacancyStats::test_get_company_distribution_dict_data PASSED [ 96%]
tests/test_vacancy_stats.py::TestVacancyStats::test_get_company_distribution_vacancy_objects PASSED [ 96%]
tests/test_vacancy_stats.py::TestVacancyStats::test_extract_company_name_hh_format PASSED [ 97%]
tests/test_vacancy_stats.py::TestVacancyStats::test_extract_company_name_sj_format PASSED [ 97%]
tests/test_vacancy_stats.py::TestVacancyStats::test_extract_company_name_vacancy_object PASSED [ 97%]
tests/test_vacancy_stats.py::TestVacancyStats::test_extract_company_name_unknown PASSED [ 98%]
tests/test_vacancy_stats.py::TestVacancyStats::test_extract_company_name_empty_employer PASSED [ 98%]
tests/test_vacancy_stats.py::TestVacancyStats::test_display_company_stats_with_data PASSED [ 98%]
tests/test_vacancy_stats.py::TestVacancyStats::test_display_company_stats_empty_data PASSED [ 98%]
tests/test_vacancy_stats.py::TestVacancyStats::test_display_source_stats PASSED [ 99%]
tests/test_vacancy_stats.py::TestVacancyStats::test_analyze_company_mapping PASSED [ 99%]
tests/test_vacancy_stats.py::TestVacancyStats::test_display_company_mapping_analysis PASSED [ 99%]
tests/test_vacancy_stats.py::TestVacancyStats::test_company_distribution_edge_cases PASSED [100%]

=================================== ERRORS ====================================
______ ERROR at setup of TestBaseFormatter.test_format_salary_full_range ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e5890>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_salary_from_only _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e5ed0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_salary_to_only ________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e6590>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_salary_none _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e6cd0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_salary_empty_dict ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e73d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_rur _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e7ad0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_usd _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f8210>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_currency_eur _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f8910>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_currency_unknown _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f9010>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_text_truncate ________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f96d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_text_short __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9e97d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_text_none __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f8390>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_________ ERROR at setup of TestBaseFormatter.test_format_date_string _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f9ad0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_date_none __________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9f9e50>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_experience_string ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fa1d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_experience_none _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fa590>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
_______ ERROR at setup of TestBaseFormatter.test_format_employment_type _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fabd0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_format_schedule ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fb210>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
________ ERROR at setup of TestBaseFormatter.test_format_company_name _________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fb850>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_company_name_dict ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d9fbe90>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_company_name_none ______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d504510>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_clean_html_tags ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d504b50>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
__________ ERROR at setup of TestBaseFormatter.test_clean_html_none ___________

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d505190>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
______ ERROR at setup of TestBaseFormatter.test_format_number_thousands _______

self = <tests.test_base_formatter.TestBaseFormatter object at 0x7f8b7d5058d0>

    @pytest.fixture
    def formatter(self):
        """Фикстура BaseFormatter"""
>       return BaseFormatter()
               ^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseFormatter with abstract method format_vacancy_info

tests/test_base_formatter.py:16: TypeError
___________ ERROR at setup of TestPostgresSaver.test_initialization ___________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d103690>
mock_db_manager = <Mock id='140237067098640'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c919010>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_______ ERROR at setup of TestPostgresSaver.test_save_vacancies_success _______

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d103c90>
mock_db_manager = <Mock id='140237071295952'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7cd1acd0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_____ ERROR at setup of TestPostgresSaver.test_save_vacancies_empty_list ______

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d114350>
mock_db_manager = <Mock id='140237063110480'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c54aa50>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
___ ERROR at setup of TestPostgresSaver.test_save_vacancies_database_error ____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d114990>
mock_db_manager = <Mock id='140237067738704'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c9b6ed0>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_________ ERROR at setup of TestPostgresSaver.test_get_all_vacancies __________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d114f90>
mock_db_manager = <Mock id='140237063098064'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c54bd10>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
________ ERROR at setup of TestPostgresSaver.test_get_vacancies_count _________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d5f3990>
mock_db_manager = <Mock id='140237067700176'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c9af950>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
____ ERROR at setup of TestPostgresSaver.test_delete_vacancy_by_id_success ____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d114510>
mock_db_manager = <Mock id='140237067252176'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c93d750>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
___ ERROR at setup of TestPostgresSaver.test_delete_vacancy_by_id_not_found ___

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d115690>
mock_db_manager = <Mock id='140237062811408'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c502310>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
_____ ERROR at setup of TestPostgresSaver.test_filter_vacancies_by_salary _____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d115ad0>
mock_db_manager = <Mock id='140237067197008'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c932510>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
____ ERROR at setup of TestPostgresSaver.test_search_vacancies_by_keyword _____

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7f8b7d115e50>
mock_db_manager = <Mock id='140237063014416'>

    @pytest.fixture
    def postgres_saver(self, mock_db_manager):
        """Фикстура PostgresSaver"""
>       saver = PostgresSaver()
                ^^^^^^^^^^^^^^^

tests/test_postgres_saver.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:80: in __init__
    self._ensure_tables_exist()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.postgres_saver.PostgresSaver object at 0x7f8b7c537050>

    def _ensure_tables_exist(self):
        """Создает таблицы если они не существуют"""
        connection = self._get_connection()
        try:
            cursor = connection.cursor()
    
            # Устанавливаем кодировку сессии
            cursor.execute("SET client_encoding TO 'UTF8'")
    
            # Сначала создаем таблицу companies если её нет
            self._ensure_companies_table_exists()
    
            # Создаем таблицу для вакансий с базовой структурой
            create_table_query = """
            CREATE TABLE IF NOT EXISTS vacancies (
                id SERIAL PRIMARY KEY,
                vacancy_id VARCHAR(50) UNIQUE NOT NULL,
                title VARCHAR(500) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """
    
            cursor.execute(create_table_query)
            logger.info("✓ Базовая структура таблицы vacancies проверена")
    
            # Список всех полей, которые должны быть в таблице vacancies
            required_fields = [
                ("url", "TEXT"),
                ("salary_from", "INTEGER"),
                ("salary_to", "INTEGER"),
                ("salary_currency", "VARCHAR(10)"),
                ("description", "TEXT"),
                ("requirements", "TEXT"),
                ("responsibilities", "TEXT"),
                ("experience", "VARCHAR(200)"),
                ("employment", "VARCHAR(200)"),
                ("schedule", "VARCHAR(200)"),
                ("area", "VARCHAR(200)"),
                ("source", "VARCHAR(50) DEFAULT 'unknown'"),
                ("published_at", "TIMESTAMP"),
                ("company_id", "INTEGER"),
            ]
    
            # Проверяем и добавляем недостающие поля
            for field_name, field_type in required_fields:
                cursor.execute(
                    """
                    SELECT column_name, data_type
                    FROM information_schema.columns
                    WHERE table_name = 'vacancies' AND column_name = %s;
                """,
                    (field_name,),
                )
    
                field_info = cursor.fetchone()
                if not field_info:
                    logger.info(f"Добавляем поле {field_name} в таблицу vacancies...")
                    cursor.execute(f"ALTER TABLE vacancies ADD COLUMN {field_name} {field_type};")
                    logger.info(f"✓ Поле {field_name} добавлено")
>               elif field_name == "company_id" and field_info[1] not in ("integer", "bigint"):
                                                    ^^^^^^^^^^^^^
E               TypeError: 'Mock' object is not subscriptable

src/storage/postgres_saver.py:320: TypeError
================================== FAILURES ===================================
__________________ TestFileCache.test_save_and_load_response __________________

self = <tests.test_cache.TestFileCache object at 0x7f8b7d507f10>
file_cache = <src.utils.cache.FileCache object at 0x7f8b7c934410>

    def test_save_and_load_response(self, file_cache):
        """Тест сохранения и загрузки ответа"""
        source = 'hh'
        params = {'text': 'python', 'area': '1'}
        data = {'items': [{'name': 'Python Developer', 'id': '1'}], 'found': 1}
    
        # Сохраняем в кэш
        file_cache.save_response(source, params, data)
    
        # Получаем из кэша
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:87: AssertionError
____________________ TestFileCache.test_clear_cache_source ____________________

self = <tests.test_cache.TestFileCache object at 0x7f8b7d9f9990>
file_cache = <src.utils.cache.FileCache object at 0x7f8b7c9196d0>

    def test_clear_cache_source(self, file_cache):
        """Тест очистки кэша определенного источника"""
        # Сохраняем кэш для HH
        hh_params = {'text': 'python', 'area': '1'}
        hh_data = {'items': []}
        file_cache.save_response('hh', hh_params, hh_data)
    
        # Сохраняем кэш для SJ
        sj_params = {'text': 'python', 'area': '1'}
        sj_data = {'items': []}
        file_cache.save_response('sj', sj_params, sj_data)
    
        # Очищаем только HH
        file_cache.clear('hh')
    
        # Проверяем, что HH очищен, а SJ остался
        assert file_cache.load_response('hh', hh_params) is None
>       assert file_cache.load_response('sj', sj_params) is not None
E       AssertionError: assert None is not None
E        +  where None = load_response('sj', {'area': '1', 'text': 'python'})
E        +    where load_response = <src.utils.cache.FileCache object at 0x7f8b7c9196d0>.load_response

tests/test_cache.py:117: AssertionError
________________ TestFileCache.test_cache_with_complex_params _________________

self = <tests.test_cache.TestFileCache object at 0x7f8b7d510ed0>
file_cache = <src.utils.cache.FileCache object at 0x7f8b7d1f2dd0>

    def test_cache_with_complex_params(self, file_cache):
        """Тест кэширования со сложными параметрами"""
        source = 'hh'
        params = {
            'text': 'python developer',
            'area': ['1', '2'],  # список
            'salary': 100000,
            'experience': 'between1And3',
            'employment': 'full'
        }
        data = {'items': [], 'found': 0}
    
        # Сохраняем и получаем
        file_cache.save_response(source, params, data)
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:151: AssertionError
__________________ TestFileCache.test_cache_unicode_support ___________________

self = <tests.test_cache.TestFileCache object at 0x7f8b7d511590>
file_cache = <src.utils.cache.FileCache object at 0x7f8b7cda6a10>

    def test_cache_unicode_support(self, file_cache):
        """Тест поддержки Unicode в кэше"""
        source = 'hh'
        params = {'text': 'разработчик python 🐍', 'area': 'Москва'}
        data = {
            'items': [
                {'name': 'Senior Python разработчик 👨‍💻', 'id': '1'}
            ],
            'found': 1
        }
    
        # Сохраняем и получаем
        file_cache.save_response(source, params, data)
        cached_response = file_cache.load_response(source, params)
    
>       assert cached_response is not None
E       assert None is not None

tests/test_cache.py:185: AssertionError
__________________ TestDBManager.test_create_tables_success ___________________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d5368d0>
mock_connect = <MagicMock name='connect' id='140237071507216'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7cd4e750>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_create_tables_success(self, mock_connect, db_manager):
        """Тест успешного создания таблиц"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
>       db_manager.create_tables()

tests/test_db_manager.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7f8b7cd4e750>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
            with self._get_connection() as conn:
                with conn.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Создаем упрощенную таблицу компаний для целевых компаний
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS companies (
                            id SERIAL PRIMARY KEY,
                            name VARCHAR(255) NOT NULL UNIQUE,
                            hh_id VARCHAR(50),
                            sj_id VARCHAR(50)
                        );
                    """
                    )
                    logger.info("✓ Таблица companies создана/проверена")
    
                    # Создаем полную таблицу вакансий сразу с правильными типами
                    cursor.execute(
                        """
                        CREATE TABLE IF NOT EXISTS vacancies (
                            id SERIAL PRIMARY KEY,
                            vacancy_id VARCHAR(255) UNIQUE NOT NULL,
                            title TEXT NOT NULL,
                            url TEXT,
                            salary_from INTEGER,
                            salary_to INTEGER,
                            salary_currency VARCHAR(10),
                            description TEXT,
                            requirements TEXT,
                            responsibilities TEXT,
                            experience VARCHAR(100),
                            employment VARCHAR(100),
                            schedule VARCHAR(100),
                            area TEXT,
                            source VARCHAR(50),
                            published_at TIMESTAMP,
                            company_id INTEGER,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    """
                    )
    
                    # Проверяем и исправляем тип company_id если нужно
                    cursor.execute(
                        """
                        SELECT data_type
                        FROM information_schema.columns
                        WHERE table_name = 'vacancies' AND column_name = 'company_id'
                    """
                    )
    
                    result = cursor.fetchone()
>                   if result and result[0] not in ("integer", "bigint"):
                                  ^^^^^^^^^
E                   TypeError: 'Mock' object is not subscriptable

src/storage/db_manager.py:123: TypeError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_________________ TestDBManager.test_populate_companies_table _________________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d536f90>
mock_connect = <MagicMock name='connect' id='140237067250192'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7c93c350>

    @patch('src.config.target_companies.TARGET_COMPANIES', [
        {"hh_id": "1", "name": "Test Company", "description": "Test Description"}
    ])
    @patch('src.storage.db_manager.psycopg2.connect')
    def test_populate_companies_table(self, mock_connect, db_manager):
        """Тест заполнения таблицы компаний"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем пустую таблицу
        mock_cursor.fetchone.return_value = [0]
    
        db_manager.populate_companies_table()
    
        # Проверяем, что был выполнен INSERT запрос
        insert_calls = [call for call in mock_cursor.execute.call_args_list
                       if 'INSERT INTO companies' in str(call)]
>       assert len(insert_calls) >= 1
E       assert 0 >= 1
E        +  where 0 = len([])

tests/test_db_manager.py:95: AssertionError
____________ TestDBManager.test_get_companies_and_vacancies_count _____________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d537610>
mock_connect = <MagicMock name='connect' id='140237067236944'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7c907510>

    @patch('src.config.target_companies.TARGET_COMPANIES', [
        {"name": "Test Company 1"},
        {"name": "Test Company 2"}
    ])
    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_companies_and_vacancies_count(self, mock_connect, db_manager):
        """Тест получения количества вакансий по компаниям"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса
        mock_cursor.fetchall.return_value = [
            ("Test Company 1", 5),
            ("Test Company 2", 3)
        ]
    
        result = db_manager.get_companies_and_vacancies_count()
    
>       assert len(result) == 2
E       AssertionError: assert 12 == 2
E        +  where 12 = len([('Яндекс', 0), ('Тинькофф', 0), ('СБЕР', 0), ('Wildberries', 0), ('OZON', 0), ('VK', 0), ...])

tests/test_db_manager.py:122: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
____________________ TestDBManager.test_get_all_vacancies _____________________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d537c90>
mock_connect = <MagicMock name='connect' id='140237067072336'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7c911490>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect, db_manager):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса
        mock_cursor.fetchall.return_value = [
            {
                'title': 'Python Developer',
                'company_name': 'Test Company',
                'salary_info': '100000 - 150000 RUR',
                'url': 'https://test.com/vacancy/1',
                'vacancy_id': 'test_1',
                'employer': 'Test Company',
                'area': 'Moscow',
                'company_id': '1'
            }
        ]
    
        result = db_manager.get_all_vacancies()
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:155: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_____________ TestDBManager.test_get_vacancies_with_higher_salary _____________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d545050>
mock_connect = <MagicMock name='connect' id='140237067232208'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7c938f90>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_higher_salary(self, mock_connect, db_manager):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Мокаем get_avg_salary
        with patch.object(db_manager, 'get_avg_salary', return_value=100000.0):
            # Имитируем результат запроса - возвращаем список кортежей
            mock_cursor.fetchall.return_value = [
                ('Senior Python Developer', 'Test Company', '150000 - 200000 RUR',
                 'https://test.com/vacancy/2', 175000.0, 'test_2', 'Test Company')
            ]
    
            result = db_manager.get_vacancies_with_higher_salary()
    
>           assert len(result) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_db_manager.py:222: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
________________ TestDBManager.test_get_vacancies_with_keyword ________________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d545690>
mock_connect = <MagicMock name='connect' id='140237063013968'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7c5343d0>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_get_vacancies_with_keyword(self, mock_connect, db_manager):
        """Тест поиска вакансий по ключевому слову"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        # Имитируем результат запроса - возвращаем список кортежей
        mock_cursor.fetchall.return_value = [
            ('Python Developer', 'Test Company', '100000 - 150000 RUR',
             'https://test.com/vacancy/1', 'Python development position', 'test_1', 'Test Company')
        ]
    
        result = db_manager.get_vacancies_with_keyword('Python')
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:246: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Ошибка при создании таблиц: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'Mock' object is not subscriptable
_________________ TestDBManager.test_check_connection_success _________________

self = <tests.test_db_manager.TestDBManager object at 0x7f8b7d547110>
mock_connect = <MagicMock name='connect' id='140237071599632'>
db_manager = <src.storage.db_manager.DBManager object at 0x7f8b7cd66910>

    @patch('src.storage.db_manager.psycopg2.connect')
    def test_check_connection_success(self, mock_connect, db_manager):
        """Тест успешной проверки подключения"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connect.return_value = mock_connection
        mock_connection.__enter__ = Mock(return_value=mock_connection)
        mock_connection.__exit__ = Mock(return_value=None)
        mock_cursor_context = Mock()
        mock_cursor_context.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor_context.__exit__ = Mock(return_value=None)
        mock_connection.cursor.return_value = mock_cursor_context
    
        result = db_manager.check_connection()
    
>       assert result is True
E       assert False is True

tests/test_db_manager.py:339: AssertionError
---------------------------- Captured stderr call -----------------------------
ERROR:src.storage.db_manager:Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
------------------------------ Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'Mock' object is not subscriptable
______________ TestDecorators.test_cache_with_complex_arguments _______________

self = <tests.test_decorators.TestDecorators object at 0x7f8b7d561050>

    def test_cache_with_complex_arguments(self):
        """Тест кэширования с комплексными аргументами"""
        call_count = 0
    
        @simple_cache()
        def cached_function(data_list, data_dict):
            nonlocal call_count
            call_count += 1
            return sum(data_list) + sum(data_dict.values())
    
        # Первый вызов
>       result1 = cached_function([1, 2, 3], {'a': 4, 'b': 5})
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_decorators.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = ([1, 2, 3], {'a': 4, 'b': 5}), kwargs = {}, actual_ttl = 3600
current_time = 1756445491.6737776
cache_key = (([1, 2, 3], {'a': 4, 'b': 5}), frozenset())

    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # Получаем TTL из переменных окружения или используем переданное значение
        actual_ttl = ttl if ttl is not None else EnvLoader.get_env_var_int("CACHE_TTL", 3600)
        current_time = time.time()
    
        cache_key = (args, frozenset(kwargs.items()))
    
        # Проверяем существующий кэш
>       if cache_key in cache:
           ^^^^^^^^^^^^^^^^^^
E       TypeError: unhashable type: 'list'

src/utils/decorators.py:29: TypeError
___________________ TestEnvLoader.test_load_env_file_exists ___________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d562350>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c50a950>

    def test_load_env_file_exists(self, env_loader):
        """Тест загрузки существующего .env файла"""
        env_content = "TEST_KEY=test_value\nANOTHER_KEY=another_value"
    
        with patch('builtins.open', mock_open(read_data=env_content)):
            with patch('os.path.exists', return_value=True):
                result = env_loader.load_env_file('.env')
>               assert result is True
E               assert {} is True

tests/test_env_loader.py:27: AssertionError
_________________ TestEnvLoader.test_load_env_file_not_exists _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d5626d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c9afc50>

    def test_load_env_file_not_exists(self, env_loader):
        """Тест загрузки несуществующего .env файла"""
        with patch('os.path.exists', return_value=False):
            result = env_loader.load_env_file('.env')
>           assert result is False
E           assert {} is False

tests/test_env_loader.py:33: AssertionError
___________________ TestEnvLoader.test_parse_env_line_valid ___________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d562d10>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c906990>

    def test_parse_env_line_valid(self, env_loader):
        """Тест парсинга корректной строки переменной окружения"""
>       key, value = env_loader.parse_env_line("API_KEY=secret123")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:37: AttributeError
________________ TestEnvLoader.test_parse_env_line_with_quotes ________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d563390>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c9b7f10>

    def test_parse_env_line_with_quotes(self, env_loader):
        """Тест парсинга строки с кавычками"""
>       key, value = env_loader.parse_env_line('DB_URL="postgresql://localhost"')
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:43: AttributeError
__________________ TestEnvLoader.test_parse_env_line_invalid __________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d5639d0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c9c2e90>

    def test_parse_env_line_invalid(self, env_loader):
        """Тест парсинга некорректной строки"""
>       result = env_loader.parse_env_line("INVALID_LINE")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:49: AttributeError
__________________ TestEnvLoader.test_parse_env_line_comment __________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56c050>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c517590>

    def test_parse_env_line_comment(self, env_loader):
        """Тест парсинга комментария"""
>       result = env_loader.parse_env_line("# This is a comment")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'parse_env_line'

tests/test_env_loader.py:54: AttributeError
_________________ TestEnvLoader.test_set_environment_variable _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56c690>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c5209d0>

    def test_set_environment_variable(self, env_loader):
        """Тест установки переменной окружения"""
>       env_loader.set_environment_variable("TEST_VAR", "test_value")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'set_environment_variable'

tests/test_env_loader.py:59: AttributeError
_________________ TestEnvLoader.test_get_environment_variable _________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56ccd0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c9a5490>

    def test_get_environment_variable(self, env_loader):
        """Тест получения переменной окружения"""
        os.environ["TEST_GET_VAR"] = "test_get_value"
    
>       value = env_loader.get_environment_variable("TEST_GET_VAR")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'

tests/test_env_loader.py:70: AttributeError
__________ TestEnvLoader.test_get_environment_variable_with_default ___________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56d310>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7d1e3d50>

    def test_get_environment_variable_with_default(self, env_loader):
        """Тест получения переменной окружения с значением по умолчанию"""
>       value = env_loader.get_environment_variable("NON_EXISTENT_VAR", "default_value")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'get_environment_variable'

tests/test_env_loader.py:78: AttributeError
________________ TestEnvLoader.test_load_environment_variables ________________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56d950>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7c9a75d0>

    @patch.dict(os.environ, {}, clear=True)
    def test_load_environment_variables(self, env_loader):
        """Тест загрузки всех переменных окружения"""
        variables = {
            "VAR1": "value1",
            "VAR2": "value2",
            "VAR3": "value3"
        }
    
>       env_loader.load_environment_variables(variables)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'load_environment_variables'

tests/test_env_loader.py:90: AttributeError
____________ TestEnvLoader.test_validate_required_env_vars_success ____________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56e050>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7cd8d550>

    def test_validate_required_env_vars_success(self, env_loader):
        """Тест валидации обязательных переменных - успешный случай"""
        required_vars = ["PATH"]  # PATH всегда должен существовать
    
>       missing = env_loader.validate_required_env_vars(required_vars)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'

tests/test_env_loader.py:99: AttributeError
____________ TestEnvLoader.test_validate_required_env_vars_missing ____________

self = <tests.test_env_loader.TestEnvLoader object at 0x7f8b7d56e750>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f8b7e53be10>

    def test_validate_required_env_vars_missing(self, env_loader):
        """Тест валидации обязательных переменных - недостающие переменные"""
        required_vars = ["NON_EXISTENT_VAR1", "NON_EXISTENT_VAR2"]
    
>       missing = env_loader.validate_required_env_vars(required_vars)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'EnvLoader' object has no attribute 'validate_required_env_vars'

tests/test_env_loader.py:106: AttributeError
_________________ TestMenuManager.test_get_user_choice_valid __________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f8b7d5df410>
mock_input = <MagicMock name='input' id='140237067068368'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f8b7c9127d0>

    @patch('builtins.input', return_value='1')
    def test_get_user_choice_valid(self, mock_input, menu_manager):
        """Тест получения корректного выбора пользователя"""
        menu_items = ['Item 1', 'Item 2', 'Exit']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:28: AttributeError
___________ TestMenuManager.test_get_user_choice_invalid_then_valid ___________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f8b7d5df950>
mock_print = <MagicMock name='print' id='140237067206352'>
mock_input = <MagicMock name='input' id='140237067669328'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f8b7c9330d0>

    @patch('builtins.input', side_effect=['invalid', '2'])
    @patch('builtins.print')
    def test_get_user_choice_invalid_then_valid(self, mock_print, mock_input, menu_manager):
        """Тест обработки некорректного, а затем корректного выбора"""
        menu_items = ['Item 1', 'Item 2']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:36: AttributeError
___________________ TestMenuManager.test_display_menu_items ___________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f8b7d5dffd0>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f8b7cd10a50>

    def test_display_menu_items(self, menu_manager):
        """Тест отображения элементов меню"""
        menu_items = ['Search', 'View', 'Exit']
        with patch('builtins.print') as mock_print:
>           menu_manager.display_menu(menu_items)
E           TypeError: MenuManager.display_menu() takes 1 positional argument but 2 were given

tests/test_menu_manager.py:43: TypeError
__________________ TestMenuManager.test_get_user_choice_exit __________________

self = <tests.test_menu_manager.TestMenuManager object at 0x7f8b7d5e45d0>
mock_input = <MagicMock name='input' id='140237071814672'>
menu_manager = <src.utils.menu_manager.MenuManager object at 0x7f8b7cd9ae10>

    @patch('builtins.input', return_value='0')
    def test_get_user_choice_exit(self, mock_input, menu_manager):
        """Тест выбора выхода из меню"""
        menu_items = ['Item 1', 'Exit']
>       choice = menu_manager.get_user_choice(menu_items)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'MenuManager' object has no attribute 'get_user_choice'

tests/test_menu_manager.py:51: AttributeError
_________________ TestPaginator.test_paginator_initialization _________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e5990>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_paginator_initialization(self, sample_data):
        """Тест инициализации пагинатора"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:20: TypeError
__________________ TestPaginator.test_get_current_page_data ___________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e6010>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_get_current_page_data(self, sample_data):
        """Тест получения данных текущей страницы"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:28: TypeError
________________________ TestPaginator.test_next_page _________________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e6710>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page(self, sample_data):
        """Тест перехода к следующей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:35: TypeError
_____________________ TestPaginator.test_next_page_at_end _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e6e50>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_next_page_at_end(self, sample_data):
        """Тест перехода к следующей странице на последней странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:43: TypeError
______________________ TestPaginator.test_previous_page _______________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e7550>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page(self, sample_data):
        """Тест перехода к предыдущей странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:50: TypeError
__________________ TestPaginator.test_previous_page_at_start __________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5e7c50>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_previous_page_at_start(self, sample_data):
        """Тест перехода к предыдущей странице на первой странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:57: TypeError
_____________________ TestPaginator.test_go_to_page_valid _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5f0390>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_valid(self, sample_data):
        """Тест перехода к корректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:63: TypeError
____________________ TestPaginator.test_go_to_page_invalid ____________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5f0a90>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_go_to_page_invalid(self, sample_data):
        """Тест перехода к некорректной странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:69: TypeError
________________________ TestPaginator.test_empty_data ________________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5f1150>

    def test_empty_data(self):
        """Тест пагинации с пустыми данными"""
>       paginator = Paginator([], page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:75: TypeError
_____________________ TestPaginator.test_single_page_data _____________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5f17d0>

    def test_single_page_data(self):
        """Тест пагинации с данными на одну страницу"""
        data = [1, 2, 3]
>       paginator = Paginator(data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:83: TypeError
________________________ TestPaginator.test_page_info _________________________

self = <tests.test_paginator.TestPaginator object at 0x7f8b7d5f1ed0>
sample_data = [1, 2, 3, 4, 5, 6, ...]

    def test_page_info(self, sample_data):
        """Тест получения информации о странице"""
>       paginator = Paginator(sample_data, page_size=10)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:89: TypeError
____________________ TestHHParser.test_parse_company_data _____________________

self = <tests.test_parsers.TestHHParser object at 0x7f8b7d5f3ad0>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f8b7d1a1dd0>

    def test_parse_company_data(self, hh_parser):
        """Тест парсинга данных компании"""
        company_data = {
            'id': '123',
            'name': 'TestCompany',
            'description': 'Test Description',
            'alternate_url': 'https://hh.ru/employer/123'
        }
    
>       result = hh_parser.parse_company(company_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_company'

tests/test_parsers.py:104: AttributeError
___________________ TestHHParser.test_parse_companies_list ____________________

self = <tests.test_parsers.TestHHParser object at 0x7f8b7d5f3f50>
hh_parser = <src.vacancies.parsers.hh_parser.HHParser object at 0x7f8b7c95fd10>

    def test_parse_companies_list(self, hh_parser):
        """Тест парсинга списка компаний"""
        companies_data = {
            'items': [
                {'id': '1', 'name': 'Company1'},
                {'id': '2', 'name': 'Company2'}
            ]
        }
    
>       result = hh_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'HHParser' object has no attribute 'parse_companies'

tests/test_parsers.py:119: AttributeError
________________ TestSuperJobParser.test_parse_companies_list _________________

self = <tests.test_parsers.TestSuperJobParser object at 0x7f8b7d101650>
sj_parser = <src.vacancies.parsers.sj_parser.SuperJobParser object at 0x7f8b7d1d7790>

    def test_parse_companies_list(self, sj_parser):
        """Тест парсинга списка компаний SJ"""
        companies_data = {
            'objects': [
                {'id': 101, 'title': 'SJ Company1'},
                {'id': 102, 'title': 'SJ Company2'}
            ]
        }
    
>       result = sj_parser.parse_companies(companies_data)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobParser' object has no attribute 'parse_companies'

tests/test_parsers.py:190: AttributeError
______________ TestSalary.test_salary_initialization_with_range _______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d116f90>

    def test_salary_initialization_with_range(self):
        """Тест инициализации зарплаты с диапазоном"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:15: TypeError
_______________ TestSalary.test_salary_initialization_from_only _______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d1174d0>

    def test_salary_initialization_from_only(self):
        """Тест инициализации зарплаты только с минимумом"""
>       salary = Salary(80000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:22: TypeError
________________ TestSalary.test_salary_initialization_to_only ________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d117ad0>

    def test_salary_initialization_to_only(self):
        """Тест инициализации зарплаты только с максимумом"""
>       salary = Salary(salary_to=200000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:29: TypeError
______________ TestSalary.test_salary_initialization_none_values ______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d120150>

    def test_salary_initialization_none_values(self):
        """Тест инициализации зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:36: TypeError
__________________ TestSalary.test_salary_from_dict_complete __________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d120750>

    def test_salary_from_dict_complete(self):
        """Тест создания зарплаты из полного словаря"""
        salary_dict = {"from": 100000, "to": 150000, "currency": "RUR"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:44: AttributeError
__________________ TestSalary.test_salary_from_dict_partial ___________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d120d50>

    def test_salary_from_dict_partial(self):
        """Тест создания зарплаты из частичного словаря"""
        salary_dict = {"from": 80000, "currency": "USD"}
>       salary = Salary.from_dict(salary_dict)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:52: AttributeError
____________________ TestSalary.test_salary_from_dict_none ____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d121350>

    def test_salary_from_dict_none(self):
        """Тест создания зарплаты из None"""
>       salary = Salary.from_dict(None)
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:59: AttributeError
___________________ TestSalary.test_salary_from_dict_empty ____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d121950>

    def test_salary_from_dict_empty(self):
        """Тест создания зарплаты из пустого словаря"""
>       salary = Salary.from_dict({})
                 ^^^^^^^^^^^^^^^^
E       AttributeError: type object 'Salary' has no attribute 'from_dict'

tests/test_salary.py:66: AttributeError
_______________________ TestSalary.test_salary_to_dict ________________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d121f50>

    def test_salary_to_dict(self):
        """Тест преобразования зарплаты в словарь"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:73: TypeError
___________________ TestSalary.test_salary_to_dict_partial ____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d122510>

    def test_salary_to_dict_partial(self):
        """Тест преобразования частичной зарплаты в словарь"""
>       salary = Salary(80000, currency="USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:81: TypeError
_______________ TestSalary.test_salary_average_with_both_values _______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d122b90>

    def test_salary_average_with_both_values(self):
        """Тест расчета средней зарплаты при наличии обоих значений"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:89: TypeError
__________________ TestSalary.test_salary_average_from_only ___________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d123250>

    def test_salary_average_from_only(self):
        """Тест расчета средней зарплаты при наличии только минимума"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:94: TypeError
___________________ TestSalary.test_salary_average_to_only ____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d123910>

    def test_salary_average_to_only(self):
        """Тест расчета средней зарплаты при наличии только максимума"""
>       salary = Salary(salary_to=150000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'salary_to'

tests/test_salary.py:99: TypeError
_________________ TestSalary.test_salary_average_none_values __________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d123fd0>

    def test_salary_average_none_values(self):
        """Тест расчета средней зарплаты при отсутствии значений"""
>       salary = Salary(None, None, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:104: TypeError
__________________ TestSalary.test_salary_comparison_greater __________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d123610>

    def test_salary_comparison_greater(self):
        """Тест сравнения зарплат - больше"""
>       salary1 = Salary(150000, 200000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:109: TypeError
___________________ TestSalary.test_salary_comparison_less ____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d121d10>

    def test_salary_comparison_less(self):
        """Тест сравнения зарплат - меньше"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:115: TypeError
___________________ TestSalary.test_salary_comparison_equal ___________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d117650>

    def test_salary_comparison_equal(self):
        """Тест сравнения зарплат - равно"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:121: TypeError
_________________ TestSalary.test_salary_comparison_with_none _________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d128110>

    def test_salary_comparison_with_none(self):
        """Тест сравнения зарплат с None значениями"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:127: TypeError
______________ TestSalary.test_salary_string_representation_full ______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d128510>

    def test_salary_string_representation_full(self):
        """Тест строкового представления полной зарплаты"""
>       salary = Salary(100000, 150000, "RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:135: TypeError
___________ TestSalary.test_salary_string_representation_from_only ____________

self = <tests.test_salary.TestSalary object at 0x7f8b7d128850>

    def test_salary_string_representation_from_only(self):
        """Тест строкового представления зарплаты только с минимумом"""
>       salary = Salary(100000, currency="RUR")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() got an unexpected keyword argument 'currency'

tests/test_salary.py:143: TypeError
______________ TestSalary.test_salary_string_representation_none ______________

self = <tests.test_salary.TestSalary object at 0x7f8b7d128b90>

    def test_salary_string_representation_none(self):
        """Тест строкового представления зарплаты с None значениями"""
>       salary = Salary(None, None, None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:150: TypeError
_____________________ TestSalary.test_salary_is_specified _____________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d129090>

    def test_salary_is_specified(self):
        """Тест проверки указана ли зарплата"""
>       salary1 = Salary(100000, 150000, "RUR")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:156: TypeError
_________________ TestSalary.test_salary_currency_conversion __________________

self = <tests.test_salary.TestSalary object at 0x7f8b7d129690>

    def test_salary_currency_conversion(self):
        """Тест конвертации валют (если поддерживается)"""
>       salary = Salary(1000, 2000, "USD")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Salary.__init__() takes from 1 to 2 positional arguments but 4 were given

tests/test_salary.py:166: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_title_match _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12a790>

    def test_filter_vacancies_by_keyword_title_match(self):
        """Тест фильтрации по ключевому слову в заголовке"""
        vacancies = [
>           self.create_test_vacancy(title="Python Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Java Developer"),
            self.create_test_vacancy(title="Frontend Developer")
        ]

tests/test_search_utils.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12a790>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_description_match ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12ad90>

    def test_filter_vacancies_by_keyword_description_match(self):
        """Тест фильтрации по ключевому слову в описании"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", description="Python programming required"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", description="Java programming required"),
            self.create_test_vacancy(title="Developer", description="Frontend development with React")
        ]

tests/test_search_utils.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12ad90>
kwargs = {'description': 'Python programming required', 'title': 'Developer'}
defaults = {'benefits': None, 'description': 'Python programming required', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_requirements_match _____

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b390>

    def test_filter_vacancies_by_keyword_requirements_match(self):
        """Тест фильтрации по ключевому слову в требованиях"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", requirements="Experience with Python"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", requirements="Experience with Java"),
        ]

tests/test_search_utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b390>
kwargs = {'requirements': 'Experience with Python', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___ TestSearchUtils.test_filter_vacancies_by_keyword_responsibilities_match ___

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b9d0>

    def test_filter_vacancies_by_keyword_responsibilities_match(self):
        """Тест фильтрации по ключевому слову в обязанностях"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", responsibilities="Develop Python applications"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", responsibilities="Develop Java applications"),
        ]

tests/test_search_utils.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b9d0>
kwargs = {'responsibilities': 'Develop Python applications', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_ TestSearchUtils.test_filter_vacancies_by_keyword_detailed_description_match _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12bfd0>

    def test_filter_vacancies_by_keyword_detailed_description_match(self):
        """Тест фильтрации по ключевому слову в детальном описании"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", detailed_description="Work with Python and Django"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", detailed_description="Work with Java and Spring"),
        ]

tests/test_search_utils.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12bfd0>
kwargs = {'detailed_description': 'Work with Python and Django', 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': 'Work with Python and Django', 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_skills_match ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13c610>

    def test_filter_vacancies_by_keyword_skills_match(self):
        """Тест фильтрации по ключевому слову в навыках"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", skills=[{"name": "Python"}, {"name": "Django"}]),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Developer", skills=[{"name": "Java"}, {"name": "Spring"}]),
        ]

tests/test_search_utils.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13c610>
kwargs = {'skills': [{'name': 'Python'}, {'name': 'Django'}], 'title': 'Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
______ TestSearchUtils.test_filter_vacancies_by_keyword_case_insensitive ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13cc10>

    def test_filter_vacancies_by_keyword_case_insensitive(self):
        """Тест нечувствительности к регистру"""
        vacancies = [
>           self.create_test_vacancy(title="PYTHON DEVELOPER"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="python developer"),
            self.create_test_vacancy(title="Python Developer")
        ]

tests/test_search_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13cc10>
kwargs = {'title': 'PYTHON DEVELOPER'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_________ TestSearchUtils.test_filter_vacancies_by_keyword_no_matches _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d210>

    def test_filter_vacancies_by_keyword_no_matches(self):
        """Тест фильтрации без совпадений"""
        vacancies = [
>           self.create_test_vacancy(title="Java Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="C++ Developer")
        ]

tests/test_search_utils.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d210>
kwargs = {'title': 'Java Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____ TestSearchUtils.test_filter_vacancies_by_keyword_relevance_scoring ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d810>

    def test_filter_vacancies_by_keyword_relevance_scoring(self):
        """Тест сортировки по релевантности"""
        vacancies = [
>           self.create_test_vacancy(title="Developer", description="Python mentioned here"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Python Developer", description="Main Python role"),
            self.create_test_vacancy(title="Senior Python Developer", requirements="Python expertise required")
        ]

tests/test_search_utils.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d810>
kwargs = {'description': 'Python mentioned here', 'title': 'Developer'}
defaults = {'benefits': None, 'description': 'Python mentioned here', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____________ TestSearchUtils.test_vacancy_contains_keyword_true ______________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13ddd0>

    def test_vacancy_contains_keyword_true(self):
        """Тест функции vacancy_contains_keyword с положительным результатом"""
>       vacancy = self.create_test_vacancy(title="Python Developer", description="Python programming")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13ddd0>
kwargs = {'description': 'Python programming', 'title': 'Python Developer'}
defaults = {'benefits': None, 'description': 'Python programming', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_____________ TestSearchUtils.test_vacancy_contains_keyword_false _____________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13e410>

    def test_vacancy_contains_keyword_false(self):
        """Тест функции vacancy_contains_keyword с отрицательным результатом"""
>       vacancy = self.create_test_vacancy(title="Java Developer", description="Java programming")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13e410>
kwargs = {'description': 'Java programming', 'title': 'Java Developer'}
defaults = {'benefits': None, 'description': 'Java programming', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSearchUtils.test_vacancy_contains_keyword_in_title ____________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b150>

    def test_vacancy_contains_keyword_in_title(self):
        """Тест поиска ключевого слова в заголовке"""
>       vacancy = self.create_test_vacancy(title="Python Developer")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d12b150>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_vacancy_contains_keyword_in_requirements ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d128290>

    def test_vacancy_contains_keyword_in_requirements(self):
        """Тест поиска ключевого слова в требованиях"""
>       vacancy = self.create_test_vacancy(requirements="Python experience required")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d128290>
kwargs = {'requirements': 'Python experience required'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
______ TestSearchUtils.test_vacancy_contains_keyword_in_responsibilities ______

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13e090>

    def test_vacancy_contains_keyword_in_responsibilities(self):
        """Тест поиска ключевого слова в обязанностях"""
>       vacancy = self.create_test_vacancy(responsibilities="Develop Python applications")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13e090>
kwargs = {'responsibilities': 'Develop Python applications'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_vacancy_contains_keyword_in_description _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d610>

    def test_vacancy_contains_keyword_in_description(self):
        """Тест поиска ключевого слова в описании"""
>       vacancy = self.create_test_vacancy(description="Work with Python and frameworks")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13d610>
kwargs = {'description': 'Work with Python and frameworks'}
defaults = {'benefits': None, 'description': 'Work with Python and frameworks', 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
____ TestSearchUtils.test_vacancy_contains_keyword_in_detailed_description ____

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13c9d0>

    def test_vacancy_contains_keyword_in_detailed_description(self):
        """Тест поиска ключевого слова в детальном описании"""
>       vacancy = self.create_test_vacancy(detailed_description="Python development role")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13c9d0>
kwargs = {'detailed_description': 'Python development role'}
defaults = {'benefits': None, 'description': None, 'detailed_description': 'Python development role', 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSearchUtils.test_vacancy_contains_keyword_in_skills ___________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13eb10>

    def test_vacancy_contains_keyword_in_skills(self):
        """Тест поиска ключевого слова в навыках"""
>       vacancy = self.create_test_vacancy(skills=[{"name": "Python"}, {"name": "Django"}])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_search_utils.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13eb10>
kwargs = {'skills': [{'name': 'Python'}, {'name': 'Django'}]}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
_______ TestSearchUtils.test_filter_vacancies_by_keyword_empty_keyword ________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13f350>

    def test_filter_vacancies_by_keyword_empty_keyword(self):
        """Тест фильтрации с пустым ключевым словом"""
        vacancies = [
>           self.create_test_vacancy(title="Python Developer"),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            self.create_test_vacancy(title="Java Developer")
        ]

tests/test_search_utils.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13f350>
kwargs = {'title': 'Python Developer'}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
________ TestSearchUtils.test_filter_vacancies_by_keyword_none_fields _________

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13f950>

    def test_filter_vacancies_by_keyword_none_fields(self):
        """Тест фильтрации вакансий с пустыми полями"""
>       vacancy = self.create_test_vacancy(
            title=None,
            description=None,
            requirements=None,
            responsibilities=None,
            detailed_description=None,
            skills=None
        )

tests/test_search_utils.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search_utils.TestSearchUtils object at 0x7f8b7d13f950>
kwargs = {'description': None, 'detailed_description': None, 'requirements': None, 'responsibilities': None, ...}
defaults = {'benefits': None, 'description': None, 'detailed_description': None, 'employer': None, ...}

    def create_test_vacancy(self, **kwargs):
        """Создает тестовую вакансию с заданными параметрами"""
        defaults = {
            'vacancy_id': '1',
            'title': 'Test Vacancy',
            'description': None,
            'requirements': None,
            'responsibilities': None,
            'detailed_description': None,
            'skills': None,
            'employer': None,
            'employment': None,
            'schedule': None,
            'experience': None,
            'benefits': None
        }
        defaults.update(kwargs)
    
>       vacancy = Vacancy()
                  ^^^^^^^^^
E       TypeError: Vacancy.__init__() missing 2 required positional arguments: 'title' and 'url'

tests/test_search_utils.py:33: TypeError
___________ TestSourceSelector.test_source_selector_initialization ____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d14e450>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bc8f6d0>

    def test_source_selector_initialization(self, source_selector):
        """Тест инициализации SourceSelector"""
        assert source_selector is not None
>       assert hasattr(source_selector, 'available_sources')
E       AssertionError: assert False
E        +  where False = hasattr(<src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bc8f6d0>, 'available_sources')

tests/test_source_selector.py:22: AssertionError
____________ TestSourceSelector.test_get_user_source_choice_single ____________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d14ea10>
mock_input = <MagicMock name='input' id='140237053937808'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bc8fa10>

    @patch('builtins.input', return_value='1')
    def test_get_user_source_choice_single(self, mock_input, source_selector):
        """Тест выбора одного источника"""
        with patch('builtins.print'):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:29: AssertionError
_____________ TestSourceSelector.test_get_user_source_choice_all ______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d14efd0>
mock_input = <MagicMock name='input' id='140237063132816'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7c550c50>

    @patch('builtins.input', return_value='3')
    def test_get_user_source_choice_all(self, mock_input, source_selector):
        """Тест выбора всех источников"""
        with patch('builtins.print'):
            sources = source_selector.get_user_source_choice()
>           assert isinstance(sources, list)
E           AssertionError: assert False
E            +  where False = isinstance({'hh.ru', 'superjob.ru'}, list)

tests/test_source_selector.py:37: AssertionError
______ TestSourceSelector.test_get_user_source_choice_invalid_then_valid ______

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d14fbd0>
mock_print = <MagicMock name='print' id='140237054255568'>
mock_input = <MagicMock name='input' id='140237054255504'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bcda4d0>

    @patch('builtins.input', side_effect=['invalid', '1'])
    @patch('builtins.print')
    def test_get_user_source_choice_invalid_then_valid(self, mock_print, mock_input, source_selector):
        """Тест некорректного, затем корректного выбора"""
        sources = source_selector.get_user_source_choice()
>       assert isinstance(sources, list)
E       AssertionError: assert False
E        +  where False = isinstance({'hh.ru'}, list)

tests/test_source_selector.py:51: AssertionError
________________ TestSourceSelector.test_get_available_sources ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d158910>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7c902a10>

    def test_get_available_sources(self, source_selector):
        """Тест получения доступных источников"""
>       sources = source_selector.get_available_sources()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_available_sources'

tests/test_source_selector.py:63: AttributeError
_______________ TestSourceSelector.test_validate_source_choice ________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d158f50>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7c54dd90>

    def test_validate_source_choice(self, source_selector):
        """Тест валидации выбора источника"""
>       assert source_selector.validate_source_choice("1") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'validate_source_choice'

tests/test_source_selector.py:70: AttributeError
______________ TestSourceSelector.test_get_source_name_by_choice ______________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d159590>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7c515f50>

    def test_get_source_name_by_choice(self, source_selector):
        """Тест получения имени источника по выбору"""
        # Предполагаем стандартную нумерацию
>       source_name = source_selector.get_source_name_by_choice("1")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'get_source_name_by_choice'

tests/test_source_selector.py:80: AttributeError
_________________ TestSourceSelector.test_is_source_available _________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d159b90>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bcb23d0>

    def test_is_source_available(self, source_selector):
        """Тест проверки доступности источника"""
>       assert source_selector.is_source_available("hh.ru") is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'is_source_available'

tests/test_source_selector.py:85: AttributeError
_________________ TestSourceSelector.test_display_source_menu _________________

self = <tests.test_source_selector.TestSourceSelector object at 0x7f8b7d15a150>
mock_print = <MagicMock name='print' id='140237053571856'>
source_selector = <src.ui_interfaces.source_selector.SourceSelector object at 0x7f8b7bc33810>

    @patch('builtins.print')
    def test_display_source_menu(self, mock_print, source_selector):
        """Тест отображения меню источников"""
>       source_selector.display_source_menu()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SourceSelector' object has no attribute 'display_source_menu'

tests/test_source_selector.py:92: AttributeError
______________ TestUINavigation.test_quick_paginate_empty_items _______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d172c90>

    def test_quick_paginate_empty_items(self):
        """Тест пагинации с пустым списком элементов"""
        items = []
    
        with patch('builtins.input', return_value='q'):
>           result = quick_paginate(items, items_per_page=5)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:20: TypeError
______________ TestUINavigation.test_quick_paginate_single_page _______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d173010>

    def test_quick_paginate_single_page(self):
        """Тест пагинации с одной страницей"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=5)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:30: TypeError
_____________ TestUINavigation.test_quick_paginate_multiple_pages _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d173610>

    def test_quick_paginate_multiple_pages(self):
        """Тест пагинации с несколькими страницами"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6']
    
        with patch('builtins.input', side_effect=['n', 'q']):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=3)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:40: TypeError
____________ TestUINavigation.test_quick_paginate_navigation_next _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d173c50>

    def test_quick_paginate_navigation_next(self):
        """Тест навигации на следующую страницу"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6']
    
        with patch('builtins.input', side_effect=['n', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:50: TypeError
__________ TestUINavigation.test_quick_paginate_navigation_previous ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d188290>

    def test_quick_paginate_navigation_previous(self):
        """Тест навигации на предыдущую страницу"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['n', 'p', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:60: TypeError
____________ TestUINavigation.test_quick_paginate_quit_immediately ____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d188890>

    def test_quick_paginate_quit_immediately(self):
        """Тест немедленного выхода из пагинации"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               result = quick_paginate(items, items_per_page=2)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:70: TypeError
_____________ TestUINavigation.test_quick_paginate_invalid_input ______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d188e90>

    def test_quick_paginate_invalid_input(self):
        """Тест обработки некорректного ввода"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['invalid', 'xyz', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:80: TypeError
_________ TestUINavigation.test_quick_paginate_custom_items_per_page __________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d189490>

    def test_quick_paginate_custom_items_per_page(self):
        """Тест пагинации с настраиваемым количеством элементов на странице"""
        items = ['item1', 'item2', 'item3', 'item4', 'item5']
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=1)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:90: TypeError
___________ TestUINavigation.test_quick_paginate_last_page_boundary ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d189a90>

    def test_quick_paginate_last_page_boundary(self):
        """Тест навигации на границе последней страницы"""
        items = ['item1', 'item2', 'item3']
    
        with patch('builtins.input', side_effect=['n', 'n', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:100: TypeError
__________ TestUINavigation.test_quick_paginate_first_page_boundary ___________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d18a050>

    def test_quick_paginate_first_page_boundary(self):
        """Тест навигации на границе первой страницы"""
        items = ['item1', 'item2', 'item3', 'item4']
    
        with patch('builtins.input', side_effect=['p', 'q']):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:110: TypeError
_____________ TestUINavigation.test_quick_paginate_display_format _____________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d18a650>

    def test_quick_paginate_display_format(self):
        """Тест формата отображения элементов"""
        items = [
            {'title': 'Job 1', 'company': 'Company A'},
            {'title': 'Job 2', 'company': 'Company B'}
        ]
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=5)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:123: TypeError
_____ TestUINavigation.test_quick_paginate_edge_case_zero_items_per_page ______

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d18ac50>

    def test_quick_paginate_edge_case_zero_items_per_page(self):
        """Тест граничного случая с нулевым количеством элементов на странице"""
        items = ['item1', 'item2']
    
        with patch('builtins.input', return_value='q'):
            # При items_per_page=0 или отрицательном значении должно использоваться значение по умолчанию
            try:
>               quick_paginate(items, items_per_page=0)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:134: TypeError
______________ TestUINavigation.test_quick_paginate_string_items ______________

self = <tests.test_ui_navigation.TestUINavigation object at 0x7f8b7d18b250>

    def test_quick_paginate_string_items(self):
        """Тест пагинации со строковыми элементами"""
        items = ["First item", "Second item", "Third item"]
    
        with patch('builtins.input', return_value='q'):
            with patch('builtins.print') as mock_print:
>               quick_paginate(items, items_per_page=2)
E               TypeError: quick_paginate() missing 1 required positional argument: 'formatter'

tests/test_ui_navigation.py:145: TypeError
_____________ TestUnifiedAPI.test_get_vacancies_from_all_sources ______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f8b7d1733d0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f8b7d1d4590>
mock_hh_api = <Mock id='140237076255184'>
mock_sj_api = <Mock id='140237076264720'>

    def test_get_vacancies_from_all_sources(self, unified_api, mock_hh_api, mock_sj_api):
        """Тест получения вакансий из всех источников"""
        result = unified_api.get_vacancies_from_sources("Python")
    
>       assert len(result) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_unified_api.py:54: AssertionError
---------------------------- Captured stdout call -----------------------------
Выполняется дедупликация и фильтрация по целевым компаниям...
Не найдено вакансий от целевых компаний
---------------------------- Captured stderr call -----------------------------
ERROR:src.api_modules.base_api:Ошибка при SQL-дедупликации с фильтрацией: 'Mock' object is not subscriptable
ERROR:src.api_modules.base_api:SQL-дедупликация обязательна. Fallback логика отключена.
------------------------------ Captured log call ------------------------------
ERROR    src.api_modules.base_api:base_api.py:311 Ошибка при SQL-дедупликации с фильтрацией: 'Mock' object is not subscriptable
ERROR    src.api_modules.base_api:base_api.py:313 SQL-дедупликация обязательна. Fallback логика отключена.
______________ TestUnifiedAPI.test_get_vacancies_from_source_hh _______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f8b7d18c410>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f8b7bc65390>
mock_hh_api = <Mock id='140237054376016'>

    def test_get_vacancies_from_source_hh(self, unified_api, mock_hh_api):
        """Тест получения вакансий из HeadHunter"""
        result = unified_api.get_vacancies_from_source("hh", "Python")
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_unified_api.py:62: AssertionError
______________ TestUnifiedAPI.test_get_vacancies_from_source_sj _______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f8b7d18ccd0>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f8b7bcc9950>
mock_sj_api = <Mock id='140237053971536'>

    def test_get_vacancies_from_source_sj(self, unified_api, mock_sj_api):
        """Тест получения вакансий из SuperJob"""
        result = unified_api.get_vacancies_from_source("sj", "Python")
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_unified_api.py:70: AssertionError
_____________ TestUnifiedAPI.test_get_companies_from_all_sources ______________

self = <tests.test_unified_api.TestUnifiedAPI object at 0x7f8b7d18d490>
unified_api = <src.api_modules.unified_api.UnifiedAPI object at 0x7f8b7c549810>
mock_hh_api = <Mock id='140237067298832'>
mock_sj_api = <Mock id='140237067197136'>

    def test_get_companies_from_all_sources(self, unified_api, mock_hh_api, mock_sj_api):
        """Тест получения компаний из всех источников"""
>       result = unified_api.get_companies_from_sources()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedAPI' object has no attribute 'get_companies_from_sources'

tests/test_unified_api.py:82: AttributeError
___ TestVacancyDisplayHandler.test_search_saved_vacancies_by_keyword_found ____

args = (<tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f8b7d18b590>,)
keywargs = {'display_handler': <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f8b7c5164d0>, 'mock_...s': [<src.vacancies.models.Vacancy object at 0x7f8b7c570a10>, <src.vacancies.models.Vacancy object at 0x7f8b7c570530>]}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f8b7cd68d50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_display_handler' from '/home/runner/workspace/src/ui_interfaces/vacancy_display_handler.py'> does not have the attribute 'get_user_input'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyDisplayHandler.test_search_saved_vacancies_by_keyword_not_found __

args = (<tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f8b7d173190>,)
keywargs = {'display_handler': <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f8b7c50b650>, 'mock_...s': [<src.vacancies.models.Vacancy object at 0x7f8b7c5b9980>, <src.vacancies.models.Vacancy object at 0x7f8b7c5b8050>]}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f8b7cd69190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_display_handler' from '/home/runner/workspace/src/ui_interfaces/vacancy_display_handler.py'> does not have the attribute 'get_user_input'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyDisplayHandler.test_search_saved_vacancies_by_keyword_empty_query _

args = (<tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f8b7d1a5250>,)
keywargs = {'display_handler': <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f8b7c522310>, 'mock_storage': <Mock id='140237062941840'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f8b7cd69990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.ui_interfaces.vacancy_display_handler' from '/home/runner/workspace/src/ui_interfaces/vacancy_display_handler.py'> does not have the attribute 'get_user_input'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyDisplayHandler.test_search_saved_vacancies_by_keyword_no_saved_vacancies _

args = (<tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7f8b7d1a5990>,)
keywargs = {'display_handler': <src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler object at 0x7f8b7bc49050>, 'mock_storage': <Mock id='140237053671888'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f8b7cd695d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True