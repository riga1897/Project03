platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 611 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  1%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  3%]
tests/test_api_modules.py .............................                                  [  8%]
tests/test_app_config.py .....                                                           [  9%]
tests/test_base_api.py ......                                                            [ 10%]
tests/test_base_formatter.py ..........                                                  [ 12%]
tests/test_base_parser.py ......                                                         [ 13%]
tests/test_cache.py .......                                                              [ 14%]
tests/test_cache_manager.py ...F................                                         [ 17%]
tests/test_cached_api.py ...........                                                     [ 19%]
tests/test_console_interface.py ......                                                   [ 20%]
tests/test_db_config.py .....                                                            [ 21%]
tests/test_db_manager.py .................                                               [ 23%]
tests/test_decorators.py .......                                                         [ 25%]
tests/test_env_loader.py ............                                                    [ 27%]
tests/test_file_handlers.py ............                                                 [ 28%]
tests/test_get_api.py ......                                                             [ 29%]
tests/test_hh_api.py .......                                                             [ 31%]
tests/test_hh_api_config.py .....                                                        [ 31%]
tests/test_hh_parser.py ........                                                         [ 33%]
tests/test_menu_manager.py ..........                                                    [ 34%]
tests/test_menu_system.py .................F..                                           [ 38%]
tests/test_paginator.py ......                                                           [ 39%]
tests/test_postgres_saver.py .......                                                     [ 40%]
tests/test_salary_utils.py ......................                                        [ 43%]
tests/test_search_utils.py ............................                                  [ 48%]
tests/test_sj_api.py ..............                                                      [ 50%]
tests/test_sj_api_config.py .....                                                        [ 51%]
tests/test_sj_parser.py ........                                                         [ 52%]
tests/test_source_manager.py .................                                           [ 55%]
tests/test_source_selector.py ..................                                         [ 58%]
tests/test_storage_factory.py ........                                                   [ 59%]
tests/test_target_companies.py .....                                                     [ 60%]
tests/test_ui_config.py .......................                                          [ 64%]
tests/test_ui_helpers.py ...........                                                     [ 66%]
tests/test_ui_navigation.py ......................                                       [ 69%]
tests/test_unified_api.py .................                                              [ 72%]
tests/test_user_interface.py .........F............                                      [ 76%]
tests/test_vacancy_display_handler.py ..............                                     [ 78%]
tests/test_vacancy_formatter.py ........                                                 [ 79%]
tests/test_vacancy_models.py .................................................           [ 87%]
tests/test_vacancy_operations.py ......                                                  [ 88%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 93%]
tests/test_vacancy_search_handler.py .F....FF.FFFF.FFF......                             [ 97%]
tests/test_vacancy_stats.py EEEFFE.F...EEFFFFF                                           [100%]

============================================ ERRORS ============================================
_________________ ERROR at setup of TestVacancyStats.test_company_distribution _________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f6615758650>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f66143060e0>
salary_data = <src.utils.salary.Salary object at 0x7f6614306860>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
_________________ ERROR at setup of TestVacancyStats.test_source_distribution __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f6615758e90>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f66143aae60>
salary_data = <src.utils.salary.Salary object at 0x7f66143aac80>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
__________________ ERROR at setup of TestVacancyStats.test_salary_percentiles __________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f66157592d0>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f66143aada0>
salary_data = <src.utils.salary.Salary object at 0x7f66143aaaa0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
___________ ERROR at setup of TestVacancyStats.test_display_company_stats_with_data ____________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f661575a450>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f66143ab1c0>
salary_data = <src.utils.salary.Salary object at 0x7f66143aab60>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_type_safety _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f6615fb0450>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f6614305fc0>
salary_data = <src.utils.salary.Salary object at 0x7f6614305ea0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ ERROR at setup of TestVacancyStats.test_vacancy_stats_performance _______________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f6615fb2190>

    @pytest.fixture
    def sample_vacancies(self) -> List[Vacancy]:
        """Фикстура тестовых вакансий с правильным созданием Salary"""
        return [
>           Vacancy(
                title="Python Developer",
                url="https://test.com/1",
                vacancy_id="1",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                salary=Salary.from_range(100000, 150000) if not SRC_AVAILABLE else Salary({'from': 100000, 'to': 150000}),
                area="Москва",
                experience="От 3 до 6 лет"
            ),
            Vacancy(
                title="Java Developer",
                url="https://test.com/2",
                vacancy_id="2",
                source="superjob.ru",
                employer={"name": "DevCompany", "id": "456"},
                salary=Salary.from_range(120000, 180000) if not SRC_AVAILABLE else Salary({'from': 120000, 'to': 180000}),
                area="Санкт-Петербург",
                experience="От 1 года до 3 лет"
            ),
            Vacancy(
                title="Frontend Developer",
                url="https://test.com/3",
                vacancy_id="3",
                source="hh.ru",
                employer={"name": "TechCorp", "id": "123"},
                area="Москва",
                experience="Нет опыта"
            )
        ]

tests/test_vacancy_stats.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.salary.Salary object at 0x7f6614307880>
salary_data = <src.utils.salary.Salary object at 0x7f6614306f20>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'Salary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
=========================================== FAILURES ===========================================
__________________________ TestCacheManager.test_cache_ttl_expiration __________________________

self = <workspace.tests.test_cache_manager.TestCacheManager object at 0x7f661635cd10>
cache_manager = <workspace.tests.test_cache_manager.CacheManager object at 0x7f6615767cd0>

    def test_cache_ttl_expiration(self, cache_manager):
        """Тест истечения времени жизни кэша"""
        key = "test_key"
        value = "test_value"
    
        # Сохраняем с коротким TTL
        cache_manager.set(key, value, ttl=1)
    
        # Сразу после сохранения значение должно быть доступно
        assert cache_manager.get(key) == value
    
        # Имитируем истечение времени с помощью фиксированного мока
        original_timestamp = datetime.now().timestamp()
    
        with patch('tests.test_cache_manager.datetime') as mock_datetime:
            # Мокируем время на 2 секунды вперед
            mock_datetime.now.return_value.timestamp.return_value = original_timestamp + 2
    
            # Пересоздаем менеджер кэша, чтобы он использовал новое время
            expired_manager = CacheManager()
            expired_manager.cache = cache_manager.cache.copy()
    
            # Проверяем истечение через новый метод
>           assert expired_manager.get(key) is None
E           AssertionError: assert 'test_value' is None
E            +  where 'test_value' = get('test_key')
E            +    where get = <workspace.tests.test_cache_manager.CacheManager object at 0x7f6615b16ed0>.get

tests/test_cache_manager.py:223: AssertionError
___________________________ TestMenuManager.test_submenu_navigation ____________________________

self = <workspace.tests.test_menu_system.TestMenuManager object at 0x7f66167b5310>
mock_print = <MagicMock name='print' id='140076424081744'>
mock_input = <MagicMock name='input' id='140076424075344'>
menu_manager = <workspace.tests.test_menu_system.MenuManager object at 0x7f6615623d90>

    @patch('builtins.input', side_effect=['3.1', '0'])
    @patch('builtins.print')
    def test_submenu_navigation(self, mock_print, mock_input, menu_manager):
        """Тест навигации по подменю"""
        submenu_item = MenuItem("3.1", "Sub Option", lambda: "sub_executed")
        main_item = MenuItem("3", "Main Option", submenu=[submenu_item])
    
>       result = menu_manager._enter_submenu(main_item)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_menu_system.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_menu_system.py:188: in _enter_submenu
    self.run_menu_loop(submenu)
tests/test_menu_system.py:161: in run_menu_loop
    choice = self.get_user_choice(menu)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_menu_system.py:117: in get_user_choice
    choice = input("\nВыберите пункт меню: ").strip()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='input' id='140076424075344'>, args = ('\nВыберите пункт меню: ',)
kwargs = {}, effect = <list_iterator object at 0x7f661636eec0>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
                         ^^^^^^^^^^^^
E               StopIteration

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1185: StopIteration
_________________________ TestUserInterface.test_logging_configuration _________________________

self = <MagicMock name='logging.getLogger' id='140076423030736'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'getLogger' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7f6615b1fdd0>
mock_logging = <MagicMock name='logging' id='140076423034832'>

    @patch('src.user_interface.logging')
    def test_logging_configuration(self, mock_logging):
        """Тест конфигурации логирования"""
        try:
            import src.user_interface
    
            # Проверяем, что модуль загружен
            assert hasattr(src.user_interface, 'main')
    
            # Логирование может быть настроено при импорте или в main
            # Проверяем хотя бы то, что getLogger был вызван
>           mock_logging.getLogger.assert_called()
E           AssertionError: Expected 'getLogger' to have been called.

tests/test_user_interface.py:242: AssertionError
_____________________ TestVacancySearchHandler.test_search_vacancies_basic _____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f66157aac90>
mock_print = <MagicMock name='print' id='140076431657168'>
mock_input = <MagicMock name='input' id='140076422712272'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f6615f37490>

    @patch('builtins.input', return_value="1")
    @patch('builtins.print')
    def test_search_vacancies_basic(self, mock_print, mock_input, search_handler):
        """Тест базового поиска вакансий"""
        if SRC_AVAILABLE:
            # Мокируем все интерактивные элементы
            with patch('src.ui_interfaces.source_selector.input', return_value="1"), \
                 patch('src.utils.ui_helpers.get_user_input', return_value="Python"), \
                 patch('src.utils.ui_helpers.get_positive_integer', return_value=15):
    
                # Мокируем API ответ
                search_handler.unified_api.search_vacancies = Mock(return_value=[])
                result = search_handler.search_vacancies()
        else:
            result = search_handler.search_vacancies()
    
>       assert isinstance(result, list)
E       assert False
E        +  where False = isinstance(None, list)

tests/test_vacancy_search_handler.py:262: AssertionError
-------------------------------------- Captured log call ---------------------------------------
ERROR    src.ui_interfaces.vacancy_search_handler:vacancy_search_handler.py:70 Ошибка поиска вакансий: 'Mock' object is not iterable
____________________ TestVacancySearchHandler.test_search_with_mocked_input ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f66157a9110>
mock_print = <MagicMock name='print' id='140076423820560'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f66157b9110>
consolidated_mocks = {'input': <Mock id='140076423811664'>, 'print': <Mock id='140076423813648'>, 'source_selector': <Mock id='140076423810768'>, 'storage': <Mock id='140076423815056'>, ...}

    @patch('builtins.print')
    def test_search_with_mocked_input(self, mock_print, search_handler, consolidated_mocks):
        """Тест поиска с замокированным вводом"""
        # Полностью мокируем все input операции
        with patch('src.ui_interfaces.source_selector.input', return_value="1") if SRC_AVAILABLE else None, \
             patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
            # Мокируем API для предотвращения реальных запросов
            if SRC_AVAILABLE:
                search_handler.unified_api.search_vacancies = Mock(return_value=[])
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:45: in search_vacancies
    query = get_user_input("\nВведите поисковый запрос: ")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:23: in get_user_input
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f661803c390>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------

Введите поисковый запрос: 
____________________ TestVacancySearchHandler.test_search_results_structure ____________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f66157a9390>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f6615f78c50>
consolidated_mocks = {'input': <Mock id='140076464147280'>, 'print': <Mock id='140076464146832'>, 'source_selector': <Mock id='140076464145872'>, 'storage': <Mock id='140076464145424'>, ...}

    def test_search_results_structure(self, search_handler, consolidated_mocks):
        """Тест структуры результатов поиска"""
        with patch('src.utils.ui_helpers.get_user_input', return_value="Python") if SRC_AVAILABLE else patch('builtins.input', return_value="Python"), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f661803c390>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario0] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f661579f950>
mock_print = <MagicMock name='print' id='140076422541520'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f6615683390>
test_scenario = {'name': 'python_search', 'query': 'Python', 'source': 'hh.ru'}
consolidated_mocks = {'input': <Mock id='140076422532304'>, 'print': <Mock id='140076422542288'>, 'source_selector': <Mock id='140076422532240'>, 'storage': <Mock id='140076422535632'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f661803c390>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario1] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f661579ffd0>
mock_print = <MagicMock name='print' id='140076431666448'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f6615f34190>
test_scenario = {'name': 'java_search', 'query': 'Java', 'source': 'superjob.ru'}
consolidated_mocks = {'input': <Mock id='140076431660560'>, 'print': <Mock id='140076431670224'>, 'source_selector': <Mock id='140076431664656'>, 'storage': <Mock id='140076431668688'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f661803c390>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
_________ TestVacancySearchHandler.test_parametrized_search_scenarios[test_scenario2] __________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f661579d850>
mock_print = <MagicMock name='print' id='140076431890128'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f6615f6f990>
test_scenario = {'name': 'empty_search', 'query': '', 'source': 'all'}
consolidated_mocks = {'input': <Mock id='140076431889808'>, 'print': <Mock id='140076431899664'>, 'source_selector': <Mock id='140076431899088'>, 'storage': <Mock id='140076431898704'>, ...}

    @pytest.mark.parametrize("test_scenario", [
        {"name": "python_search", "query": "Python", "source": "hh.ru"},
        {"name": "java_search", "query": "Java", "source": "superjob.ru"},
        {"name": "empty_search", "query": "", "source": "all"},
    ])
    @patch('builtins.print')
    def test_parametrized_search_scenarios(self, mock_print, search_handler, test_scenario, consolidated_mocks):
        """Параметризованный тест различных сценариев поиска"""
        query = test_scenario["query"]
    
        with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
             patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
    
>           result = search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_search_handler.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.capture.DontReadFromInput object at 0x7f661803c390>, size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------------------- Captured stdout call -------------------------------------
Ваш выбор: 
______________________ TestVacancySearchHandler.test_concurrent_searches _______________________

self = <workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7f661579ce50>
mock_print = <MagicMock name='print' id='140076423295504'>
search_handler = <src.ui_interfaces.vacancy_search_handler.VacancySearchHandler object at 0x7f661573bb10>
consolidated_mocks = {'input': <Mock id='140076423294288'>, 'print': <Mock id='140076423289040'>, 'source_selector': <Mock id='140076423291408'>, 'storage': <Mock id='140076423293904'>, ...}

    @patch('builtins.print')
    def test_concurrent_searches(self, mock_print, search_handler, consolidated_mocks):
        """Тест одновременных поисков"""
        import concurrent.futures
    
        queries = ["Python", "Java", "JavaScript", "C++"]
    
        def search_task(query):
            with patch('src.utils.ui_helpers.get_user_input', return_value=query) if SRC_AVAILABLE else patch('builtins.input', return_value=query), \
                 patch('src.utils.ui_helpers.get_positive_integer', return_value=15) if SRC_AVAILABLE else patch('builtins.input', return_value="15"):
                return search_handler.search_vacancies() if SRC_AVAILABLE else search_handler.search_vacancies()
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [executor.submit(search_task, query) for query in queries]
>           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
