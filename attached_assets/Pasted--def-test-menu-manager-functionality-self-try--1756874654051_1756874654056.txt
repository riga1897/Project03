
    def test_menu_manager_functionality(self):
        """Тест менеджера меню"""
        try:
            from src.utils.menu_manager import MenuManager
    
            with patch('builtins.input', return_value='1'), \
                 patch('builtins.print'):
    
                menu_items = [
                    ("Поиск вакансий", lambda: "search"),
                    ("Просмотр сохраненных", lambda: "view"),
                    ("Выход", lambda: "exit")
                ]
    
>               manager = MenuManager(menu_items)
                          ^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: MenuManager.__init__() takes 1 positional argument but 2 were given

tests/test_consolidated_coverage.py:544: TypeError
________ TestConsolidatedCoverage.test_paginator_functionality ________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180e890>

    def test_paginator_functionality(self):
        """Тест пагинатора"""
        try:
            from src.utils.paginator import Paginator
    
            items = list(range(100))
>           paginator = Paginator(items, per_page=10)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Paginator() takes no arguments

tests/test_consolidated_coverage.py:576: TypeError
_ TestConsolidatedCoverage.test_main_application_interface_functionality _

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180efd0>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508535406352'>, 'env_loader': <Mock id='140508535394576'>, 'file_cache': <Mock id='140508535392720'>, ...}

    def test_main_application_interface_functionality(self, consolidated_mocks):
        """Тест главного интерфейса приложения"""
        try:
            from src.interfaces.main_application_interface import ConsoleApplicationInterface
    
            with patch('builtins.input', return_value='q'), \
                 patch('builtins.print'):
    
                # Создание с необходимыми моками
>               interface = ConsoleApplicationInterface()
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: MainApplicationInterface.__init__() missing 3 required positional arguments: 'provider', 'processor', and 'storage'

tests/test_consolidated_coverage.py:599: TypeError
_____ TestConsolidatedCoverage.test_storage_factory_functionality _____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180f710>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508514636112'>, 'env_loader': <Mock id='140508514637136'>, 'file_cache': <Mock id='140508514640272'>, ...}

    def test_storage_factory_functionality(self, consolidated_mocks):
        """Тест фабрики хранилища"""
        try:
            from src.storage.storage_factory import StorageFactory
    
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            with patch('src.storage.storage_factory.PostgresSaver') as mock_saver:
                mock_saver.return_value = consolidated_mocks['storage']
    
>               storage = StorageFactory.create_storage("postgres", db_config)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: StorageFactory.create_storage() takes from 0 to 1 positional arguments but 2 were given

tests/test_consolidated_coverage.py:632: TypeError
______ TestConsolidatedCoverage.test_main_user_interface_module _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180fe90>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508514638224'>, 'env_loader': <Mock id='140508535913680'>, 'file_cache': <Mock id='140508535899280'>, ...}

    def test_main_user_interface_module(self, consolidated_mocks):
        """Тест главного модуля пользовательского интерфейса"""
        try:
            import src.user_interface as ui_module
    
>           with patch('src.user_interface.DBManager') as mock_db_manager, \
                 patch('src.user_interface.UserInterface') as mock_ui, \
                 patch('builtins.input', return_value='q'), \
                 patch('builtins.print'):

tests/test_consolidated_coverage.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab15efd50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestConsolidatedCoverage.test_api_connector_functionality ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180f910>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508534552848'>, 'env_loader': <Mock id='140508534553232'>, 'file_cache': <Mock id='140508534553936'>, ...}

    def test_api_connector_functionality(self, consolidated_mocks):
        """Тест API коннектора"""
        try:
            from src.api_modules.get_api import APIConnector
    
>           with patch('src.api_modules.get_api.HeadHunterAPI') as mock_hh, \
                 patch('src.api_modules.get_api.SuperJobAPI') as mock_sj:

tests/test_consolidated_coverage.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14a3e10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.api_modules.get_api' from '/home/runner/workspace/tests/../src/api_modules/get_api.py'> does not have the attribute 'HeadHunterAPI'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_____ TestConsolidatedCoverage.test_comprehensive_error_handling ______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab180e590>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508535499920'>, 'env_loader': <Mock id='140508535500048'>, 'file_cache': <Mock id='140508535490960'>, ...}

    def test_comprehensive_error_handling(self, consolidated_mocks):
        """Тест обработки ошибок во всех модулях"""
        # Тест с ошибками подключения к БД
        with patch('src.storage.postgres_saver.psycopg2.connect', side_effect=Exception("Connection failed")):
            try:
                from src.storage.postgres_saver import PostgresSaver
    
                db_config = {'host': 'localhost', 'port': '5432', 'database': 'test', 'username': 'user', 'password': 'pass'}
>               saver = PostgresSaver(db_config)
                        ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_consolidated_coverage.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:54: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:80: in _ensure_database_exists
    connection = self._get_connection("postgres")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:61: in _get_connection
    connection = psycopg2.connect(
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='connect' id='140508535500176'>, args = ()
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': 'pass', ...}
effect = Exception('Connection failed')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Connection failed

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1183: Exception
_________ TestConsolidatedCoverage.test_integration_workflow __________

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab1805810>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508534574928'>, 'env_loader': <Mock id='140508534584400'>, 'file_cache': <Mock id='140508534583120'>, ...}

    def test_integration_workflow(self, consolidated_mocks):
        """Интеграционный тест основного рабочего процесса"""
>       with patch('src.api_modules.hh_api.requests.get') as mock_get, \
             patch('src.storage.postgres_saver.psycopg2.connect') as mock_connect, \
             patch('builtins.input', return_value='q'), \
             patch('builtins.print'):

tests/test_consolidated_coverage.py:739: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____ TestConsolidatedCoverage.test_complete_service_layer_coverage ____

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab1818610>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508544078160'>, 'env_loader': <Mock id='140508514639056'>, 'file_cache': <Mock id='140508514639440'>, ...}

    def test_complete_service_layer_coverage(self, consolidated_mocks):
        """Тест полного покрытия сервисного слоя"""
        try:
            # Мок для сервисов с правильными параметрами
            mock_storage = consolidated_mocks['storage']
    
            # Тест дедупликации
            from src.storage.services.deduplication_service import DeduplicationService
            dedup_service = DeduplicationService(mock_storage)
>           result = dedup_service.deduplicate_vacancies([consolidated_mocks['vacancy']])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DeduplicationService' object has no attribute 'deduplicate_vacancies'

tests/test_consolidated_coverage.py:806: AttributeError
_______ TestConsolidatedCoverage.test_complete_application_flow _______

self = <tests.test_consolidated_coverage.TestConsolidatedCoverage object at 0x7fcab1818990>
mock_print = <MagicMock name='print' id='140508525474256'>
mock_input = <MagicMock name='input' id='140508525751504'>
consolidated_mocks = {'api_response': {'items': [{'employer': {'id': '456', 'name': 'Test Company'}, 'id': '123', 'salary': {'currency': 'R...<Mock id='140508525469904'>, 'env_loader': <Mock id='140508525477008'>, 'file_cache': <Mock id='140508525474064'>, ...}

    @patch('builtins.input', return_value='q')
    @patch('builtins.print')
    def test_complete_application_flow(self, mock_print, mock_input, consolidated_mocks):
        """Тест полного потока приложения"""
>       with patch('src.storage.db_manager.psycopg2.connect') as mock_connect, \
             patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_consolidated_coverage.py:831: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______ TestCoverageValidation.test_basic_functionality_coverage _______

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7fcab182f550>

    def test_basic_functionality_coverage(self):
        """Базовый тест функциональности для покрытия"""
        # Тест модели вакансии
        from src.vacancies.models import Vacancy
    
        vacancy_data = {
            'id': 'test_123',
            'name': 'Test Job',
            'url': 'https://test.com',
            'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
            'employer': {'name': 'Test Company'},
            'area': {'name': 'Test City'},
            'experience': {'name': 'Test Experience'},
            'employment': {'name': 'Test Employment'},
            'schedule': {'name': 'Test Schedule'},
            'snippet': {'requirement': 'Test req', 'responsibility': 'Test resp'},
            'published_at': '2025-01-01T00:00:00+0300'
        }
    
>       vacancy = Vacancy.from_dict(vacancy_data, 'test')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_coverage_validation.py:63: TypeError
_______ TestCoverageValidation.test_api_modules_basic_coverage ________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7fcab183dd90>

    def test_api_modules_basic_coverage(self):
        """Базовое покрытие API модулей"""
>       with patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_coverage_validation.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestCoverageValidation.test_ui_basic_coverage ____________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7fcab183eb50>

    def test_ui_basic_coverage(self):
        """Базовое покрытие UI модулей"""
        with patch('builtins.input', return_value='q'), \
             patch('builtins.print'):
    
            from src.ui_interfaces.console_interface import UserInterface
    
            mock_storage = Mock()
            mock_api = Mock()
            mock_storage.get_vacancies.return_value = []
    
>           interface = UserInterface(storage=mock_storage, unified_api=mock_api)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: UserInterface.__init__() got an unexpected keyword argument 'unified_api'

tests/test_coverage_validation.py:109: TypeError
__________ TestCoverageValidation.test_config_basic_coverage __________

self = <tests.test_coverage_validation.TestCoverageValidation object at 0x7fcab183f1d0>

    def test_config_basic_coverage(self):
        """Базовое покрытие модулей конфигурации"""
        try:
            from src.config.db_config import DatabaseConfig
            config = DatabaseConfig()
            assert config is not None
        except ImportError:
            pass
    
        try:
            from src.config.target_companies import TargetCompanies
>           companies = TargetCompanies.get_target_companies()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'TargetCompanies' has no attribute 'get_target_companies'

tests/test_coverage_validation.py:139: AttributeError
____ TestOptimizedCoverage.test_vacancy_model_creation_and_methods ____

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d5510>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_vacancy_model_creation_and_methods(self, standard_vacancy_data):
        """Тест создания и методов модели вакансии"""
        # Создание из словаря
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:67: TypeError
________ TestOptimizedCoverage.test_api_modules_comprehensive _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d4ad0>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_api_modules_comprehensive(self, standard_vacancy_data):
        """Комплексный тест API модулей"""
        # Тест HeadHunter API
>       with patch('src.api_modules.hh_api.requests.get') as mock_get:

tests/test_optimized_coverage.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
______ TestOptimizedCoverage.test_storage_modules_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d4750>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140508419035792'>, <Mock name='mock.cursor()' id='140508419035920'>)

    def test_storage_modules_comprehensive(self, standard_vacancy_data, mock_db_setup):
        """Комплексный тест модулей хранения"""
        connection, cursor = mock_db_setup
    
        # Тест DBManager
        with patch('src.storage.db_manager.psycopg2.connect', return_value=connection):
            from src.storage.db_manager import DBManager
    
            db_config = {
                'host': 'localhost',
                'port': '5432',
                'database': 'test_db',
                'username': 'test_user',
                'password': 'test_pass'
            }
    
            db_manager = DBManager(db_config)
>           db_manager.create_tables()

tests/test_optimized_coverage.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/db_manager.py:82: in create_tables
    with self._get_connection() as conn:
         ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fcaaa679e50>

    def _get_connection(self):
        """
        Создает подключение к базе данных
    
        Returns:
            connection: Подключение к БД (psycopg2 или простой адаптер)
    
        Raises:
            Exception: При ошибке подключения к БД
        """
        if not PSYCOPG2_AVAILABLE:
            # Возвращаем простой адаптер как "подключение"
            return get_db_adapter()
    
        try:
>           connection_params = self.db_config.get_connection_params()
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'get_connection_params'

src/storage/db_manager.py:64: AttributeError
-------------------------- Captured log call --------------------------
ERROR    src.storage.db_manager:db_manager.py:73 Ошибка подключения к базе данных: 'dict' object has no attribute 'get_connection_params'
ERROR    src.storage.db_manager:db_manager.py:212 Ошибка при создании таблиц: 'dict' object has no attribute 'get_connection_params'
_______ TestOptimizedCoverage.test_ui_interfaces_comprehensive ________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d52d0>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140508535452688'>, <Mock name='mock.cursor()' id='140508535455504'>)

    def test_ui_interfaces_comprehensive(self, standard_vacancy_data, mock_db_setup):
        """Комплексный тест UI интерфейсов"""
        connection, cursor = mock_db_setup
    
        with patch('builtins.input', return_value='1'), \
             patch('builtins.print'), \
             patch('src.storage.postgres_saver.psycopg2.connect', return_value=connection):
    
            from src.ui_interfaces.console_interface import UserInterface
            from src.storage.postgres_saver import PostgresSaver
            from src.api_modules.unified_api import UnifiedAPI
    
            # Создание компонентов
            db_config = {'host': 'localhost', 'port': '5432', 'database': 'test', 'username': 'user', 'password': 'pass'}
            storage = PostgresSaver(db_config)
            unified_api = UnifiedAPI()
    
>           interface = UserInterface(storage=storage, unified_api=unified_api)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: UserInterface.__init__() got an unexpected keyword argument 'unified_api'

tests/test_optimized_coverage.py:191: TypeError
______ TestOptimizedCoverage.test_utility_modules_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d53d0>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_utility_modules_comprehensive(self, standard_vacancy_data):
        """Комплексный тест утилитных модулей"""
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:202: TypeError
________ TestOptimizedCoverage.test_file_operations_and_cache _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d5c50>

    def test_file_operations_and_cache(self):
        """Тест файловых операций и кэширования"""
        # Тест файловых операций
        try:
            from src.utils.file_handlers import FileOperations
    
            # Создание временного файла
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                test_data = {"test": "data", "numbers": [1, 2, 3]}
                json.dump(test_data, f)
                temp_path = f.name
    
            try:
                file_ops = FileOperations()
    
                # Тест чтения
                result = file_ops.read_json(temp_path)
>               assert isinstance(result, dict)
E               assert False
E                +  where False = isinstance([], dict)

tests/test_optimized_coverage.py:265: AssertionError
-------------------------- Captured log call --------------------------
ERROR    src.utils.file_handlers:file_handlers.py:47 Failed to read /tmp/tmph8txr21e.json: 'str' object has no attribute 'exists'
__________ TestOptimizedCoverage.test_configuration_modules ___________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d60d0>

    def test_configuration_modules(self):
        """Тест модулей конфигурации"""
        try:
            from src.config.db_config import DatabaseConfig
    
            config = DatabaseConfig()
>           db_params = config.get_db_params()
                        ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DatabaseConfig' object has no attribute 'get_db_params'

tests/test_optimized_coverage.py:300: AttributeError
_________ TestOptimizedCoverage.test_decorators_and_utilities _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d6bd0>

    def test_decorators_and_utilities(self):
        """Тест декораторов и вспомогательных утилит"""
        try:
            from src.utils.decorators import simple_cache, time_execution
    
            # Тест кэширующего декоратора
            call_count = 0
    
            @simple_cache
            def expensive_function(x):
                nonlocal call_count
                call_count += 1
                return x * 2
    
            result1 = expensive_function(5)
            result2 = expensive_function(5)
    
>           assert result1 == result2 == 10
E           assert <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7fcaaa6f2ca0> == <function simple_cache.<locals>.decorator.<locals>.wrapper at 0x7fcaaa6f1bc0>

tests/test_optimized_coverage.py:357: AssertionError
_________ TestOptimizedCoverage.test_env_loader_comprehensive _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d68d0>

    def test_env_loader_comprehensive(self):
        """Комплексный тест загрузчика переменных окружения"""
        try:
            from src.utils.env_loader import EnvLoader
    
            # Создание временного .env файла
            with tempfile.NamedTemporaryFile(mode='w', suffix='.env', delete=False) as f:
                f.write("DATABASE_HOST=localhost\n")
                f.write("DATABASE_PORT=5432\n")
                f.write("API_KEY=test_key\n")
                f.write("DEBUG=True\n")
                env_path = f.name
    
            try:
>               loader = EnvLoader(env_path)
                         ^^^^^^^^^^^^^^^^^^^
E               TypeError: EnvLoader() takes no arguments

tests/test_optimized_coverage.py:385: TypeError
_______ TestOptimizedCoverage.test_error_handling_comprehensive _______

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14d7a50>
mock_db_setup = (<Mock id='140508514644880'>, <Mock name='mock.cursor()' id='140508514634192'>)

    def test_error_handling_comprehensive(self, mock_db_setup):
        """Комплексный тест обработки ошибок"""
        connection, cursor = mock_db_setup
    
        # Тест ошибок API
>       with patch('src.api_modules.hh_api.requests.get', side_effect=Exception("Network error")):

tests/test_optimized_coverage.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
_________ TestOptimizedCoverage.test_data_processing_modules __________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14e5710>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}

    def test_data_processing_modules(self, standard_vacancy_data):
        """Тест модулей обработки данных"""
>       vacancy = Vacancy.from_dict(standard_vacancy_data, 'hh')
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 were given

tests/test_optimized_coverage.py:432: TypeError
________ TestOptimizedCoverage.test_complete_integration_flow _________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14e4950>
standard_vacancy_data = {'area': {'name': 'Москва'}, 'employer': {'id': '789', 'name': 'Tech Company'}, 'employment': {'name': 'Полная занятость'}, 'experience': {'name': 'От 1 года до 3 лет'}, ...}
mock_db_setup = (<Mock id='140508418956688'>, <Mock name='mock.cursor()' id='140508418957968'>)

    def test_complete_integration_flow(self, standard_vacancy_data, mock_db_setup):
        """Полный интеграционный тест"""
        connection, cursor = mock_db_setup
    
>       with patch('src.api_modules.hh_api.requests.get') as mock_api_get, \
             patch('src.storage.postgres_saver.psycopg2.connect', return_value=connection), \
             patch('builtins.input', return_value='q'), \
             patch('builtins.print'):

tests/test_optimized_coverage.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.api_modules.hh_api.requests'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api_modules.hh_api' has no attribute 'requests'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/pkgutil.py:715: AttributeError
___________ TestOptimizedCoverage.test_remaining_utilities ____________

self = <tests.test_optimized_coverage.TestOptimizedCoverage object at 0x7fcab14e5190>

    def test_remaining_utilities(self):
        """Тест оставшихся утилит"""
        # Тест пагинатора
        try:
            from src.utils.paginator import Paginator
    
            items = list(range(50))
>           paginator = Paginator(items, per_page=10)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Paginator() takes no arguments

tests/test_optimized_coverage.py:536: TypeError
________________ TestPostgresSaver.test_get_connection ________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab14addd0>
mock_connect = <MagicMock name='connect' id='140508418896912'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_connection(self, mock_connect):
        """Тест получения соединения с БД"""
        mock_connection = Mock()
        mock_connect.return_value = mock_connection
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        connection = saver._get_connection()
>       assert connection == mock_connection
E       AssertionError: assert <MagicMock name='mock.connect()' id='140508418898512'> == <Mock name='connect()' id='140508418892176'>

tests/test_postgres_saver.py:157: AssertionError
_________________ TestPostgresSaver.test_save_vacancy _________________

self = <Mock name='connect().cursor().execute' id='140508516344592'>
args = ('INSERT INTO vacancies VALUES (%s, %s, %s)', ('123', 'Python Developer', 'hh.ru'))
kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab14adad0>
mock_connect = <MagicMock name='connect' id='140508516090384'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancy(self, mock_connect):
        """Тест сохранения вакансии"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        # Создаем мок вакансии, так как оригинальный класс Vacancy может быть не импортирован
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
    
>       mock_cursor.execute.assert_called_once_with(
            "INSERT INTO vacancies VALUES (%s, %s, %s)", (vacancy.vacancy_id, vacancy.title, vacancy.source)
        )
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:182: AssertionError
________________ TestPostgresSaver.test_save_vacancies ________________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab14aed50>
mock_connect = <MagicMock name='connect' id='140508515910224'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_save_vacancies(self, mock_connect):
        """Тест сохранения нескольких вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancies = [
            MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru"),
            MockVacancy(vacancy_id="124", title="Java Developer", source="superjob.ru"),
        ]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancies(vacancies)
    
>       assert mock_cursor.execute.call_count == len(vacancies)
E       AssertionError: assert 0 == 2
E        +  where 0 = <Mock name='connect().cursor().execute' id='140508419310160'>.call_count
E        +    where <Mock name='connect().cursor().execute' id='140508419310160'> = <Mock name='connect().cursor()' id='140508419324368'>.execute
E        +  and   2 = len([<tests.test_postgres_saver.TestPostgresSaver.test_save_vacancies.<locals>.MockVacancy object at 0x7fcaaa6be610>, <tests.test_postgres_saver.TestPostgresSaver.test_save_vacancies.<locals>.MockVacancy object at 0x7fcaaa6bc8d0>])

tests/test_postgres_saver.py:212: AssertionError
________________ TestPostgresSaver.test_get_vacancies _________________

self = <Mock name='connect().cursor().execute' id='140508418894544'>
args = ('SELECT * FROM vacancies',), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab1629990>
mock_connect = <MagicMock name='connect' id='140508534591440'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_vacancies(self, mock_connect):
        """Тест получения всех вакансий"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        mock_cursor.fetchall.return_value = [
            ("123", "Python Developer", "hh.ru"),
            ("124", "Java Developer", "superjob.ru"),
        ]
        # Имитируем описание столбцов, чтобы psycopg2.fetchmany корректно работал
        mock_cursor.description = [("id",), ("title",), ("source",)]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
    
>       mock_cursor.execute.assert_called_once_with("SELECT * FROM vacancies")
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:236: AssertionError
_____________ TestPostgresSaver.test_get_vacancies_empty ______________

self = <Mock name='connect().cursor().execute' id='140508419846544'>
args = ('SELECT * FROM vacancies',), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab16299d0>
mock_connect = <MagicMock name='connect' id='140508419839440'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_get_vacancies_empty(self, mock_connect):
        """Тест получения всех вакансий, когда они отсутствуют"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
    
        mock_cursor.fetchall.return_value = []
        mock_cursor.description = [("id",), ("title",), ("source",)]
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
    
>       mock_cursor.execute.assert_called_once_with("SELECT * FROM vacancies")
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:257: AssertionError
_________ TestPostgresSaver.test_delete_vacancy_by_id_success _________

self = <Mock name='connect().cursor().execute' id='140508418846864'>
args = ('DELETE FROM vacancies WHERE id = %s', ('123',)), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab16292d0>
mock_connect = <MagicMock name='connect' id='140508538097424'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_success(self, mock_connect):
        """Тест удаления вакансии по ID - успех"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
        mock_cursor.rowcount = 1
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.delete_vacancy_by_id("123")
    
>       mock_cursor.execute.assert_called_once_with("DELETE FROM vacancies WHERE id = %s", ("123",))
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:274: AssertionError
________ TestPostgresSaver.test_delete_vacancy_by_id_not_found ________

self = <Mock name='connect().cursor().execute' id='140508417781200'>
args = ('DELETE FROM vacancies WHERE id = %s', ('999',)), kwargs = {}
msg = "Expected 'execute' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'execute' to be called once. Called 0 times.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:950: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab1629a50>
mock_connect = <MagicMock name='connect' id='140508417771088'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_delete_vacancy_by_id_not_found(self, mock_connect):
        """Тест удаления вакансии по ID - не найдено"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_connection
        mock_cursor.rowcount = 0
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.delete_vacancy_by_id("999")
    
>       mock_cursor.execute.assert_called_once_with("DELETE FROM vacancies WHERE id = %s", ("999",))
E       AssertionError: Expected 'execute' to be called once. Called 0 times.

tests/test_postgres_saver.py:292: AssertionError
________ TestPostgresSaver.test_connection_error_handling_save ________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab162a150>
mock_connect = <MagicMock name='connect' id='140508516185360'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_connection_error_handling_save(self, mock_connect):
        """Тест обработки ошибок соединения при сохранении"""
        mock_connect.side_effect = psycopg2.Error("Connection failed")
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
>       assert result is False
E       assert True is False

tests/test_postgres_saver.py:312: AssertionError
________ TestPostgresSaver.test_connection_error_handling_get _________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab162a890>
mock_connect = <MagicMock name='connect' id='140508525866384'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_connection_error_handling_get(self, mock_connect):
        """Тест обработки ошибок соединения при получении"""
        mock_connect.side_effect = psycopg2.Error("Connection failed")
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
>       assert result == []
E       AssertionError: assert <MagicMock na...508534594896'> == []
E         
E         Use -v to get more diff

tests/test_postgres_saver.py:323: AssertionError
__________ TestPostgresSaver.test_cursor_error_handling_save __________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab162b490>
mock_connect = <MagicMock name='connect' id='140508516074832'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_cursor_error_handling_save(self, mock_connect):
        """Тест обработки ошибок курсора при сохранении"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.execute.side_effect = psycopg2.Error("Cursor execute error")
        mock_connect.return_value = mock_connection
    
        class MockVacancy:
            def __init__(self, vacancy_id, title, source):
                self.vacancy_id = vacancy_id
                self.title = title
                self.source = source
    
        vacancy = MockVacancy(vacancy_id="123", title="Python Developer", source="hh.ru")
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.save_vacancy(vacancy)
>       assert result is False
E       assert True is False

tests/test_postgres_saver.py:356: AssertionError
__________ TestPostgresSaver.test_cursor_error_handling_get ___________

self = <tests.test_postgres_saver.TestPostgresSaver object at 0x7fcab162bcd0>
mock_connect = <MagicMock name='connect' id='140508515835280'>

    @patch("src.storage.postgres_saver.psycopg2.connect")
    def test_cursor_error_handling_get(self, mock_connect):
        """Тест обработки ошибок курсора при получении"""
        mock_connection = Mock()
        mock_cursor = Mock()
        mock_connection.cursor.return_value = mock_cursor
        mock_cursor.execute.side_effect = psycopg2.Error("Cursor execute error")
        mock_connect.return_value = mock_connection
    
        mock_db_config = self.get_test_db_config()
        saver = PostgresSaver(mock_db_config)
    
        result = saver.get_vacancies()
>       assert result == []
E       AssertionError: assert <MagicMock na...508534594896'> == []
E         
E         Use -v to get more diff

tests/test_postgres_saver.py:371: AssertionError
_ TestVacancyStorageService.test_vacancy_storage_service_all_methods __

self = <tests.test_targeted_coverage.TestVacancyStorageService object at 0x7fcab176c810>
mock_connect = <MagicMock name='connect' id='140508514954384'>

    @patch('psycopg2.connect')
    def test_vacancy_storage_service_all_methods(self, mock_connect):
        """Тестирование всех методов VacancyStorageService"""
        try:
            from src.storage.services.vacancy_storage_service import VacancyStorageService
    
            mock_conn = Mock()
            mock_cursor = Mock()
            mock_cursor.fetchone.return_value = (1, 'Test Company', '123')
            mock_cursor.fetchall.return_value = [(1, 'vacancy1'), (2, 'vacancy2')]
            mock_cursor.rowcount = 5
            mock_conn.cursor.return_value = mock_cursor
            mock_connect.return_value = mock_conn
    
            # Инициализация сервиса
>           storage = VacancyStorageService()
                      ^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: Can't instantiate abstract class VacancyStorageService with abstract methods delete_vacancy, get_storage_stats, get_vacancies

tests/test_targeted_coverage.py:115: TypeError
_______ TestUserInterface.test_user_interface_complete_workflow _______

self = <tests.test_targeted_coverage.TestUserInterface object at 0x7fcab176db50>
mock_print = <MagicMock name='print' id='140508514879568'>
mock_input = <MagicMock name='input' id='140508515167120'>

    @patch('builtins.input')
    @patch('builtins.print')
    def test_user_interface_complete_workflow(self, mock_print, mock_input):
        """Полное тестирование пользовательского интерфейса"""
        try:
            from src.user_interface import UserInterface
    
            # Различные сценарии ввода пользователя
            mock_input.side_effect = [
                '1',  # Поиск вакансий
                'Python',  # Запрос
                '1',  # HH.ru
                '1',  # Москва
                '100000',  # Зарплата от
                '200000',  # Зарплата до
                '2',  # От 1 до 3 лет
                'y',  # Подтверждение
                '0'   # Выход
            ]
    
            ui = UserInterface()
            assert ui is not None
    
            # Тест инициализации
            if hasattr(ui, '__init__'):
                ui.__init__()
    
            # Тест основного меню
            if hasattr(ui, 'show_main_menu'):
                ui.show_main_menu()
    
            if hasattr(ui, 'display_menu'):
                ui.display_menu()
    
            # Тест обработки пользовательского ввода
            if hasattr(ui, 'get_user_input'):
                result = ui.get_user_input('Введите запрос: ')
                assert isinstance(result, (str, type(None)))
    
            if hasattr(ui, 'get_user_choice'):
                choice = ui.get_user_choice(['Опция 1', 'Опция 2', 'Опция 3'])
                assert isinstance(choice, (int, str, type(None)))
    
            # Тест поиска вакансий
            if hasattr(ui, 'handle_search'):
                ui.handle_search()
    
            if hasattr(ui, 'search_vacancies'):
                ui.search_vacancies()
    
            if hasattr(ui, 'get_search_parameters'):
                params = ui.get_search_parameters()
                assert isinstance(params, (dict, type(None)))
    
            # Тест отображения результатов
            if hasattr(ui, 'display_vacancies'):
                vacancies = [create_test_vacancy(), create_test_vacancy()]
                ui.display_vacancies(vacancies)
    
            if hasattr(ui, 'display_vacancy'):
                ui.display_vacancy(create_test_vacancy())
    
            if hasattr(ui, 'show_vacancy_details'):
                ui.show_vacancy_details(create_test_vacancy())
    
            # Тест пагинации
            if hasattr(ui, 'paginate_results'):
                vacancies = [create_test_vacancy() for _ in range(20)]
                ui.paginate_results(vacancies)
    
            if hasattr(ui, 'show_page'):
                ui.show_page([create_test_vacancy()], 1, 10)
    
            # Тест фильтрации и сортировки
            if hasattr(ui, 'handle_filtering'):
                ui.handle_filtering()
    
            if hasattr(ui, 'apply_filters'):
                filters = {'salary_from': 100000, 'area': 'Москва'}
                ui.apply_filters(filters)
    
            if hasattr(ui, 'handle_sorting'):
                ui.handle_sorting()
    
            # Тест сохранения результатов
            if hasattr(ui, 'save_results'):
                vacancies = [create_test_vacancy()]
                ui.save_results(vacancies)
    
            if hasattr(ui, 'export_to_file'):
                ui.export_to_file([create_test_vacancy()], 'results.json')
    
            # Тест статистики
            if hasattr(ui, 'show_statistics'):
                ui.show_statistics([create_test_vacancy()])
    
            if hasattr(ui, 'display_stats'):
                stats = {'total': 100, 'avg_salary': 150000}
                ui.display_stats(stats)
    
            # Тест настроек
            if hasattr(ui, 'show_settings'):
                ui.show_settings()
    
            if hasattr(ui, 'configure_settings'):
                ui.configure_settings()
    
            # Тест справки
            if hasattr(ui, 'show_help'):
                ui.show_help()
    
            if hasattr(ui, 'display_instructions'):
                ui.display_instructions()
    
            # Тест запуска приложения
            if hasattr(ui, 'start'):
                # Мокаем все зависимости для избежания бесконечного цикла
                with patch.object(ui, 'show_main_menu', return_value=None):
                    with patch.object(ui, 'handle_search', return_value=None):
                        ui.start()
    
            if hasattr(ui, 'run'):
>               with patch.object(ui, 'display_menu', return_value=None):

tests/test_targeted_coverage.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab0225650>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <src.ui_interfaces.console_interface.UserInterface object at 0x7fcab0225950> does not have the attribute 'display_menu'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestRemainingLowCoverageModules.test_vacancy_search_handler_methods _

self = <tests.test_targeted_coverage.TestRemainingLowCoverageModules object at 0x7fcab176f810>

    def test_vacancy_search_handler_methods(self):
        """Тестирование vacancy_search_handler.py - 16% покрытие"""
        try:
            from src.ui_interfaces.vacancy_search_handler import VacancySearchHandler
    
>           handler = VacancySearchHandler()
                      ^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: VacancySearchHandler.__init__() missing 2 required positional arguments: 'unified_api' and 'storage'

tests/test_targeted_coverage.py:651: TypeError
________ TestUIHelpers.test_filter_vacancies_by_keyword_basic _________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7fcab150c610>
sample_vacancies = [<Mock id='140508513799568'>, <Mock id='140508513799888'>, <Mock id='140508513800400'>, <Mock id='140508513801360'>]

    def test_filter_vacancies_by_keyword_basic(self, sample_vacancies):
        """Тест базовой фильтрации по ключевому слову"""
        # Создаем реальные вакансии вместо Mock
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Python Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': {'from': 100000, 'to': 150000, 'currency': 'RUR'},
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Python', 'responsibility': 'Development'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
>       result = ui_helpers.filter_vacancies_by_keyword(real_vacancies, "Python")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:144: in filter_vacancies_by_keyword
    full_text = _build_searchable_text(vacancy)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancy = <tests.test_ui_helpers_comprehensive.Vacancy object at 0x7fcab00d8410>

    def _build_searchable_text(vacancy: Vacancy) -> str:
        """
        Формирует единую строку поиска из всех текстовых полей вакансии
    
        Args:
            vacancy: Объект вакансии
    
        Returns:
            str: Объединенный текст для поиска в нижнем регистре
        """
        searchable_text = []
    
        # Проверяем названия
>       if vacancy.title:
           ^^^^^^^^^^^^^
E       AttributeError: 'Vacancy' object has no attribute 'title'

src/utils/ui_helpers.py:202: AttributeError
____________ TestUIHelpers.test_display_vacancy_info_basic ____________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7fcab150c7d0>

    def test_display_vacancy_info_basic(self):
        """Тест отображения информации о вакансии"""
        # Создаем реальную вакансию для более точного теста
        vacancy_data = {
            'id': 'test_1',
            'name': 'Test Developer',
            'url': 'http://test.com',
            'salary': {'from': 50000, 'to': 70000, 'currency': 'RUR'},
            'employer': {'name': 'Test Company'},
            'area': {'name': 'Санкт-Петербург'},
            'experience': {'name': 'От 1 года до 3 лет'},
            'employment': {'name': 'Полная занятость'},
            'schedule': {'name': 'Полный день'},
            'snippet': {'requirement': 'Good skills', 'responsibility': 'Coding'},
            'published_at': '2025-01-01T00:00:00+0300'
        }
        vacancy = Vacancy.from_dict(vacancy_data, 'hh')
    
        with patch('builtins.print') as mock_print:
            ui_helpers.display_vacancy_info(vacancy, 1)
    
        # Проверяем, что print был вызван с ожидаемым форматом
        # Примерные строки, которые должны быть напечатаны
        expected_calls = [
>           pytest.call("Вакансия № 1:"),
            ^^^^^^^^^^^
            pytest.call(f"Название: {vacancy.name}"),
            pytest.call(f"Компания: {vacancy.employer.name}"),
            pytest.call(f"Зарплата: от {vacancy.salary.salary_from} до {vacancy.salary.salary_to} RUR"),
            pytest.call(f"URL: {vacancy.url}")
        ]
E       AttributeError: module 'pytest' has no attribute 'call'

tests/test_ui_helpers_comprehensive.py:275: AttributeError
_______ TestUIHelpers.test_filter_vacancies_by_min_salary_basic _______

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7fcab150d210>
sample_vacancies = [<Mock id='140508513809296'>, <Mock id='140508513809104'>, <Mock id='140508513808976'>, <Mock id='140508513798416'>]

    def test_filter_vacancies_by_min_salary_basic(self, sample_vacancies):
        """Тест фильтрации по минимальной зарплате"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Python Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': {'from': 100000 + i * 30000, 'to': 150000 + i * 50000, 'currency': 'RUR'},
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Python', 'responsibility': 'Development'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
        min_salary_threshold = 120000
>       result = ui_helpers.filter_vacancies_by_min_salary(real_vacancies, min_salary_threshold)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:256: in filter_vacancies_by_min_salary
    return VacancyOperations.filter_vacancies_by_min_salary(vacancies, min_salary)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

vacancies = [<tests.test_ui_helpers_comprehensive.Vacancy object at 0x7fcab00d8990>, <tests.test_ui_helpers_comprehensive.Vacancy ...omprehensive.Vacancy object at 0x7fcab00d8750>, <tests.test_ui_helpers_comprehensive.Vacancy object at 0x7fcab00daf50>]
min_salary = 120000

    @staticmethod
    def filter_vacancies_by_min_salary(vacancies: List[Vacancy], min_salary: int) -> List[Vacancy]:
        """
        Фильтрация вакансий по минимальной зарплате
    
        Args:
            vacancies: Список вакансий для фильтрации
            min_salary: Минимальная зарплата
    
        Returns:
            List[Vacancy]: Список отфильтрованных вакансий
        """
        filtered_vacancies = []
    
        for vacancy in vacancies:
            # Пропускаем вакансии без зарплаты
            if not vacancy.salary:
                continue
    
            # Получаем значения зарплаты
>           salary_from = vacancy.salary.salary_from
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'salary_from'

src/utils/vacancy_operations.py:66: AttributeError
_________ TestUIHelpers.test_get_vacancies_with_salary_basic __________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7fcab150d590>
sample_vacancies = [<Mock id='140508513921936'>, <Mock id='140508513921360'>, <Mock id='140508513921872'>, <Mock id='140508513922192'>]

    def test_get_vacancies_with_salary_basic(self, sample_vacancies):
        """Тест получения вакансий с зарплатой"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            salary_data = {'from': 100000 + i * 20000, 'to': 150000 + i * 30000, 'currency': 'RUR'} if i % 2 == 0 else None
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': salary_data,
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Skills', 'responsibility': 'Tasks'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
>       result = ui_helpers.get_vacancies_with_salary(real_vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/utils/ui_helpers.py:271: in get_vacancies_with_salary
    return VacancyOperations.get_vacancies_with_salary(vacancies)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/vacancy_operations.py:24: in get_vacancies_with_salary
    return [v for v in vacancies if v.salary and (v.salary.salary_from or v.salary.salary_to)]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x7fcab0228880>

>   return [v for v in vacancies if v.salary and (v.salary.salary_from or v.salary.salary_to)]
                                                  ^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'salary_from'

src/utils/vacancy_operations.py:24: AttributeError
__________ TestUIHelpers.test_sort_vacancies_by_salary_basic __________

self = <tests.test_ui_helpers_comprehensive.TestUIHelpers object at 0x7fcab1497590>
sample_vacancies = [<Mock id='140508514115280'>, <Mock id='140508514120848'>, <Mock id='140508514120720'>, <Mock id='140508514120976'>]

    def test_sort_vacancies_by_salary_basic(self, sample_vacancies):
        """Тест сортировки вакансий по зарплате"""
        # Используем реальные вакансии для теста
        real_vacancies = []
        for i, mock_v in enumerate(sample_vacancies):
            salary_data = {'from': 100000 + i * 30000, 'to': 150000 + i * 50000, 'currency': 'RUR'}
            vacancy_data = {
                'id': f'test_{i}',
                'name': f'Developer {i}',
                'url': f'https://test.com/{i}',
                'salary': salary_data,
                'employer': {'name': f'Company {i}'},
                'area': {'name': 'Москва'},
                'experience': {'name': 'От 1 года до 3 лет'},
                'employment': {'name': 'Полная занятость'},
                'schedule': {'name': 'Полный день'},
                'snippet': {'requirement': 'Skills', 'responsibility': 'Tasks'},
                'published_at': '2025-01-01T00:00:00+0300'
            }
            real_vacancies.append(Vacancy.from_dict(vacancy_data, 'hh'))
    
        result = ui_helpers.sort_vacancies_by_salary(real_vacancies)
    
        assert isinstance(result, list)
        assert len(result) == 4
        # Проверяем, что зарплаты отсортированы по возрастанию
        # sample_vacancies[0] -> from: 100000
        # sample_vacancies[1] -> from: 130000
        # sample_vacancies[2] -> from: 160000
        # sample_vacancies[3] -> from: 190000
        expected_salaries = [100000, 130000, 160000, 190000]
>       actual_salaries = [v.salary.salary_from for v in result]
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ui_helpers_comprehensive.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x7fcab1d96590>

>   actual_salaries = [v.salary.salary_from for v in result]
                       ^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'salary_from'

tests/test_ui_helpers_comprehensive.py:381: AttributeError
_________________ TestUserInterface.test_main_success _________________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bfd10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14b8110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_db_connection_fails ___________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15be690>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab15c3850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_create_tables_fails ___________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bdfd0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14c5410>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestUserInterface.test_main_populate_companies_fails _________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15be310>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14c6550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______ TestUserInterface.test_main_initialization_check_fails ________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bea90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14c5f90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
___________ TestUserInterface.test_main_keyboard_interrupt ____________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bcb90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14c6b10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestUserInterface.test_main_database_error_handling _________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bc910>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab14c6f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestUserInterface.test_main_general_error_handling __________

args = (<tests.test_user_interface.TestUserInterface object at 0x7fcab15bd1d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fcab15bef50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.user_interface' from '/home/runner/workspace/tests/../src/user_interface.py'> does not have the attribute 'DBManager'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_with_keyword _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1615050>
mock_filter = <MagicMock name='filter_vacancies_by_keyword' id='140508515965776'>

    @patch('src.utils.vacancy_operations.filter_vacancies_by_keyword')
    def test_filter_vacancies_by_criteria_with_keyword(self, mock_filter):
        """Тест фильтрации вакансий по критериям с ключевым словом"""
        vacancies = [MockVacancy("Python Developer"), MockVacancy("Java Developer")]
        mock_filter.return_value = [vacancies[0]]
    
        criteria = {"keyword": "Python"}
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:207: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_with_min_salary _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1615550>

    def test_filter_vacancies_by_criteria_with_min_salary(self):
        """Тест фильтрации вакансий по критериям с минимальной зарплатой"""
        vacancies = [
            MockVacancy("High Salary Job", MockSalary(150000, 200000)),
            MockVacancy("Low Salary Job", MockSalary(50000, 80000))
        ]
    
        criteria = {"min_salary": 100000}
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:221: AttributeError
__ TestVacancyOperations.test_filter_vacancies_by_criteria_combined ___

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1615910>

    def test_filter_vacancies_by_criteria_combined(self):
        """Тест фильтрации по комбинированным критериям"""
        vacancies = [
            MockVacancy("Python Developer", MockSalary(150000, 200000)),
            MockVacancy("Python Junior", MockSalary(50000, 80000)),
            MockVacancy("Java Developer", MockSalary(120000, 150000))
        ]
    
        with patch('src.utils.vacancy_operations.filter_vacancies_by_keyword') as mock_filter:
            # Мокаем чтобы вернуть только Python вакансии
            mock_filter.return_value = [vacancies[0], vacancies[1]]
    
            criteria = {"keyword": "Python", "min_salary": 100000}
>           result = VacancyOperations.filter_vacancies_by_criteria(vacancies, criteria)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:239: AttributeError
_ TestVacancyOperations.test_filter_vacancies_by_criteria_empty_criteria _

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1615e90>

    def test_filter_vacancies_by_criteria_empty_criteria(self):
        """Тест фильтрации с пустыми критериями"""
        vacancies = [MockVacancy("Job 1"), MockVacancy("Job 2")]
    
>       result = VacancyOperations.filter_vacancies_by_criteria(vacancies, {})
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'filter_vacancies_by_criteria'

tests/test_vacancy_operations_enhanced.py:248: AttributeError
__ TestVacancyOperations.test_get_vacancies_statistics_comprehensive __

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1617c90>

    def test_get_vacancies_statistics_comprehensive(self):
        """Тест получения комплексной статистики по вакансиям"""
        vacancies = [
            MockVacancy("Python Developer", MockSalary(100000, 150000)),
            MockVacancy("Java Developer", MockSalary(80000, 120000)),
            MockVacancy("No Salary Job", None),
            MockVacancy("Frontend Developer", MockSalary(70000, 100000))
        ]
    
>       stats = VacancyOperations.get_vacancies_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:262: AttributeError
___ TestVacancyOperations.test_get_vacancies_statistics_empty_list ____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1616990>

    def test_get_vacancies_statistics_empty_list(self):
        """Тест статистики для пустого списка"""
>       stats = VacancyOperations.get_vacancies_statistics([])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:272: AttributeError
___ TestVacancyOperations.test_get_vacancies_statistics_no_salaries ___

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab16173d0>

    def test_get_vacancies_statistics_no_salaries(self):
        """Тест статистики когда нет зарплат"""
        vacancies = [
            MockVacancy("Job 1", None),
            MockVacancy("Job 2", MockSalary(None, None))
        ]
    
>       stats = VacancyOperations.get_vacancies_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'get_vacancies_statistics'

tests/test_vacancy_operations_enhanced.py:287: AttributeError
_______ TestVacancyOperations.test_deduplicate_vacancies_by_url _______

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1614d90>

    def test_deduplicate_vacancies_by_url(self):
        """Тест дедупликации вакансий по URL"""
        vacancies = [
            MockVacancy("Job 1"),
            MockVacancy("Job 2"),
            MockVacancy("Job 1 Duplicate")
        ]
    
        # Устанавливаем одинаковые URL для дубликатов
        vacancies[0].url = "http://test.com/job1"
        vacancies[1].url = "http://test.com/job2"
        vacancies[2].url = "http://test.com/job1"  # Дубликат
    
>       result = VacancyOperations.deduplicate_vacancies(vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:308: AttributeError
_____ TestVacancyOperations.test_deduplicate_vacancies_empty_list _____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1614710>

    def test_deduplicate_vacancies_empty_list(self):
        """Тест дедупликации пустого списка"""
>       result = VacancyOperations.deduplicate_vacancies([])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:317: AttributeError
___ TestVacancyOperations.test_deduplicate_vacancies_no_duplicates ____

self = <tests.test_vacancy_operations_enhanced.TestVacancyOperations object at 0x7fcab1507e10>

    def test_deduplicate_vacancies_no_duplicates(self):
        """Тест дедупликации когда дубликатов нет"""
        vacancies = [
            MockVacancy("Job 1"),
            MockVacancy("Job 2"),
            MockVacancy("Job 3")
        ]
    
        # Устанавливаем уникальные URL
        for i, vacancy in enumerate(vacancies):
            vacancy.url = f"http://test.com/job{i+1}"
    
>       result = VacancyOperations.deduplicate_vacancies(vacancies)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: type object 'VacancyOperations' has no attribute 'deduplicate_vacancies'

tests/test_vacancy_operations_enhanced.py:333: AttributeError
======================= short test summary info =======================
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_hh_api_functionality - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_superjob_api_functionality - AttributeError: module 'src.api_modules.sj_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_unified_api_functionality - AttributeError: Mock object has no attribute 'get'
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_db_manager_functionality - AttributeError: 'dict' object has no attribute 'get_connection_par...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_postgres_saver_functionality - AttributeError: 'PostgresSaver' object has no attribute 'save_vaca...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_user_interface_functionality - AttributeError: <class 'src.ui_interfaces.console_interface.UserIn...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_vacancy_model_functionality - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_utility_modules_functionality - assert False
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_storage_services_functionality - AttributeError: <class 'src.storage.components.vacancy_repository....
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_config_modules_functionality - AttributeError: 'DatabaseConfig' object has no attribute 'get_db_p...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_ui_components_functionality - AttributeError: 'VacancyDisplayHandler' object has no attribute 'd...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_decorators_functionality - assert <function simple_cache.<locals>.decorator.<locals>.wrapper ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_vacancy_operations_functionality - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_env_loader_functionality - TypeError: EnvLoader() takes no arguments
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_menu_manager_functionality - TypeError: MenuManager.__init__() takes 1 positional argument but ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_paginator_functionality - TypeError: Paginator() takes no arguments
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_main_application_interface_functionality - TypeError: MainApplicationInterface.__init__() missing 3 required ...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_storage_factory_functionality - TypeError: StorageFactory.create_storage() takes from 0 to 1 posit...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_main_user_interface_module - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_api_connector_functionality - AttributeError: <module 'src.api_modules.get_api' from '/home/runn...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_comprehensive_error_handling - Exception: Connection failed
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_integration_workflow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_complete_service_layer_coverage - AttributeError: 'DeduplicationService' object has no attribute 'de...
FAILED tests/test_consolidated_coverage.py::TestConsolidatedCoverage::test_complete_application_flow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_basic_functionality_coverage - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_api_modules_basic_coverage - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_ui_basic_coverage - TypeError: UserInterface.__init__() got an unexpected keyword argu...
FAILED tests/test_coverage_validation.py::TestCoverageValidation::test_config_basic_coverage - AttributeError: type object 'TargetCompanies' has no attribute 'ge...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_vacancy_model_creation_and_methods - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_api_modules_comprehensive - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_storage_modules_comprehensive - AttributeError: 'dict' object has no attribute 'get_connection_par...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_ui_interfaces_comprehensive - TypeError: UserInterface.__init__() got an unexpected keyword argu...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_utility_modules_comprehensive - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_file_operations_and_cache - assert False
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_configuration_modules - AttributeError: 'DatabaseConfig' object has no attribute 'get_db_p...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_decorators_and_utilities - assert <function simple_cache.<locals>.decorator.<locals>.wrapper ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_env_loader_comprehensive - TypeError: EnvLoader() takes no arguments
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_error_handling_comprehensive - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_data_processing_modules - TypeError: Vacancy.from_dict() takes 2 positional arguments but 3 ...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_complete_integration_flow - AttributeError: module 'src.api_modules.hh_api' has no attribute '...
FAILED tests/test_optimized_coverage.py::TestOptimizedCoverage::test_remaining_utilities - TypeError: Paginator() takes no arguments
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_connection - AssertionError: assert <MagicMock name='mock.connect()' id='140508...
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancy - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_save_vacancies - AssertionError: assert 0 == 2
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_get_vacancies_empty - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_success - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_delete_vacancy_by_id_not_found - AssertionError: Expected 'execute' to be called once. Called 0 times.
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_connection_error_handling_save - assert True is False
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_connection_error_handling_get - AssertionError: assert <MagicMock na...508534594896'> == []
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_cursor_error_handling_save - assert True is False
FAILED tests/test_postgres_saver.py::TestPostgresSaver::test_cursor_error_handling_get - AssertionError: assert <MagicMock na...508534594896'> == []
FAILED tests/test_targeted_coverage.py::TestVacancyStorageService::test_vacancy_storage_service_all_methods - TypeError: Can't instantiate abstract class VacancyStorageService ...
FAILED tests/test_targeted_coverage.py::TestUserInterface::test_user_interface_complete_workflow - AttributeError: <src.ui_interfaces.console_interface.UserInterface...
FAILED tests/test_targeted_coverage.py::TestRemainingLowCoverageModules::test_vacancy_search_handler_methods - TypeError: VacancySearchHandler.__init__() missing 2 required posi...
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_filter_vacancies_by_keyword_basic - AttributeError: 'Vacancy' object has no attribute 'title'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_display_vacancy_info_basic - AttributeError: module 'pytest' has no attribute 'call'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_filter_vacancies_by_min_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_get_vacancies_with_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_ui_helpers_comprehensive.py::TestUIHelpers::test_sort_vacancies_by_salary_basic - AttributeError: 'dict' object has no attribute 'salary_from'
FAILED tests/test_user_interface.py::TestUserInterface::test_main_success - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_db_connection_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_create_tables_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_populate_companies_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_initialization_check_fails - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_keyboard_interrupt - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_database_error_handling - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_user_interface.py::TestUserInterface::test_main_general_error_handling - AttributeError: <module 'src.user_interface' from '/home/runner/wo...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_with_keyword - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_with_min_salary - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_combined - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_filter_vacancies_by_criteria_empty_criteria - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_comprehensive - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_empty_list - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_get_vacancies_statistics_no_salaries - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_by_url - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_empty_list - AttributeError: type object 'VacancyOperations' has no attribute '...
FAILED tests/test_vacancy_operations_enhanced.py::TestVacancyOperations::test_deduplicate_vacancies_no_duplicates - AttributeError: type object 'VacancyOperations' has no attribute '...
=================== 78 failed, 638 passed in 5.79s ====================
~/workspace$ 