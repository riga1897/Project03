~/workspace$ pytest
========================== test session starts ==========================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 294 items                                                     

tests/test_abstract.py ........                                   [  2%]
tests/test_abstract_db_manager.py ....                            [  4%]
tests/test_api_config.py ....                                     [  5%]
tests/test_app_config.py .....                                    [  7%]
tests/test_base_api.py ......                                     [  9%]
tests/test_base_parser.py ......                                  [ 11%]
tests/test_cache.py .......                                       [ 13%]
tests/test_cached_api.py FFFFF                                    [ 15%]
tests/test_db_manager.py FF..FF.F                                 [ 18%]
tests/test_decorators.py .......                                  [ 20%]
tests/test_env_loader.py ............                             [ 24%]
tests/test_file_handlers.py ............                          [ 28%]
tests/test_get_api.py ......                                      [ 30%]
tests/test_hh_api.py .......                                      [ 32%]
tests/test_hh_api_config.py .....                                 [ 34%]
tests/test_hh_parser.py ....FFF.                                  [ 37%]
tests/test_menu_manager.py ..........                             [ 40%]
tests/test_paginator.py ....FF                                    [ 42%]
tests/test_postgres_saver.py .......                              [ 45%]
tests/test_salary_utils.py .F..................                   [ 52%]
tests/test_search_utils.py ..................                     [ 58%]
tests/test_sj_api.py FF...FFF.                                    [ 61%]
tests/test_sj_api_config.py .....                                 [ 62%]
tests/test_sj_parser.py ........                                  [ 65%]
tests/test_storage_factory.py .F...F..                            [ 68%]
tests/test_target_companies.py .....                              [ 70%]
tests/test_ui_config.py .....                                     [ 71%]
tests/test_ui_helpers.py ...........                              [ 75%]
tests/test_unified_api.py .................                       [ 81%]
tests/test_user_interface.py .FF..F..                             [ 84%]
tests/test_vacancy_display_handler.py ..FFFFF                     [ 86%]
tests/test_vacancy_formatter.py ..FFFF.                           [ 88%]
tests/test_vacancy_models.py .......FFFFF                         [ 92%]
tests/test_vacancy_operations_coordinator.py .FFFF.F.             [ 95%]
tests/test_vacancy_search_handler.py .F.FFF                       [ 97%]
tests/test_vacancy_stats.py .......                               [100%]

=============================== FAILURES ================================
_____________ TestCachedAPI.test_cached_api_initialization ______________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fecb35b6e10>
mock_file_cache = <MagicMock name='FileCache' id='140654576768272'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_initialization(self, mock_file_cache):
        """Тест инициализации CachedAPI"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'CachedAPIImplementation' is not defined

tests/test_cached_api.py:45: NameError
___________ TestCachedAPI.test_cached_api_with_cache_manager ____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fecb35b5090>
mock_file_cache = <MagicMock name='FileCache' id='140654576962960'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_with_cache_manager(self, mock_file_cache):
        """Тест CachedAPI с кэш менеджером"""
        mock_cache_instance = Mock()
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'CachedAPIImplementation' is not defined

tests/test_cached_api.py:54: NameError
____________ TestCachedAPI.test_cached_api_abstract_methods _____________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fecb35b5e50>
mock_file_cache = <MagicMock name='FileCache' id='140654576697232'>

    @patch("src.utils.cache.FileCache")
    def test_cached_api_abstract_methods(self, mock_file_cache):
        """Тест абстрактных методов CachedAPI"""
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'CachedAPIImplementation' is not defined

tests/test_cached_api.py:60: NameError
_________________ TestCachedAPI.test_cache_integration __________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fecb35b5b90>
mock_file_cache = <MagicMock name='FileCache' id='140654576744080'>

    @patch("src.utils.cache.FileCache")
    def test_cache_integration(self, mock_file_cache):
        """Тест интеграции с кэшем"""
        mock_cache_instance = Mock()
        mock_cache_instance.get.return_value = None
        mock_cache_instance.set.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'CachedAPIImplementation' is not defined

tests/test_cached_api.py:77: NameError
_________________ TestCachedAPI.test_clear_cache_method _________________

self = <workspace.tests.test_cached_api.TestCachedAPI object at 0x7fecb35b13d0>
mock_file_cache = <MagicMock name='FileCache' id='140654576811664'>

    @patch("src.utils.cache.FileCache")
    def test_clear_cache_method(self, mock_file_cache):
        """Тест метода очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache_instance.clear.return_value = None
        mock_file_cache.return_value = mock_cache_instance
    
>       api = CachedAPIImplementation()
              ^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'CachedAPIImplementation' is not defined

tests/test_cached_api.py:89: NameError
______________ TestDBManager.test_check_connection_success ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fecb35de890>
mock_connect = <MagicMock name='connect' id='140654576599504'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_check_connection_success(self, mock_connect):
        """Тест успешной проверки соединения"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем метод проверки соединения
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            result = db_manager.check_connection()
>           assert result is True
E           assert False is True

tests/test_db_manager.py:84: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:809 Неожиданная ошибка при проверке подключения: 'MockConnection' object does not support the context manager protocol
___________________ TestDBManager.test_create_tables ____________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fecb35de850>
mock_connect = <MagicMock name='connect' id='140654576972432'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_create_tables(self, mock_connect):
        """Тест создания таблиц"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
        # Мокаем метод обеспечения существования таблиц
        with patch.object(db_manager, "_ensure_tables_exist", return_value=True):
            with patch.object(db_manager, "_get_connection", return_value=mock_connection):
>               db_manager.create_tables()

tests/test_db_manager.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.storage.db_manager.DBManager object at 0x7fecb211efd0>

    def create_tables(self):
        """
        Создает таблицы компаний и вакансий в базе данных, если они не существуют
        Автоматически добавляет недостающие поля в существующие таблицы
        """
        try:
>           with self._get_connection() as conn:
E           TypeError: 'MockConnection' object does not support the context manager protocol

src/storage/db_manager.py:68: TypeError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'MockConnection' object does not support the context manager protocol
___________________ TestDBManager.test_get_avg_salary ___________________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fecb35c3990>
mock_connect = <MagicMock name='connect' id='140654576778128'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_get_avg_salary(self, mock_connect):
        """Тест получения средней зарплаты"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor_instance = mock_cursor.__enter__.return_value
        mock_cursor_instance.fetchone.return_value = (125000.0,)
    
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем соединение
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            result = db_manager.get_avg_salary()
    
>       assert result == 125000.0
E       assert None == 125000.0

tests/test_db_manager.py:155: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'MockConnection' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'MockConnection' object does not support the context manager protocol
__________ TestDBManager.test_get_vacancies_with_higher_salary __________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fecb35e9d10>
mock_connect = <MagicMock name='connect' id='140654576811152'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_get_vacancies_with_higher_salary(self, mock_connect):
        """Тест получения вакансий с зарплатой выше средней"""
        mock_connection = MockConnection()
        mock_cursor = mock_connection.cursor()
        mock_cursor_instance = mock_cursor.__enter__.return_value
        mock_cursor_instance.fetchall.return_value = [
            ("124", "Senior Python Developer", "Test Company", 200000, "Москва", "https://test.com")
        ]
    
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем соединение
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            result = db_manager.get_vacancies_with_higher_salary()
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_db_manager.py:175: AssertionError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.db_manager:db_manager.py:196 Ошибка при создании таблиц: 'MockConnection' object does not support the context manager protocol
WARNING  src.storage.db_manager:db_manager.py:410 Не удалось создать таблицы: 'MockConnection' object does not support the context manager protocol
______________ TestDBManager.test_populate_companies_table ______________

self = <workspace.tests.test_db_manager.TestDBManager object at 0x7fecb35ea890>
mock_connect = <MagicMock name='connect' id='140654636368720'>

    @patch("src.storage.db_manager.psycopg2.connect")
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_connection = MockConnection()
        mock_connect.return_value = mock_connection
    
        db_manager = DBManager()
    
        # Мокаем функцию получения целевых компаний
        test_companies = [{"id": "1", "name": "Test Company 1"}, {"id": "2", "name": "Test Company 2"}]
    
        with patch.object(db_manager, "_get_connection", return_value=mock_connection):
            # Мокаем функцию получения целевых компаний
>           with patch("src.config.target_companies.get_target_companies_data", return_value=test_companies):

tests/test_db_manager.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb21958d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.config.target_companies' from '/home/runner/workspace/tests/../src/config/target_companies.py'> does not have the attribute 'get_target_companies_data'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_______________ TestHHParser.test_parse_hh_vacancies_list _______________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fecb29b5050>

    def test_parse_hh_vacancies_list(self):
        """Тест парсинга списка вакансий HH"""
        data = {"items": [self.sample_hh_vacancy]}
>       result = self.parser.parse_vacancies(data["items"])
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_hh_parser.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/parsers/hh_parser.py:23: in parse_vacancies
    return [Vacancy.to_dict(vacancy) for vacancy in parsed_vacancies]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/parsers/hh_parser.py:23: in <listcomp>
    return [Vacancy.to_dict(vacancy) for vacancy in parsed_vacancies]
            ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.vacancies.models.Vacancy object at 0x7fecb1d46000>

    def to_dict(self) -> Dict[str, Any]:
        """Преобразование вакансии в словарь"""
        result = {
            "vacancy_id": self.vacancy_id,
            "title": self.title,
            "url": self.url,
            "source": self.source,
            "area": self.area,
            "experience": self.experience,
            "employment": self.employment,
            "description": self.description,
            "published_at": self.published_at,
        }
    
        if self.salary:
            result["salary"] = {
>               "from_amount": self.salary.from_amount,
                               ^^^^^^^^^^^^^^^^^^^^^^^
                "to_amount": self.salary.to_amount,
                "currency": self.salary.currency,
            }
E           AttributeError: 'Salary' object has no attribute 'from_amount'

src/vacancies/models.py:364: AttributeError
____________ TestHHParser.test_parse_hh_vacancy_minimal_data ____________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fecb29b5710>

    def test_parse_hh_vacancy_minimal_data(self):
        """Тест парсинга вакансии с минимальными данными"""
        minimal_data = {"id": "123", "name": "Test Job"}
        result = self.parser.parse_vacancy(minimal_data)
>       assert result.vacancy_id == "123"
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'vacancy_id'

tests/test_hh_parser.py:64: AttributeError
_______________ TestHHParser.test_parse_hh_employer_data ________________

self = <workspace.tests.test_hh_parser.TestHHParser object at 0x7fecb29b5dd0>

    def test_parse_hh_employer_data(self):
        """Тест парсинга данных работодателя"""
        result = self.parser.parse_vacancy(self.sample_hh_vacancy)
>       assert result.employer["name"] == "Test Company"
               ^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'employer'

tests/test_hh_parser.py:71: AttributeError
________________ TestPaginator.test_quick_paginate_quit _________________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fecb2550650>
mock_print = <MagicMock name='print' id='140654577404944'>
mock_input = <MagicMock name='input' id='140654572621840'>

    @patch('builtins.input', side_effect=['q'])
    @patch('builtins.print')
    def test_quick_paginate_quit(self, mock_print, mock_input):
        """Тест быстрой пагинации с выходом"""
        items = ["item1", "item2", "item3"]
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Тестируем реальный пагинатор
        from src.utils.paginator import Paginator
>       paginator = Paginator(items, per_page=2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:111: TypeError
_____________ TestPaginator.test_quick_paginate_navigation ______________

self = <workspace.tests.test_paginator.TestPaginator object at 0x7fecb2550f10>
mock_print = <MagicMock name='print' id='140654577432720'>
mock_input = <MagicMock name='input' id='140654577238736'>

    @patch('builtins.input', side_effect=['n', 'q'])
    @patch('builtins.print')
    def test_quick_paginate_navigation(self, mock_print, mock_input):
        """Тест навигации в быстрой пагинации"""
        items = list(range(1, 21))  # 20 элементов
    
        def simple_formatter(item, number=None):
            return f"{number}. {item}" if number else str(item)
    
        # Тестируем реальный пагинатор
        from src.utils.paginator import Paginator
>       paginator = Paginator(items, per_page=5)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Paginator() takes no arguments

tests/test_paginator.py:127: TypeError
____________ TestSalaryUtils.test_parse_salary_range_invalid ____________

self = <workspace.tests.test_salary_utils.TestSalaryUtils object at 0x7fecb2562610>

    def test_parse_salary_range_invalid(self):
        """Тест парсинга невалидного диапазона зарплаты"""
        result = parse_salary_range("invalid")
        assert result == (None, None)
        result_empty = parse_salary_range("")
        assert result_empty == (None, None)
>       assert parse_salary_range("100000") is None
E       AssertionError: assert (100000, 100000) is None
E        +  where (100000, 100000) = parse_salary_range('100000')

tests/test_salary_utils.py:93: AssertionError
___________ TestSuperJobAPI.test_superjob_api_initialization ____________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fecb2579b50>
mock_paginator = <MagicMock name='Paginator' id='140654573250192'>
mock_api_config = <MagicMock name='APIConfig' id='140654573009936'>
mock_cache = <MagicMock name='FileCache' id='140654573179728'>
mock_connector = <MagicMock name='APIConnector' id='140654577122128'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_superjob_api_initialization(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест инициализации SuperJobAPI"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        api = SuperJobAPI()
    
>       assert api.base_url == "https://api.superjob.ru"
               ^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'base_url'

tests/test_sj_api.py:28: AttributeError
______________ TestSuperJobAPI.test_get_vacancies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fecb257a350>
mock_paginator = <MagicMock name='Paginator' id='140654589115152'>
mock_api_config = <MagicMock name='APIConfig' id='140654585536272'>
mock_cache = <MagicMock name='FileCache' id='140654577112720'>
mock_connector = <MagicMock name='APIConnector' id='140654577111120'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_vacancies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения вакансий"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        # Настраиваем мок коннектора
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
    
        test_response = {
            "objects": [
                {
                    "id": 123,
                    "profession": "Python Developer",
                    "link": "https://superjob.ru/vacancy/123"
                }
            ]
        }
        mock_connector_instance.get.return_value = test_response
    
        api = SuperJobAPI()
        result = api.get_vacancies("Python")
    
>       assert len(result) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/test_sj_api.py:60: AssertionError
--------------------------- Captured log call ---------------------------
WARNING  root:cached_api.py:100 Ошибка кэша памяти: unhashable type: 'dict'. Переключаемся на файловый кэш
WARNING  src.api_modules.cached_api:cached_api.py:125 Данные неполные или повреждены, кэширование пропущено для sj
ERROR    src.api_modules.sj_api:sj_api.py:198 Failed to get vacancies: '>' not supported between instances of 'Mock' and 'int'
_______________ TestSuperJobAPI.test_format_search_params _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fecb257ff90>
mock_paginator = <MagicMock name='Paginator' id='140654576768592'>
mock_api_config = <MagicMock name='APIConfig' id='140654572480464'>
mock_cache = <MagicMock name='FileCache' id='140654572888272'>
mock_connector = <MagicMock name='APIConnector' id='140654572886736'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_format_search_params(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест форматирования параметров поиска"""
        api = SuperJobAPI()
    
>       params = api._format_search_params("Python", per_page=50, page=1)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute '_format_search_params'

tests/test_sj_api.py:120: AttributeError
______________ TestSuperJobAPI.test_get_companies_success _______________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fecb257e3d0>
mock_paginator = <MagicMock name='Paginator' id='140654577186064'>
mock_api_config = <MagicMock name='APIConfig' id='140654577174480'>
mock_cache = <MagicMock name='FileCache' id='140654577188048'>
mock_connector = <MagicMock name='APIConnector' id='140654572624784'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_get_companies_success(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест успешного получения компаний"""
        mock_config = Mock()
        mock_config.superjob_base_url = "https://api.superjob.ru"
        mock_config.superjob_api_key = "test_key"
        mock_api_config.return_value = mock_config
    
        mock_connector_instance = Mock()
        mock_connector.return_value = mock_connector_instance
    
        test_response = {
            "objects": [
                {
                    "id": 1,
                    "title": "Яндекс",
                    "link": "https://superjob.ru/company/1"
                }
            ]
        }
        mock_connector_instance.get.return_value = test_response
    
        api = SuperJobAPI()
>       result = api.get_companies()
                 ^^^^^^^^^^^^^^^^^
E       AttributeError: 'SuperJobAPI' object has no attribute 'get_companies'

tests/test_sj_api.py:152: AttributeError
___________________ TestSuperJobAPI.test_clear_cache ____________________

self = <workspace.tests.test_sj_api.TestSuperJobAPI object at 0x7fecb2d1e310>
mock_paginator = <MagicMock name='Paginator' id='140654572789008'>
mock_api_config = <MagicMock name='APIConfig' id='140654572789776'>
mock_cache = <MagicMock name='FileCache' id='140654572786768'>
mock_connector = <MagicMock name='APIConnector' id='140654572482320'>

    @patch('src.api_modules.sj_api.APIConnector')
    @patch('src.utils.cache.FileCache')
    @patch('src.api_modules.sj_api.APIConfig')
    @patch('src.api_modules.sj_api.Paginator')
    def test_clear_cache(self, mock_paginator, mock_api_config, mock_cache, mock_connector):
        """Тест очистки кэша"""
        mock_cache_instance = Mock()
        mock_cache.return_value = mock_cache_instance
    
        api = SuperJobAPI()
>       api.clear_cache()
E       TypeError: SuperJobAPI.clear_cache() missing 1 required positional argument: 'api_prefix'

tests/test_sj_api.py:167: TypeError
____________ TestStorageFactory.test_create_postgres_storage ____________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fecb2130310>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=postgres"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fecb250f290>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140654576655632'>

    @patch("src.storage.postgres_saver.PostgresSaver")
    def test_create_postgres_storage(self, mock_postgres_saver):
        """Тест создания PostgreSQL хранилища с моками"""
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        with patch("src.config.app_config.AppConfig") as mock_app_config:
            mock_config_instance = Mock()
            mock_config_instance.get_db_config.return_value = {"host": "localhost"}
            mock_app_config.return_value = mock_config_instance
    
            factory = StorageFactory()
>           storage = factory.create_storage("postgres")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = "host=localhost port=5432 user=postgres password='' client_encoding=utf8 dbname=Project03"
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'Project03', 'host': 'localhost', 'password': '', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
E           Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
E           Is the server running on that host and accepting TCP/IP connections?

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД Project03: connection to server at "localhost" (127.0.0.1), port 5432 failed: Connection refused
    Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (::1), port 5432 failed: Cannot assign requested address
    Is the server running on that host and accepting TCP/IP connections?

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных Project03 недоступна и не может быть создана
_________ TestStorageFactory.test_create_storage_with_db_config _________

self = <src.storage.postgres_saver.PostgresSaver object at 0x7fecb25d4d50>

    def _ensure_database_exists(self):
        """Создает базу данных Project03 если она не существует"""
        # Подключаемся к системной БД postgres для создания новой БД
        try:
>           connection = self._get_connection("postgres")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/storage/postgres_saver.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=postgres'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'postgres', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_storage_factory.TestStorageFactory object at 0x7fecb29f6f50>
mock_postgres_saver = <MagicMock name='PostgresSaver' id='140654576811728'>

    @patch("src.storage.postgres_saver.PostgresSaver")
    def test_create_storage_with_db_config(self, mock_postgres_saver):
        """Тест создания хранилища с конфигурацией БД"""
        mock_storage_instance = Mock()
        mock_postgres_saver.return_value = mock_storage_instance
    
        with patch("src.config.app_config.AppConfig") as mock_app_config:
            mock_config_instance = Mock()
            test_db_config = {
                "host": "test_host",
                "port": "5432",
                "database": "test_db",
                "username": "test_user",
                "password": "test_pass",
            }
            mock_config_instance.get_db_config.return_value = test_db_config
            mock_app_config.return_value = mock_config_instance
    
            factory = StorageFactory()
>           storage = factory.create_storage("postgres")
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_storage_factory.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/storage/storage_factory.py:25: in create_storage
    return PostgresSaver(app_config.get_db_config())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:79: in __init__
    self._ensure_database_exists()
src/storage/postgres_saver.py:112: in _ensure_database_exists
    test_connection = self._get_connection()
                      ^^^^^^^^^^^^^^^^^^^^^^
src/storage/postgres_saver.py:86: in _get_connection
    connection = psycopg2.connect(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

dsn = 'host=test_host port=5432 user=test_user password=test_pass client_encoding=utf8 dbname=test_db'
connection_factory = None, cursor_factory = None
kwargs = {'client_encoding': 'utf8', 'database': 'test_db', 'host': 'test_host', 'password': 'test_pass', ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: could not translate host name "test_host" to address: Name or service not known

.pythonlibs/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
--------------------------- Captured log call ---------------------------
ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:108 Не удается подключиться к системной БД postgres: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:98 Ошибка подключения к БД test_db: could not translate host name "test_host" to address: Name or service not known

ERROR    src.storage.postgres_saver:postgres_saver.py:117 База данных test_db недоступна и не может быть создана
____________ TestUserInterface.test_user_interface_run_exit _____________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecb258fbd0>
mock_stdout = <_io.StringIO object at 0x7fecb1d2cc10>
mock_input = <MagicMock name='input' id='140654576520592'>

    @patch("builtins.input", return_value="0")
    @patch("sys.stdout", new_callable=StringIO)
    def test_user_interface_run_exit(self, mock_stdout, mock_input):
        """Тест запуска интерфейса с выходом"""
        ui = UserInterface()
>       with patch("src.user_interface.UserInterface.display_menu"):

tests/test_user_interface.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb1db39d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.console_interface.UserInterface'> does not have the attribute 'display_menu'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestUserInterface.test_user_interface_handle_search __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecb259c290>
mock_input = <MagicMock name='input' id='140654576600720'>

    @patch("builtins.input", return_value="1")
    def test_user_interface_handle_search(self, mock_input):
        """Тест обработки поиска вакансий"""
        ui = UserInterface()
>       with patch.object(ui, "coordinator") as mock_coordinator:

tests/test_user_interface.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb212bc50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <workspace.tests.test_user_interface.UserInterface object at 0x7fecb21310d0> does not have the attribute 'coordinator'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_________ TestUserInterface.test_user_interface_error_handling __________

self = <workspace.tests.test_user_interface.TestUserInterface object at 0x7fecb258c2d0>

    def test_user_interface_error_handling(self):
        """Тест обработки ошибок пользовательского интерфейса"""
        ui = UserInterface()
        # Тестируем что интерфейс создается корректно
        assert ui is not None
>       assert hasattr(ui, "coordinator")
E       AssertionError: assert False
E        +  where False = hasattr(<workspace.tests.test_user_interface.UserInterface object at 0x7fecb1d8fb10>, 'coordinator')

tests/test_user_interface.py:93: AssertionError
______ TestVacancyDisplayHandler.test_display_vacancies_with_data _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fecb25b31d0>
mock_print = <MagicMock name='print' id='140654563657680'>

    @patch("builtins.print")
    def test_display_vacancies_with_data(self, mock_print):
        """Тест отображения списка вакансий"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [
            Vacancy("123", "Python Developer", "https://test.com", "hh.ru"),
            Vacancy("124", "Java Developer", "https://test2.com", "hh.ru"),
        ]
    
>       handler.display_vacancies(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies'

tests/test_vacancy_display_handler.py:126: AttributeError
___ TestVacancyDisplayHandler.test_display_vacancies_with_pagination ____

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fecb25b3590>
mock_paginate = <MagicMock name='quick_paginate' id='140654572786768'>

    @patch("src.ui_interfaces.vacancy_display_handler.quick_paginate")
    def test_display_vacancies_with_pagination(self, mock_paginate):
        """Тест отображения вакансий с пагинацией"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
        vacancies = [Vacancy("123", "Python Developer", "https://test.com", "hh.ru")]
    
>       handler.display_vacancies_paginated(vacancies)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'VacancyDisplayHandler' object has no attribute 'display_vacancies_paginated'

tests/test_vacancy_display_handler.py:141: AttributeError
_______ TestVacancyDisplayHandler.test_format_vacancy_for_display _______

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fecb25b3950>

    def test_format_vacancy_for_display(self):
        """Тест форматирования вакансии для отображения"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
                 ^^^^^^^^^^^^^
E       NameError: name 'VacancySalary' is not defined

tests/test_vacancy_display_handler.py:154: NameError
__ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_salary __

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fecb25b3f50>

    def test_format_vacancy_for_display_no_salary(self):
        """Тест форматирования вакансии для отображения без зарплаты"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       employer = VacancyEmployer(id="1", name="Test Company")
                   ^^^^^^^^^^^^^^^
E       NameError: name 'VacancyEmployer' is not defined

tests/test_vacancy_display_handler.py:178: NameError
_ TestVacancyDisplayHandler.test_format_vacancy_for_display_no_employer _

self = <workspace.tests.test_vacancy_display_handler.TestVacancyDisplayHandler object at 0x7fecb25bc590>

    def test_format_vacancy_for_display_no_employer(self):
        """Тест форматирования вакансии для отображения без работодателя"""
        mock_storage = Mock()
        handler = VacancyDisplayHandler(mock_storage)
    
>       salary = VacancySalary(from_amount=50000, currency="RUR")
                 ^^^^^^^^^^^^^
E       NameError: name 'VacancySalary' is not defined

tests/test_vacancy_display_handler.py:195: NameError
_______ TestVacancyFormatter.test_format_vacancy_info_with_salary _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fecb25be410>

    def test_format_vacancy_info_with_salary(self):
        """Тест форматирования вакансии с зарплатой"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
        )

tests/test_vacancy_formatter.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fecb1d0af20>
salary_data = <workspace.tests.test_vacancy_formatter.VacancySalary object at 0x7fecb213c450>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______ TestVacancyFormatter.test_format_vacancy_info_with_employer ______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fecb25bea50>

    def test_format_vacancy_info_with_employer(self):
        """Тест форматирования вакансии с работодателем"""
        employer = VacancyEmployer(name="Test Company")
        vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            employer=employer,
        )
    
        formatter = VacancyFormatter()
        result = formatter.format_vacancy_info(vacancy)
    
>       assert "Test Company" in result
E       AssertionError: assert 'Test Company' in 'ID: 123\nНазвание: Python Developer\nКомпания: <workspace.tests.test_vacancy_formatter.VacancyEmployer object at 0x7fecb197ed10>\nЗарплата: Зарплата не указана\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123'

tests/test_vacancy_formatter.py:130: AssertionError
_______ TestVacancyFormatter.test_format_vacancy_info_with_number _______

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fecb25bf050>

    def test_format_vacancy_info_with_number(self):
        """Тест форматирования вакансии с номером"""
        vacancy = Vacancy(
            vacancy_id="123", title="Python Developer", url="https://test.com/vacancy/123", source="hh.ru"
        )
    
        formatter = VacancyFormatter()
        result = formatter.format_vacancy_info(vacancy, number=1)
    
>       assert "1. " in result
E       AssertionError: assert '1. ' in '1.\nID: 123\nНазвание: Python Developer\nЗарплата: Зарплата не указана\nИсточник: hh.ru\nСсылка: https://test.com/vacancy/123'

tests/test_vacancy_formatter.py:141: AssertionError
__________ TestVacancyFormatter.test_format_vacancy_info_full ___________

self = <workspace.tests.test_vacancy_formatter.TestVacancyFormatter object at 0x7fecb25bf650>

    def test_format_vacancy_info_full(self):
        """Тест полного форматирования вакансии"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            url="https://test.com/vacancy/123",
            source="hh.ru",
            salary=salary,
            employer=employer,
            area="Москва",
            experience="От 1 года до 3 лет",
            employment="Полная занятость",
        )

tests/test_vacancy_formatter.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/vacancies/models.py:74: in __init__
    self.salary = self._validate_salary(salary)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/vacancies/models.py:100: in _validate_salary
    return Salary(salary_data) if salary_data else Salary()
           ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.utils.salary.Salary object at 0x7fecb1405b40>
salary_data = <workspace.tests.test_vacancy_formatter.VacancySalary object at 0x7fecb1df5bd0>

    def __init__(self, salary_data: Optional[Dict[str, Any]] = None):
        if salary_data is None:
            salary_data = {}
    
        self.amount_from = 0
        self.amount_to = 0
        self.gross = False
        self.period = "month"
    
        # Сначала проверяем, есть ли строковый диапазон для парсинга
        if isinstance(salary_data, str):
            salary_data = self._parse_salary_range_string(salary_data)
        elif isinstance(salary_data, dict) and salary_data.get("salary_range"):
            range_data = self._parse_salary_range_string(salary_data["salary_range"])
            salary_data.update(range_data)
    
>       self._salary_from = self._validate_salary_value(salary_data.get("from"))
                                                        ^^^^^^^^^^^^^^^
E       AttributeError: 'VacancySalary' object has no attribute 'get'

src/utils/salary.py:25: AttributeError
______________ TestVacancy.test_vacancy_str_representation ______________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fecb25cb190>

    def test_vacancy_str_representation(self):
        """Тест строкового представления Vacancy"""
        vacancy = Vacancy(
            vacancy_id="123", title="Python Developer", url="https://test.com/vacancy/123", source="hh.ru"
        )
        # Устанавливаем работодателя после создания
        vacancy.employer = {"name": "Test Company"}
        str_repr = str(vacancy)
        assert "Python Developer" in str_repr
        assert "123" in str_repr
        assert "Test Company" in str_repr
>       assert "hh.ru" in str_repr
E       AssertionError: assert 'hh.ru' in '[HH.RU] Должность: Python Developer\nКомпания: Test Company\nЗарплата: Зарплата не указана\nТребования: Не указаны\nСсылка: https://test.com/vacancy/123'

tests/test_vacancy_models.py:157: AssertionError
_________________ TestVacancy.test_vacancy_from_dict_hh _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fecb25cb7d0>
mock_vacancy_data_hh = {'alternate_url': 'https://hh.ru/vacancy/123456', 'employer': {'id': '1', 'name': 'Test Company HH', 'trusted': True, 'url': 'https://hh.ru/employer/1'}, 'id': '123456', 'name': 'Python Developer', ...}

    def test_vacancy_from_dict_hh(self, mock_vacancy_data_hh):
        """Тест создания вакансии из словаря HH"""
        # We need to adapt the placeholder Vacancy to accept these arguments
        # or create a more sophisticated mock. For now, let's assume a direct mapping.
>       vacancy = Vacancy(
            vacancy_id=mock_vacancy_data_hh["id"],
            title=mock_vacancy_data_hh["name"],
            company=mock_vacancy_data_hh["employer"]["name"],
            url=mock_vacancy_data_hh["alternate_url"],
            description=mock_vacancy_data_hh["snippet"]["requirement"],
            source="hh.ru",
            # Salary and employer are complex and might need specific handling
            # For the placeholder, we'll skip direct salary/employer assignment as attributes
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:190: TypeError
_________________ TestVacancy.test_vacancy_from_dict_sj _________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fecb25cbe10>
mock_vacancy_data_sj = {'currency': 'rub', 'description': '<p>Java developer position</p>', 'firm_name': 'Another Company SJ', 'id': 789012, ...}

    def test_vacancy_from_dict_sj(self, mock_vacancy_data_sj):
        """Тест создания вакансии из словаря SuperJob"""
>       vacancy = Vacancy(
            vacancy_id=str(mock_vacancy_data_sj["id"]),
            title=mock_vacancy_data_sj["profession"],
            company=mock_vacancy_data_sj["firm_name"],
            salary=f"{mock_vacancy_data_sj['payment_from']} - {mock_vacancy_data_sj['payment_to']} {mock_vacancy_data_sj['currency']}",
            url=mock_vacancy_data_sj["link"],
            description=mock_vacancy_data_sj["description"],
            source="superjob.ru",
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:209: TypeError
__________________ TestVacancy.test_vacancy_comparison __________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fecb25d4450>

    def test_vacancy_comparison(self):
        """Тест сравнения вакансий"""
>       vacancy1 = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company="Test Company",
            url="https://test.com/vacancy/123",
            source="hh.ru",
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:228: TypeError
___________________ TestVacancy.test_vacancy_to_dict ____________________

self = <workspace.tests.test_vacancy_models.TestVacancy object at 0x7fecb25d4a50>

    def test_vacancy_to_dict(self):
        """Тест преобразования вакансии в словарь"""
        salary = VacancySalary(from_amount=100000, to_amount=150000, currency="RUR")
        employer = VacancyEmployer(id="1", name="Test Company")
    
>       vacancy = Vacancy(
            vacancy_id="123",
            title="Python Developer",
            company=employer.name,
            url="https://test.com/vacancy/123",
            salary=str(salary),
            source="hh.ru",
        )
E       TypeError: Vacancy.__init__() got an unexpected keyword argument 'company'

tests/test_vacancy_models.py:251: TypeError
______ TestVacancyOperationsCoordinator.test_handle_vacancy_search ______

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fecb25e6850>
mock_search_handler = <MagicMock name='VacancySearchHandler' id='140654581185680'>

    @patch("src.ui_interfaces.vacancy_search_handler.VacancySearchHandler")
    def test_handle_vacancy_search(self, mock_search_handler):
        """Тест обработки поиска вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_search_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_vacancy_search()

tests/test_vacancy_operations_coordinator.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:47: in handle_vacancy_search
    self.search_handler.search_vacancies()
src/ui_interfaces/vacancy_search_handler.py:38: in search_vacancies
    sources = self.source_selector.get_user_source_choice()
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ui_interfaces/source_selector.py:36: in get_user_source_choice
    choice = input("Ваш выбор: ").strip()
             ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7fecb3e2fad0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

==================================================
ВЫБОР ИСТОЧНИКОВ ВАКАНСИЙ
==================================================
Выберите источники для поиска вакансий:
1. HH.ru
2. SuperJob.ru
3. Оба источника
0. Отмена
==================================================
Ваш выбор: 
___ TestVacancyOperationsCoordinator.test_handle_show_saved_vacancies ___

self = <Mock name='VacancyDisplayHandler().show_all_saved_vacancies' id='140654563467536'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'show_all_saved_vacancies' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fecb25e69d0>
mock_display_handler = <MagicMock name='VacancyDisplayHandler' id='140654563461264'>

    @patch("src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler")
    def test_handle_show_saved_vacancies(self, mock_display_handler):
        """Тест отображения сохраненных вакансий"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_display_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
        coordinator.handle_show_saved_vacancies()
    
        # Проверяем, что display handler был вызван
>       mock_handler_instance.show_all_saved_vacancies.assert_called()
E       AssertionError: Expected 'show_all_saved_vacancies' to have been called.

tests/test_vacancy_operations_coordinator.py:63: AssertionError
------------------------- Captured stdout call --------------------------
Ошибка получения статистики БД: object of type 'Mock' has no len()
Ошибка при загрузке вакансий: object of type 'Mock' has no len()
--------------------------- Captured log call ---------------------------
ERROR    src.ui_interfaces.vacancy_display_handler:vacancy_display_handler.py:69 Ошибка при отображении сохраненных вакансий: object of type 'Mock' has no len()
_ TestVacancyOperationsCoordinator.test_handle_top_vacancies_by_salary __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fecb25e7850>
mock_display_handler = <MagicMock name='VacancyDisplayHandler' id='140654576681424'>

    @patch("src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler")
    def test_handle_top_vacancies_by_salary(self, mock_display_handler):
        """Тест получения топ вакансий по зарплате"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_display_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_top_vacancies_by_salary()

tests/test_vacancy_operations_coordinator.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:55: in handle_top_vacancies_by_salary
    self.display_handler.show_top_vacancies_by_salary()
src/ui_interfaces/vacancy_display_handler.py:74: in show_top_vacancies_by_salary
    n = get_positive_integer("\nВведите количество вакансий для отображения: ")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:43: in get_positive_integer
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7fecb3e2fad0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

Введите количество вакансий для отображения: 
_ TestVacancyOperationsCoordinator.test_handle_search_saved_by_keyword __

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fecb25e7b90>
mock_display_handler = <MagicMock name='VacancyDisplayHandler' id='140654563364112'>

    @patch("src.ui_interfaces.vacancy_display_handler.VacancyDisplayHandler")
    def test_handle_search_saved_by_keyword(self, mock_display_handler):
        """Тест поиска сохраненных вакансий по ключевому слову"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_handler_instance = Mock()
        mock_display_handler.return_value = mock_handler_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
>       coordinator.handle_search_saved_by_keyword()

tests/test_vacancy_operations_coordinator.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/ui_interfaces/vacancy_operations_coordinator.py:59: in handle_search_saved_by_keyword
    self.display_handler.search_saved_vacancies_by_keyword()
src/ui_interfaces/vacancy_display_handler.py:113: in search_saved_vacancies_by_keyword
    keyword = get_user_input("\nВведите ключевое слово для поиска в описании: ")
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/utils/ui_helpers.py:23: in get_user_input
    user_input = input(prompt).strip()
                 ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_pytest.capture.DontReadFromInput object at 0x7fecb3e2fad0>
size = -1

    def read(self, size: int = -1) -> str:
>       raise OSError(
            "pytest: reading from stdin while output is captured!  Consider using `-s`."
        )
E       OSError: pytest: reading from stdin while output is captured!  Consider using `-s`.

.pythonlibs/lib/python3.11/site-packages/_pytest/capture.py:229: OSError
------------------------- Captured stdout call --------------------------

Введите ключевое слово для поиска в описании: 
______ TestVacancyOperationsCoordinator.test_handle_cache_cleanup _______

self = <Mock name='mock.clear_cache' id='140654576962448'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'clear_cache' to have been called.

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:908: AssertionError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_vacancy_operations_coordinator.TestVacancyOperationsCoordinator object at 0x7fecb25f2710>
mock_selector = <MagicMock name='SourceSelector' id='140654576651472'>
mock_confirm = <MagicMock name='confirm_action' id='140654568272976'>

    @patch("src.utils.ui_helpers.confirm_action", return_value=True)
    @patch("src.ui_interfaces.source_selector.SourceSelector")
    def test_handle_cache_cleanup(self, mock_selector, mock_confirm):
        """Тест очистки кэша"""
        mock_api = Mock()
        mock_storage = Mock()
    
        mock_selector_instance = Mock()
        mock_selector_instance.get_user_source_choice.return_value = {"hh.ru"}
        mock_selector_instance.display_sources_info.return_value = None
        mock_selector.return_value = mock_selector_instance
    
        coordinator = VacancyOperationsCoordinator(mock_api, mock_storage)
    
        with patch("builtins.print"):
            coordinator.handle_cache_cleanup()
    
        # Проверяем, что очистка кэша была вызвана
>       mock_api.clear_cache.assert_called()
E       AssertionError: Expected 'clear_cache' to have been called.

tests/test_vacancy_operations_coordinator.py:130: AssertionError
------------------------- Captured stdout call --------------------------
Ваш выбор: 
--------------------------- Captured log call ---------------------------
ERROR    src.ui_interfaces.vacancy_operations_coordinator:vacancy_operations_coordinator.py:78 Ошибка при очистке кэша: pytest: reading from stdin while output is captured!  Consider using `-s`.
__________ TestVacancySearchHandler.test_handle_search_success __________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecb25f0510>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb25f3690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_no_results _________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecb25d6410>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb25e6fd0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
________ TestVacancySearchHandler.test_handle_search_with_saving ________

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecb25d6ad0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb25e6190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestVacancySearchHandler.test_handle_search_cancelled_source_selection _

args = (<workspace.tests.test_vacancy_search_handler.TestVacancySearchHandler object at 0x7fecb25d6e90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7fecb25f2750>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <class 'src.ui_interfaces.source_selector.SourceSelector'> does not have the attribute 'select_sources'

/nix/store/7d088dip86hlzri9sk0h78b63yfmx0a0-python3-3.11.13/lib/python3.11/unittest/mock.py:1419: AttributeError
=========================== warnings summary ============================
tests/test_cached_api.py:15
  /home/runner/workspace/tests/test_cached_api.py:15: PytestCollectionWarning: cannot collect test class 'TestCachedAPIImplementation' because it has a __init__ constructor (from: tests/test_cached_api.py)
    class TestCachedAPIImplementation(CachedAPI):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== short test summary info ========================
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_initialization - NameError: name 'CachedAPIImplementation' is not defined
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_with_cache_manager - NameError: name 'CachedAPIImplementation' is not defined
FAILED tests/test_cached_api.py::TestCachedAPI::test_cached_api_abstract_methods - NameError: name 'CachedAPIImplementation' is not defined
FAILED tests/test_cached_api.py::TestCachedAPI::test_cache_integration - NameError: name 'CachedAPIImplementation' is not defined
FAILED tests/test_cached_api.py::TestCachedAPI::test_clear_cache_method - NameError: name 'CachedAPIImplementation' is not defined
FAILED tests/test_db_manager.py::TestDBManager::test_check_connection_success - assert False is True
FAILED tests/test_db_manager.py::TestDBManager::test_create_tables - TypeError: 'MockConnection' object does not support the context mana...
FAILED tests/test_db_manager.py::TestDBManager::test_get_avg_salary - assert None == 125000.0
FAILED tests/test_db_manager.py::TestDBManager::test_get_vacancies_with_higher_salary - assert 0 == 1
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - AttributeError: <module 'src.config.target_companies' from '/home/ru...
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancies_list - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_vacancy_minimal_data - AttributeError: 'dict' object has no attribute 'vacancy_id'
FAILED tests/test_hh_parser.py::TestHHParser::test_parse_hh_employer_data - AttributeError: 'dict' object has no attribute 'employer'
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_quit - TypeError: Paginator() takes no arguments
FAILED tests/test_paginator.py::TestPaginator::test_quick_paginate_navigation - TypeError: Paginator() takes no arguments
FAILED tests/test_salary_utils.py::TestSalaryUtils::test_parse_salary_range_invalid - AssertionError: assert (100000, 100000) is None
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_superjob_api_initialization - AttributeError: 'SuperJobAPI' object has no attribute 'base_url'
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_vacancies_success - assert 0 == 1
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_format_search_params - AttributeError: 'SuperJobAPI' object has no attribute '_format_searc...
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_get_companies_success - AttributeError: 'SuperJobAPI' object has no attribute 'get_companies'
FAILED tests/test_sj_api.py::TestSuperJobAPI::test_clear_cache - TypeError: SuperJobAPI.clear_cache() missing 1 required positional a...
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_postgres_storage - psycopg2.OperationalError: connection to server at "localhost" (127....
FAILED tests/test_storage_factory.py::TestStorageFactory::test_create_storage_with_db_config - psycopg2.OperationalError: could not translate host name "test_host"...
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_run_exit - AttributeError: <class 'src.ui_interfaces.console_interface.UserInte...
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_handle_search - AttributeError: <workspace.tests.test_user_interface.UserInterface o...
FAILED tests/test_user_interface.py::TestUserInterface::test_user_interface_error_handling - AssertionError: assert False
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_data - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_display_vacancies_with_pagination - AttributeError: 'VacancyDisplayHandler' object has no attribute 'dis...
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display - NameError: name 'VacancySalary' is not defined
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_salary - NameError: name 'VacancyEmployer' is not defined
FAILED tests/test_vacancy_display_handler.py::TestVacancyDisplayHandler::test_format_vacancy_for_display_no_employer - NameError: name 'VacancySalary' is not defined
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_salary - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_employer - AssertionError: assert 'Test Company' in 'ID: 123\nНазвание: Python ...
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_with_number - AssertionError: assert '1. ' in '1.\nID: 123\nНазвание: Python Devel...
FAILED tests/test_vacancy_formatter.py::TestVacancyFormatter::test_format_vacancy_info_full - AttributeError: 'VacancySalary' object has no attribute 'get'
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_str_representation - AssertionError: assert 'hh.ru' in '[HH.RU] Должность: Python Develop...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_hh - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_from_dict_sj - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_comparison - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_models.py::TestVacancy::test_vacancy_to_dict - TypeError: Vacancy.__init__() got an unexpected keyword argument 'co...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_vacancy_search - OSError: pytest: reading from stdin while output is captured!  Consi...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_show_saved_vacancies - AssertionError: Expected 'show_all_saved_vacancies' to have been cal...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_top_vacancies_by_salary - OSError: pytest: reading from stdin while output is captured!  Consi...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_search_saved_by_keyword - OSError: pytest: reading from stdin while output is captured!  Consi...
FAILED tests/test_vacancy_operations_coordinator.py::TestVacancyOperationsCoordinator::test_handle_cache_cleanup - AssertionError: Expected 'clear_cache' to have been called.
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_success - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_no_results - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_with_saving - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
FAILED tests/test_vacancy_search_handler.py::TestVacancySearchHandler::test_handle_search_cancelled_source_selection - AttributeError: <class 'src.ui_interfaces.source_selector.SourceSele...
=============== 49 failed, 245 passed, 1 warning in 3.15s ===============
~/workspace$ 