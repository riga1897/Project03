~/workspace$ pytest tests/test_db_manager.py
============================ test session starts =============================
platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace/tests
configfile: pytest.ini
plugins: mock-3.14.1, cov-6.2.1
collected 10 items                                                           

tests/test_db_manager.py ....F....F                                    [100%]

================================== FAILURES ==================================
____________________ TestDBManager.test_get_all_vacancies ____________________

self = <tests.test_db_manager.TestDBManager object at 0x7fbf64d2af90>
mock_connect = <MagicMock name='connect' id='140459999170640'>

    @patch('psycopg2.connect')
    def test_get_all_vacancies(self, mock_connect):
        """Тест получения всех вакансий"""
        mock_conn = Mock()
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor = Mock()
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
    
        # Настраиваем множественные вызовы fetchone для create_tables
        mock_cursor.fetchone.side_effect = [
            ("integer",),  # Для проверки типа company_id в create_tables
            (True,),       # Для проверки constraint в create_tables
        ]
    
        # Настраиваем fetchall для основного запроса
        test_row = Mock()
        test_row.get.side_effect = lambda key, default=None: {
            "title": "Python Developer",
            "company_name": "СБЕР",
            "salary_info": "100000 - 150000 RUR",
            "url": "https://hh.ru/vacancy/12345",
            "vacancy_id": "12345",
            "raw_company_id": 1,
            "linked_company_id": 1
        }.get(key, default)
    
        mock_cursor.fetchall.return_value = [test_row]
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        with patch('psycopg2.extras.RealDictCursor'):
            db_manager = DBManager()
            vacancies = db_manager.get_all_vacancies()
    
>           assert len(vacancies) == 1
E           assert 0 == 1
E            +  where 0 = len([])

tests/test_db_manager.py:118: AssertionError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка при получении всех вакансий: Mock.keys() returned a non-iterable (type Mock)
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:480 Ошибка при получении всех вакансий: Mock.keys() returned a non-iterable (type Mock)
________________ TestDBManager.test_populate_companies_table _________________

self = <tests.test_db_manager.TestDBManager object at 0x7fbf64d372d0>
mock_connect = <MagicMock name='connect' id='140459994973584'>

    @patch('psycopg2.connect')
    def test_populate_companies_table(self, mock_connect):
        """Тест заполнения таблицы компаний"""
        mock_conn = Mock()
        mock_conn.__enter__ = Mock(return_value=mock_conn)
        mock_conn.__exit__ = Mock(return_value=None)
        mock_cursor = Mock()
        mock_cursor.__enter__ = Mock(return_value=mock_cursor)
        mock_cursor.__exit__ = Mock(return_value=None)
        mock_conn.cursor.return_value = mock_cursor
        mock_connect.return_value = mock_conn
    
        # Настраиваем ответы для SQL запросов - добавляем больше ответов
        fetchone_responses = [
            (True,),   # Таблица существует
            (0,),      # Количество компаний = 0
        ]
    
        # Добавляем None для каждой проверки существования компании (15 целевых компаний)
        for _ in range(15):
            fetchone_responses.append(None)
    
        # Финальное количество компаний
        fetchone_responses.append((15,))
    
        mock_cursor.fetchone.side_effect = fetchone_responses
    
        db_manager = DBManager()
>       db_manager.populate_companies_table()

tests/test_db_manager.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.storage.db_manager.DBManager object at 0x7fbf641b06d0>

    def populate_companies_table(self):
        """Заполняет таблицу companies целевыми компаниями"""
        try:
            # Используем контекстный менеджер для безопасной работы с подключением
            with self._get_connection() as connection:
                with connection.cursor() as cursor:
                    # Устанавливаем кодировку сессии
                    cursor.execute("SET client_encoding TO 'UTF8'")
    
                    # Проверяем, существует ли таблица companies
                    cursor.execute(
                        """
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables
                            WHERE table_schema = 'public'
                            AND table_name = 'companies'
                        );
                    """
                    )
    
                    table_exists = cursor.fetchone()[0]
                    if not table_exists:
                        logger.warning("Таблица companies не существует. Таблицы должны быть созданы заранее.")
                        return
    
                    # Проверяем, есть ли уже данные в таблице
                    cursor.execute("SELECT COUNT(*) FROM companies")
                    companies_count = cursor.fetchone()[0]
    
                    if companies_count > 0:
                        logger.info(f"✓ Таблица companies уже содержит {companies_count} компаний")
                        return
    
                    # Добавляем целевые компании с их API идентификаторами
                    for company in TARGET_COMPANIES:
                        # Сначала проверяем, существует ли компания
                        cursor.execute("SELECT id FROM companies WHERE name = %s", (company.name,))
                        if not cursor.fetchone():
                            cursor.execute(
                                """
                                INSERT INTO companies (name, hh_id, sj_id)
                                VALUES (%s, %s, %s)
                            """,
                                (company.name, getattr(company, "hh_id", None), getattr(company, "sj_id", None)),
                            )
                            logger.info(f"Добавлена целевая компания: {company.name}")
    
                    # Проверяем результат
                    cursor.execute("SELECT COUNT(*) FROM companies")
>                   final_count = cursor.fetchone()[0]
                                  ^^^^^^^^^^^^^^^^^^^^
E                   TypeError: 'NoneType' object is not subscriptable

src/storage/db_manager.py:248: TypeError
---------------------------- Captured stderr call ----------------------------
ERROR:src.storage.db_manager:Ошибка при заполнении таблицы companies: 'NoneType' object is not subscriptable
----------------------------- Captured log call ------------------------------
ERROR    src.storage.db_manager:db_manager.py:252 Ошибка при заполнении таблицы companies: 'NoneType' object is not subscriptable
========================== short test summary info ===========================
FAILED tests/test_db_manager.py::TestDBManager::test_get_all_vacancies - assert 0 == 1
FAILED tests/test_db_manager.py::TestDBManager::test_populate_companies_table - TypeError: 'NoneType' object is not subscriptable
======================== 2 failed, 8 passed in 0.23s =========================
~/workspace$ 