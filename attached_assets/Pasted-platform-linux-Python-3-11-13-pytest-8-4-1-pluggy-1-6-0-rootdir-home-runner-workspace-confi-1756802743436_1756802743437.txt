platform linux -- Python 3.11.13, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: mock-3.14.1, cov-6.2.1
collected 676 items                                                                            

tests/test_abstract.py ........                                                          [  1%]
tests/test_abstract_db_manager.py ....                                                   [  1%]
tests/test_api_config.py ....                                                            [  2%]
tests/test_api_data_filter.py ........                                                   [  3%]
tests/test_api_modules.py .............................                                  [  7%]
tests/test_app_config.py .....                                                           [  8%]
tests/test_base_api.py ......                                                            [  9%]
tests/test_base_formatter.py ..........                                                  [ 10%]
tests/test_base_parser.py ......                                                         [ 11%]
tests/test_cache.py .......                                                              [ 12%]
tests/test_cache_manager.py ....................                                         [ 15%]
tests/test_cached_api.py ...........                                                     [ 17%]
tests/test_comprehensive_coverage.py ........................                            [ 21%]
tests/test_console_interface.py ......                                                   [ 21%]
tests/test_db_config.py .....                                                            [ 22%]
tests/test_db_manager.py .................                                               [ 25%]
tests/test_db_manager_demo.py FF..FFFF                                                   [ 26%]
tests/test_decorators.py .......                                                         [ 27%]
tests/test_env_loader.py FFFFFF                                                          [ 28%]
tests/test_extended_coverage.py ...................E..EE                                 [ 31%]
tests/test_file_handlers.py ............                                                 [ 33%]
tests/test_full_src_coverage.py .............                                            [ 35%]
tests/test_get_api.py ......                                                             [ 36%]
tests/test_hh_api.py .......                                                             [ 37%]
tests/test_hh_api_config.py .....                                                        [ 38%]
tests/test_hh_parser.py ........                                                         [ 39%]
tests/test_integration.py .............                                                  [ 41%]
tests/test_menu_manager.py ..........                                                    [ 42%]
tests/test_menu_system.py ....................                                           [ 45%]
tests/test_paginator.py ......                                                           [ 46%]
tests/test_postgres_saver.py .......                                                     [ 47%]
tests/test_salary_utils.py ......................                                        [ 50%]
tests/test_search_utils.py ............................                                  [ 55%]
tests/test_sj_api.py ..............                                                      [ 57%]
tests/test_sj_api_config.py .....                                                        [ 57%]
tests/test_sj_parser.py ........                                                         [ 59%]
tests/test_source_manager.py .................                                           [ 61%]
tests/test_source_selector.py ..................                                         [ 64%]
tests/test_storage_factory.py ........                                                   [ 65%]
tests/test_target_companies.py .....                                                     [ 66%]
tests/test_ui_config.py .......................                                          [ 69%]
tests/test_ui_helpers.py ...........                                                     [ 71%]
tests/test_ui_navigation.py ......................                                       [ 74%]
tests/test_unified_api.py .................                                              [ 76%]
tests/test_user_interface.py ......................                                      [ 80%]
tests/test_vacancy_display_handler.py ..............                                     [ 82%]
tests/test_vacancy_formatter.py ........                                                 [ 83%]
tests/test_vacancy_models.py .................................................           [ 90%]
tests/test_vacancy_operations.py ......                                                  [ 91%]
tests/test_vacancy_operations_coordinator.py ...........................                 [ 95%]
tests/test_vacancy_search_handler.py .......................                             [ 98%]
tests/test_vacancy_stats.py .F.FF..                                                      [100%]

============================================ ERRORS ============================================
___________ ERROR at setup of TestUserInterfaceExtended.test_display_search_results ____________
file /home/runner/workspace/tests/test_extended_coverage.py, line 512
      @patch('builtins.print')
      def test_display_search_results(self, mock_print, user_interface, sample_vacancies_extended):
E       fixture 'sample_vacancies_extended' not found
>       available fixtures: base_mock_api, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, mock_connection, mock_db_config, mock_vacancy_data, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, user_interface
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_extended_coverage.py:512
___________ ERROR at setup of TestInterfaceHandlers.test_format_vacancy_for_display ____________
file /home/runner/workspace/tests/test_extended_coverage.py, line 596
      def test_format_vacancy_for_display(self, display_handler, sample_vacancies_extended):
E       fixture 'sample_vacancies_extended' not found
>       available fixtures: base_mock_api, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, display_handler, doctest_namespace, mock_connection, mock_db_config, mock_vacancy_data, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_extended_coverage.py:596
______________ ERROR at setup of TestInterfaceHandlers.test_display_vacancy_list _______________
file /home/runner/workspace/tests/test_extended_coverage.py, line 606
      @patch('builtins.print')
      def test_display_vacancy_list(self, mock_print, display_handler, sample_vacancies_extended):
E       fixture 'sample_vacancies_extended' not found
>       available fixtures: base_mock_api, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, display_handler, doctest_namespace, mock_connection, mock_db_config, mock_vacancy_data, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/home/runner/workspace/tests/test_extended_coverage.py:606
=========================================== FAILURES ===========================================
_____________________________ TestDBManagerDemo.test_run_full_demo _____________________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c0090>
mock_print = <MagicMock name='print' id='139820287874704'>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a72975390>

    @patch('builtins.print')
    def test_run_full_demo(self, mock_print, db_manager_demo):
        """Тест полной демонстрации"""
        # Выполняем демонстрацию
>       db_manager_demo.run_full_demo()

tests/test_db_manager_demo.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/db_manager_demo.py:53: in run_full_demo
    self._demo_all_vacancies()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a72975390>

    def _demo_all_vacancies(self) -> None:
        """Демонстрирует метод get_all_vacancies()"""
        print("\n4. get_all_vacancies() - Все вакансии:")
        print("-" * 80)
        all_vacancies = self.db_manager.get_all_vacancies()
    
        if not all_vacancies:
            print("Вакансии не найдены.")
            return
    
        # Сортируем вакансии: сначала по убыванию зарплаты, потом по названию
        def get_salary_value(vacancy):
            """Извлекает числовое значение зарплаты для сортировки"""
            salary_info = vacancy.get("salary_info", "Не указана")
            if salary_info == "Не указана":
                return 0
    
            # Извлекаем числа из строки зарплаты
            numbers = re.findall(r"\d+", salary_info)
            if numbers:
                # Берем максимальное значение (если есть диапазон)
                return max(int(num) for num in numbers)
            return 0
    
        sorted_vacancies = sorted(all_vacancies, key=lambda x: (-get_salary_value(x), x.get("title", "")))
    
        print(f"{'№':<3} {'Название':<40} {'Компания':<20} {'Зарплата':<20}")
        print("-" * 85)
    
        # Показываем первые 25 вакансий
        for i, vacancy in enumerate(sorted_vacancies[:25], 1):
            title = vacancy["title"][:39] if len(vacancy["title"]) > 39 else vacancy["title"]
            company = (
                vacancy.get("company_name", "Неизвестная")[:19]
                if len(vacancy.get("company_name", "Неизвестная")) > 19
                else vacancy.get("company_name", "Неизвестная")
            )
>           salary = vacancy["salary_info"][:19] if len(vacancy["salary_info"]) > 19 else vacancy["salary_info"]
                                                        ^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'salary_info'

src/utils/db_manager_demo.py:194: KeyError
________________________ TestDBManagerDemo.test_demo_with_empty_results ________________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c06d0>
mock_db_manager = <Mock spec='DBManager' id='139820283858256'>

    def test_demo_with_empty_results(self, mock_db_manager):
        """Тест демонстрации с пустыми результатами"""
        # Настраиваем пустые результаты
        mock_db_manager.get_target_companies_analysis.return_value = []
        mock_db_manager.get_companies_and_vacancies_count.return_value = []
        mock_db_manager.get_all_vacancies.return_value = []
        mock_db_manager.get_avg_salary.return_value = None
        mock_db_manager.get_vacancies_with_higher_salary.return_value = []
        mock_db_manager.get_vacancies_with_keyword.return_value = []
    
        if DB_MANAGER_DEMO_AVAILABLE:
            demo = DBManagerDemo(mock_db_manager)
        else:
            demo = MockDBManagerDemo(mock_db_manager)
    
        # Демонстрация должна работать даже с пустыми результатами
        with patch('builtins.print'):
>           demo.run_full_demo()

tests/test_db_manager_demo.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/db_manager_demo.py:57: in run_full_demo
    self._demo_database_stats()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a725a1210>

    def _demo_database_stats(self) -> None:
        """Демонстрирует получение статистики БД"""
        print("\n8. Статистика базы данных:")
        print("----------------------------------------")
    
        stats = self.db_manager.get_database_stats()
        if stats:
            print(f"Общее количество вакансий: {stats.get('total_vacancies', 0)}")
            print(f"Общее количество компаний: {stats.get('total_companies', 0)}")
            print(f"Вакансий с указанной зарплатой: {stats.get('vacancies_with_salary', 0)}")
    
            # Обрабатываем даты
            latest_date = stats.get("latest_vacancy_date")
            earliest_date = stats.get("earliest_vacancy_date")
    
            if latest_date:
                if hasattr(latest_date, "strftime"):
                    latest_str = latest_date.strftime("%d.%m.%Y %H:%M:%S")
                else:
                    latest_str = str(latest_date)
                print(f"Дата последней вакансии: {latest_str}")
            else:
                print("Дата последней вакансии: Не указана")
    
            if earliest_date:
                if hasattr(earliest_date, "strftime"):
                    earliest_str = earliest_date.strftime("%d.%m.%Y %H:%M:%S")
                else:
                    earliest_str = str(earliest_date)
                print(f"Дата первой вакансии: {earliest_str}")
            else:
                print("Дата первой вакансии: Не указана")
    
            # Дополнительная статистика если есть
            if stats.get("vacancies_last_week"):
                print(f"Вакансий за последнюю неделю: {stats.get('vacancies_last_week', 0)}")
            if stats.get("vacancies_last_month"):
                print(f"Вакансий за последний месяц: {stats.get('vacancies_last_month', 0)}")
    
            # Статистика заполненности полей
            total = stats.get("total_vacancies", 0)
>           if total > 0:
               ^^^^^^^^^
E           TypeError: '>' not supported between instances of 'Mock' and 'int'

src/utils/db_manager_demo.py:358: TypeError
_____________________ TestDBManagerDemo.test_demo_methods_call_db_manager ______________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c1390>
mock_print = <MagicMock name='print' id='139820287869968'>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a72974490>

    @patch('builtins.print')
    def test_demo_methods_call_db_manager(self, mock_print, db_manager_demo):
        """Тест что демонстрация вызывает методы DB менеджера"""
        # Запускаем полную демонстрацию
>       db_manager_demo.run_full_demo()

tests/test_db_manager_demo.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/db_manager_demo.py:53: in run_full_demo
    self._demo_all_vacancies()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a72974490>

    def _demo_all_vacancies(self) -> None:
        """Демонстрирует метод get_all_vacancies()"""
        print("\n4. get_all_vacancies() - Все вакансии:")
        print("-" * 80)
        all_vacancies = self.db_manager.get_all_vacancies()
    
        if not all_vacancies:
            print("Вакансии не найдены.")
            return
    
        # Сортируем вакансии: сначала по убыванию зарплаты, потом по названию
        def get_salary_value(vacancy):
            """Извлекает числовое значение зарплаты для сортировки"""
            salary_info = vacancy.get("salary_info", "Не указана")
            if salary_info == "Не указана":
                return 0
    
            # Извлекаем числа из строки зарплаты
            numbers = re.findall(r"\d+", salary_info)
            if numbers:
                # Берем максимальное значение (если есть диапазон)
                return max(int(num) for num in numbers)
            return 0
    
        sorted_vacancies = sorted(all_vacancies, key=lambda x: (-get_salary_value(x), x.get("title", "")))
    
        print(f"{'№':<3} {'Название':<40} {'Компания':<20} {'Зарплата':<20}")
        print("-" * 85)
    
        # Показываем первые 25 вакансий
        for i, vacancy in enumerate(sorted_vacancies[:25], 1):
            title = vacancy["title"][:39] if len(vacancy["title"]) > 39 else vacancy["title"]
            company = (
                vacancy.get("company_name", "Неизвестная")[:19]
                if len(vacancy.get("company_name", "Неизвестная")) > 19
                else vacancy.get("company_name", "Неизвестная")
            )
>           salary = vacancy["salary_info"][:19] if len(vacancy["salary_info"]) > 19 else vacancy["salary_info"]
                                                        ^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'salary_info'

src/utils/db_manager_demo.py:194: KeyError
_______________________ TestDBManagerDemo.test_demo_with_real_like_data ________________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c1990>
mock_db_manager = <Mock spec='DBManager' id='139820288215504'>

    def test_demo_with_real_like_data(self, mock_db_manager):
        """Тест демонстрации с реалистичными данными"""
        # Настраиваем реалистичные данные
        mock_db_manager.get_target_companies_analysis.return_value = [
            ("ООО Яндекс", 15),
            ("ПАО Сбербанк", 12),
            ("АО Тинькофф Банк", 8),
            ("Mail.Ru Group", 6),
            ("Wildberries", 4)
        ]
    
        if DB_MANAGER_DEMO_AVAILABLE:
            demo = DBManagerDemo(mock_db_manager)
        else:
            demo = MockDBManagerDemo(mock_db_manager)
    
        with patch('builtins.print') as mock_print:
>           demo.run_full_demo()

tests/test_db_manager_demo.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/db_manager_demo.py:53: in run_full_demo
    self._demo_all_vacancies()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a729c8dd0>

    def _demo_all_vacancies(self) -> None:
        """Демонстрирует метод get_all_vacancies()"""
        print("\n4. get_all_vacancies() - Все вакансии:")
        print("-" * 80)
        all_vacancies = self.db_manager.get_all_vacancies()
    
        if not all_vacancies:
            print("Вакансии не найдены.")
            return
    
        # Сортируем вакансии: сначала по убыванию зарплаты, потом по названию
        def get_salary_value(vacancy):
            """Извлекает числовое значение зарплаты для сортировки"""
            salary_info = vacancy.get("salary_info", "Не указана")
            if salary_info == "Не указана":
                return 0
    
            # Извлекаем числа из строки зарплаты
            numbers = re.findall(r"\d+", salary_info)
            if numbers:
                # Берем максимальное значение (если есть диапазон)
                return max(int(num) for num in numbers)
            return 0
    
        sorted_vacancies = sorted(all_vacancies, key=lambda x: (-get_salary_value(x), x.get("title", "")))
    
        print(f"{'№':<3} {'Название':<40} {'Компания':<20} {'Зарплата':<20}")
        print("-" * 85)
    
        # Показываем первые 25 вакансий
        for i, vacancy in enumerate(sorted_vacancies[:25], 1):
            title = vacancy["title"][:39] if len(vacancy["title"]) > 39 else vacancy["title"]
            company = (
                vacancy.get("company_name", "Неизвестная")[:19]
                if len(vacancy.get("company_name", "Неизвестная")) > 19
                else vacancy.get("company_name", "Неизвестная")
            )
>           salary = vacancy["salary_info"][:19] if len(vacancy["salary_info"]) > 19 else vacancy["salary_info"]
                                                        ^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'salary_info'

src/utils/db_manager_demo.py:194: KeyError
___________________________ TestDBManagerDemo.test_demo_performance ____________________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c2450>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a725aa750>

    def test_demo_performance(self, db_manager_demo):
        """Тест производительности демонстрации"""
        import time
    
        start_time = time.time()
        with patch('builtins.print'):
>           db_manager_demo.run_full_demo()

tests/test_db_manager_demo.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/utils/db_manager_demo.py:53: in run_full_demo
    self._demo_all_vacancies()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a725aa750>

    def _demo_all_vacancies(self) -> None:
        """Демонстрирует метод get_all_vacancies()"""
        print("\n4. get_all_vacancies() - Все вакансии:")
        print("-" * 80)
        all_vacancies = self.db_manager.get_all_vacancies()
    
        if not all_vacancies:
            print("Вакансии не найдены.")
            return
    
        # Сортируем вакансии: сначала по убыванию зарплаты, потом по названию
        def get_salary_value(vacancy):
            """Извлекает числовое значение зарплаты для сортировки"""
            salary_info = vacancy.get("salary_info", "Не указана")
            if salary_info == "Не указана":
                return 0
    
            # Извлекаем числа из строки зарплаты
            numbers = re.findall(r"\d+", salary_info)
            if numbers:
                # Берем максимальное значение (если есть диапазон)
                return max(int(num) for num in numbers)
            return 0
    
        sorted_vacancies = sorted(all_vacancies, key=lambda x: (-get_salary_value(x), x.get("title", "")))
    
        print(f"{'№':<3} {'Название':<40} {'Компания':<20} {'Зарплата':<20}")
        print("-" * 85)
    
        # Показываем первые 25 вакансий
        for i, vacancy in enumerate(sorted_vacancies[:25], 1):
            title = vacancy["title"][:39] if len(vacancy["title"]) > 39 else vacancy["title"]
            company = (
                vacancy.get("company_name", "Неизвестная")[:19]
                if len(vacancy.get("company_name", "Неизвестная")) > 19
                else vacancy.get("company_name", "Неизвестная")
            )
>           salary = vacancy["salary_info"][:19] if len(vacancy["salary_info"]) > 19 else vacancy["salary_info"]
                                                        ^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'salary_info'

src/utils/db_manager_demo.py:194: KeyError
______________________ TestDBManagerDemo.test_demo_components_separately _______________________

self = <workspace.tests.test_db_manager_demo.TestDBManagerDemo object at 0x7f2a735c2c10>
db_manager_demo = <src.utils.db_manager_demo.DBManagerDemo object at 0x7f2a71480a10>

    def test_demo_components_separately(self, db_manager_demo):
        """Тест отдельных компонентов демонстрации"""
        with patch('builtins.print'):
            # Тестируем что можем вызвать run_full_demo без ошибок
            try:
                db_manager_demo.run_full_demo()
                success = True
            except Exception:
                success = False
    
>           assert success
E           assert False

tests/test_db_manager_demo.py:179: AssertionError
___________________________ TestEnvLoader.test_load_env_file_success ___________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73577bd0>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a71479510>

    @patch.dict(os.environ, {}, clear=True)
    def test_load_env_file_success(self, env_loader):
        """Тест успешной загрузки .env файла"""
        env_content = "API_KEY=test_key\nDATABASE_URL=postgresql://localhost:5432/test\n"
    
        with patch("builtins.open", mock_open(read_data=env_content)):
            with patch("os.path.exists", return_value=True):
                if ENV_LOADER_AVAILABLE:
>                   env_loader.load(".env")
                    ^^^^^^^^^^^^^^^
E                   AttributeError: 'EnvLoader' object has no attribute 'load'

tests/test_env_loader.py:40: AttributeError
_________________________ TestEnvLoader.test_load_env_file_not_exists __________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73574450>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a7146b050>

    @patch.dict(os.environ, {}, clear=True)
    def test_load_env_file_not_exists(self, env_loader):
        """Тест загрузки несуществующего .env файла"""
        with patch("os.path.exists", return_value=False):
            if ENV_LOADER_AVAILABLE:
                # Реальный EnvLoader не возвращает результат, проверяем что не падает
                try:
                    env_loader.load(".env")
                    success = True
                except Exception:
                    success = False
>               assert success
E               assert False

tests/test_env_loader.py:59: AssertionError
___________________________ TestEnvLoader.test_get_env_var_existing ____________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73574650>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a725ce750>

    def test_get_env_var_existing(self, env_loader):
        """Тест получения существующей переменной окружения"""
        with patch.dict(os.environ, {"TEST_VAR": "test_value"}):
            if ENV_LOADER_AVAILABLE:
>               value = env_loader.get("TEST_VAR")
                        ^^^^^^^^^^^^^^
E               AttributeError: 'EnvLoader' object has no attribute 'get'

tests/test_env_loader.py:68: AttributeError
_________________________ TestEnvLoader.test_get_env_var_with_default __________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73574c90>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a725a4e10>

    def test_get_env_var_with_default(self, env_loader):
        """Тест получения переменной окружения с значением по умолчанию"""
        with patch.dict(os.environ, {}, clear=True):
            if ENV_LOADER_AVAILABLE:
>               value = env_loader.get("NONEXISTENT_VAR", "default_value")
                        ^^^^^^^^^^^^^^
E               AttributeError: 'EnvLoader' object has no attribute 'get'

tests/test_env_loader.py:77: AttributeError
_____________________________ TestEnvLoader.test_validate_env_vars _____________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73574d50>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a71445010>

    def test_validate_env_vars(self, env_loader):
        """Тест валидации переменных окружения"""
        required_vars = ["API_KEY", "DATABASE_URL"]
    
        # Тест с отсутствующими переменными
        with patch.dict(os.environ, {}, clear=True):
            if ENV_LOADER_AVAILABLE:
                try:
                    env_loader.validate(required_vars)
                    # Если не падает, значит метод не проверяет обязательные переменные
                    assert True
                except Exception:
                    # Ожидаемое поведение при отсутствующих переменных
                    assert True
            else:
                missing_vars = env_loader.validate_required_vars(required_vars)
                assert len(missing_vars) == 2
    
        # Тест с присутствующими переменными
        test_env = {
            "API_KEY": "key",
            "DATABASE_URL": "url"
        }
        with patch.dict(os.environ, test_env):
            if ENV_LOADER_AVAILABLE:
                # Метод validate должен работать без ошибок
                try:
>                   env_loader.validate(required_vars)
                    ^^^^^^^^^^^^^^^^^^^
E                   AttributeError: 'EnvLoader' object has no attribute 'validate'

tests/test_env_loader.py:109: AttributeError

During handling of the above exception, another exception occurred:

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73574d50>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a71445010>

    def test_validate_env_vars(self, env_loader):
        """Тест валидации переменных окружения"""
        required_vars = ["API_KEY", "DATABASE_URL"]
    
        # Тест с отсутствующими переменными
        with patch.dict(os.environ, {}, clear=True):
            if ENV_LOADER_AVAILABLE:
                try:
                    env_loader.validate(required_vars)
                    # Если не падает, значит метод не проверяет обязательные переменные
                    assert True
                except Exception:
                    # Ожидаемое поведение при отсутствующих переменных
                    assert True
            else:
                missing_vars = env_loader.validate_required_vars(required_vars)
                assert len(missing_vars) == 2
    
        # Тест с присутствующими переменными
        test_env = {
            "API_KEY": "key",
            "DATABASE_URL": "url"
        }
        with patch.dict(os.environ, test_env):
            if ENV_LOADER_AVAILABLE:
                # Метод validate должен работать без ошибок
                try:
                    env_loader.validate(required_vars)
                    assert True
                except Exception:
>                   assert False, "Validate should not fail with existing vars"
E                   AssertionError: Validate should not fail with existing vars
E                   assert False

tests/test_env_loader.py:112: AssertionError
___________________________ TestEnvLoader.test_env_loader_get_method ___________________________

self = <workspace.tests.test_env_loader.TestEnvLoader object at 0x7f2a73575850>
env_loader = <src.utils.env_loader.EnvLoader object at 0x7f2a729bfd50>

    def test_env_loader_get_method(self, env_loader):
        """Тест метода get с различными параметрами"""
        test_env = {
            "STRING_VAR": "test_string",
            "EMPTY_VAR": ""
        }
    
        with patch.dict(os.environ, test_env):
            if ENV_LOADER_AVAILABLE:
                # Тест обычного получения
>               assert env_loader.get("STRING_VAR") == "test_string"
                       ^^^^^^^^^^^^^^
E               AttributeError: 'EnvLoader' object has no attribute 'get'

tests/test_env_loader.py:127: AttributeError
______________________ TestVacancyStats.test_calculate_salary_statistics _______________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f2a72534d90>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a7133af90>
sample_vacancies = [{'description': 'Работа с Python и Django', 'employer': {'name': 'Яндекс'}, 'salary': {'currency': 'RUR', 'from': 100...ption': 'Работа с React и TypeScript', 'employer': {'name': 'Тинькофф'}, 'salary': None, 'source': 'superjob.ru', ...}]

    def test_calculate_salary_statistics(self, vacancy_stats, sample_vacancies):
        """Тест расчета статистики по зарплатам"""
        # Конвертируем в объекты Vacancy если доступно
        if VACANCY_STATS_AVAILABLE:
            try:
                vacancies = [Vacancy(**data) for data in sample_vacancies]
            except Exception:
                vacancies = sample_vacancies
        else:
            vacancies = sample_vacancies
    
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a7133af90>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f2a71327380>, <src.vacancies.models.Vacancy object at 0x7f2a71327450>, <src.vacancies.models.Vacancy object at 0x7f2a71327ad0>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
________________________ TestVacancyStats.test_vacancies_without_salary ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f2a72535350>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a7142df50>

    def test_vacancies_without_salary(self, vacancy_stats):
        """Тест обработки вакансий без зарплаты"""
        vacancies_no_salary = [
            {
                "title": "Developer",
                "vacancy_id": "1",
                "url": "https://example.com/1",
                "source": "hh.ru",
                "employer": {"name": "Company1"},
                "salary": None,
                "description": "Job description"
            }
        ]
    
        if VACANCY_STATS_AVAILABLE:
            try:
                vacancies = [Vacancy(**data) for data in vacancies_no_salary]
            except Exception:
                vacancies = vacancies_no_salary
        else:
            vacancies = vacancies_no_salary
    
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a7142df50>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f2a71334d50>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
________________________ TestVacancyStats.test_salary_range_calculation ________________________

self = <workspace.tests.test_vacancy_stats.TestVacancyStats object at 0x7f2a725358d0>
vacancy_stats = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a71354190>

    def test_salary_range_calculation(self, vacancy_stats):
        """Тест расчета диапазона зарплат"""
        vacancies_with_range = [
            {
                "title": "Developer",
                "vacancy_id": "1",
                "url": "https://example.com/1",
                "source": "hh.ru",
                "employer": {"name": "Company1"},
                "salary": {"from": 50000, "to": 100000, "currency": "RUR"},
                "description": "Job description"
            }
        ]
    
        if VACANCY_STATS_AVAILABLE:
            try:
                vacancies = [Vacancy(**data) for data in vacancies_with_range]
            except Exception:
                vacancies = vacancies_with_range
        else:
            vacancies = vacancies_with_range
    
>       stats = vacancy_stats.calculate_salary_statistics(vacancies)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_vacancy_stats.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.utils.vacancy_stats.VacancyStats object at 0x7f2a71354190>
vacancies = [<src.vacancies.models.Vacancy object at 0x7f2a71309b20>]

    def calculate_salary_statistics(self, vacancies):
        """Подсчет статистики по зарплатам"""
        salaries = []
        for vacancy in vacancies:
            if vacancy.salary:
>               if vacancy.salary.from_amount:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'Salary' object has no attribute 'from_amount'

src/utils/vacancy_stats.py:24: AttributeError
=================================== short test summary info ====================================
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_run_full_demo - KeyError: 'salary_info'
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_with_empty_results - TypeError: '>' not supported between instances of 'Mock' and 'int'
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_methods_call_db_manager - KeyError: 'salary_info'
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_with_real_like_data - KeyError: 'salary_info'
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_performance - KeyError: 'salary_info'
FAILED tests/test_db_manager_demo.py::TestDBManagerDemo::test_demo_components_separately - assert False
FAILED tests/test_env_loader.py::TestEnvLoader::test_load_env_file_success - AttributeError: 'EnvLoader' object has no attribute 'load'
FAILED tests/test_env_loader.py::TestEnvLoader::test_load_env_file_not_exists - assert False
FAILED tests/test_env_loader.py::TestEnvLoader::test_get_env_var_existing - AttributeError: 'EnvLoader' object has no attribute 'get'
FAILED tests/test_env_loader.py::TestEnvLoader::test_get_env_var_with_default - AttributeError: 'EnvLoader' object has no attribute 'get'
FAILED tests/test_env_loader.py::TestEnvLoader::test_validate_env_vars - AssertionError: Validate should not fail with existing vars
FAILED tests/test_env_loader.py::TestEnvLoader::test_env_loader_get_method - AttributeError: 'EnvLoader' object has no attribute 'get'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_calculate_salary_statistics - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_vacancies_without_salary - AttributeError: 'Salary' object has no attribute 'from_amount'
FAILED tests/test_vacancy_stats.py::TestVacancyStats::test_salary_range_calculation - AttributeError: 'Salary' object has no attribute 'from_amount'
ERROR tests/test_extended_coverage.py::TestUserInterfaceExtended::test_display_search_results
ERROR tests/test_extended_coverage.py::TestInterfaceHandlers::test_format_vacancy_for_display
ERROR tests/test_extended_coverage.py::TestInterfaceHandlers::test_display_vacancy_list